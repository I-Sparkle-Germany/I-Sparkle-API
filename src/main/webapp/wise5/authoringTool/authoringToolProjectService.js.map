{"version":3,"sources":["authoringToolProjectService.es6"],"names":["AuthoringToolProjectService","$filter","$http","$injector","$q","$rootScope","ConfigService","UtilService","$translate","projectId","httpParams","method","url","getConfigParam","then","result","otherAuthors","data","resolve","reject","project","getProjectId","nodeId","componentId","component","getComponentByNodeIdAndComponentId","componentType","type","componentService","get","getPossibleTransitionCriteria","copyProjectURL","headers","$","param","projectJSONString","commitMessage","registerNewProjectURL","JSON","parse","e","Error","commitProjectURL","components","getComponentsByNodeId","c","length","tempComponent","id","title","getNextAvailableGroupId","startId","constraints","transitionLogic","transitions","ids","getNextAvailableNodeId","showSaveButton","showSubmitButton","nodeIds","newNodes","n","nodeIdToCopy","newNode","copyNode","newNodeId","createNodeInside","createNodeAfter","parseProject","push","selectedNodes","fromProjectId","toProjectId","nodeIdToInsertInsideOrAfter","steps","angular","toJson","inactiveNodes","getInactiveNodes","newNodeIds","selectedNode","tempNode","makeCopyOfJSONObject","isNodeIdUsed","nextAvailableNodeId","tempComponents","isComponentIdUsed","newComponentId","getUnusedComponentId","isGroupNode","node","addInactiveNodeInsertAfter","setIdToNode","setIdToElement","isInactive","addInactiveNodeInsertInside","addNode","insertNodeInsideOnlyUpdateTransitions","insertNodeInsideInGroups","insertNodeAfterInGroups","insertNodeAfterInTransitions","oldToGroupIds","transitionsFromGroup","getTransitionsByFromNodeId","transitionFromGroup","toNodeId","to","fromGroupId","newToGroupId","updateTransitionsForInsertingGroup","inactiveNode","nodes","field","value","getNodeById","fromNodeId","transition","nodeIdAfter","orderedItems","idToOrder","foundNodeId","item","tempNodeId","$key","targetNodeId","makeThisNodeNotVisibleConstraint","getNextAvailableConstraintIdForNodeId","action","targetId","removalConditional","removalCriteria","name","params","makeThisNodeNotVisitableConstraint","html","rubric","getTransitionLogicByFromNodeId","criteria","singleCriteria","howToChooseAmongAvailablePaths","flattenedNodeIds","getFlattenedProjectAsNodeIds","indexOfNodeId","indexOf","indexOfPreviousNodeId","scriptFilename","script","numberOfRubrics","getNumberOfRubricsByNodeId","componentIds","insertAfterComponentId","newComponents","newComponentIds","newComponent","copyComponent","insertPosition","getComponentPositionByNodeIdAndComponentId","splice","componentIdsToSkip","importProjectId","currentComponents","nodeIdToBranchPathLetter","i","idToNode","service","componentUsesSaveButton","nodeRemoved","activeNodes","a","activeNode","removeChildNodesFromActiveNodes","childId","removeNodeFromActiveNodes","nodeIdToInsertAfter","isActive","clearTransitionsFromNode","isNodeIdToInsertTargetNotSpecified","insertNodeAtBeginningOfInactiveNodes","insertNodeAfterInactiveNode","inactiveGroupNodes","addGroupChildNodesToInactive","inactiveStepNodes","parentGroup","getParentGroup","nodeIdToInsertTarget","nodeIdToInsertInside","removeNodeFromInactiveNodes","childIds","childNode","inactiveNodesIndex","inactiveStepNodesIndex","insertNodeInsideInactiveNode","getInactiveGroupNodes","inactiveGroup","ProjectService","$inject"],"mappings":"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","file":"authoringToolProjectService.js","sourcesContent":["'use strict';\nimport ProjectService from '../services/projectService';\n\nclass AuthoringToolProjectService extends ProjectService {\n  constructor($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService) {\n    super($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService);\n  }\n\n  /**\n   * Returns a project template for new projects\n   */\n  getNewProjectTemplate() {\n    return {\n      \"nodes\": [\n        {\n          \"id\": \"group0\",\n          \"type\": \"group\",\n          \"title\": \"Master\",\n          \"startId\": \"group1\",\n          \"ids\": [\n            \"group1\"\n          ]\n        },\n        {\n          \"id\": \"group1\",\n          \"type\": \"group\",\n          \"title\": this.$translate('FIRST_ACTIVITY'),\n          \"startId\": \"\",\n          \"ids\": [\n          ],\n          \"icons\": {\n            \"default\": {\n              \"color\": \"#2196F3\",\n              \"type\": \"font\",\n              \"fontSet\": \"material-icons\",\n              \"fontName\": \"info\"\n            }\n          }\n        }\n      ],\n      \"constraints\": [],\n      \"startGroupId\": \"group0\",\n      \"startNodeId\": \"group0\",\n      \"navigationMode\": \"guided\",\n      \"layout\": {\n        \"template\": \"starmap|leftNav|rightNav\"\n      },\n      \"metadata\": {\n        \"title\": \"\"\n      },\n      \"notebook\": {\n        \"enabled\": false,\n        \"label\": this.$translate('NOTEBOOK'),\n        \"enableAddNew\": true,\n        \"itemTypes\": {\n          \"note\": {\n            \"type\": \"note\",\n            \"enabled\": true,\n            \"enableLink\": true,\n            \"enableAddNote\": true,\n            \"enableClipping\": true,\n            \"enableStudentUploads\": true,\n            \"requireTextOnEveryNote\": false,\n            \"label\": {\n              \"singular\": this.$translate('NOTE_LOWERCASE'),\n              \"plural\": this.$translate('NOTES_LOWERCASE'),\n              \"link\": this.$translate('NOTES'),\n              \"icon\": \"note\",\n              \"color\": \"#1565C0\"\n            }\n          },\n          \"report\": {\n            \"enabled\": false,\n            \"label\": {\n              \"singular\": this.$translate('REPORT_LOWERCASE'),\n              \"plural\": this.$translate('REPORTS_LOWERCASE'),\n              \"link\": this.$translate('REPORT'),\n              \"icon\": \"assignment\",\n              \"color\": \"#AD1457\"\n            },\n            \"notes\": [\n              {\n                \"reportId\": \"finalReport\",\n                \"title\": this.$translate('FINAL_REPORT'),\n                \"description\": this.$translate('REPORT_DESCRIPTION'),\n                \"prompt\": this.$translate('REPORT_PROMPT'),\n                \"content\": this.$translate('REPORT_CONTENT')\n              }\n            ]\n          }\n        }\n      },\n      \"teacherNotebook\": {\n        \"enabled\": true,\n        \"label\": this.$translate('TEACHER_NOTEBOOK'),\n        \"enableAddNew\": true,\n        \"itemTypes\": {\n          \"note\": {\n            \"type\": \"note\",\n            \"enabled\": false,\n            \"enableLink\": true,\n            \"enableAddNote\": true,\n            \"enableClipping\": true,\n            \"enableStudentUploads\": true,\n            \"requireTextOnEveryNote\": false,\n            \"label\": {\n              \"singular\": this.$translate('NOTE_LOWERCASE'),\n              \"plural\": this.$translate('NOTES_LOWERCASE'),\n              \"link\": this.$translate('NOTES'),\n              \"icon\": \"note\",\n              \"color\": \"#1565C0\"\n            }\n          },\n          \"report\": {\n            \"enabled\": true,\n            \"label\": {\n              \"singular\": this.$translate('TEACHER_REPORT_LOWERCASE'),\n              \"plural\": this.$translate('TEACHER_REPORTS_LOWERCASE'),\n              \"link\": this.$translate('TEACHER_REPORT'),\n              \"icon\": \"assignment\",\n              \"color\": \"#AD1457\"\n            },\n            \"notes\": [\n              {\n                \"reportId\": \"teacherReport\",\n                \"title\": this.$translate('TEACHER_REPORT'),\n                \"description\": this.$translate('TEACHER_REPORT_DESCRIPTION'),\n                \"prompt\": this.$translate('TEACHER_REPORT_PROMPT'),\n                \"content\": this.$translate('TEACHER_REPORT_CONTENT')\n              }\n            ]\n          }\n        }\n      },\n      \"inactiveNodes\": []\n    };\n  }\n\n  notifyAuthorProjectBegin(projectId) {\n    const httpParams = {\n      method: 'POST',\n      url: this.ConfigService.getConfigParam('notifyProjectBeginURL') + projectId\n    };\n    return this.$http(httpParams).then((result) => {\n      const otherAuthors = result.data;\n      return otherAuthors;\n    });\n  }\n\n  /**\n   * Notifies others that the specified project is no longer being authored\n   * @param projectId id of the project\n   */\n  notifyAuthorProjectEnd(projectId = null) {\n    return this.$q((resolve, reject) => {\n      if (projectId == null) {\n        if (this.project != null) {\n          projectId = this.ConfigService.getProjectId();\n        } else {\n          resolve();\n        }\n      }\n      const httpParams = {\n        method: 'POST',\n        url: this.ConfigService.getConfigParam('notifyProjectEndURL') + projectId\n      };\n      this.$http(httpParams).then(() => {\n        resolve();\n      })\n    });\n  }\n\n  /**\n   * Returns all possible transition criteria for the specified node and component.\n   */\n  getPossibleTransitionCriteria(nodeId, componentId) {\n    let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    if (component != null) {\n      let componentType = component.type;\n      let componentService = this.$injector.get(componentType + 'Service');\n      if (componentService.getPossibleTransitionCriteria) {\n        return componentService.getPossibleTransitionCriteria(nodeId, componentId, component);\n      } else {\n        return [];\n      }\n    } else {\n      return [];\n    }\n  };\n\n  /**\n   * Copies the project with the specified id and returns\n   * a new project id if the project is successfully copied\n   */\n  copyProject(projectId) {\n    const copyProjectURL = this.ConfigService.getConfigParam('copyProjectURL');\n    if (copyProjectURL == null) {\n      return null;\n    }\n\n    const httpParams = {\n      method: 'POST',\n      url: copyProjectURL + \"/\" + projectId,\n      headers:  {'Content-Type': 'application/x-www-form-urlencoded'},\n      data: $.param({})\n    };\n\n    return this.$http(httpParams).then((result) => {\n      return result.data;  // project Id\n    });\n  };\n\n  /**\n   * Registers a new project having the projectJSON content with the server.\n   * Returns a new project Id if the project is successfully registered.\n   * Returns null if Config.registerNewProjectURL is undefined.\n   * Throws an error if projectJSONString is invalid JSON string\n   */\n  registerNewProject(projectJSONString, commitMessage = \"\") {\n    const registerNewProjectURL = this.ConfigService.getConfigParam('registerNewProjectURL');\n    if (registerNewProjectURL == null) {\n      return null;\n    }\n\n    try {\n      JSON.parse(projectJSONString);\n    } catch (e) {\n      throw new Error(\"Invalid projectJSONString.\");\n    }\n\n    const httpParams = {\n      method: 'POST',\n      url: registerNewProjectURL,\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n      data: $.param({\n        commitMessage: commitMessage,\n        projectJSONString: projectJSONString\n      })\n    };\n\n    return this.$http(httpParams).then((result) => {\n      const projectId = result.data;\n      return projectId;\n    });\n  };\n\n  /**\n   * Retrieves and returns the project's commit history.\n   */\n  getCommitHistory() {\n    const commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\n    return this.$http({\n      url: commitProjectURL,\n      method: 'GET'\n    }).then((result) => {\n      return result.data;\n    });\n  };\n\n  /**\n   * Replace a component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @param component the new component\n   */\n  replaceComponent(nodeId, componentId, component) {\n    if (nodeId != null && componentId != null && component != null) {\n      const components = this.getComponentsByNodeId(nodeId);\n      if (components != null) {\n        for (let c = 0; c < components.length; c++) {\n          const tempComponent = components[c];\n          if (tempComponent != null) {\n            if (tempComponent.id === componentId) {\n              components[c] = component;\n              break;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Create a new group\n   * @param title the title of the group\n   * @returns the group object\n   */\n  createGroup(title) {\n    return {\n      id: this.getNextAvailableGroupId(),\n      type: 'group',\n      title: title,\n      startId: '',\n      constraints: [],\n      transitionLogic: {\n        transitions: []\n      },\n      ids: []\n    }\n  };\n\n  /**\n   * Create a new node\n   * @param title the title of the node\n   * @returns the node object\n   */\n  createNode(title) {\n    return {\n      id: this.getNextAvailableNodeId(),\n      title: title,\n      type: 'node',\n      constraints: [],\n      transitionLogic: {\n        transitions: []\n      },\n      showSaveButton: false,\n      showSubmitButton: false,\n      components: []\n    }\n  };\n\n  /**\n   * Copy nodes and put them after a certain node id\n   * @param nodeIds the node ids to copy\n   * @param nodeId the node id we will put the copied nodes after\n   */\n  copyNodesInside(nodeIds, nodeId) {\n    const newNodes = [];\n    for (let n = 0; n < nodeIds.length; n++) {\n      const nodeIdToCopy = nodeIds[n];\n      const newNode = this.copyNode(nodeIdToCopy);\n      const newNodeId = newNode.id;\n\n      if (n == 0) {\n        // this is the first node we are copying so we will insert it\n        // into the beginning of the group\n        this.createNodeInside(newNode, nodeId);\n      } else {\n        // this is not the first node we are copying so we will insert\n        // it after the node we previously inserted\n        this.createNodeAfter(newNode, nodeId);\n      }\n\n      // remember the node id so we can put the next node (if any) after this one\n      nodeId = newNodeId;\n      this.parseProject();  // refresh project and update references because a new node have been added.\n\n      newNodes.push(newNode);\n    }\n    return newNodes;\n  }\n\n  /**\n   * Copy the nodes into the project\n   * @param selectedNodes the nodes to import\n   * @param fromProjectId copy the nodes from this project\n   * @param toProjectId copy the nodes into this project\n   * @param nodeIdToInsertInsideOrAfter If this is a group, we will make the\n   * new step the first step in the group. If this is a step, we will place\n   * the new step after it.\n   */\n  copyNodes(selectedNodes, fromProjectId, toProjectId, nodeIdToInsertInsideOrAfter) {\n    const httpParams = {\n      method: 'POST',\n      url: this.ConfigService.getConfigParam('importStepsURL'),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n      data: $.param({\n        steps: angular.toJson(selectedNodes),\n        fromProjectId: fromProjectId,\n        toProjectId: toProjectId\n      })\n    };\n\n    /*\n     * Make the request to import the steps. This will copy the asset files\n     * and change file names if necessary. If an asset file with the same\n     * name exists in both projects we will check if their content is the\n     * same. If the content is the same we don't need to copy the file. If\n     * the content is different, we need to make a copy of the file with a\n     * new name and change all the references in the steps to use the new\n     * name.\n     */\n    return this.$http(httpParams).then((result) => {\n      selectedNodes = result.data;\n\n      const inactiveNodes = this.getInactiveNodes();\n      const newNodes = [];\n      const newNodeIds = [];\n\n      for (let selectedNode of selectedNodes) {\n        if (selectedNode != null) {\n          // make a copy of the node so that we don't modify the source\n          const tempNode = this.UtilService.makeCopyOfJSONObject(selectedNode);\n\n          // check if the node id is already being used in the current project\n          if (this.isNodeIdUsed(tempNode.id)) {\n            // the node id is already being used in the current project\n\n            // get the next available node id\n            const nextAvailableNodeId = this.getNextAvailableNodeId(newNodeIds);\n\n            // change the node id of the node we are importing\n            tempNode.id = nextAvailableNodeId;\n          }\n\n          // get the components in the node\n          const tempComponents = tempNode.components;\n\n          if (tempComponents != null) {\n            for (let tempComponent of tempComponents) {\n              if (tempComponent != null) {\n                if (this.isComponentIdUsed(tempComponent.id)) {\n                  // we are already using the component id so we will need to change it\n\n                  const newComponentId = this.getUnusedComponentId();\n                  tempComponent.id = newComponentId;\n                }\n              }\n            }\n          }\n\n          // clear the constraints\n          tempNode.constraints = [];\n\n          // add the new node and new node id to our arrays\n          newNodes.push(tempNode);\n          newNodeIds.push(tempNode.id);\n        }\n      }\n\n      if (nodeIdToInsertInsideOrAfter == null) {\n        /*\n         * the place to put the new node has not been specified so we\n         * will place it in the inactive steps section\n         */\n\n        /*\n         * Insert the node after the last inactive node. If there\n         * are no inactive nodes it will just be placed in the\n         * inactive nodes section. In the latter case we do this by\n         * setting nodeIdToInsertInsideOrAfter to 'inactiveSteps'.\n         */\n        if (inactiveNodes != null && inactiveNodes.length > 0) {\n          nodeIdToInsertInsideOrAfter = inactiveNodes[inactiveNodes.length - 1];\n        } else {\n          nodeIdToInsertInsideOrAfter = 'inactiveSteps';\n        }\n      }\n\n      for (let newNode of newNodes) {\n        if (this.isGroupNode(nodeIdToInsertInsideOrAfter)) {\n          // we want to make the new step the first step in the given activity\n          this.createNodeInside(newNode, nodeIdToInsertInsideOrAfter);\n        } else {\n          // we want to place the new step after the given step\n          this.createNodeAfter(newNode, nodeIdToInsertInsideOrAfter);\n        }\n\n        /*\n         * Update the nodeIdToInsertInsideOrAfter so that when we are\n         * importing multiple steps, the steps get placed in the correct\n         * order.\n         *\n         * Example\n         * We are importing nodeA and nodeB and want to place them after\n         * nodeX. Therefore we want the order to be\n         *\n         * nodeX\n         * nodeA\n         * nodeB\n         *\n         * This means after we add nodeA, we must update\n         * nodeIdToInsertInsideOrAfter to be nodeA so that when we add\n         * nodeB, it will be placed after nodeA.\n         */\n        nodeIdToInsertInsideOrAfter = newNode.id;\n      }\n      return newNodes;\n    });\n  }\n\n  /**\n   * Create a node inside the group\n   * @param node the new node\n   * @param nodeId the node id of the group to create the node in\n   */\n  createNodeInside(node, nodeId) {\n    if (nodeId == 'inactiveNodes' || nodeId == 'inactiveGroups') {\n      this.addInactiveNodeInsertAfter(node);\n      this.setIdToNode(node.id, node);\n      this.setIdToElement(node.id, node);\n    } else {\n      this.setIdToNode(node.id, node);\n      if (this.isInactive(nodeId)) {\n        // we are creating an inactive node\n        this.addInactiveNodeInsertInside(node, nodeId);\n      } else {\n        // we are creating an active node\n        this.addNode(node);\n        this.insertNodeInsideOnlyUpdateTransitions(node.id, nodeId);\n        this.insertNodeInsideInGroups(node.id, nodeId);\n      }\n    }\n  }\n\n  /**\n   * Create a node after the given node id\n   * @param node the new node\n   * @param nodeId the node to add after\n   */\n  createNodeAfter(node, nodeId) {\n    if (this.isInactive(nodeId)) {\n      // we are adding the node after a node that is inactive\n\n      this.addInactiveNodeInsertAfter(node, nodeId);\n      this.setIdToNode(node.id, node);\n      this.setIdToElement(node.id, node);\n    } else {\n      // we are adding the node after a node that is active\n\n      this.addNode(node);\n      this.setIdToNode(node.id, node);\n      this.insertNodeAfterInGroups(node.id, nodeId);\n      this.insertNodeAfterInTransitions(node, nodeId);\n    }\n\n    if (this.isGroupNode(node.id)) {\n      /*\n       * we are creating a group node so we will update/create the\n       * transitions that traverse from the previous group to this group\n       */\n      // TODO geoffreykwan oldToGroupIds is declared here and below. Refactor\n      var oldToGroupIds = [];\n\n      const transitionsFromGroup = this.getTransitionsByFromNodeId(nodeId);\n      if (transitionsFromGroup != null) {\n        /*\n         * loop through all the transitions that come out of the previous group\n         * and get the node ids that the group transitions to\n         */\n        for (let transitionFromGroup of transitionsFromGroup) {\n          if (transitionFromGroup != null) {\n            const toNodeId = transitionFromGroup.to;\n            if (toNodeId != null) {\n              oldToGroupIds.push(toNodeId);\n            }\n          }\n        }\n      }\n\n      const fromGroupId = nodeId;\n      // TODO geoffreykwan oldToGroupIds is declared here and above. Refactor\n      var oldToGroupIds = oldToGroupIds;\n      const newToGroupId = node.id;\n\n      /*\n       * make the transitions point to the new group and make the new\n       * group transition to the old group\n       */\n      this.updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId);\n    }\n  }\n\n  /**\n   * Copy nodes and put them after a certain node id\n   * @param nodeIds the node ids to copy\n   * @param nodeId the node id we will put the copied nodes after\n   */\n  copyNodesAfter(nodeIds, nodeId) {\n    const newNodes = [];\n    for (let nodeIdToCopy of nodeIds) {\n      const newNode = this.copyNode(nodeIdToCopy);\n      const newNodeId = newNode.id;\n      this.createNodeAfter(newNode, nodeId);\n\n      // remember the node id so we can put the next node (if any) after this one\n      nodeId = newNodeId;\n      this.parseProject();  // refresh project and update references because a new node have been added.\n\n      newNodes.push(newNode);\n    }\n    return newNodes;\n  }\n\n  /**\n   * Check if a node is inactive. At the moment only step nodes can be\n   * inactive.\n   * @param nodeId the node id of the step\n   */\n  isInactive(nodeId) {\n    if (nodeId != null && this.project.inactiveNodes != null) {\n      for (let inactiveNode of this.project.inactiveNodes) {\n        if (inactiveNode != null) {\n          if (nodeId === inactiveNode.id) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a node id is already being used in the project\n   * @param nodeId check if this node id is already being used in the project\n   * @return whether the node id is already being used in the project\n   */\n  isNodeIdUsed(nodeId) {\n    for (let node of this.project.nodes) {\n      if (node != null) {\n        if (nodeId === node.id) {\n          return true;\n        }\n      }\n    }\n\n    for (let node of this.project.inactiveNodes) {\n      if (node != null) {\n        if (nodeId === node.id) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Set a field in the transition logic of a node\n   */\n  setTransitionLogicField(nodeId, field, value) {\n    if (nodeId != null && field != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        const transitionLogic = node.transitionLogic;\n        if (transitionLogic != null) {\n          transitionLogic[field] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Set the transition to value of a node\n   * @param fromNodeId the from node\n   * @param toNodeId the to node\n   */\n  setTransition(fromNodeId, toNodeId) {\n    const node = this.getNodeById(fromNodeId);\n    if (node != null) {\n      const transitionLogic = node.transitionLogic;\n      if (transitionLogic != null) {\n        let transitions = transitionLogic.transitions;\n        if (transitions == null || transitions.length == 0) {\n          transitionLogic.transitions = [];\n          const transition = {};\n          transitionLogic.transitions.push(transition);\n          transitions = transitionLogic.transitions;\n        }\n\n        if (transitions != null && transitions.length > 0) {\n          // get the first transition. we will assume there is only one transition.\n          const transition = transitions[0];\n          if (transition != null) {\n            transition.to = toNodeId;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the node id that comes after a given node id\n   * @param nodeId get the node id that comes after this node id\n   * @param the node id that comes after the one that is passed in as a parameter\n   */\n  getNodeIdAfter(nodeId) {\n    let nodeIdAfter = null;\n\n    // get an array of ordered items. each item represents a node\n    const orderedItems = this.$filter('orderBy')(this.$filter('toArray')(this.idToOrder), 'order');\n\n    if (orderedItems != null) {\n      let foundNodeId = false;\n      for (let item of orderedItems) {\n        if (item != null) {\n          const tempNodeId = item.$key;\n\n          // check if we have found the node id that was passed in as a parameter\n          if (foundNodeId) {\n            /*\n             * we have previously found the node id that was passed in which means\n             * the current temp node id is the one that comes after it\n             */\n            nodeIdAfter = tempNodeId;\n            break;\n          } else {\n            if (nodeId == tempNodeId) {\n              // we have found the node id that was passed in as a parameter\n              foundNodeId = true;\n            }\n          }\n        }\n      }\n    }\n    return nodeIdAfter;\n  }\n\n  /**\n   * Add branch path taken constraints to the node\n   * @param targetNodeId the node to add the constraints to\n   * @param fromNodeId the from node id of the branch path taken constraint\n   * @param toNodeId the to node id of the branch path taken constraint\n   */\n  addBranchPathTakenConstraints(targetNodeId, fromNodeId, toNodeId) {\n    if (targetNodeId != null) {\n      const node = this.getNodeById(targetNodeId);\n      if (node != null) {\n        /*\n         * create the constraint that makes the node not visible until\n         * the given branch path is taken\n         */\n        const makeThisNodeNotVisibleConstraint = {\n          id: this.getNextAvailableConstraintIdForNodeId(targetNodeId),\n          action: 'makeThisNodeNotVisible',\n          targetId: targetNodeId,\n          removalConditional: 'all',\n          removalCriteria: [{\n            name: 'branchPathTaken',\n            params: {\n              fromNodeId: fromNodeId,\n              toNodeId: toNodeId\n            }\n          }]\n        };\n        node.constraints.push(makeThisNodeNotVisibleConstraint);\n\n        /*\n         * create the constraint that makes the node not visitable until\n         * the given branch path is taken\n         */\n        const makeThisNodeNotVisitableConstraint = {\n          id: this.getNextAvailableConstraintIdForNodeId(targetNodeId),\n          action: 'makeThisNodeNotVisitable',\n          targetId: targetNodeId,\n          removalConditional: 'all',\n          removalCriteria: [{\n            name: 'branchPathTaken',\n            params: {\n              fromNodeId: fromNodeId,\n              toNodeId: toNodeId\n            }\n          }]\n        };\n        node.constraints.push(makeThisNodeNotVisitableConstraint);\n      }\n    }\n  }\n\n  /**\n   * Set the project level rubric\n   */\n  setProjectRubric(html) {\n    this.project.rubric = html;\n  }\n\n  /**\n   * Get the number of branch paths. This is assuming the node is a branch point.\n   * @param nodeId The node id of the branch point node.\n   * @return The number of branch paths for this branch point.\n   */\n  getNumberOfBranchPaths(nodeId) {\n    let transitions = this.getTransitionsByFromNodeId(nodeId);\n    if (transitions != null) {\n      return transitions.length;\n    }\n    return 0;\n  }\n\n  /**\n   * If this step is a branch point, we will return the criteria that is used\n   * to determine which path the student gets assigned to.\n   * @param nodeId The node id of the branch point.\n   * @returns A human readable string containing the criteria of how students\n   * are assigned branch paths on this branch point.\n   */\n  getBranchCriteriaDescription(nodeId) {\n    let transitionLogic = this.getTransitionLogicByFromNodeId(nodeId);\n    let transitions = transitionLogic.transitions;\n\n    // Loop through the transitions to try to find a transition criteria\n    for (let transition of transitions) {\n      if (transition.criteria != null && transition.criteria.length > 0) {\n        for (let singleCriteria of transition.criteria) {\n          if (singleCriteria.name == 'choiceChosen') {\n            return 'multiple choice';\n          } else if (singleCriteria.name == 'score') {\n            return 'score';\n          }\n        }\n      }\n    }\n\n    /*\n     * None of the transitions had a specific criteria so the branching is just\n     * based on the howToChooseAmongAvailablePaths field.\n     */\n    if (transitionLogic.howToChooseAmongAvailablePaths == 'workgroupId') {\n      return 'workgroup ID';\n    } else if (transitionLogic.howToChooseAmongAvailablePaths == 'random') {\n      return 'random assignment';\n    }\n  }\n\n  /**\n   * Get the previous node\n   * @param nodeId get the node id that comes before this one\n   * @return the node id that comes before\n   */\n  getPreviousNodeId(nodeId) {\n    const flattenedNodeIds = this.getFlattenedProjectAsNodeIds();\n    if (flattenedNodeIds != null) {\n      const indexOfNodeId = flattenedNodeIds.indexOf(nodeId);\n      if (indexOfNodeId != -1) {\n        const indexOfPreviousNodeId = indexOfNodeId - 1;\n        return flattenedNodeIds[indexOfPreviousNodeId];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Set the project script filename\n   * @param script the script filename\n   */\n  setProjectScriptFilename(scriptFilename) {\n    this.project.script = scriptFilename;\n  }\n\n  /**\n   * Get the project script filename\n   */\n  getProjectScriptFilename() {\n    if (this.project != null && this.project.script != null) {\n      return this.project.script;\n    }\n    return null;\n  }\n\n  /**\n   * Check if a node has rubrics.\n   * @param nodeId The node id of the node.\n   * @return Whether the node has rubrics authored on it.\n   */\n  nodeHasRubric(nodeId) {\n    let numberOfRubrics = this.getNumberOfRubricsByNodeId(nodeId);\n    if (numberOfRubrics > 0) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Copy a component and insert it into the step\n   * @param nodeId we are copying a component in this node\n   * @param componentIds the components to copy\n   * @param insertAfterComponentId Which component to place the new components\n   * after. If this is null, we will put the new components at the beginning.\n   * @return an array of the new components\n   */\n  copyComponentAndInsert(nodeId, componentIds, insertAfterComponentId) {\n    const node = this.getNodeById(nodeId);\n    const newComponents = [];\n    const newComponentIds = [];\n    for (let componentId of componentIds) {\n      const newComponent =\n        this.copyComponent(nodeId, componentId, newComponentIds);\n      newComponents.push(newComponent);\n      newComponentIds.push(newComponent.id);\n    }\n\n    const components = node.components;\n    if (components != null) {\n      let insertPosition = 0;\n      if (insertAfterComponentId == null) {\n        // place the new components at the beginning\n        insertPosition = 0;\n      } else {\n        // place the new components after the specified component id\n        insertPosition = this.getComponentPositionByNodeIdAndComponentId(nodeId, insertAfterComponentId) + 1;\n      }\n\n      for (let newComponent of newComponents) {\n        components.splice(insertPosition, 0, newComponent);\n\n        /*\n         * increment the insert position for cases when we have multiple\n         * new components\n         */\n        insertPosition += 1;\n      }\n    }\n    return newComponents;\n  }\n\n  /**\n   * Copy a component\n   * @param nodeId the node id\n   * @param componentId the compnent id\n   * @param componentIdsToSkip component ids that we can't use for our new\n   * component\n   * @return a new component object\n   */\n  copyComponent(nodeId, componentId, componentIdsToSkip) {\n    const component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    const newComponent = this.UtilService.makeCopyOfJSONObject(component);\n    const newComponentId = this.getUnusedComponentId(componentIdsToSkip);\n    newComponent.id = newComponentId;\n    return newComponent;\n  }\n\n  /**\n   * Import components from a project. Also import asset files that are\n   * referenced in any of those components.\n   * @param components an array of component objects that we are importing\n   * @param importProjectId the id of the project we are importing from\n   * @param nodeId the node we are adding the components to\n   * @param insertAfterComponentId insert the components after this component\n   * id\n   * @return an array of the new components\n   */\n  importComponents(components, importProjectId, nodeId, insertAfterComponentId) {\n    let newComponents = [];\n    const newComponentIds = [];\n\n    /*\n     * loop through all the components and make sure their ids are not\n     * already used in the project\n     */\n    for (let component of components) {\n      if (component != null) {\n        const newComponent = this.UtilService.makeCopyOfJSONObject(component);\n        let newComponentId = newComponent.id;\n\n        if (this.isComponentIdUsed(newComponentId)) {\n          // component id is already used so we will find a new component id\n          newComponentId = this.getUnusedComponentId(newComponentIds);\n          newComponent.id = newComponentId;\n        }\n\n        newComponents.push(newComponent);\n        newComponentIds.push(newComponentId);\n      }\n    }\n\n    const httpParams = {\n      method: 'POST',\n      url: this.ConfigService.getConfigParam('importStepsURL'),\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n      data: $.param({\n        steps: angular.toJson(newComponents),\n        fromProjectId: importProjectId,\n        toProjectId:  this.ConfigService.getConfigParam('projectId'),\n      })\n    };\n\n    /*\n     * Make the request to import the components. This will copy the asset files\n     * and change file names if necessary. If an asset file with the same\n     * name exists in both projects we will check if their content is the\n     * same. If the content is the same we don't need to copy the file. If\n     * the content is different, we need to make a copy of the file with a\n     * new name and change all the references in the steps to use the new\n     * name.\n     */\n    return this.$http(httpParams).then((result) => {\n      newComponents = result.data;\n      const node = this.getNodeById(nodeId);\n      const currentComponents = node.components;\n      let insertPosition = 0;\n\n      if (insertAfterComponentId == null) {\n        // place the new components at the beginning\n        insertPosition = 0;\n      } else {\n        // place the new components after the specified component id\n        insertPosition = this.getComponentPositionByNodeIdAndComponentId(nodeId, insertAfterComponentId) + 1;\n      }\n\n      for (let newComponent of newComponents) {\n        // insert the new component\n        currentComponents.splice(insertPosition, 0, newComponent);\n\n        /*\n         * increment the insert position for cases when we have multiple\n         * new components\n         */\n        insertPosition += 1;\n      }\n      return newComponents;\n    });\n  }\n\n  /**\n   * Get the branch path letter\n   * @param nodeId get the branch path letter for this node if it is in a\n   * branch\n   * @return the branch path letter for the node if it is in a branch\n   */\n  getBranchPathLetter(nodeId) {\n    return this.nodeIdToBranchPathLetter[nodeId];\n  }\n\n  /**\n   * Set the node into the project by replacing the existing node with the\n   * given node id\n   * @param nodeId the node id of the node\n   * @param node the node object\n   */\n  setNode(nodeId, node) {\n    if (nodeId != null && node != null) {\n      for (let n = 0; n < this.project.nodes.length; n++) {\n        let tempNode = this.project.nodes[n];\n        if (tempNode != null && tempNode.id == nodeId) {\n          this.project.nodes[n] = node;\n        }\n      }\n\n      for (let i = 0; i < this.project.inactiveNodes.length; i++) {\n        let tempNode = this.project.inactiveNodes[i];\n        if (tempNode != null && tempNode.id == nodeId) {\n          this.project.inactiveNodes[i] = node;\n        }\n      }\n      this.idToNode[nodeId] = node;\n    }\n  }\n\n  /**\n   * Get the id to node mappings.\n   * @return An object the keys as node ids and the values as nodes.\n   */\n  getIdToNode() {\n    return this.idToNode;\n  }\n\n  /**\n   * Turn on the save button in all the components in the step\n   * @param node the node\n   */\n  turnOnSaveButtonForAllComponents(node) {\n    for (let component of node.components) {\n      const service = this.$injector.get(component.type + 'Service');\n      if (service.componentUsesSaveButton()) {\n        component.showSaveButton = true;\n      }\n    }\n  }\n\n  /**\n   * Turn off the submit button in all the components in the step\n   * @param node the node\n   */\n  turnOffSaveButtonForAllComponents(node) {\n    for (let component of node.components) {\n      const service = this.$injector.get(component.type + 'Service');\n      if (service.componentUsesSaveButton()) {\n        component.showSaveButton = false;\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the active nodes.\n   * If the node is a group node, also remove its children.\n   * @param nodeId the node to remove\n   * @returns the node that was removed\n   */\n  removeNodeFromActiveNodes(nodeId) {\n    let nodeRemoved = null;\n    const activeNodes = this.project.nodes;\n    for (let a = 0; a < activeNodes.length; a++) {\n      const activeNode = activeNodes[a];\n      if (activeNode.id === nodeId) {\n        activeNodes.splice(a, 1);\n        nodeRemoved = activeNode;\n        if (activeNode.type == 'group') {\n          this.removeChildNodesFromActiveNodes(activeNode);\n        }\n        break;\n      }\n    }\n    return nodeRemoved;\n  }\n\n  /**\n   * Move the child nodes of a group from the active nodes.\n   * @param node The group node.\n   */\n  removeChildNodesFromActiveNodes(node) {\n    for (let childId of node.ids) {\n      this.removeNodeFromActiveNodes(childId);\n    }\n  }\n\n  /**\n   * Move an active node to the inactive nodes array.\n   * @param node the node to move\n   * @param nodeIdToInsertAfter place the node after this\n   */\n  moveToInactive(node, nodeIdToInsertAfter) {\n    if (this.isActive(node.id)) {\n      this.removeNodeFromActiveNodes(node.id);\n      this.addInactiveNodeInsertAfter(node, nodeIdToInsertAfter);\n    }\n  }\n\n  /**\n   * Add the node to the inactive nodes array.\n   * @param node the node to move\n   * @param nodeIdToInsertAfter place the node after this\n   */\n  addInactiveNodeInsertAfter(node, nodeIdToInsertAfter) {\n    this.clearTransitionsFromNode(node);\n\n    if (this.isNodeIdToInsertTargetNotSpecified(nodeIdToInsertAfter)) {\n      this.insertNodeAtBeginningOfInactiveNodes(node);\n    } else {\n      this.insertNodeAfterInactiveNode(node, nodeIdToInsertAfter);\n    }\n\n    if (node.type == 'group') {\n      this.inactiveGroupNodes.push(node.id);\n      this.addGroupChildNodesToInactive(node);\n    } else {\n      this.inactiveStepNodes.push(node.id);\n    }\n  }\n\n  clearTransitionsFromNode(node) {\n    if (node.transitionLogic != null) {\n      node.transitionLogic.transitions = [];\n    }\n  }\n\n  insertNodeAtBeginningOfInactiveNodes(node) {\n    this.project.inactiveNodes.splice(0, 0, node);\n  }\n\n  insertNodeAfterInactiveNode(node, nodeIdToInsertAfter) {\n    const inactiveNodes = this.getInactiveNodes();\n    for (let i = 0; i < inactiveNodes.length; i++) {\n      if (inactiveNodes[i].id === nodeIdToInsertAfter) {\n        let parentGroup = this.getParentGroup(nodeIdToInsertAfter);\n        if (parentGroup != null) {\n          this.insertNodeAfterInGroups(node.id, nodeIdToInsertAfter);\n          this.insertNodeAfterInTransitions(node, nodeIdToInsertAfter);\n        }\n        inactiveNodes.splice(i + 1, 0, node);\n      }\n    }\n  }\n\n  isNodeIdToInsertTargetNotSpecified(nodeIdToInsertTarget) {\n    return nodeIdToInsertTarget == null ||\n        nodeIdToInsertTarget === 'inactiveNodes' ||\n        nodeIdToInsertTarget === 'inactiveSteps' ||\n        nodeIdToInsertTarget === 'inactiveGroups';\n  }\n\n  /**\n   * Move the node from active to inside an inactive group\n   * @param node the node to move\n   * @param nodeIdToInsertInside place the node inside this\n   */\n  moveFromActiveToInactiveInsertInside(node, nodeIdToInsertInside) {\n    this.removeNodeFromActiveNodes(node.id);\n    this.addInactiveNodeInsertInside(node, nodeIdToInsertInside);\n  }\n\n  /**\n   * Move the node from inactive to inside an inactive group\n   * @param node the node to move\n   * @param nodeIdToInsertInside place the node inside this\n   */\n  moveFromInactiveToInactiveInsertInside(node, nodeIdToInsertInside) {\n    this.removeNodeFromInactiveNodes(node.id);\n\n    if (this.isGroupNode(node.id)) {\n      /*\n       * remove the group's child nodes from our data structures so that we can\n       * add them back in later\n       */\n      let childIds = node.ids;\n      for (let childId of childIds) {\n        let childNode = this.getNodeById(childId);\n        let inactiveNodesIndex = this.project.inactiveNodes.indexOf(childNode);\n        if (inactiveNodesIndex != -1) {\n          this.project.inactiveNodes.splice(inactiveNodesIndex, 1);\n        }\n        let inactiveStepNodesIndex = this.inactiveStepNodes.indexOf(childNode);\n        if (inactiveStepNodesIndex != -1) {\n          this.inactiveStepNodes.splice(inactiveStepNodesIndex, 1);\n        }\n      }\n    }\n\n    // add the node to the inactive array\n    this.addInactiveNodeInsertInside(node, nodeIdToInsertInside);\n  }\n\n  /**\n   * Add the node to the inactive nodes array.\n   * @param node the node to move\n   * @param nodeIdToInsertAfter place the node after this\n   */\n  addInactiveNodeInsertInside(node, nodeIdToInsertInside) {\n    this.clearTransitionsFromNode(node);\n    if (this.isNodeIdToInsertTargetNotSpecified(nodeIdToInsertInside)) {\n      this.insertNodeAtBeginningOfInactiveNodes(node);\n    } else {\n      this.insertNodeInsideInactiveNode(node, nodeIdToInsertInside);\n    }\n    if (node.type == 'group') {\n      this.inactiveGroupNodes.push(node.id);\n      this.addGroupChildNodesToInactive(node);\n    } else {\n      this.inactiveStepNodes.push(node.id);\n    }\n  }\n\n  insertNodeInsideInactiveNode(node, nodeIdToInsertInside) {\n    const inactiveNodes = this.getInactiveNodes();\n    const inactiveGroupNodes = this.getInactiveGroupNodes();\n    for (let inactiveGroup of inactiveGroupNodes) {\n      if (nodeIdToInsertInside == inactiveGroup.id) {\n        this.insertNodeInsideOnlyUpdateTransitions(node.id, nodeIdToInsertInside);\n        this.insertNodeInsideInGroups(node.id, nodeIdToInsertInside);\n        for (let i = 0; i < inactiveNodes.length; i++) {\n          if (inactiveNodes[i].id == nodeIdToInsertInside) {\n            inactiveNodes.splice(i + 1, 0, node);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n    * Move an inactive node within the inactive nodes array.\n    * @param node The node to move.\n    * @param nodeIdToInsertAfter Place the node after this.\n    */\n  moveInactiveNodeToInactiveSection(node, nodeIdToInsertAfter) {\n    this.removeNodeFromInactiveNodes(node.id);\n    this.addInactiveNodeInsertAfter(node, nodeIdToInsertAfter);\n  }\n}\n\nAuthoringToolProjectService.$inject = [\n  '$filter',\n  '$http',\n  '$injector',\n  '$q',\n  '$rootScope',\n  'ConfigService',\n  'UtilService'\n];\n\nexport default AuthoringToolProjectService;\n"]}