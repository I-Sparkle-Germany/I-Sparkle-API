{"version":3,"sources":["classroomMonitorProjectService.es6"],"names":["ClassroomMonitorProjectService","$filter","$http","$injector","$q","$rootScope","ConfigService","UtilService","nodeId","nodeIdAndComponentIds","nodeContent","getNodeContentByNodeId","components","component","componentId","id","nodeIdAndComponentId","push","nodePosition","getNodePositionById","branchLetterRegex","match","exec","node","idToOrder","nodeCount","isGroupNode","childIds","ids","childId","child","getNodeById","calculateNodeOrder","planningIds","availablePlanningNodes","planningId","$inject"],"mappings":"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","file":"classroomMonitorProjectService.js","sourcesContent":["'use strict';\nimport ProjectService from '../services/projectService';\n\nclass ClassroomMonitorProjectService extends ProjectService {\n  constructor($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService) {\n    super($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService);\n  }\n\n  /**\n   * Get the node ids and component ids in a node\n   * @param nodeId get the node ids and component ids in this node\n   * @returns an array of objects. the objects contain a node id\n   * and component id.\n   */\n  getNodeIdsAndComponentIds(nodeId) {\n    const nodeIdAndComponentIds = [];\n    if (nodeId != null) {\n      const nodeContent = this.getNodeContentByNodeId(nodeId);\n      if (nodeContent != null) {\n        const components = nodeContent.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null) {\n              const componentId = component.id;\n              const nodeIdAndComponentId = {};\n              nodeIdAndComponentId.nodeId = nodeId;\n              nodeIdAndComponentId.componentId = componentId;\n              nodeIdAndComponentIds.push(nodeIdAndComponentId);\n            }\n          }\n        }\n      }\n    }\n    return nodeIdAndComponentIds;\n  }\n\n  /**\n   * Get the branch letter in the node position string if the node is in a\n   * branch path\n   * @param nodeId the node id we want the branch letter for\n   * @return the branch letter in the node position if the node is in a branch\n   * path\n   */\n  getBranchLetter(nodeId) {\n    if (nodeId != null) {\n      // get the node position e.g. \"1.8\" or \"1.9 A\"\n      const nodePosition = this.getNodePositionById(nodeId);\n\n      if (nodePosition != null) {\n        // regex for extracting the branch letter\n        const branchLetterRegex = /.*([A-Z])/;\n\n        // run the regex on the node position string\n        const match = branchLetterRegex.exec(nodePosition);\n\n        if (match != null) {\n          /*\n           * the node position has a branch letter so we will get it\n           * from the matched group\n           */\n          return match[1];\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Recursively calculates the node order.\n   * @param node\n   */\n  calculateNodeOrder(node) {\n    this.idToOrder[node.id] = {'order': this.nodeCount};\n    this.nodeCount++;\n    if (this.isGroupNode(node.id)) {\n      const childIds = node.ids;\n      for (let childId of childIds) {\n        const child = this.getNodeById(childId);\n        this.calculateNodeOrder(child);\n      }\n      const planningIds = node.availablePlanningNodes;\n      if (planningIds) {\n        for (let planningId of planningIds) {\n          const child = this.getNodeById(planningId.nodeId);\n          this.calculateNodeOrder(child);\n        }\n      }\n    }\n  };\n}\n\nClassroomMonitorProjectService.$inject = [\n  '$filter',\n  '$http',\n  '$injector',\n  '$q',\n  '$rootScope',\n  'ConfigService',\n  'UtilService'\n];\n\nexport default ClassroomMonitorProjectService;\n"]}