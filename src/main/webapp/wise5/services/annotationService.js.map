{"version":3,"sources":["annotationService.es6"],"names":["AnnotationService","$filter","$http","$rootScope","ConfigService","UtilService","$translate","annotations","annotationId","annotation","id","params","nodeId","componentId","fromWorkgroupId","toWorkgroupId","type","a","length","tempAnnotation","match","constructor","Array","i","thisType","runId","periodId","studentWorkId","annotationType","data","clientSaveTime","push","requestToken","generateKey","addOrUpdateAnnotation","getRunId","workgroupId","getWorkgroupId","angular","toJson","httpParams","method","url","getConfigParam","headers","$","param","then","bind","result","localAnnotation","savedAnnotations","localAnnotations","x","savedAnnotation","y","serverSaveTime","$broadcast","updated","totalScore","scoresFound","scoreFound","indexOf","value","isNaN","score","tempNodeId","Date","parse","createAnnotation","scoreType","latestScoreAnnotation","latestCommentAnnotation","getLatestScoreAnnotation","getLatestCommentAnnotation","getAnnotations","acceptAnnotation","tempComponentId","tempToWorkgroupId","tempAnnotationType","commentType","scoreAnnotation","scoreValue","allGlobalAnnotations","getAllGlobalAnnotations","globalAnnotationsByNodeIdAndComponentId","filter","globalAnnotation","globalAnnotations","isGlobal","globalAnnotationGroups","annotationGroupName","annotationGroupCreatedTime","sameGroupFound","g","globalAnnotationGroup","annotationGroupNameAndTime","annotationGroup","console","error","activeGlobalAnnotationGroups","unGlobalizedTimestamp","ag","activeGlobalAnnotationGroup","his","inActiveGlobalAnnotations","$inject"],"mappings":"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","file":"annotationService.js","sourcesContent":["'use strict';\n\nclass AnnotationService {\n    constructor($filter,\n                $http,\n                $rootScope,\n                ConfigService,\n                UtilService) {\n\n        this.$filter = $filter;\n        this.$http = $http;\n        this.$rootScope = $rootScope;\n        this.ConfigService = ConfigService;\n        this.UtilService = UtilService;\n\n        this.$translate = this.$filter('translate');\n\n        this.annotations = null;\n    }\n\n    /**\n     * Get all the annotations\n     */\n    getAnnotations() {\n        return this.annotations;\n    }\n\n    /**\n     * Get the annotation with the specified id, or null if not found\n     * @param annotationId\n     */\n    getAnnotationById(annotationId) {\n        for (let annotation of this.annotations) {\n            if (annotation.id === annotationId) {\n                return annotation;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Get the latest annotation with the given params\n     * @param params an object containing the params to match\n     * @returns the latest annotation that matches the params\n     */\n    getLatestAnnotation(params) {\n        var annotation = null;\n\n        if (params != null) {\n            var nodeId = params.nodeId;\n            var componentId = params.componentId;\n            var fromWorkgroupId = params.fromWorkgroupId;\n            var toWorkgroupId = params.toWorkgroupId;\n            var type = params.type;\n\n            var annotations = this.annotations;\n\n            if (annotations != null) {\n                for (var a = annotations.length - 1; a >= 0; a--) {\n                    var tempAnnotation = annotations[a];\n\n                    if (tempAnnotation != null) {\n                        let match = true;\n\n                        if (nodeId && tempAnnotation.nodeId !== nodeId) {\n                            match = false;\n                        }\n                        if (match && componentId && tempAnnotation.componentId !== componentId) {\n                            match = false;\n                        }\n                        if (match && fromWorkgroupId && tempAnnotation.fromWorkgroupId !== fromWorkgroupId) {\n                            match = false;\n                        }\n                        if (match && toWorkgroupId && tempAnnotation.toWorkgroupId !== toWorkgroupId) {\n                            match = false;\n                        }\n                        if (match && type) {\n                            if (type.constructor === Array) {\n                                for (let i = 0; i < type.length; i++) {\n                                    let thisType = type[i];\n                                    if (tempAnnotation.type !== thisType) {\n                                        match = false;\n                                    }\n                                }\n                            } else {\n                                if (tempAnnotation.type !== type) {\n                                    match = false;\n                                }\n                            }\n                        }\n\n                        if (match) {\n                            annotation = tempAnnotation;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return annotation;\n    };\n\n    /**\n     * Create an annotation object\n     * @param annotationId the annotation id\n     * @param runId the run id\n     * @param periodId the period id\n     * @param fromWorkgroupId the from workgroup id\n     * @param toWorkgroupId the to workgroup id\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param studentWorkId the student work id\n     * @param annotationType the annotation type\n     * @param data the data\n     * @param clientSaveTime the client save time\n     * @returns an annotation object\n     */\n    createAnnotation(\n        annotationId, runId, periodId, fromWorkgroupId, toWorkgroupId,\n        nodeId, componentId, studentWorkId,\n        annotationType, data, clientSaveTime) {\n\n        var annotation = {};\n        annotation.id = annotationId;\n        annotation.runId = runId;\n        annotation.periodId = periodId;\n        annotation.fromWorkgroupId = fromWorkgroupId;\n        annotation.toWorkgroupId = toWorkgroupId;\n        annotation.nodeId = nodeId;\n        annotation.componentId = componentId;\n        annotation.studentWorkId = studentWorkId;\n        annotation.type = annotationType;\n        annotation.data = data;\n        annotation.clientSaveTime = clientSaveTime;\n\n        return annotation;\n    };\n\n    /**\n     * Save the annotation to the server\n     * @param annotation the annotation object\n     * @returns a promise\n     */\n    saveAnnotation(annotation) {\n\n        if (annotation != null) {\n            var annotations = [];\n            annotations.push(annotation);\n\n            // loop through all the annotations and inject a request token\n            if (annotations != null && annotations.length > 0) {\n                for (var a = 0; a < annotations.length; a++) {\n                    var annotation = annotations[a];\n\n                    if (annotation != null) {\n                        annotation.requestToken = this.UtilService.generateKey(); // use this to keep track of unsaved annotations.\n                        this.addOrUpdateAnnotation(annotation);\n                    }\n                }\n            } else {\n                annotations = [];\n            }\n\n            var params = {};\n            params.runId = this.ConfigService.getRunId();\n            params.workgroupId = this.ConfigService.getWorkgroupId();\n            params.annotations = angular.toJson(annotations);\n\n            var httpParams = {};\n            httpParams.method = 'POST';\n            httpParams.url = this.ConfigService.getConfigParam('teacherDataURL');\n            httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n            httpParams.data = $.param(params);\n\n            return this.$http(httpParams).then(angular.bind(this, function(result) {\n\n                var localAnnotation = null;\n\n                if (result != null && result.data != null) {\n                    var data = result.data;\n\n                    if (data != null) {\n\n                        // get the saved annotations\n                        var savedAnnotations = data.annotations;\n\n                        // get the local annotations\n                        var localAnnotations = this.annotations;\n\n                        if (savedAnnotations != null && localAnnotations != null) {\n\n                            // loop through all the saved annotations\n                            for (var x = 0; x < savedAnnotations.length; x++) {\n                                var savedAnnotation = savedAnnotations[x];\n\n                                // loop through all the local annotations\n                                for (var y = localAnnotations.length - 1; y >= 0; y--) {\n                                    localAnnotation = localAnnotations[y];\n\n                                    if (localAnnotation.id != null &&\n                                        localAnnotation.id === savedAnnotation.id) {\n\n                                        // we have found the matching local annotation so we will update it\n                                        localAnnotation.serverSaveTime = savedAnnotation.serverSaveTime;\n                                        //localAnnotation.requestToken = null; // requestToken is no longer needed.\n\n                                        this.$rootScope.$broadcast('annotationSavedToServer', {annotation: localAnnotation});\n                                        break;\n                                    } else if (localAnnotation.requestToken != null &&\n                                        localAnnotation.requestToken === savedAnnotation.requestToken) {\n\n                                        // we have found the matching local annotation so we will update it\n                                        localAnnotation.id = savedAnnotation.id;\n                                        localAnnotation.serverSaveTime = savedAnnotation.serverSaveTime;\n                                        localAnnotation.requestToken = null; // requestToken is no longer needed.\n\n                                        this.$rootScope.$broadcast('annotationSavedToServer', {annotation: localAnnotation});\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n\n                return localAnnotation;\n            }));\n        }\n    };\n\n    /**\n     * Add or update the annotation to our local collection\n     * @param annotation the annotation object\n     */\n    addOrUpdateAnnotation(annotation) {\n\n        if (annotation != null) {\n\n            var updated = false;\n\n            var annotations = this.annotations;\n\n            if (annotations != null) {\n\n                // loop through all the local annotations\n                for (var a = annotations.length - 1; a >= 0; a--) {\n                    var tempAnnotation = annotations[a];\n\n                    if (tempAnnotation != null) {\n\n                        if (annotation.id == tempAnnotation.id &&\n                            annotation.nodeId == tempAnnotation.nodeId &&\n                            annotation.componentId == tempAnnotation.componentId &&\n                            annotation.fromWorkgroupId == tempAnnotation.fromWorkgroupId &&\n                            annotation.toWorkgroupId == tempAnnotation.toWorkgroupId &&\n                            annotation.type == tempAnnotation.type &&\n                            annotation.studentWorkId == tempAnnotation.studentWorkId &&\n                            annotation.runId == tempAnnotation.runId &&\n                            annotation.periodId == tempAnnotation.periodId) {\n\n                            // the annotation matches so we will update it\n                            tempAnnotation.data = annotation.data;\n                            tempAnnotation.clientSaveTime = annotation.clientSaveTime;\n                            tempAnnotation.serverSaveTime = annotation.serverSaveTime;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n\n            if (!updated) {\n                // we did not find a match so we will add it\n                annotations.push(annotation);\n            }\n        }\n    };\n\n    /**\n     * Set the annotations\n     * @param annotations the annotations aray\n     */\n    setAnnotations(annotations) {\n        this.annotations = annotations;\n    };\n\n    /**\n     * Get the total score for a workgroup\n     * @param annotations an array of annotations\n     * @param workgroupId the workgroup id\n     */\n    getTotalScore(annotations, workgroupId) {\n\n        var totalScore = 0;\n\n        var scoresFound = [];\n\n        if (annotations != null && workgroupId != null) {\n            // loop through all the annotations from newest to oldest\n            for (var a = annotations.length - 1; a >= 0; a--) {\n\n                // get an annotation\n                var annotation = annotations[a];\n\n                // check that the annotation is for the workgroup id we are looking for\n                if (annotation != null && annotation.toWorkgroupId == workgroupId) {\n\n                    // check that the annotation is a score annotation\n                    if (annotation.type === 'score') {\n\n                        var nodeId = annotation.nodeId;\n                        var componentId = annotation.componentId;\n                        var data = annotation.data;\n\n                        var scoreFound = nodeId + '-' + componentId;\n\n                        // check if we have obtained a score from this component already\n                        if (scoresFound.indexOf(scoreFound) == -1) {\n                            // we have not obtained a score from this component yet\n\n                            if (data != null) {\n                                var value = data.value;\n\n                                if (!isNaN(value)) {\n\n                                    if (totalScore == null) {\n                                        totalScore = value;\n                                    } else {\n                                        totalScore += value;\n                                    }\n\n                                    /*\n                                     * remember that we have found a score for this component\n                                     * so that we don't double count it if the teacher scored\n                                     * the component more than once\n                                     */\n                                    scoresFound.push(scoreFound);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return totalScore;\n    }\n\n    /**\n     * Get the score for a workgroup for a node\n     * @param workgroupId the workgroup id\n     * @param nodeId the node id\n     * @returns the score for a workgroup for a node\n     */\n    getScore(workgroupId, nodeId) {\n\n        var score = null;\n\n        /*\n         * an array to keep track of the components that we have obtained a\n         * score for. we do not want to double count components if the student\n         * has received a score multiple times for a node from the teacher.\n         */\n        var scoresFound = [];\n\n        // get all the annotations\n        var annotations = this.annotations;\n\n        if (workgroupId != null && nodeId != null) {\n            // loop through all the annotations from newest to oldest\n            for (var a = annotations.length - 1; a >= 0; a--) {\n\n                // get an annotation\n                var annotation = annotations[a];\n\n                // check that the annotation is for the workgroup id we are looking for\n                if (annotation != null && annotation.toWorkgroupId == workgroupId) {\n\n                    // check that the annotation is a score annotation\n                    if (annotation.type === 'score' || annotation.type === 'autoScore') {\n\n                        var tempNodeId = annotation.nodeId;\n\n                        // check that the annotation is for the node we are looking for\n                        if (nodeId == tempNodeId) {\n                            var componentId = annotation.componentId;\n                            var data = annotation.data;\n\n                            var scoreFound = tempNodeId + '-' + componentId;\n\n                            // check if we have obtained a score from this component already\n                            if (scoresFound.indexOf(scoreFound) == -1) {\n                                // we have not obtained a score from this component yet\n\n                                if (data != null) {\n                                    var value = data.value;\n\n                                    if (!isNaN(value)) {\n\n                                        if (score == null) {\n                                            score = value;\n                                        } else {\n                                            score += value;\n                                        }\n\n                                        /*\n                                         * remember that we have found a score for this component\n                                         * so that we don't double count it if the teacher scored\n                                         * the component more than once\n                                         */\n                                        scoresFound.push(scoreFound);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return score;\n    }\n\n    /**\n     * Create an auto score annotation\n     * @param runId the run id\n     * @param periodId the period id\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param toWorkgroupId the student workgroup id\n     * @param data the annotation data\n     * @returns the auto score annotation\n     */\n    createAutoScoreAnnotation(runId, periodId, nodeId, componentId, toWorkgroupId, data) {\n        var annotationId = null;\n        var fromWorkgroupId = null;\n        var studentWorkId = null;\n        var annotationType = 'autoScore';\n        var clientSaveTime = Date.parse(new Date());\n\n        var annotation = this.createAnnotation(\n            annotationId, runId, periodId, fromWorkgroupId, toWorkgroupId,\n            nodeId, componentId, studentWorkId,\n            annotationType, data, clientSaveTime\n        );\n\n        return annotation;\n    }\n\n    /**\n     * Create an auto comment annotation\n     * @param runId the run id\n     * @param periodId the period id\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param toWorkgroupId the student workgroup id\n     * @param data the annotation data\n     * @returns the auto comment annotation\n     */\n    createAutoCommentAnnotation(runId, periodId, nodeId, componentId, toWorkgroupId, data) {\n        var annotationId = null;\n        var fromWorkgroupId = null;\n        var studentWorkId = null;\n        var annotationType = 'autoComment';\n        var clientSaveTime = Date.parse(new Date());\n\n        var annotation = this.createAnnotation(\n            annotationId, runId, periodId, fromWorkgroupId, toWorkgroupId,\n            nodeId, componentId, studentWorkId,\n            annotationType, data, clientSaveTime\n        );\n\n        return annotation;\n    }\n\n    /**\n     * Get the latest annotations for a given component (as an object)\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param workgroupId the workgroup id\n     * @param scoreType (optional) the type of score\n     * e.g.\n     * 'autoScore' for auto graded score\n     * 'score' for teacher graded score\n     * 'any' for auto graded score or teacher graded score\n     * @return object containing the component's latest score and comment annotations\n     */\n    getLatestComponentAnnotations(nodeId, componentId, workgroupId, scoreType) {\n        let latestScoreAnnotation = null;\n        let latestCommentAnnotation = null;\n\n        // get the latest score annotation for this component\n        latestScoreAnnotation = this.getLatestScoreAnnotation(nodeId, componentId, workgroupId, scoreType);\n\n        // get the latest comment annotation for this component\n        latestCommentAnnotation = this.getLatestCommentAnnotation(nodeId, componentId, workgroupId, scoreType);\n\n        return {\n            'score': latestScoreAnnotation,\n            'comment': latestCommentAnnotation\n        };\n    };\n\n    /**\n     * Get the latest score annotation\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param workgroupId the workgroup id\n     * @param scoreType (optional) the type of score\n     * e.g.\n     * 'autoScore' for auto graded score\n     * 'score' for teacher graded score\n     * 'any' for auto graded score or teacher graded score\n     * @returns the latest score annotation\n     */\n    getLatestScoreAnnotation(nodeId, componentId, workgroupId, scoreType) {\n\n        var annotation = null;\n\n        var annotations = this.getAnnotations();\n\n        if (scoreType == null) {\n            // default to 'any'\n            scoreType = 'any';\n        }\n\n        // loop through all the annotations from newest to oldest\n        for (var a = annotations.length - 1; a >= 0; a--) {\n            var tempAnnotation = annotations[a];\n\n            if (tempAnnotation != null) {\n                var acceptAnnotation = false;\n                var tempNodeId = tempAnnotation.nodeId;\n                var tempComponentId = tempAnnotation.componentId;\n                var tempToWorkgroupId = tempAnnotation.toWorkgroupId;\n                var tempAnnotationType = tempAnnotation.type;\n\n                // make sure the annotation values match what we are looking for\n                if (nodeId == tempNodeId && componentId == tempComponentId && workgroupId == tempToWorkgroupId) {\n\n                    if (scoreType === 'any' && (tempAnnotationType === 'autoScore' || tempAnnotationType === 'score')) {\n                        // we are looking for an auto score or teacher score and have found one\n                        acceptAnnotation = true;\n                    } else if (scoreType === 'autoScore' && tempAnnotationType === 'autoScore') {\n                        // we are looking for an auto score and have found one\n                        acceptAnnotation = true;\n                    } else if (scoreType === 'score' && tempAnnotationType === 'score') {\n                        // we are looking for a teacher score and have found one\n                        acceptAnnotation = true;\n                    }\n\n                    if (acceptAnnotation) {\n                        // we have found the latest score annotation of the type we want\n                        annotation = tempAnnotation;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return annotation;\n    }\n\n    /**\n     * Get the latest comment annotation\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param workgroupId the workgroup id\n     * @param commentType (optional) the type of comment\n     * e.g.\n     * 'autoComment' for auto graded comment\n     * 'comment' for teacher graded comment\n     * 'any' for auto graded comment or teacher graded comment\n     * @returns the latest comment annotation\n     */\n    getLatestCommentAnnotation(nodeId, componentId, workgroupId, commentType) {\n\n        var annotation = null;\n\n        var annotations = this.getAnnotations();\n\n        if (commentType == null) {\n            // default to 'any'\n            commentType = 'any';\n        }\n\n        // loop through all the annotations from newest to oldest\n        for (var a = annotations.length - 1; a >= 0; a--) {\n            var tempAnnotation = annotations[a];\n\n            if (tempAnnotation != null) {\n                var acceptAnnotation = false;\n                var tempNodeId = tempAnnotation.nodeId;\n                var tempComponentId = tempAnnotation.componentId;\n                var tempToWorkgroupId = tempAnnotation.toWorkgroupId;\n                var tempAnnotationType = tempAnnotation.type;\n\n                // make sure the annotation values match what we are looking for\n                if (nodeId == tempNodeId && componentId == tempComponentId && workgroupId == tempToWorkgroupId) {\n\n                    if (commentType === 'any' && (tempAnnotationType === 'autoComment' || tempAnnotationType === 'comment')) {\n                        // we are looking for an auto comment or teacher comment and have found one\n                        acceptAnnotation = true;\n                    } else if (commentType === 'autoComment' && tempAnnotationType === 'autoComment') {\n                        // we are looking for an auto comment and have found one\n                        acceptAnnotation = true;\n                    } else if (commentType === 'comment' && tempAnnotationType === 'comment') {\n                        // we are looking for a teacher comment and have found one\n                        acceptAnnotation = true;\n                    }\n\n                    if (acceptAnnotation) {\n                        // we have found the latest comment annotation of the type we want\n                        annotation = tempAnnotation;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return annotation;\n    }\n\n    /**\n     * Get the score value from the score annotation\n     * @param scoreAnnotation a score annotation\n     * @returns the score value e.g. 5\n     */\n    getScoreValueFromScoreAnnotation(scoreAnnotation) {\n        var scoreValue = null;\n\n        if (scoreAnnotation != null) {\n            var data = scoreAnnotation.data;\n\n            if (data != null) {\n                scoreValue = data.value;\n            }\n        }\n\n        return scoreValue;\n    }\n\n    /**\n     * Get all global annotations that are active and inactive for a specified node and component\n     * @returns all global annotations that are active and inactive for a specified node and component\n     */\n    getAllGlobalAnnotationsByNodeIdAndComponentId(nodeId, componentId) {\n        let allGlobalAnnotations = this.getAllGlobalAnnotations();\n        let globalAnnotationsByNodeIdAndComponentId = allGlobalAnnotations.filter((globalAnnotation) => {\n            return globalAnnotation.nodeId === nodeId && globalAnnotation.componentId === componentId;\n        });\n        return globalAnnotationsByNodeIdAndComponentId;\n    };\n\n    /**\n     * Get all global annotations that are active and inactive\n     * @returns all global annotations that are active and inactive\n     */\n    getAllGlobalAnnotations() {\n        let globalAnnotations = [];\n\n        for (let a = 0; a < this.annotations.length; a++) {\n            let annotation = this.annotations[a];\n            if (annotation != null && annotation.data != null) {\n                if (annotation.data.isGlobal) {\n                    globalAnnotations.push(annotation);\n                }\n            }\n        }\n\n        return globalAnnotations;\n    };\n\n    /**\n     * Get all global annotations that are active and inactive and groups them by annotation group name\n     * @returns all global annotations that are active and inactive\n     */\n    getAllGlobalAnnotationGroups() {\n        let globalAnnotationGroups = [];\n\n        for (let a = 0; a < this.annotations.length; a++) {\n            let annotation = this.annotations[a];\n            if (annotation != null && annotation.data != null) {\n                if (annotation.data.isGlobal) {\n                    // check if this global annotation can be grouped (has the same annotationGroupName as another that we've seen before)\n                    if (annotation.data.annotationGroupName != null && annotation.data.annotationGroupCreatedTime != null) {\n                        let sameGroupFound = false;\n                        for (let g = 0; g < globalAnnotationGroups.length; g++) {\n                            let globalAnnotationGroup = globalAnnotationGroups[g];\n                            if (globalAnnotationGroup.annotationGroupNameAndTime == (annotation.data.annotationGroupName + annotation.data.annotationGroupCreatedTime)) {\n                                // push this annotation to the end of the group\n                                globalAnnotationGroup.annotations.push(annotation);\n                                sameGroupFound = true;\n                            }\n                        }\n                        if (!sameGroupFound) {\n                            let annotationGroup = {\n                                \"annotationGroupNameAndTime\": (annotation.data.annotationGroupName + annotation.data.annotationGroupCreatedTime),\n                                \"annotations\": [annotation]\n                            };\n                            globalAnnotationGroups.push(annotationGroup);\n                        }\n                    } else {\n                        // each global annotation should have a name, so it shouldn't get here\n                        console.error(this.$translate('GLOBAL_ANNOTATION_DOES_NOT_HAVE_A_NAME') + annotation);\n                    }\n                }\n            }\n        }\n\n        return globalAnnotationGroups;\n    };\n\n    /**\n     * Get all global annotations that are active\n     * @returns all global annotations that are active, in a group\n     * [\n     * {\n     *   annotationGroupName:\"score1\",\n     *   annotations:[\n     *   {\n     *     type:autoScore,\n     *     value:1\n     *   },\n     *   {\n     *     type:autoComment,\n     *     value:\"you received a score of 1.\"\n     *   }\n     *   ]\n     * },\n     * {\n     *   annotationGroupName:\"score2\",\n     *   annotations:[...]\n     * }\n     * ]\n     */\n    getActiveGlobalAnnotationGroups() {\n        return this.activeGlobalAnnotationGroups;\n    };\n\n    /**\n     * Calculates the active global annotations and groups them by annotation group name\n     */\n    calculateActiveGlobalAnnotationGroups() {\n        this.activeGlobalAnnotationGroups = [];\n\n        for (let a = 0; a < this.annotations.length; a++) {\n            let annotation = this.annotations[a];\n            if (annotation != null && annotation.data != null) {\n                if (annotation.data.isGlobal && annotation.data.unGlobalizedTimestamp == null) {\n                    // check if this global annotation can be grouped (has the same annotationGroupName as another that we've seen before)\n                    if (annotation.data.annotationGroupName != null) {\n                        let sameGroupFound = false;\n                        for (let ag = 0; ag < this.activeGlobalAnnotationGroups.length; ag++) {\n                            let activeGlobalAnnotationGroup = this.activeGlobalAnnotationGroups[ag];\n                            if (activeGlobalAnnotationGroup.annotationGroupName == (annotation.data.annotationGroupName + '_' + annotation.data.annotationGroupCreatedTime)) {\n                                // push this annotation to the end of the group\n                                activeGlobalAnnotationGroup.annotations.push(annotation);\n                                sameGroupFound = true;\n                            }\n                        }\n                        if (!sameGroupFound) {\n                            let annotationGroup = {\n                                \"annotationGroupName\": annotation.data.annotationGroupName + '_' + annotation.data.annotationGroupCreatedTime,\n                                \"annotations\": [annotation],\n                                \"nodeId\": annotation.nodeId,\n                                \"componentId\": annotation.componentId,\n                                \"serverSaveTime\": annotation.serverSaveTime\n                            };\n                            this.activeGlobalAnnotationGroups.push(annotationGroup);\n                        }\n                    } else {\n                        // each global annotation should have a name, so it shouldn't get here\n                        console.error(his.$translate('GLOBAL_ANNOTATION_DOES_NOT_HAVE_A_NAME') + annotation);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Get all global annotations that are in-active\n     * @returns all global annotations that are in-active\n     * In-active global annotations has data.isGlobal = false and data.unGlobalizedTimestamp is set.\n     */\n    getInActiveGlobalAnnotations() {\n        let inActiveGlobalAnnotations = [];\n\n        for (let a = 0; a < this.annotations.length; a++) {\n            let annotation = this.annotations[a];\n            if (annotation != null && annotation.data != null) {\n                if (annotation.data.isGlobal && annotation.data.unGlobalizedTimestamp != null) {\n                    inActiveGlobalAnnotations.push(annotation);\n                }\n            }\n        }\n\n        return inActiveGlobalAnnotations;\n    };\n}\n\nAnnotationService.$inject = [\n    '$filter',\n    '$http',\n    '$rootScope',\n    'ConfigService',\n    'UtilService'\n];\n\nexport default AnnotationService;\n"]}