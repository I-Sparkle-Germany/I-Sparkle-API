{"version":3,"sources":["nodeService.es6"],"names":[],"mappings":"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","file":"nodeService.js","sourcesContent":["class NodeService {\n\n    constructor($http, \n                $injector, \n                $mdDialog,\n                $q, \n                ConfigService, \n                ProjectService, \n                StudentDataService) {\n        this.$http = $http;\n        this.$injector = $injector;\n        this.$mdDialog = $mdDialog;\n        this.$q = $q;\n        this.ConfigService = ConfigService;\n        this.ProjectService = ProjectService;\n        this.StudentDataService = StudentDataService;\n        \n        this.transitionResults = {};\n        this.chooseTransitionPromises = {};\n    }\n\n    /**\n     * Create a new empty node state\n     * @return a new empty node state\n     */\n    createNewComponentState() {\n        var componentState = {};\n\n        // set the timestamp\n        componentState.clientSaveTime = Date.parse(new Date());\n\n        return componentState;\n    };\n\n    /**\n     * Create a new empty node state\n     * @return a new empty node state\n     */\n    createNewNodeState() {\n        var nodeState = {};\n        nodeState.runId = this.ConfigService.getRunId();\n        nodeState.periodId = this.ConfigService.getPeriodId();\n        nodeState.workgroupId = this.ConfigService.getWorkgroupId();\n\n        // set the timestamp\n        nodeState.clientSaveTime = Date.parse(new Date());\n\n        return nodeState;\n    };\n\n    /**\n     * Get the node type in camel case\n     * @param nodeType the node type e.g. OpenResponse\n     * @return the node type in camel case\n     * e.g.\n     * openResponse\n     */\n    toCamelCase(nodeType) {\n        var nodeTypeCamelCased = null;\n\n        if (nodeType != null && nodeType.length > 0) {\n\n            // get the first character\n            var firstChar = nodeType.charAt(0);\n\n            if(firstChar != null) {\n\n                // make the first character lower case\n                var firstCharLowerCase = firstChar.toLowerCase();\n\n                if (firstCharLowerCase != null) {\n\n                    /*\n                     * replace the first character with the lower case\n                     * character\n                     */\n                    nodeTypeCamelCased = firstCharLowerCase + nodeType.substr(1);\n                }\n            }\n        }\n\n        return nodeTypeCamelCased;\n    };\n\n    /**\n     * Check if the string is in all uppercase\n     * @param str the string to check\n     * @return whether the string is in all uppercase\n     */\n    isStringUpperCase(str) {\n        var result = false;\n\n        if (str != null) {\n            if (str === str.toUpperCase()) {\n                // the string is in all uppercase\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the html template for the component\n     * @param componentType the component type\n     * @return the path to the html template for the component\n     */\n    getComponentTemplatePath(componentType) {\n\n        if (componentType == null) {\n            // error\n        } else if (this.isStringUpperCase(componentType)) {\n            /*\n             * the component type is all uppercase so we will convert it to all\n             * lowercase\n             */\n            componentType = componentType.toLowerCase();\n        } else {\n            // get the component type in camel case\n            componentType = this.toCamelCase(componentType);\n        }\n        var wiseBaseURL = this.ConfigService.getWISEBaseURL();\n        return wiseBaseURL + '/wise5/components/' + componentType + '/index.html';\n    };\n\n    /**\n     * Get the component content\n     * @param componentContent the component content\n     * @param componentId the component id\n     * @return the component content\n     */\n    getComponentContentById(nodeContent, componentId) {\n        var componentContent = null;\n\n        if (nodeContent != null && componentId != null) {\n\n            // get the components\n            var components = nodeContent.components;\n\n            if (components != null) {\n\n                // loop through the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n                        var tempComponentId = tempComponent.id;\n\n                        if (tempComponentId === componentId) {\n                            // we have found the component with the component id we want\n                            componentContent = tempComponent;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return componentContent;\n    };\n\n    /**\n     * Check if any of the component states were submitted\n     * @param componentStates an array of component states\n     * @return whether any of the component states were submitted\n     */\n    isWorkSubmitted(componentStates) {\n        var result = false;\n\n        if (componentStates != null) {\n\n            // loop through all the component states\n            for (var c = 0; c < componentStates.length; c++) {\n                var componentState = componentStates[c];\n\n                if (componentState != null) {\n\n                    if (componentState.isSubmit) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if the node or component is completed\n     * @param functionParams the params that will specify which node or component\n     * to check for completion\n     * @returns whether the specified node or component is completed\n     */\n    isCompleted(functionParams) {\n\n        var result = false;\n\n        if (functionParams != null) {\n            var nodeId = functionParams.nodeId;\n            var componentId = functionParams.componentId;\n\n            result = this.StudentDataService.isCompleted(nodeId, componentId);\n        }\n\n        return result;\n    };\n\n    /**\n     * Go to the next node\n     */\n    goToNextNode() {\n\n        this.getNextNodeId().then((nextNodeId) => {\n            if (nextNodeId != null) {\n                this.StudentDataService.endCurrentNodeAndSetCurrentNodeByNodeId(nextNodeId);\n            }\n        });\n    };\n\n    /**\n     * Get the next node in the project sequence. We return a promise because\n     * in preview mode we allow the user to specify which branch path they\n     * want to go to. In all other cases we will resolve the promise immediately.\n     * @returns a promise that returns the next node id\n     */\n    getNextNodeId() {\n        \n        // create a promise that will return the next node id\n        var deferred = this.$q.defer();\n        var promise = deferred.promise;\n        \n        var nextNodeId = null;\n\n        // get the current node\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n            var currentNodeId = currentNode.id;\n            \n            // get the transition logic from the current node\n            var transitionLogic = this.ProjectService.getTransitionLogicByFromNodeId(currentNodeId);\n            \n            // get all the branchPathTaken events for the current node\n            var branchPathTakenEvents = this.StudentDataService.getBranchPathTakenEventsByNodeId(currentNodeId);\n            \n            if (branchPathTakenEvents != null && branchPathTakenEvents.length > 0 && \n                (transitionLogic != null && transitionLogic.canChangePath != true)) {\n                // the student has branched on this node before and they are not allowed to change paths\n                \n                // loop through all the branchPathTaken events from newest to oldest\n                for (var b = branchPathTakenEvents.length - 1; b >= 0; b--) {\n                    var branchPathTakenEvent = branchPathTakenEvents[b];\n                    \n                    if (branchPathTakenEvent != null) {\n                        \n                        // get the data from the event\n                        var data = branchPathTakenEvent.data;\n                        \n                        if (data != null) {\n                            // get the to node id\n                            var toNodeId = data.toNodeId;\n                            nextNodeId = toNodeId;\n                            deferred.resolve(nextNodeId);\n                            break;\n                        }\n                    }\n                }\n            } else {\n                // the student has not branched on this node before\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n                    \n                    if (transitions == null || transitions.length == 0) {\n                        /*\n                         * this node does not have any transitions so we will\n                         * check if the parent group has transitions\n                         */\n                        \n                        // get the parent group id\n                        var parentGroupId = this.ProjectService.getParentGroupId(currentNodeId);\n                        var parentHasTransitionLogic = false;\n                        \n                        if (parentGroupId != null) {\n                            \n                            // get the transition logic from the parent\n                            var parentTransitionLogic = this.ProjectService.getTransitionLogicByFromNodeId(parentGroupId);\n                            \n                            if (parentTransitionLogic != null) {\n                                \n                                parentHasTransitionLogic = true;\n                                \n                                // choose a transition\n                                this.chooseTransition(parentGroupId, parentTransitionLogic).then((transition) => {\n                                    \n                                    if (transition != null) {\n                                        // get the to node id\n                                        var transitionToNodeId = transition.to;\n                                        \n                                        if (this.ProjectService.isGroupNode(transitionToNodeId)) {\n                                            // the to node is a group\n                                            \n                                            // get the start id of the group\n                                            var startId = this.ProjectService.getGroupStartId(transitionToNodeId);\n                                            \n                                            if (startId == null || startId == '') {\n                                                // the group does not have a start id so we will just use the group\n                                                nextNodeId = transitionToNodeId;\n                                            } else {\n                                                // the group has a start id so we will use the start id\n                                                nextNodeId = startId;\n                                            }\n                                        } else {\n                                            // the to node is a step\n                                            nextNodeId = transitionToNodeId;\n                                        }\n                                    }\n                                    \n                                    // resolve the promise with the next node id\n                                    deferred.resolve(nextNodeId);\n                                });\n                            }\n                        }\n                        \n                        if (!parentHasTransitionLogic) {\n                            /*\n                             * the parent does not have any transition logic so \n                             * there is no next node from the parent\n                             */\n                            deferred.resolve(null);\n                        }\n                    } else {\n                        // choose a transition\n                        this.chooseTransition(currentNodeId, transitionLogic).then((transition) => {\n                            \n                            if (transition != null) {\n                                // move the student to the toNodeId\n                                nextNodeId = transition.to;\n                                \n                                // resolve the promise with the next node id\n                                deferred.resolve(nextNodeId);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        return promise;\n    };\n\n    /**\n     * Go to the previous node\n     */\n    goToPrevNode() {\n\n        var prevNodeId = this.getPrevNodeId();\n        if (prevNodeId != null) {\n            this.StudentDataService.endCurrentNodeAndSetCurrentNodeByNodeId(prevNodeId);\n        }\n    };\n\n    /**\n     * Get the previous node in the project sequence\n     */\n    getPrevNodeId() {\n\n        var prevNodeId = null;\n\n        // get the current node\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n\n            var currentNodeId = currentNode.id;\n            \n            // get all the nodes that transition to the current node\n            var nodeIdsByToNodeId = this.ProjectService.getNodeIdsByToNodeId(currentNodeId);\n            \n            if (nodeIdsByToNodeId == null) {\n                \n            } else if (nodeIdsByToNodeId.length === 1) {\n                // there is only one node that transitions to the current node\n                prevNodeId = nodeIdsByToNodeId[0];\n            } else if (nodeIdsByToNodeId.length > 1) {\n                // there are multiple nodes that transition to the current node\n                \n                // get the stack history\n                var stackHistory = this.StudentDataService.getStackHistory();\n                \n                // loop through the stack history node ids from newest to oldest\n                for (var s = stackHistory.length - 1; s >= 0; s--) {\n                    var stackHistoryNodeId = stackHistory[s];\n                    \n                    if (nodeIdsByToNodeId.indexOf(stackHistoryNodeId) != -1) {\n                        // we have found a node that we previously visited that transitions to the current node\n                        prevNodeId = stackHistoryNodeId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return prevNodeId;\n    };\n\n    /**\n     * Close the current node (and open the current node's parent group)\n     */\n    closeNode() {\n        var currentNode = this.StudentDataService.getCurrentNode();\n        if (currentNode) {\n\n            var currentNodeId = currentNode.id;\n\n            // get the parent node of the current node\n            var parentNode = this.ProjectService.getParentGroup(currentNodeId);\n\n            var parentNodeId = parentNode.id;\n\n            // set the current node to the parent node\n            this.StudentDataService.endCurrentNodeAndSetCurrentNodeByNodeId(parentNodeId);\n        }\n    };\n\n    /**\n     * Choose the transition the student will take\n     * @param nodeId the current node id\n     * @param transitionLogic an object containing transitions and parameters\n     * for how to choose a transition\n     * @returns a promise that will return a transition\n     */\n    chooseTransition(nodeId, transitionLogic) {\n        \n        var deferred = this.$q.defer();\n        \n        // see if there is already a promise for this step\n        var promise = this.getChooseTransitionPromise(nodeId);\n        \n        if (promise == null) {\n            // there is no existing promise for this step so we will create one\n            promise = deferred.promise;\n        } else {\n            // there is an existing promise for this step so we will use it\n            return promise;\n        }\n        \n        var resolvePromiseNow = true;\n        \n        // check if the transition was already previously calculated\n        var transitionResult = this.getTransitionResultByNodeId(nodeId);\n        \n        if (transitionResult == null || (transitionLogic != null && transitionLogic.canChangePath == true)) {\n            /*\n             * we have not previously calculated the transition or the \n             * transition logic allows the student to change branch paths\n             * so we will calculate the transition again\n             */\n\n            // get the transitions\n            var transitions = transitionLogic.transitions;\n\n            if (transitions != null) {\n\n                let availableTransitions = [];\n\n                // loop through all the transitions\n                for (var t = 0; t < transitions.length; t++) {\n\n                    // get a transition\n                    var transition = transitions[t];\n\n                    // get the to node id\n                    var toNodeId = transition.to;\n\n                    // get the criteria for which this transition can be used\n                    var criteria = transition.criteria;\n\n                    // set the default result to true in case there is no criteria\n                    var criteriaResult = true;\n\n                    if (criteria != null) {\n\n                        var firstResult = true;\n                        var tempResult = true;\n\n                        // loop through all of the criteria\n                        for (var c = 0; c < criteria.length; c++) {\n\n                            // get a criteria\n                            var tempCriteria = criteria[c];\n\n                            // check if the criteria is satisfied\n                            tempResult = this.StudentDataService.evaluateCriteria(tempCriteria);\n\n                            if (firstResult) {\n                                // this is the first criteria in this for loop\n                                criteriaResult = tempResult;\n                                firstResult = false;\n                            } else {\n                                // this is not the first criteria in this for loop so we will && the result\n                                criteriaResult = criteriaResult && tempResult;\n                            }\n                        }\n                    }\n\n                    if (toNodeId != null) {\n\n                        // check if the criteria was satisfied and the to node is visitable\n                        if (criteriaResult) {\n\n                            // the student is allowed to use the transition\n                            availableTransitions.push(transition);\n                        }\n                    }\n                }\n                \n                if (availableTransitions.length == 0) {\n                    // there are no available transitions for the student\n                    transitionResult = null;\n                } else if (availableTransitions.length == 1) {\n                    // there is one available transition for the student\n                    transitionResult = availableTransitions[0];\n                } else if (availableTransitions.length > 1) {\n                    // there are multiple available transitions for the student\n                    \n                    if (this.ConfigService.isPreview()) {\n                        /*\n                         * we are in preview mode so we will let the user choose\n                         * the branch path to go to\n                         */\n                         \n                         if (transitionResult != null) {\n                             /*\n                              * the user has previously chosen the branch path\n                              * so we will use the transition they chose and\n                              * not ask them again\n                              */\n                         } else {\n                             // ask the user which branch path to go to\n                             \n                             resolvePromiseNow = false;\n                             \n                             let chooseBranchPathTemplateUrl = this.ProjectService.getThemePath() + '/themeComponents/branchPathTools/branchPathChooser.html';\n                             \n                             var dialogOptions = {\n                                 templateUrl: chooseBranchPathTemplateUrl,\n                                 controller: ChooseBranchPathController,\n                                 locals: {\n                                     availableTransitions: availableTransitions,\n                                     deferred: deferred,\n                                     nodeId: nodeId\n                                 }\n                             };\n                             \n                             /**\n                              * Controller that handles the dialog popup that lets the user \n                              * which branch path to go to.\n                              * @param $scope the scope\n                              * @param $mdDialog the dialog popup object\n                              * @param availableTransitions the branch paths\n                              * @param deferred used to resolve the promise once the user\n                              * has chosen a branch path\n                              * @param nodeId the current node\n                              */\n                             function ChooseBranchPathController($scope, $mdDialog, availableTransitions, deferred, nodeId) {\n                                 \n                                 $scope.availableTransitions = availableTransitions;\n                                 \n                                 // called when the user clicks on a branch path\n                                 $scope.chooseBranchPath = (transitionResult) => {\n                                     // remember the transition that was chosen\n                                     this.setTransitionResult(nodeId, transitionResult);\n                                     \n                                     // resolve the promise\n                                     deferred.resolve(transitionResult);\n                                     \n                                     /*\n                                      * don't remember the promise for this step anymore\n                                      * since we have resolved it\n                                      */\n                                     this.setChooseTransitionPromise(nodeId, null);\n                                     \n                                     // close the dialog\n                                     $mdDialog.hide();\n                                 }\n                                 \n                                 // obtains the step number and title\n                                 $scope.getNodePositionAndTitleByNodeId = (nodeId) => {\n                                     return this.ProjectService.getNodePositionAndTitleByNodeId(nodeId);\n                                 }\n                                 \n                                 // called when the dialog is closed\n                                 $scope.close = () => {\n                                     $mdDialog.hide();\n                                 }\n                             }\n                             \n                             ChooseBranchPathController.$inject = ['$scope', '$mdDialog', 'availableTransitions', 'deferred', 'nodeId'];\n                             \n                             /*\n                              * show the popup dialog that lets the user choose the\n                              * branch path\n                              */\n                             this.$mdDialog.show(dialogOptions);\n                         }\n                    } else {\n                        /*\n                         * we are in regular student run mode so we will choose\n                         * the branch according to how the step was authored\n                         */\n                        \n                        var howToChooseAmongAvailablePaths = transitionLogic.howToChooseAmongAvailablePaths;\n\n                        if (howToChooseAmongAvailablePaths == null || \n                            howToChooseAmongAvailablePaths === '' || \n                            howToChooseAmongAvailablePaths === 'random') {\n                            // choose a random transition\n\n                            var randomIndex = Math.floor(Math.random() * availableTransitions.length);\n                            transitionResult = availableTransitions[randomIndex];\n                        } else if (howToChooseAmongAvailablePaths === 'workgroupId') {\n                            // use the workgroup id to choose the transition\n\n                            // get the workgroup id\n                            var workgroupId = this.ConfigService.getWorkgroupId();\n                            \n                            // choose the transition index\n                            var index = workgroupId % availableTransitions.length;\n                            \n                            transitionResult = availableTransitions[index];\n                        } else if (howToChooseAmongAvailablePaths === 'firstAvailable') {\n                            // choose the first available transition\n\n                            transitionResult = availableTransitions[0];\n                        } else if (howToChooseAmongAvailablePaths === 'lastAvailable') {\n                            // choose the last available transition\n\n                            transitionResult = availableTransitions[availableTransitions.length - 1];\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (resolvePromiseNow) {\n            // remember the transition that was chosen for this step\n            this.setTransitionResult(nodeId, transitionResult);\n            \n            // resolve the promise immediately\n            deferred.resolve(transitionResult);\n        } else {\n            /*\n             * remember the promise in case someone else calls chooseTransition()\n             * so we can chain off of this promise instead of creating another\n             * promise\n             */\n            this.setChooseTransitionPromise(nodeId, promise);\n        }\n        \n        return promise;\n    };\n\n    hasTransitionLogic() {\n        var result = false;\n\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n            var transitionLogic = currentNode.transitionLogic;\n\n            if (transitionLogic != null) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Evaluate the transition logic for the current node and create branch\n     * path taken events if necessary.\n     */\n    evaluateTransitionLogic() {\n        \n        // get the current node\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n\n            var nodeId = currentNode.id;\n            var transitionLogic = currentNode.transitionLogic;\n\n            if (transitionLogic != null) {\n\n                // get all the transitions from the current node\n                var transitions = transitionLogic.transitions;\n                var canChangePath = transitionLogic.canChangePath;\n                var alreadyBranched = false;\n                \n                // get all the branchPathTaken events for the current node\n                var events = this.StudentDataService.getBranchPathTakenEventsByNodeId(currentNode.id);\n\n                if (events.length > 0) {\n                    // the student has branched from this node before\n                    alreadyBranched = true;\n                }\n\n                var transition, fromNodeId, toNodeId;\n\n                if (alreadyBranched) {\n                    // student has previously branched\n\n                    if (canChangePath) {\n                        // student can change path\n\n                        // choose a transition\n                        this.chooseTransition(nodeId, transitionLogic).then((transition) => {\n                            \n                            if (transition != null) {\n                                fromNodeId = currentNode.id;\n                                toNodeId = transition.to;\n\n                                // create a branchPathTaken event to signify taking the branch path\n                                this.createBranchPathTakenEvent(fromNodeId, toNodeId);\n                            }\n                        });\n                    } else {\n                        // student can't change path\n\n                    }\n                } else {\n                    // student has not branched yet\n\n                    // choose a transition\n                    this.chooseTransition(nodeId, transitionLogic).then((transition) => {\n                        \n                        if (transition != null) {\n                            fromNodeId = currentNode.id;\n                            toNodeId = transition.to;\n\n                            // create a branchPathTaken event to signify taking the branch path\n                            this.createBranchPathTakenEvent(fromNodeId, toNodeId);\n                        }\n                    });\n                }\n            }\n        }\n    };\n    \n    /**\n     * Create a branchPathTaken event\n     * @param fromNodeId the from node id\n     * @param toNodeid the to node id\n     */\n    createBranchPathTakenEvent(fromNodeId, toNodeId) {\n        var nodeId = fromNodeId;\n        var componentId = null;\n        var componentType = null;\n        var category = \"Navigation\";\n        var event = \"branchPathTaken\";\n        var eventData = {};\n        eventData.fromNodeId = fromNodeId;\n        eventData.toNodeId = toNodeId;\n        this.StudentDataService.saveVLEEvent(nodeId, componentId, componentType, category, event, eventData);\n    }\n\n    evaluateTransitionLogicOn(event) {\n        var result = false;\n\n        // get the current node\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n            var transitionLogic = currentNode.transitionLogic;\n\n            var whenToChoosePath = transitionLogic.whenToChoosePath;\n\n            if (event === whenToChoosePath) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the transition result for a node\n     * @param nodeId the the node id\n     * @returns the transition object that was chosen for the node\n     */\n    getTransitionResultByNodeId(nodeId) {\n        return this.transitionResults[nodeId];\n    }\n    \n    /**\n     * Set the transition result for a node\n     * @param nodeId the node id\n     * @param transitionResult the transition object that was chosen for the node\n     */\n    setTransitionResult(nodeId, transitionResult) {\n        if (nodeId != null) {\n            this.transitionResults[nodeId] = transitionResult;\n        }\n    }\n    \n    /**\n     * Get the promise that was created for a specific node when the \n     * chooseTransition() function was called. This promise has not been \n     * resolved yet.\n     * @param nodeId the node id\n     * @returns the promise that was created when chooseTransition() was called\n     * or null if there is no unresolved promise.\n     */\n    getChooseTransitionPromise(nodeId) {\n        return this.chooseTransitionPromises[nodeId];\n    }\n    \n    /**\n     * Set the promise that was created for a specific node when the \n     * chooseTransition() function was called. This promise has not been \n     * resolved yet.\n     * @param nodeId the node id\n     * @param promise the promise\n     */\n    setChooseTransitionPromise(nodeId, promise) {\n        if (nodeId != null) {\n            this.chooseTransitionPromises[nodeId] = promise;\n        }\n    }\n}\n\nNodeService.$inject = [\n    '$http',\n    '$injector',\n    '$mdDialog',\n    '$q',\n    'ConfigService',\n    'ProjectService',\n    'StudentDataService'\n];\n\nexport default NodeService;\n"]}