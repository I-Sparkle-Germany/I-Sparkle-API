{"version":3,"sources":["nodeService.es6"],"names":["NodeService","$http","$injector","$mdDialog","$q","ConfigService","ProjectService","StudentDataService","transitionResults","chooseTransitionPromises","componentState","clientSaveTime","Date","parse","nodeState","runId","getRunId","periodId","getPeriodId","workgroupId","getWorkgroupId","nodeType","nodeTypeCamelCased","length","firstChar","charAt","firstCharLowerCase","toLowerCase","substr","str","result","toUpperCase","componentType","isStringUpperCase","toCamelCase","wiseBaseURL","getWISEBaseURL","nodeContent","componentId","componentContent","components","c","tempComponent","tempComponentId","id","componentStates","isSubmit","functionParams","nodeId","isCompleted","getNextNodeId","then","nextNodeId","endCurrentNodeAndSetCurrentNodeByNodeId","deferred","defer","promise","currentNode","getCurrentNode","currentNodeId","transitionLogic","getTransitionLogicByFromNodeId","branchPathTakenEvents","getBranchPathTakenEventsByNodeId","canChangePath","b","branchPathTakenEvent","data","toNodeId","resolve","transitions","parentGroupId","getParentGroupId","parentHasTransitionLogic","parentTransitionLogic","chooseTransition","transition","transitionToNodeId","to","isGroupNode","startId","getGroupStartId","prevNodeId","getPrevNodeId","nodeIdsByToNodeId","getNodeIdsByToNodeId","stackHistory","getStackHistory","s","stackHistoryNodeId","indexOf","parentNode","getParentGroup","parentNodeId","getChooseTransitionPromise","resolvePromiseNow","transitionResult","getTransitionResultByNodeId","availableTransitions","t","criteria","criteriaResult","firstResult","tempResult","tempCriteria","evaluateCriteria","push","isPreview","ChooseBranchPathController","$scope","chooseBranchPath","setTransitionResult","setChooseTransitionPromise","hide","getNodePositionAndTitleByNodeId","close","chooseBranchPathTemplateUrl","getThemePath","dialogOptions","templateUrl","controller","locals","$inject","show","howToChooseAmongAvailablePaths","randomIndex","Math","floor","random","index","alreadyBranched","events","fromNodeId","createBranchPathTakenEvent","category","event","eventData","saveVLEEvent","whenToChoosePath"],"mappings":";;;;;;;;;;IAAMA,W;AAEF,yBAAYC,KAAZ,EACYC,SADZ,EAEYC,SAFZ,EAGYC,EAHZ,EAIYC,aAJZ,EAKYC,cALZ,EAMYC,kBANZ,EAMgC;AAAA;;AAC5B,aAAKN,KAAL,GAAaA,KAAb;AACA,aAAKC,SAAL,GAAiBA,SAAjB;AACA,aAAKC,SAAL,GAAiBA,SAAjB;AACA,aAAKC,EAAL,GAAUA,EAAV;AACA,aAAKC,aAAL,GAAqBA,aAArB;AACA,aAAKC,cAAL,GAAsBA,cAAtB;AACA,aAAKC,kBAAL,GAA0BA,kBAA1B;;AAEA,aAAKC,iBAAL,GAAyB,EAAzB;AACA,aAAKC,wBAAL,GAAgC,EAAhC;AACH;;AAED;;;;;;;;kDAI0B;AACtB,gBAAIC,iBAAiB,EAArB;;AAEA;AACAA,2BAAeC,cAAf,GAAgCC,KAAKC,KAAL,CAAW,IAAID,IAAJ,EAAX,CAAhC;;AAEA,mBAAOF,cAAP;AACH;;;;;AAED;;;;6CAIqB;AACjB,gBAAII,YAAY,EAAhB;AACAA,sBAAUC,KAAV,GAAkB,KAAKV,aAAL,CAAmBW,QAAnB,EAAlB;AACAF,sBAAUG,QAAV,GAAqB,KAAKZ,aAAL,CAAmBa,WAAnB,EAArB;AACAJ,sBAAUK,WAAV,GAAwB,KAAKd,aAAL,CAAmBe,cAAnB,EAAxB;;AAEA;AACAN,sBAAUH,cAAV,GAA2BC,KAAKC,KAAL,CAAW,IAAID,IAAJ,EAAX,CAA3B;;AAEA,mBAAOE,SAAP;AACH;;;;;AAED;;;;;;;oCAOYO,Q,EAAU;AAClB,gBAAIC,qBAAqB,IAAzB;;AAEA,gBAAID,YAAY,IAAZ,IAAoBA,SAASE,MAAT,GAAkB,CAA1C,EAA6C;;AAEzC;AACA,oBAAIC,YAAYH,SAASI,MAAT,CAAgB,CAAhB,CAAhB;;AAEA,oBAAGD,aAAa,IAAhB,EAAsB;;AAElB;AACA,wBAAIE,qBAAqBF,UAAUG,WAAV,EAAzB;;AAEA,wBAAID,sBAAsB,IAA1B,EAAgC;;AAE5B;;;;AAIAJ,6CAAqBI,qBAAqBL,SAASO,MAAT,CAAgB,CAAhB,CAA1C;AACH;AACJ;AACJ;;AAED,mBAAON,kBAAP;AACH;;;;;AAED;;;;;0CAKkBO,G,EAAK;AACnB,gBAAIC,SAAS,KAAb;;AAEA,gBAAID,OAAO,IAAX,EAAiB;AACb,oBAAIA,QAAQA,IAAIE,WAAJ,EAAZ,EAA+B;AAC3B;AACAD,6BAAS,IAAT;AACH;AACJ;;AAED,mBAAOA,MAAP;AACH;;;;;AAED;;;;;iDAKyBE,a,EAAe;;AAEpC,gBAAIA,iBAAiB,IAArB,EAA2B;AACvB;AACH,aAFD,MAEO,IAAI,KAAKC,iBAAL,CAAuBD,aAAvB,CAAJ,EAA2C;AAC9C;;;;AAIAA,gCAAgBA,cAAcL,WAAd,EAAhB;AACH,aANM,MAMA;AACH;AACAK,gCAAgB,KAAKE,WAAL,CAAiBF,aAAjB,CAAhB;AACH;AACD,gBAAIG,cAAc,KAAK9B,aAAL,CAAmB+B,cAAnB,EAAlB;AACA,mBAAOD,cAAc,oBAAd,GAAqCH,aAArC,GAAqD,aAA5D;AACH;;;;;AAED;;;;;;gDAMwBK,W,EAAaC,W,EAAa;AAC9C,gBAAIC,mBAAmB,IAAvB;;AAEA,gBAAIF,eAAe,IAAf,IAAuBC,eAAe,IAA1C,EAAgD;;AAE5C;AACA,oBAAIE,aAAaH,YAAYG,UAA7B;;AAEA,oBAAIA,cAAc,IAAlB,EAAwB;;AAEpB;AACA,yBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAID,WAAWjB,MAA/B,EAAuCkB,GAAvC,EAA4C;AACxC,4BAAIC,gBAAgBF,WAAWC,CAAX,CAApB;;AAEA,4BAAIC,iBAAiB,IAArB,EAA2B;AACvB,gCAAIC,kBAAkBD,cAAcE,EAApC;;AAEA,gCAAID,oBAAoBL,WAAxB,EAAqC;AACjC;AACAC,mDAAmBG,aAAnB;AACA;AACH;AACJ;AACJ;AACJ;AACJ;;AAED,mBAAOH,gBAAP;AACH;;;;;AAED;;;;;wCAKgBM,e,EAAiB;AAC7B,gBAAIf,SAAS,KAAb;;AAEA,gBAAIe,mBAAmB,IAAvB,EAA6B;;AAEzB;AACA,qBAAK,IAAIJ,IAAI,CAAb,EAAgBA,IAAII,gBAAgBtB,MAApC,EAA4CkB,GAA5C,EAAiD;AAC7C,wBAAI/B,iBAAiBmC,gBAAgBJ,CAAhB,CAArB;;AAEA,wBAAI/B,kBAAkB,IAAtB,EAA4B;;AAExB,4BAAIA,eAAeoC,QAAnB,EAA6B;AACzBhB,qCAAS,IAAT;AACA;AACH;AACJ;AACJ;AACJ;;AAED,mBAAOA,MAAP;AACH;;;;;AAED;;;;;;oCAMYiB,c,EAAgB;;AAExB,gBAAIjB,SAAS,KAAb;;AAEA,gBAAIiB,kBAAkB,IAAtB,EAA4B;AACxB,oBAAIC,SAASD,eAAeC,MAA5B;AACA,oBAAIV,cAAcS,eAAeT,WAAjC;;AAEAR,yBAAS,KAAKvB,kBAAL,CAAwB0C,WAAxB,CAAoCD,MAApC,EAA4CV,WAA5C,CAAT;AACH;;AAED,mBAAOR,MAAP;AACH;;;;;AAED;;;uCAGe;AAAA;;AAEX,iBAAKoB,aAAL,GAAqBC,IAArB,CAA0B,UAACC,UAAD,EAAgB;AACtC,oBAAIA,cAAc,IAAlB,EAAwB;AACpB,0BAAK7C,kBAAL,CAAwB8C,uCAAxB,CAAgED,UAAhE;AACH;AACJ,aAJD;AAKH;;;;;AAED;;;;;;wCAMgB;AAAA;;AAEZ;AACA,gBAAIE,WAAW,KAAKlD,EAAL,CAAQmD,KAAR,EAAf;AACA,gBAAIC,UAAUF,SAASE,OAAvB;;AAEA,gBAAIJ,aAAa,IAAjB;;AAEA;AACA,gBAAIK,cAAc,KAAKlD,kBAAL,CAAwBmD,cAAxB,EAAlB;;AAEA,gBAAID,eAAe,IAAnB,EAAyB;AACrB,oBAAIE,gBAAgBF,YAAYb,EAAhC;;AAEA;AACA,oBAAIgB,kBAAkB,KAAKtD,cAAL,CAAoBuD,8BAApB,CAAmDF,aAAnD,CAAtB;;AAEA;AACA,oBAAIG,wBAAwB,KAAKvD,kBAAL,CAAwBwD,gCAAxB,CAAyDJ,aAAzD,CAA5B;;AAEA,oBAAIG,yBAAyB,IAAzB,IAAiCA,sBAAsBvC,MAAtB,GAA+B,CAAhE,IACCqC,mBAAmB,IAAnB,IAA2BA,gBAAgBI,aAAhB,IAAiC,IADjE,EACwE;AACpE;;AAEA;AACA,yBAAK,IAAIC,IAAIH,sBAAsBvC,MAAtB,GAA+B,CAA5C,EAA+C0C,KAAK,CAApD,EAAuDA,GAAvD,EAA4D;AACxD,4BAAIC,uBAAuBJ,sBAAsBG,CAAtB,CAA3B;;AAEA,4BAAIC,wBAAwB,IAA5B,EAAkC;;AAE9B;AACA,gCAAIC,OAAOD,qBAAqBC,IAAhC;;AAEA,gCAAIA,QAAQ,IAAZ,EAAkB;AACd;AACA,oCAAIC,WAAWD,KAAKC,QAApB;AACAhB,6CAAagB,QAAb;AACAd,yCAASe,OAAT,CAAiBjB,UAAjB;AACA;AACH;AACJ;AACJ;AACJ,iBAtBD,MAsBO;AACH;;AAEA,wBAAIQ,mBAAmB,IAAvB,EAA6B;AACzB,4BAAIU,cAAcV,gBAAgBU,WAAlC;;AAEA,4BAAIA,eAAe,IAAf,IAAuBA,YAAY/C,MAAZ,IAAsB,CAAjD,EAAoD;AAChD;;;;;AAKA;AACA,gCAAIgD,gBAAgB,KAAKjE,cAAL,CAAoBkE,gBAApB,CAAqCb,aAArC,CAApB;AACA,gCAAIc,2BAA2B,KAA/B;;AAEA,gCAAIF,iBAAiB,IAArB,EAA2B;;AAEvB;AACA,oCAAIG,wBAAwB,KAAKpE,cAAL,CAAoBuD,8BAApB,CAAmDU,aAAnD,CAA5B;;AAEA,oCAAIG,yBAAyB,IAA7B,EAAmC;;AAE/BD,+DAA2B,IAA3B;;AAEA;AACA,yCAAKE,gBAAL,CAAsBJ,aAAtB,EAAqCG,qBAArC,EAA4DvB,IAA5D,CAAiE,UAACyB,UAAD,EAAgB;;AAE7E,4CAAIA,cAAc,IAAlB,EAAwB;AACpB;AACA,gDAAIC,qBAAqBD,WAAWE,EAApC;;AAEA,gDAAI,OAAKxE,cAAL,CAAoByE,WAApB,CAAgCF,kBAAhC,CAAJ,EAAyD;AACrD;;AAEA;AACA,oDAAIG,UAAU,OAAK1E,cAAL,CAAoB2E,eAApB,CAAoCJ,kBAApC,CAAd;;AAEA,oDAAIG,WAAW,IAAX,IAAmBA,WAAW,EAAlC,EAAsC;AAClC;AACA5B,iEAAayB,kBAAb;AACH,iDAHD,MAGO;AACH;AACAzB,iEAAa4B,OAAb;AACH;AACJ,6CAbD,MAaO;AACH;AACA5B,6DAAayB,kBAAb;AACH;AACJ;;AAED;AACAvB,iDAASe,OAAT,CAAiBjB,UAAjB;AACH,qCA3BD;AA4BH;AACJ;;AAED,gCAAI,CAACqB,wBAAL,EAA+B;AAC3B;;;;AAIAnB,yCAASe,OAAT,CAAiB,IAAjB;AACH;AACJ,yBA1DD,MA0DO;AACH;AACA,iCAAKM,gBAAL,CAAsBhB,aAAtB,EAAqCC,eAArC,EAAsDT,IAAtD,CAA2D,UAACyB,UAAD,EAAgB;;AAEvE,oCAAIA,cAAc,IAAlB,EAAwB;AACpB;AACAxB,iDAAawB,WAAWE,EAAxB;;AAEA;AACAxB,6CAASe,OAAT,CAAiBjB,UAAjB;AACH;AACJ,6BATD;AAUH;AACJ;AACJ;AACJ;;AAED,mBAAOI,OAAP;AACH;;;;;AAED;;;uCAGe;;AAEX,gBAAI0B,aAAa,KAAKC,aAAL,EAAjB;AACA,gBAAID,cAAc,IAAlB,EAAwB;AACpB,qBAAK3E,kBAAL,CAAwB8C,uCAAxB,CAAgE6B,UAAhE;AACH;AACJ;;;;;AAED;;;wCAGgB;;AAEZ,gBAAIA,aAAa,IAAjB;;AAEA;AACA,gBAAIzB,cAAc,KAAKlD,kBAAL,CAAwBmD,cAAxB,EAAlB;;AAEA,gBAAID,eAAe,IAAnB,EAAyB;;AAErB,oBAAIE,gBAAgBF,YAAYb,EAAhC;;AAEA;AACA,oBAAIwC,oBAAoB,KAAK9E,cAAL,CAAoB+E,oBAApB,CAAyC1B,aAAzC,CAAxB;;AAEA,oBAAIyB,qBAAqB,IAAzB,EAA+B,CAE9B,CAFD,MAEO,IAAIA,kBAAkB7D,MAAlB,KAA6B,CAAjC,EAAoC;AACvC;AACA2D,iCAAaE,kBAAkB,CAAlB,CAAb;AACH,iBAHM,MAGA,IAAIA,kBAAkB7D,MAAlB,GAA2B,CAA/B,EAAkC;AACrC;;AAEA;AACA,wBAAI+D,eAAe,KAAK/E,kBAAL,CAAwBgF,eAAxB,EAAnB;;AAEA;AACA,yBAAK,IAAIC,IAAIF,aAAa/D,MAAb,GAAsB,CAAnC,EAAsCiE,KAAK,CAA3C,EAA8CA,GAA9C,EAAmD;AAC/C,4BAAIC,qBAAqBH,aAAaE,CAAb,CAAzB;;AAEA,4BAAIJ,kBAAkBM,OAAlB,CAA0BD,kBAA1B,KAAiD,CAAC,CAAtD,EAAyD;AACrD;AACAP,yCAAaO,kBAAb;AACA;AACH;AACJ;AACJ;AACJ;;AAED,mBAAOP,UAAP;AACH;;;;;AAED;;;oCAGY;AACR,gBAAIzB,cAAc,KAAKlD,kBAAL,CAAwBmD,cAAxB,EAAlB;AACA,gBAAID,WAAJ,EAAiB;;AAEb,oBAAIE,gBAAgBF,YAAYb,EAAhC;;AAEA;AACA,oBAAI+C,aAAa,KAAKrF,cAAL,CAAoBsF,cAApB,CAAmCjC,aAAnC,CAAjB;;AAEA,oBAAIkC,eAAeF,WAAW/C,EAA9B;;AAEA;AACA,qBAAKrC,kBAAL,CAAwB8C,uCAAxB,CAAgEwC,YAAhE;AACH;AACJ;;;;;AAED;;;;;;;yCAOiB7C,M,EAAQY,e,EAAiB;;AAEtC,gBAAIN,WAAW,KAAKlD,EAAL,CAAQmD,KAAR,EAAf;;AAEA;AACA,gBAAIC,UAAU,KAAKsC,0BAAL,CAAgC9C,MAAhC,CAAd;;AAEA,gBAAIQ,WAAW,IAAf,EAAqB;AACjB;AACAA,0BAAUF,SAASE,OAAnB;AACH,aAHD,MAGO;AACH;AACA,uBAAOA,OAAP;AACH;;AAED,gBAAIuC,oBAAoB,IAAxB;;AAEA;AACA,gBAAIC,mBAAmB,KAAKC,2BAAL,CAAiCjD,MAAjC,CAAvB;;AAEA,gBAAIgD,oBAAoB,IAApB,IAA6BpC,mBAAmB,IAAnB,IAA2BA,gBAAgBI,aAAhB,IAAiC,IAA7F,EAAoG;AAChG;;;;;;AAMA;AACA,oBAAIM,cAAcV,gBAAgBU,WAAlC;;AAEA,oBAAIA,eAAe,IAAnB,EAAyB;;AAErB,wBAAI4B,uBAAuB,EAA3B;;AAEA;AACA,yBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI7B,YAAY/C,MAAhC,EAAwC4E,GAAxC,EAA6C;;AAEzC;AACA,4BAAIvB,aAAaN,YAAY6B,CAAZ,CAAjB;;AAEA;AACA,4BAAI/B,WAAWQ,WAAWE,EAA1B;;AAEA;AACA,4BAAIsB,WAAWxB,WAAWwB,QAA1B;;AAEA;AACA,4BAAIC,iBAAiB,IAArB;;AAEA,4BAAID,YAAY,IAAhB,EAAsB;;AAElB,gCAAIE,cAAc,IAAlB;AACA,gCAAIC,aAAa,IAAjB;;AAEA;AACA,iCAAK,IAAI9D,IAAI,CAAb,EAAgBA,IAAI2D,SAAS7E,MAA7B,EAAqCkB,GAArC,EAA0C;;AAEtC;AACA,oCAAI+D,eAAeJ,SAAS3D,CAAT,CAAnB;;AAEA;AACA8D,6CAAa,KAAKhG,kBAAL,CAAwBkG,gBAAxB,CAAyCD,YAAzC,CAAb;;AAEA,oCAAIF,WAAJ,EAAiB;AACb;AACAD,qDAAiBE,UAAjB;AACAD,kDAAc,KAAd;AACH,iCAJD,MAIO;AACH;AACAD,qDAAiBA,kBAAkBE,UAAnC;AACH;AACJ;AACJ;;AAED,4BAAInC,YAAY,IAAhB,EAAsB;;AAElB;AACA,gCAAIiC,cAAJ,EAAoB;;AAEhB;AACAH,qDAAqBQ,IAArB,CAA0B9B,UAA1B;AACH;AACJ;AACJ;;AAED,wBAAIsB,qBAAqB3E,MAArB,IAA+B,CAAnC,EAAsC;AAClC;AACAyE,2CAAmB,IAAnB;AACH,qBAHD,MAGO,IAAIE,qBAAqB3E,MAArB,IAA+B,CAAnC,EAAsC;AACzC;AACAyE,2CAAmBE,qBAAqB,CAArB,CAAnB;AACH,qBAHM,MAGA,IAAIA,qBAAqB3E,MAArB,GAA8B,CAAlC,EAAqC;AACxC;;AAEA,4BAAI,KAAKlB,aAAL,CAAmBsG,SAAnB,EAAJ,EAAoC;AAChC;;;;;AAKC,gCAAIX,oBAAoB,IAAxB,EAA8B;AAC1B;;;;;AAKH,6BAND,MAMO;;AAiBH;;;;;;;;;;AAjBG,oCA2BMY,0BA3BN,GA2BH,SAASA,0BAAT,CAAoCC,MAApC,EAA4C1G,SAA5C,EAAuDH,WAAvD,EAAoEM,cAApE,EAAoF4F,oBAApF,EAA0G5C,QAA1G,EAAoHN,MAApH,EAA4H;;AAExH6D,2CAAOX,oBAAP,GAA8BA,oBAA9B;AACAW,2CAAO7G,WAAP,GAAqBA,WAArB;AACA6G,2CAAOvG,cAAP,GAAwBA,cAAxB;;AAEA;AACAuG,2CAAOC,gBAAP,GAA0B,UAACd,gBAAD,EAAsB;AAC5C;AACAa,+CAAO7G,WAAP,CAAmB+G,mBAAnB,CAAuC/D,MAAvC,EAA+CgD,gBAA/C;;AAEA;AACA1C,iDAASe,OAAT,CAAiB2B,gBAAjB;;AAEA;;;;AAIAa,+CAAO7G,WAAP,CAAmBgH,0BAAnB,CAA8ChE,MAA9C,EAAsD,IAAtD;;AAEA;AACA7C,kDAAU8G,IAAV;AACH,qCAfD;;AAiBA;AACAJ,2CAAOK,+BAAP,GAAyC,UAAClE,MAAD,EAAY;AACjD,+CAAO6D,OAAOvG,cAAP,CAAsB4G,+BAAtB,CAAsDlE,MAAtD,CAAP;AACH,qCAFD;;AAIA;AACA6D,2CAAOM,KAAP,GAAe,YAAM;AACjBhH,kDAAU8G,IAAV;AACH,qCAFD;AAGH,iCA5DE;;AACH;;AAEAlB,oDAAoB,KAApB;;AAEA,oCAAIqB,8BAA8B,KAAK9G,cAAL,CAAoB+G,YAApB,KAAqC,mCAAvE;;AAEA,oCAAIC,gBAAgB;AAChBC,iDAAaH,2BADG;AAEhBI,gDAAYZ,0BAFI;AAGhBa,4CAAQ;AACJvB,8DAAsBA,oBADlB;AAEJ5C,kDAAUA,QAFN;AAGJN,gDAAQA;AAHJ;AAHQ,iCAApB;;AAuDA4D,2DAA2Bc,OAA3B,GAAqC,CAAC,QAAD,EAAW,WAAX,EAAwB,aAAxB,EAAuC,gBAAvC,EAAyD,sBAAzD,EAAiF,UAAjF,EAA6F,QAA7F,CAArC;;AAEA;;;;AAIA,qCAAKvH,SAAL,CAAewH,IAAf,CAAoBL,aAApB;AACH;AACL,yBAlFD,MAkFO;AACH;;;;;AAKA,gCAAIM,iCAAiChE,gBAAgBgE,8BAArD;;AAEA,gCAAIA,kCAAkC,IAAlC,IACAA,mCAAmC,EADnC,IAEAA,mCAAmC,QAFvC,EAEiD;AAC7C;;AAEA,oCAAIC,cAAcC,KAAKC,KAAL,CAAWD,KAAKE,MAAL,KAAgB9B,qBAAqB3E,MAAhD,CAAlB;AACAyE,mDAAmBE,qBAAqB2B,WAArB,CAAnB;AACH,6BAPD,MAOO,IAAID,mCAAmC,aAAvC,EAAsD;AACzD;;AAEA;AACA,oCAAIzG,cAAc,KAAKd,aAAL,CAAmBe,cAAnB,EAAlB;;AAEA;AACA,oCAAI6G,QAAQ9G,cAAc+E,qBAAqB3E,MAA/C;;AAEAyE,mDAAmBE,qBAAqB+B,KAArB,CAAnB;AACH,6BAVM,MAUA,IAAIL,mCAAmC,gBAAvC,EAAyD;AAC5D;;AAEA5B,mDAAmBE,qBAAqB,CAArB,CAAnB;AACH,6BAJM,MAIA,IAAI0B,mCAAmC,eAAvC,EAAwD;AAC3D;;AAEA5B,mDAAmBE,qBAAqBA,qBAAqB3E,MAArB,GAA8B,CAAnD,CAAnB;AACH;AACJ;AACJ;AACJ;AACJ;;AAED,gBAAIwE,iBAAJ,EAAuB;AACnB;AACA,qBAAKgB,mBAAL,CAAyB/D,MAAzB,EAAiCgD,gBAAjC;;AAEA;AACA1C,yBAASe,OAAT,CAAiB2B,gBAAjB;AACH,aAND,MAMO;AACH;;;;;AAKA,qBAAKgB,0BAAL,CAAgChE,MAAhC,EAAwCQ,OAAxC;AACH;;AAED,mBAAOA,OAAP;AACH;;;6CAEoB;AACjB,gBAAI1B,SAAS,KAAb;;AAEA,gBAAI2B,cAAc,KAAKlD,kBAAL,CAAwBmD,cAAxB,EAAlB;;AAEA,gBAAID,eAAe,IAAnB,EAAyB;AACrB,oBAAIG,kBAAkBH,YAAYG,eAAlC;;AAEA,oBAAIA,mBAAmB,IAAvB,EAA6B;AACzB9B,6BAAS,IAAT;AACH;AACJ;;AAED,mBAAOA,MAAP;AACH;;;;;AAED;;;;kDAI0B;AAAA;;AAEtB;AACA,gBAAI2B,cAAc,KAAKlD,kBAAL,CAAwBmD,cAAxB,EAAlB;;AAEA,gBAAID,eAAe,IAAnB,EAAyB;;AAErB,oBAAIT,SAASS,YAAYb,EAAzB;AACA,oBAAIgB,kBAAkBH,YAAYG,eAAlC;;AAEA,oBAAIA,mBAAmB,IAAvB,EAA6B;;AAEzB;AACA,wBAAIU,cAAcV,gBAAgBU,WAAlC;AACA,wBAAIN,gBAAgBJ,gBAAgBI,aAApC;AACA,wBAAIkE,kBAAkB,KAAtB;;AAEA;AACA,wBAAIC,SAAS,KAAK5H,kBAAL,CAAwBwD,gCAAxB,CAAyDN,YAAYb,EAArE,CAAb;;AAEA,wBAAIuF,OAAO5G,MAAP,GAAgB,CAApB,EAAuB;AACnB;AACA2G,0CAAkB,IAAlB;AACH;;AAED,wBAAItD,UAAJ,EAAgBwD,UAAhB,EAA4BhE,QAA5B;;AAEA,wBAAI8D,eAAJ,EAAqB;AACjB;;AAEA,4BAAIlE,aAAJ,EAAmB;AACf;;AAEA;AACA,iCAAKW,gBAAL,CAAsB3B,MAAtB,EAA8BY,eAA9B,EAA+CT,IAA/C,CAAoD,UAACyB,UAAD,EAAgB;;AAEhE,oCAAIA,cAAc,IAAlB,EAAwB;AACpBwD,iDAAa3E,YAAYb,EAAzB;AACAwB,+CAAWQ,WAAWE,EAAtB;;AAEA;AACA,2CAAKuD,0BAAL,CAAgCD,UAAhC,EAA4ChE,QAA5C;AACH;AACJ,6BATD;AAUH,yBAdD,MAcO;AACH;;AAEH;AACJ,qBArBD,MAqBO;AACH;;AAEA;AACA,6BAAKO,gBAAL,CAAsB3B,MAAtB,EAA8BY,eAA9B,EAA+CT,IAA/C,CAAoD,UAACyB,UAAD,EAAgB;;AAEhE,gCAAIA,cAAc,IAAlB,EAAwB;AACpBwD,6CAAa3E,YAAYb,EAAzB;AACAwB,2CAAWQ,WAAWE,EAAtB;;AAEA;AACA,uCAAKuD,0BAAL,CAAgCD,UAAhC,EAA4ChE,QAA5C;AACH;AACJ,yBATD;AAUH;AACJ;AACJ;AACJ;;;;;AAED;;;;;mDAK2BgE,U,EAAYhE,Q,EAAU;AAC7C,gBAAIpB,SAASoF,UAAb;AACA,gBAAI9F,cAAc,IAAlB;AACA,gBAAIN,gBAAgB,IAApB;AACA,gBAAIsG,WAAW,YAAf;AACA,gBAAIC,QAAQ,iBAAZ;AACA,gBAAIC,YAAY,EAAhB;AACAA,sBAAUJ,UAAV,GAAuBA,UAAvB;AACAI,sBAAUpE,QAAV,GAAqBA,QAArB;AACA,iBAAK7D,kBAAL,CAAwBkI,YAAxB,CAAqCzF,MAArC,EAA6CV,WAA7C,EAA0DN,aAA1D,EAAyEsG,QAAzE,EAAmFC,KAAnF,EAA0FC,SAA1F;AACH;;;kDAEyBD,K,EAAO;AAC7B,gBAAIzG,SAAS,KAAb;;AAEA;AACA,gBAAI2B,cAAc,KAAKlD,kBAAL,CAAwBmD,cAAxB,EAAlB;;AAEA,gBAAID,eAAe,IAAnB,EAAyB;AACrB,oBAAIG,kBAAkBH,YAAYG,eAAlC;;AAEA,oBAAI8E,mBAAmB9E,gBAAgB8E,gBAAvC;;AAEA,oBAAIH,UAAUG,gBAAd,EAAgC;AAC5B5G,6BAAS,IAAT;AACH;AACJ;;AAED,mBAAOA,MAAP;AACH;;;;;AAED;;;;;oDAK4BkB,M,EAAQ;AAChC,mBAAO,KAAKxC,iBAAL,CAAuBwC,MAAvB,CAAP;AACH;;AAED;;;;;;;;4CAKoBA,M,EAAQgD,gB,EAAkB;AAC1C,gBAAIhD,UAAU,IAAd,EAAoB;AAChB,qBAAKxC,iBAAL,CAAuBwC,MAAvB,IAAiCgD,gBAAjC;AACH;AACJ;;AAED;;;;;;;;;;;mDAQ2BhD,M,EAAQ;AAC/B,mBAAO,KAAKvC,wBAAL,CAA8BuC,MAA9B,CAAP;AACH;;AAED;;;;;;;;;;mDAO2BA,M,EAAQQ,O,EAAS;AACxC,gBAAIR,UAAU,IAAd,EAAoB;AAChB,qBAAKvC,wBAAL,CAA8BuC,MAA9B,IAAwCQ,OAAxC;AACH;AACJ;;;;;;AAGLxD,YAAY0H,OAAZ,GAAsB,CAClB,OADkB,EAElB,WAFkB,EAGlB,WAHkB,EAIlB,IAJkB,EAKlB,eALkB,EAMlB,gBANkB,EAOlB,oBAPkB,CAAtB;;kBAUe1H,W","file":"nodeService.js","sourcesContent":["class NodeService {\n\n    constructor($http,\n                $injector,\n                $mdDialog,\n                $q,\n                ConfigService,\n                ProjectService,\n                StudentDataService) {\n        this.$http = $http;\n        this.$injector = $injector;\n        this.$mdDialog = $mdDialog;\n        this.$q = $q;\n        this.ConfigService = ConfigService;\n        this.ProjectService = ProjectService;\n        this.StudentDataService = StudentDataService;\n\n        this.transitionResults = {};\n        this.chooseTransitionPromises = {};\n    }\n\n    /**\n     * Create a new empty node state\n     * @return a new empty node state\n     */\n    createNewComponentState() {\n        var componentState = {};\n\n        // set the timestamp\n        componentState.clientSaveTime = Date.parse(new Date());\n\n        return componentState;\n    };\n\n    /**\n     * Create a new empty node state\n     * @return a new empty node state\n     */\n    createNewNodeState() {\n        var nodeState = {};\n        nodeState.runId = this.ConfigService.getRunId();\n        nodeState.periodId = this.ConfigService.getPeriodId();\n        nodeState.workgroupId = this.ConfigService.getWorkgroupId();\n\n        // set the timestamp\n        nodeState.clientSaveTime = Date.parse(new Date());\n\n        return nodeState;\n    };\n\n    /**\n     * Get the node type in camel case\n     * @param nodeType the node type e.g. OpenResponse\n     * @return the node type in camel case\n     * e.g.\n     * openResponse\n     */\n    toCamelCase(nodeType) {\n        var nodeTypeCamelCased = null;\n\n        if (nodeType != null && nodeType.length > 0) {\n\n            // get the first character\n            var firstChar = nodeType.charAt(0);\n\n            if(firstChar != null) {\n\n                // make the first character lower case\n                var firstCharLowerCase = firstChar.toLowerCase();\n\n                if (firstCharLowerCase != null) {\n\n                    /*\n                     * replace the first character with the lower case\n                     * character\n                     */\n                    nodeTypeCamelCased = firstCharLowerCase + nodeType.substr(1);\n                }\n            }\n        }\n\n        return nodeTypeCamelCased;\n    };\n\n    /**\n     * Check if the string is in all uppercase\n     * @param str the string to check\n     * @return whether the string is in all uppercase\n     */\n    isStringUpperCase(str) {\n        var result = false;\n\n        if (str != null) {\n            if (str === str.toUpperCase()) {\n                // the string is in all uppercase\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the html template for the component\n     * @param componentType the component type\n     * @return the path to the html template for the component\n     */\n    getComponentTemplatePath(componentType) {\n\n        if (componentType == null) {\n            // error\n        } else if (this.isStringUpperCase(componentType)) {\n            /*\n             * the component type is all uppercase so we will convert it to all\n             * lowercase\n             */\n            componentType = componentType.toLowerCase();\n        } else {\n            // get the component type in camel case\n            componentType = this.toCamelCase(componentType);\n        }\n        var wiseBaseURL = this.ConfigService.getWISEBaseURL();\n        return wiseBaseURL + '/wise5/components/' + componentType + '/index.html';\n    };\n\n    /**\n     * Get the component content\n     * @param componentContent the component content\n     * @param componentId the component id\n     * @return the component content\n     */\n    getComponentContentById(nodeContent, componentId) {\n        var componentContent = null;\n\n        if (nodeContent != null && componentId != null) {\n\n            // get the components\n            var components = nodeContent.components;\n\n            if (components != null) {\n\n                // loop through the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n                        var tempComponentId = tempComponent.id;\n\n                        if (tempComponentId === componentId) {\n                            // we have found the component with the component id we want\n                            componentContent = tempComponent;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return componentContent;\n    };\n\n    /**\n     * Check if any of the component states were submitted\n     * @param componentStates an array of component states\n     * @return whether any of the component states were submitted\n     */\n    isWorkSubmitted(componentStates) {\n        var result = false;\n\n        if (componentStates != null) {\n\n            // loop through all the component states\n            for (var c = 0; c < componentStates.length; c++) {\n                var componentState = componentStates[c];\n\n                if (componentState != null) {\n\n                    if (componentState.isSubmit) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if the node or component is completed\n     * @param functionParams the params that will specify which node or component\n     * to check for completion\n     * @returns whether the specified node or component is completed\n     */\n    isCompleted(functionParams) {\n\n        var result = false;\n\n        if (functionParams != null) {\n            var nodeId = functionParams.nodeId;\n            var componentId = functionParams.componentId;\n\n            result = this.StudentDataService.isCompleted(nodeId, componentId);\n        }\n\n        return result;\n    };\n\n    /**\n     * Go to the next node\n     */\n    goToNextNode() {\n\n        this.getNextNodeId().then((nextNodeId) => {\n            if (nextNodeId != null) {\n                this.StudentDataService.endCurrentNodeAndSetCurrentNodeByNodeId(nextNodeId);\n            }\n        });\n    };\n\n    /**\n     * Get the next node in the project sequence. We return a promise because\n     * in preview mode we allow the user to specify which branch path they\n     * want to go to. In all other cases we will resolve the promise immediately.\n     * @returns a promise that returns the next node id\n     */\n    getNextNodeId() {\n\n        // create a promise that will return the next node id\n        var deferred = this.$q.defer();\n        var promise = deferred.promise;\n\n        var nextNodeId = null;\n\n        // get the current node\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n            var currentNodeId = currentNode.id;\n\n            // get the transition logic from the current node\n            var transitionLogic = this.ProjectService.getTransitionLogicByFromNodeId(currentNodeId);\n\n            // get all the branchPathTaken events for the current node\n            var branchPathTakenEvents = this.StudentDataService.getBranchPathTakenEventsByNodeId(currentNodeId);\n\n            if (branchPathTakenEvents != null && branchPathTakenEvents.length > 0 &&\n                (transitionLogic != null && transitionLogic.canChangePath != true)) {\n                // the student has branched on this node before and they are not allowed to change paths\n\n                // loop through all the branchPathTaken events from newest to oldest\n                for (var b = branchPathTakenEvents.length - 1; b >= 0; b--) {\n                    var branchPathTakenEvent = branchPathTakenEvents[b];\n\n                    if (branchPathTakenEvent != null) {\n\n                        // get the data from the event\n                        var data = branchPathTakenEvent.data;\n\n                        if (data != null) {\n                            // get the to node id\n                            var toNodeId = data.toNodeId;\n                            nextNodeId = toNodeId;\n                            deferred.resolve(nextNodeId);\n                            break;\n                        }\n                    }\n                }\n            } else {\n                // the student has not branched on this node before\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    if (transitions == null || transitions.length == 0) {\n                        /*\n                         * this node does not have any transitions so we will\n                         * check if the parent group has transitions\n                         */\n\n                        // get the parent group id\n                        var parentGroupId = this.ProjectService.getParentGroupId(currentNodeId);\n                        var parentHasTransitionLogic = false;\n\n                        if (parentGroupId != null) {\n\n                            // get the transition logic from the parent\n                            var parentTransitionLogic = this.ProjectService.getTransitionLogicByFromNodeId(parentGroupId);\n\n                            if (parentTransitionLogic != null) {\n\n                                parentHasTransitionLogic = true;\n\n                                // choose a transition\n                                this.chooseTransition(parentGroupId, parentTransitionLogic).then((transition) => {\n\n                                    if (transition != null) {\n                                        // get the to node id\n                                        var transitionToNodeId = transition.to;\n\n                                        if (this.ProjectService.isGroupNode(transitionToNodeId)) {\n                                            // the to node is a group\n\n                                            // get the start id of the group\n                                            var startId = this.ProjectService.getGroupStartId(transitionToNodeId);\n\n                                            if (startId == null || startId == '') {\n                                                // the group does not have a start id so we will just use the group\n                                                nextNodeId = transitionToNodeId;\n                                            } else {\n                                                // the group has a start id so we will use the start id\n                                                nextNodeId = startId;\n                                            }\n                                        } else {\n                                            // the to node is a step\n                                            nextNodeId = transitionToNodeId;\n                                        }\n                                    }\n\n                                    // resolve the promise with the next node id\n                                    deferred.resolve(nextNodeId);\n                                });\n                            }\n                        }\n\n                        if (!parentHasTransitionLogic) {\n                            /*\n                             * the parent does not have any transition logic so\n                             * there is no next node from the parent\n                             */\n                            deferred.resolve(null);\n                        }\n                    } else {\n                        // choose a transition\n                        this.chooseTransition(currentNodeId, transitionLogic).then((transition) => {\n\n                            if (transition != null) {\n                                // move the student to the toNodeId\n                                nextNodeId = transition.to;\n\n                                // resolve the promise with the next node id\n                                deferred.resolve(nextNodeId);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n\n        return promise;\n    };\n\n    /**\n     * Go to the previous node\n     */\n    goToPrevNode() {\n\n        var prevNodeId = this.getPrevNodeId();\n        if (prevNodeId != null) {\n            this.StudentDataService.endCurrentNodeAndSetCurrentNodeByNodeId(prevNodeId);\n        }\n    };\n\n    /**\n     * Get the previous node in the project sequence\n     */\n    getPrevNodeId() {\n\n        var prevNodeId = null;\n\n        // get the current node\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n\n            var currentNodeId = currentNode.id;\n\n            // get all the nodes that transition to the current node\n            var nodeIdsByToNodeId = this.ProjectService.getNodeIdsByToNodeId(currentNodeId);\n\n            if (nodeIdsByToNodeId == null) {\n\n            } else if (nodeIdsByToNodeId.length === 1) {\n                // there is only one node that transitions to the current node\n                prevNodeId = nodeIdsByToNodeId[0];\n            } else if (nodeIdsByToNodeId.length > 1) {\n                // there are multiple nodes that transition to the current node\n\n                // get the stack history\n                var stackHistory = this.StudentDataService.getStackHistory();\n\n                // loop through the stack history node ids from newest to oldest\n                for (var s = stackHistory.length - 1; s >= 0; s--) {\n                    var stackHistoryNodeId = stackHistory[s];\n\n                    if (nodeIdsByToNodeId.indexOf(stackHistoryNodeId) != -1) {\n                        // we have found a node that we previously visited that transitions to the current node\n                        prevNodeId = stackHistoryNodeId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return prevNodeId;\n    };\n\n    /**\n     * Close the current node (and open the current node's parent group)\n     */\n    closeNode() {\n        var currentNode = this.StudentDataService.getCurrentNode();\n        if (currentNode) {\n\n            var currentNodeId = currentNode.id;\n\n            // get the parent node of the current node\n            var parentNode = this.ProjectService.getParentGroup(currentNodeId);\n\n            var parentNodeId = parentNode.id;\n\n            // set the current node to the parent node\n            this.StudentDataService.endCurrentNodeAndSetCurrentNodeByNodeId(parentNodeId);\n        }\n    };\n\n    /**\n     * Choose the transition the student will take\n     * @param nodeId the current node id\n     * @param transitionLogic an object containing transitions and parameters\n     * for how to choose a transition\n     * @returns a promise that will return a transition\n     */\n    chooseTransition(nodeId, transitionLogic) {\n\n        var deferred = this.$q.defer();\n\n        // see if there is already a promise for this step\n        var promise = this.getChooseTransitionPromise(nodeId);\n\n        if (promise == null) {\n            // there is no existing promise for this step so we will create one\n            promise = deferred.promise;\n        } else {\n            // there is an existing promise for this step so we will use it\n            return promise;\n        }\n\n        var resolvePromiseNow = true;\n\n        // check if the transition was already previously calculated\n        var transitionResult = this.getTransitionResultByNodeId(nodeId);\n\n        if (transitionResult == null || (transitionLogic != null && transitionLogic.canChangePath == true)) {\n            /*\n             * we have not previously calculated the transition or the\n             * transition logic allows the student to change branch paths\n             * so we will calculate the transition again\n             */\n\n            // get the transitions\n            var transitions = transitionLogic.transitions;\n\n            if (transitions != null) {\n\n                let availableTransitions = [];\n\n                // loop through all the transitions\n                for (var t = 0; t < transitions.length; t++) {\n\n                    // get a transition\n                    var transition = transitions[t];\n\n                    // get the to node id\n                    var toNodeId = transition.to;\n\n                    // get the criteria for which this transition can be used\n                    var criteria = transition.criteria;\n\n                    // set the default result to true in case there is no criteria\n                    var criteriaResult = true;\n\n                    if (criteria != null) {\n\n                        var firstResult = true;\n                        var tempResult = true;\n\n                        // loop through all of the criteria\n                        for (var c = 0; c < criteria.length; c++) {\n\n                            // get a criteria\n                            var tempCriteria = criteria[c];\n\n                            // check if the criteria is satisfied\n                            tempResult = this.StudentDataService.evaluateCriteria(tempCriteria);\n\n                            if (firstResult) {\n                                // this is the first criteria in this for loop\n                                criteriaResult = tempResult;\n                                firstResult = false;\n                            } else {\n                                // this is not the first criteria in this for loop so we will && the result\n                                criteriaResult = criteriaResult && tempResult;\n                            }\n                        }\n                    }\n\n                    if (toNodeId != null) {\n\n                        // check if the criteria was satisfied and the to node is visitable\n                        if (criteriaResult) {\n\n                            // the student is allowed to use the transition\n                            availableTransitions.push(transition);\n                        }\n                    }\n                }\n\n                if (availableTransitions.length == 0) {\n                    // there are no available transitions for the student\n                    transitionResult = null;\n                } else if (availableTransitions.length == 1) {\n                    // there is one available transition for the student\n                    transitionResult = availableTransitions[0];\n                } else if (availableTransitions.length > 1) {\n                    // there are multiple available transitions for the student\n\n                    if (this.ConfigService.isPreview()) {\n                        /*\n                         * we are in preview mode so we will let the user choose\n                         * the branch path to go to\n                         */\n\n                         if (transitionResult != null) {\n                             /*\n                              * the user has previously chosen the branch path\n                              * so we will use the transition they chose and\n                              * not ask them again\n                              */\n                         } else {\n                             // ask the user which branch path to go to\n\n                             resolvePromiseNow = false;\n\n                             let chooseBranchPathTemplateUrl = this.ProjectService.getThemePath() + '/templates/branchPathChooser.html';\n\n                             var dialogOptions = {\n                                 templateUrl: chooseBranchPathTemplateUrl,\n                                 controller: ChooseBranchPathController,\n                                 locals: {\n                                     availableTransitions: availableTransitions,\n                                     deferred: deferred,\n                                     nodeId: nodeId\n                                 }\n                             };\n\n                             /**\n                              * Controller that handles the dialog popup that lets the user\n                              * which branch path to go to.\n                              * @param $scope the scope\n                              * @param $mdDialog the dialog popup object\n                              * @param availableTransitions the branch paths\n                              * @param deferred used to resolve the promise once the user\n                              * has chosen a branch path\n                              * @param nodeId the current node\n                              */\n                             function ChooseBranchPathController($scope, $mdDialog, NodeService, ProjectService, availableTransitions, deferred, nodeId) {\n\n                                 $scope.availableTransitions = availableTransitions;\n                                 $scope.NodeService = NodeService;\n                                 $scope.ProjectService = ProjectService;\n\n                                 // called when the user clicks on a branch path\n                                 $scope.chooseBranchPath = (transitionResult) => {\n                                     // remember the transition that was chosen\n                                     $scope.NodeService.setTransitionResult(nodeId, transitionResult);\n\n                                     // resolve the promise\n                                     deferred.resolve(transitionResult);\n\n                                     /*\n                                      * don't remember the promise for this step anymore\n                                      * since we have resolved it\n                                      */\n                                     $scope.NodeService.setChooseTransitionPromise(nodeId, null);\n\n                                     // close the dialog\n                                     $mdDialog.hide();\n                                 }\n\n                                 // obtains the step number and title\n                                 $scope.getNodePositionAndTitleByNodeId = (nodeId) => {\n                                     return $scope.ProjectService.getNodePositionAndTitleByNodeId(nodeId);\n                                 }\n\n                                 // called when the dialog is closed\n                                 $scope.close = () => {\n                                     $mdDialog.hide();\n                                 }\n                             }\n\n                             ChooseBranchPathController.$inject = ['$scope', '$mdDialog', 'NodeService', 'ProjectService', 'availableTransitions', 'deferred', 'nodeId'];\n\n                             /*\n                              * show the popup dialog that lets the user choose the\n                              * branch path\n                              */\n                             this.$mdDialog.show(dialogOptions);\n                         }\n                    } else {\n                        /*\n                         * we are in regular student run mode so we will choose\n                         * the branch according to how the step was authored\n                         */\n\n                        var howToChooseAmongAvailablePaths = transitionLogic.howToChooseAmongAvailablePaths;\n\n                        if (howToChooseAmongAvailablePaths == null ||\n                            howToChooseAmongAvailablePaths === '' ||\n                            howToChooseAmongAvailablePaths === 'random') {\n                            // choose a random transition\n\n                            var randomIndex = Math.floor(Math.random() * availableTransitions.length);\n                            transitionResult = availableTransitions[randomIndex];\n                        } else if (howToChooseAmongAvailablePaths === 'workgroupId') {\n                            // use the workgroup id to choose the transition\n\n                            // get the workgroup id\n                            var workgroupId = this.ConfigService.getWorkgroupId();\n\n                            // choose the transition index\n                            var index = workgroupId % availableTransitions.length;\n\n                            transitionResult = availableTransitions[index];\n                        } else if (howToChooseAmongAvailablePaths === 'firstAvailable') {\n                            // choose the first available transition\n\n                            transitionResult = availableTransitions[0];\n                        } else if (howToChooseAmongAvailablePaths === 'lastAvailable') {\n                            // choose the last available transition\n\n                            transitionResult = availableTransitions[availableTransitions.length - 1];\n                        }\n                    }\n                }\n            }\n        }\n\n        if (resolvePromiseNow) {\n            // remember the transition that was chosen for this step\n            this.setTransitionResult(nodeId, transitionResult);\n\n            // resolve the promise immediately\n            deferred.resolve(transitionResult);\n        } else {\n            /*\n             * remember the promise in case someone else calls chooseTransition()\n             * so we can chain off of this promise instead of creating another\n             * promise\n             */\n            this.setChooseTransitionPromise(nodeId, promise);\n        }\n\n        return promise;\n    };\n\n    hasTransitionLogic() {\n        var result = false;\n\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n            var transitionLogic = currentNode.transitionLogic;\n\n            if (transitionLogic != null) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Evaluate the transition logic for the current node and create branch\n     * path taken events if necessary.\n     */\n    evaluateTransitionLogic() {\n\n        // get the current node\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n\n            var nodeId = currentNode.id;\n            var transitionLogic = currentNode.transitionLogic;\n\n            if (transitionLogic != null) {\n\n                // get all the transitions from the current node\n                var transitions = transitionLogic.transitions;\n                var canChangePath = transitionLogic.canChangePath;\n                var alreadyBranched = false;\n\n                // get all the branchPathTaken events for the current node\n                var events = this.StudentDataService.getBranchPathTakenEventsByNodeId(currentNode.id);\n\n                if (events.length > 0) {\n                    // the student has branched from this node before\n                    alreadyBranched = true;\n                }\n\n                var transition, fromNodeId, toNodeId;\n\n                if (alreadyBranched) {\n                    // student has previously branched\n\n                    if (canChangePath) {\n                        // student can change path\n\n                        // choose a transition\n                        this.chooseTransition(nodeId, transitionLogic).then((transition) => {\n\n                            if (transition != null) {\n                                fromNodeId = currentNode.id;\n                                toNodeId = transition.to;\n\n                                // create a branchPathTaken event to signify taking the branch path\n                                this.createBranchPathTakenEvent(fromNodeId, toNodeId);\n                            }\n                        });\n                    } else {\n                        // student can't change path\n\n                    }\n                } else {\n                    // student has not branched yet\n\n                    // choose a transition\n                    this.chooseTransition(nodeId, transitionLogic).then((transition) => {\n\n                        if (transition != null) {\n                            fromNodeId = currentNode.id;\n                            toNodeId = transition.to;\n\n                            // create a branchPathTaken event to signify taking the branch path\n                            this.createBranchPathTakenEvent(fromNodeId, toNodeId);\n                        }\n                    });\n                }\n            }\n        }\n    };\n\n    /**\n     * Create a branchPathTaken event\n     * @param fromNodeId the from node id\n     * @param toNodeid the to node id\n     */\n    createBranchPathTakenEvent(fromNodeId, toNodeId) {\n        var nodeId = fromNodeId;\n        var componentId = null;\n        var componentType = null;\n        var category = \"Navigation\";\n        var event = \"branchPathTaken\";\n        var eventData = {};\n        eventData.fromNodeId = fromNodeId;\n        eventData.toNodeId = toNodeId;\n        this.StudentDataService.saveVLEEvent(nodeId, componentId, componentType, category, event, eventData);\n    }\n\n    evaluateTransitionLogicOn(event) {\n        var result = false;\n\n        // get the current node\n        var currentNode = this.StudentDataService.getCurrentNode();\n\n        if (currentNode != null) {\n            var transitionLogic = currentNode.transitionLogic;\n\n            var whenToChoosePath = transitionLogic.whenToChoosePath;\n\n            if (event === whenToChoosePath) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the transition result for a node\n     * @param nodeId the the node id\n     * @returns the transition object that was chosen for the node\n     */\n    getTransitionResultByNodeId(nodeId) {\n        return this.transitionResults[nodeId];\n    }\n\n    /**\n     * Set the transition result for a node\n     * @param nodeId the node id\n     * @param transitionResult the transition object that was chosen for the node\n     */\n    setTransitionResult(nodeId, transitionResult) {\n        if (nodeId != null) {\n            this.transitionResults[nodeId] = transitionResult;\n        }\n    }\n\n    /**\n     * Get the promise that was created for a specific node when the\n     * chooseTransition() function was called. This promise has not been\n     * resolved yet.\n     * @param nodeId the node id\n     * @returns the promise that was created when chooseTransition() was called\n     * or null if there is no unresolved promise.\n     */\n    getChooseTransitionPromise(nodeId) {\n        return this.chooseTransitionPromises[nodeId];\n    }\n\n    /**\n     * Set the promise that was created for a specific node when the\n     * chooseTransition() function was called. This promise has not been\n     * resolved yet.\n     * @param nodeId the node id\n     * @param promise the promise\n     */\n    setChooseTransitionPromise(nodeId, promise) {\n        if (nodeId != null) {\n            this.chooseTransitionPromises[nodeId] = promise;\n        }\n    }\n}\n\nNodeService.$inject = [\n    '$http',\n    '$injector',\n    '$mdDialog',\n    '$q',\n    'ConfigService',\n    'ProjectService',\n    'StudentDataService'\n];\n\nexport default NodeService;\n"]}