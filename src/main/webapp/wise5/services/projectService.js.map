{"version":3,"sources":["projectService.es6"],"names":["ProjectService","$filter","$http","$injector","$q","$rootScope","ConfigService","UtilService","project","transitions","applicationNodes","inactiveNodes","groupNodes","idToNode","idToElement","metadata","activeConstraints","rootNode","idToPosition","idToOrder","nodeCount","componentServices","nodeIdToNumber","nodeIdToIsInBranchPath","achievements","$translate","additionalProcessingFunctionsMap","filters","parseProject","style","name","getProjectMetadata","title","projectTitle","nodes","planningNodes","nodeId","childIds","node","getNodeById","ids","id","result","getNodes","n","length","transition","existingTransitions","getTransitions","replaced","t","existingTransition","splice","push","existingNodes","existingNode","existingNodeId","$broadcast","groupId","group","groupChildNodeIds","indexOf","groupNode","type","applicationNode","nodeType","content","constraints","setIdToNode","setIdToElement","addNode","addGroupNode","addApplicationNode","addNodeToGroupNode","isPreview","getConfigParam","c","constraint","p","planningNode","clearProjectFields","loadNodes","loadPlanningNodes","loadInactiveNodes","constraintId","active","getRootNode","setNodeOrder","branches","getBranches","branchNodeIds","pos","setIdToPosition","isNodeIdInABranch","getPositionById","b","getBranchNodePositionById","calculateNodeNumbers","isGroupNode","i","child","getMode","planningIds","availablePlanningNodes","a","startGroupId","stepNumber","importProjectIdToOrder","getNodeOrderOfProjectHelper","item","childId","childStepNumber","path","getPathToNode","undefined","order","getIdByOrder","integerToAlpha","int","alphabet","branch","branchPaths","branchPath","nodeIndex","startPoint","branchStartPoint","startPointPos","branchPathPos","num","position","Object","entries","value","element","contentString","JSON","stringify","replaceAssetPaths","parse","contentBaseURL","replace","RegExp","matchedString","delimiter","matchedStringWithoutQuotes","substr","charAt","injectClickToSnipImageIntoContentString","imgMatcher","matchGroup1","newString","tempNode","getNodePositionById","nodeIcon","defaultName","color","fontSet","fontName","imgSrc","imgAlt","icons","default","icon","$","extend","getGroupNodes","g","isNodeDirectChildOfGroup","parentGroupId","parentGroup","getParentGroup","val","depth","parent","getNodeDepth","groupIds","descendents","getDescendentsOfGroup","childDescendents","concat","projectStartId","getStartNodeId","groups","getGroups","groupStartId","startId","startNodeId","allConstraints","isNodeAffectedByConstraint","targetId","action","isNodeIdAfter","targetNode","isNodeDescendentOfGroup","nodeIdBefore","nodeIdAfter","isApplicationNode","pathsToEnd","getAllPaths","pathToEnd","index","parentGroupIndex","getTransitionsByFromNodeId","toNodeId","to","navigationMode","componentId","component","getComponentByNodeIdAndComponentId","componentType","componentService","get","getPossibleTransitionCriteria","fromNodeId","transitionLogic","getTransitionLogicByFromNodeId","nodesByToNodeId","nodeIds","getNodesByToNodeId","groupsThatPointToNodeId","hasTransitionTo","transitionsResults","projectURL","Date","getTime","then","projectJSON","data","setProject","projectId","configURL","window","configJSON","previewProjectURL","commitMessage","cleanupBeforeSave","getProjectId","saveProjectURL","projectJSONString","angular","toJson","httpParams","method","url","headers","params","param","commitHistory","notifyProjectBeginURL","otherAuthors","resolve","reject","notifyProjectEndURL","inactiveNode","checked","copyProjectURL","registerNewProjectURL","e","Error","commitProjectURL","wiseBaseURL","getWISEBaseURL","theme","themeSettings","pathsSoFar","allPaths","consolidatePaths","pathSoFar","includeGroups","addedCurrentNodeId","getParentGroupId","parentGroupTransitions","parentGroupTransition","allPathsFromToNode","tempPath","unshift","transitionResult","firstNodeId","firstParentGroupId","lastNodeId","pop","ap","paths","consolidatedPath","arePathsEmpty","currentPath","getNonEmptyPathIndex","getFirstNodeIdInPathAtIndex","areFirstNodeIdsInPathsTheSame","removeNodeIdFromPaths","pathsThatContainNodeId","getPathsThatContainNodeId","removeNodeIdFromPath","consumedPath","consumePathsUntilNodeId","consumedNodeIds","x","tempNodeId","pathsToConsume","pathThatContainsNodeId","tempNodeIdIndex","nodeIdIndex","tempConsumedNodeIds","pathIndex","findBranches","previousNodeId","branchMetaObject","createBranchMetaObject","nextCommonNodeId","findNextCommonNodeId","branchEndPoint","extractPathsUpToNodeId","removeDuplicatePaths","trimPathsUpToNodeId","subPaths","allPathsContainNodeId","extractedPaths","extractedPath","slice","uniquePaths","isPathInUniquePaths","u","uniquePath","pathsEqual","path1","path2","path1NodeId","path2NodeId","bp","branchPathsIn","components","getComponentsByNodeId","tempComponent","tempComponentId","componentPosition","nodeContent","newGroupId","getNextAvailableGroupId","newGroup","newNodeId","getNextAvailableNodeId","newNode","showSaveButton","showSubmitButton","addInactiveNode","insertNodeInsideInTransitions","insertNodeInsideInGroups","isInactive","insertNodeAfterInGroups","insertNodeAfterInTransitions","oldToGroupIds","transitionsFromGroup","transitionFromGroup","fromGroupId","newToGroupId","updateTransitionsForInsertingGroup","nodeIdToInsert","nodeIdToInsertAfter","previousNode","updateChildrenTransitionsForMovingGroup","previousNodeTransitionLogic","transitionsJSONString","transitionsCopy","fromJson","parentTransitions","parentTransition","newTransition","getGroupStartId","transitionObject","removeBranchPathTakenNodeConstraints","branchPathTakenConstraints","getBranchPathTakenConstraintsByNodeId","branchPathTakenConstraint","newConstraint","getNextAvailableConstraintIdForNodeId","removalCriteria","makeCopyOfJSONObject","nodeIdToInsertInside","nodeToInsert","previousNodes","previousGroups","getGroupNodesByToNodeId","previousGroup","lastNodesInGroup","getLastNodesInGroup","addToTransition","updateToTransition","nodesThatTransitionToGroup","nodeThatTransitionsToGroup","startNode","nextGroup","criteria","oldToNodeId","newToNodeId","lastNodes","getGroupIds","largestGroupIdNumber","groupIdNumber","isNaN","parseInt","nextAvailableGroupId","getNodeIds","largestNodeIdNumber","nodeIdNumber","inactiveNodeIds","getInactiveNodeIds","inactiveNodeId","nextAvailableNodeId","movingNodeIsActive","isActive","stationaryNodeIsActive","removeNodeIdFromTransitions","removeNodeIdFromGroups","moveToInactive","moveToActive","moveInactiveNode","nodeIdToCopy","copyNode","createNodeInside","createNodeAfter","nodeCopy","service","componentCopy","copyComponent","maxScore","showPreviousWorkPrompt","showPreviousWorkNodeId","showPreviousWorkComponentId","removingProjectStartNodeId","removeNodeIdFromNodes","hasSetNewStartId","isNodeInGroup","setStartNodeId","nextNodeId","nextGroupNode","nextGroupStartId","transitionToNodeId","recalculatePositionsInGroup","nodeToRemove","nodeToRemoveTransitionLogic","nodeToRemoveTransitions","parentIdOfNodeToRemove","parentGroupStartId","nodeToRemoveTransition","parentIdOfFromNode","tc","tempTransition","tempToNodeId","parentIdOfToNode","isFirstNodeInBranchPath","nodeIdsInBranch","getNodeIdsInBranch","nib","nodeIdInBranch","nodeInBranch","transitionCopy","currentFromNodeId","currentToNodeId","newFromNodeId","updateBranchPathTakenConstraint","isBranchPoint","getBranchesByBranchStartPointNodeId","bpn","branchPathNodeId","branchPathNode","insertIndex","groupIdWeAreMoving","groupThatTransitionsToGroupWeAreMoving","updateChildrenTransitionsIntoGroupWeAreMoving","removeTransitionsOutOfGroup","createComponent","componentHasWork","doesAnyComponentShowSubmitButton","addComponentToNode","componentUsesSaveButton","firstPath","nodeMaxScore","getMaxScoreForNode","componentMaxScore","firstLeafNodeId","done","tempApplicationNode","tempApplicationNodeId","planning","planningNodeTemplateId","availablePlanningNodeIds","availablePlanningNodesSoFar","availablePlanningNode","availablePlanningNodeActual","max","nextAvailablePlanningNodeId","planningNodeInstance","planningNodeInstanceNodeId","nodeIdToMove","moveNodesInside","moveNodesAfter","getChildNodeIdsById","message","nodeTitle","getNodePositionAndTitleByNodeId","removalConditional","criteriaMessages","tempRemovalCriteria","criteriaMessage","getCriteriaMessage","scoresString","scores","join","score","requiredSubmitCount","oldToGroupId","fromGroup","oldToGroup","newToGroup","newToGroupStartId","ot","oldToGroupStartId","transitionsBefore","previousGroupNodes","transitionsAfter","extracted","previousGroupNode","updateTransitionsForExtractingGroup","transitionAfter","inserted","getStartGroupId","startGroup","firstGroupId","connectedComponentId","connectedComponents","connectedComponent","componentContent","connectedComponentParams","inactiveGroups","activeNodes","activeNode","activeNodeId","activeComponents","activeComponent","activeComponentId","removeNodeFromInactiveNodes","removeNodeFromActiveNodes","added","removeTransitionsThatPointToNodeIdFromOutsideGroup","nodesThatPointToTargetNode","nodeThatPointsToTargetNode","nodeThatPointsToTargetNodeParentGroupId","removeTransition","toNodeIdParentGroupId","transitionsFromChild","tfc","transitionFromChild","firstNodeToRemoveTransition","firstNodeToRemoveTransitionToNodeId","nodeIdAndComponentIds","getNodeContentByNodeId","nodeIdAndComponentId","annotation","displayAnnotation","previousScore","currentScore","annotationGroup","globalAnnotationSettings","globalAnnotationGroups","globalAnnotationGroup","enableCriteria","scoreSequence","previousScoreMatch","currentScoreMatch","toString","match","notificationResult","notificationSettings","notifications","notification","getComponentService","componentServiceName","idLength","newComponentId","generateKey","isComponentIdUsed","alreadyUsed","isUsed","selectedNodes","fromProjectId","toProjectId","importStepsURL","steps","getInactiveNodes","selectedNode","isNodeIdUsed","tempComponents","getUnusedComponentId","nextAvailableConstraintId","usedConstraintIds","foundNextAvailableConstraintId","counter","potentialConstraintId","field","orderedItems","foundNodeId","$key","nodesInBranch","hasBranchPathTakenConstraint","r","removalCriterion","targetNodeId","makeThisNodeNotVisibleConstraint","notVisibleRemovalCriterion","makeThisNodeNotVisitableConstraint","notVisitableRemovalCriterion","rc","rubric","html","transitionTo","allBranches","currentActivityNumber","currentStepNumber","calculateNodeNumbersHelper","branchLetterCode","isBranchMergePoint","isBranchStartPoint","branchesByBranchStartPointNodeId","branchesObject","maxCurrentStepNumber","branchCurrentStepNumber","branchEndPointNodeId","number","branchLetter","String","fromCharCode","pg","script","scriptFilename","assetDirectoryPath","getProjectAssetsDirectoryPath","scriptPath","additionalProcessingFunction","key","getAdditionalProcessingFunctions","flattenedNodeIds","getFlattenedProjectAsNodeIds","indexOfNodeId","indexOfPreviousNodeId","indexOfNextNodeId","isEnabled","items","achievementItems","getAchievements","achievementId","achievement","nodePosition","branchLetterRegex","exec","nodeRubric","componentRubric","$inject"],"mappings":"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","file":"projectService.js","sourcesContent":["'use strict';\r\n\r\nclass ProjectService {\r\n\r\n    constructor($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService) {\r\n        this.$filter = $filter;\r\n        this.$http = $http;\r\n        this.$injector = $injector;\r\n        this.$q = $q;\r\n        this.$rootScope = $rootScope;\r\n        this.ConfigService = ConfigService;\r\n        this.UtilService = UtilService;\r\n        this.project = null;\r\n        this.transitions = [];\r\n        this.applicationNodes = [];\r\n        this.inactiveNodes = [];\r\n        this.groupNodes = [];\r\n        this.idToNode = {};\r\n        this.idToElement = {};\r\n        this.metadata = {};\r\n        this.activeConstraints = [];\r\n        this.rootNode = null;\r\n        this.idToPosition = {};\r\n        this.idToOrder = {};\r\n        this.nodeCount = 0;\r\n        this.componentServices = {};\r\n        this.nodeIdToNumber = {};\r\n        this.nodeIdToIsInBranchPath = {};\r\n        this.achievements = [];\r\n\r\n        this.$translate = this.$filter('translate');\r\n\r\n        // map from nodeId_componentId to array of additionalProcessingFunctions\r\n        this.additionalProcessingFunctionsMap = {};\r\n\r\n        // filtering options for navigation displays\r\n        this.filters = [\r\n            {'name': 'all', 'label': 'All'}\r\n            //{'name': 'todo', 'label': 'Todo'},\r\n            //{'name': 'completed', 'label': 'Completed'}\r\n        ];\r\n    };\r\n\r\n    setProject(project) {\r\n        this.project = project;\r\n        this.parseProject();\r\n    };\r\n\r\n    /**\r\n     * Initialize the data structures used to hold project information\r\n     */\r\n    clearProjectFields() {\r\n        this.transitions = [];\r\n        this.applicationNodes = [];\r\n        this.inactiveNodes = [];\r\n        this.groupNodes = [];\r\n        this.idToNode = {};\r\n        this.idToElement = {};\r\n        this.metadata = {};\r\n        this.activeConstraints = [];\r\n        this.rootNode = null;\r\n        this.idToPosition = {};\r\n        this.idToOrder = {};\r\n        this.nodeCount = 0;\r\n        this.nodeIdToIsInBranchPath = {};\r\n        this.achievements = [];\r\n    };\r\n\r\n    getStyle() {\r\n        var style = '';\r\n        var project = this.project;\r\n        if (project != null) {\r\n            style = project.style;\r\n        }\r\n        return style;\r\n    };\r\n\r\n    getFilters() {\r\n        return this.filters;\r\n    };\r\n\r\n    /**\r\n     * Returns the name/title of the current project\r\n     */\r\n    getProjectTitle() {\r\n        var name = this.getProjectMetadata().title;\r\n        return name ? name : 'A WISE Project (No name)';\r\n    };\r\n\r\n    /**\r\n     * Set the project title\r\n     */\r\n    setProjectTitle(projectTitle) {\r\n        var metadata = this.getProjectMetadata();\r\n\r\n        if (metadata != null) {\r\n            metadata.title = projectTitle;\r\n        }\r\n    }\r\n\r\n    getProjectMetadata() {\r\n        return this.metadata ? this.metadata : {};\r\n    };\r\n\r\n    getNodes() {\r\n        var nodes = null;\r\n        var project = this.project;\r\n\r\n        if (project != null) {\r\n            nodes = project.nodes;\r\n        }\r\n\r\n        return nodes;\r\n    };\r\n\r\n    getPlanningNodes() {\r\n        var planningNodes = null;\r\n        var project = this.project;\r\n\r\n        if (project != null) {\r\n            planningNodes = project.planningNodes;\r\n        }\r\n\r\n        return planningNodes;\r\n    };\r\n\r\n    getChildNodeIdsById(nodeId) {\r\n        var childIds = [];\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node.ids) {\r\n            childIds = node.ids;\r\n        }\r\n\r\n        return childIds;\r\n    };\r\n\r\n    getGroupNodes() {\r\n        return this.groupNodes;\r\n    };\r\n\r\n    isNode(id) {\r\n        var result = false;\r\n        var nodes = this.getNodes();\r\n\r\n        if (nodes != null) {\r\n            for (var n = 0; n < nodes.length; n++) {\r\n                var node = nodes[n];\r\n\r\n                if (node != null) {\r\n                    var nodeId = node.id;\r\n\r\n                    if (nodeId === id) {\r\n                        result = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    // adds or update transition if exists\r\n    addTransition(transition) {\r\n\r\n        var existingTransitions = this.getTransitions();\r\n        var replaced = false;\r\n        for (var t = 0; t < existingTransitions.length; t++) {\r\n            var existingTransition = existingTransitions[t];\r\n            if (existingTransition.id === transition.id) {\r\n                existingTransitions.splice(t, 1, transition);\r\n                replaced = true;\r\n            }\r\n        }\r\n        if (!replaced) {\r\n            existingTransitions.push(transition);\r\n        }\r\n    };\r\n\r\n    addNode(node) {\r\n        var existingNodes = this.project.nodes;\r\n\r\n        var replaced = false;\r\n        if (node != null && existingNodes != null) {\r\n            for (var n = 0; n < existingNodes.length; n++) {\r\n                var existingNode = existingNodes[n];\r\n                var existingNodeId = existingNode.id;\r\n                if (existingNodeId === node.id) {\r\n                    existingNodes.splice(n, 1, node);\r\n                    replaced = true;\r\n                }\r\n            }\r\n        }\r\n        if (!replaced) {\r\n            existingNodes.push(node);\r\n        }\r\n    };\r\n\r\n    addApplicationNode(node) {\r\n\r\n        var applicationNodes = this.applicationNodes;\r\n\r\n        if (node != null && applicationNodes != null) {\r\n            applicationNodes.push(node);\r\n        }\r\n    };\r\n\r\n    addGroupNode(node) {\r\n\r\n        var groupNodes = this.groupNodes;\r\n\r\n        if (node != null && groupNodes != null) {\r\n            groupNodes.push(node);\r\n        }\r\n\r\n        this.$rootScope.$broadcast('groupsChanged');\r\n    };\r\n\r\n    addNodeToGroupNode(groupId, nodeId) {\r\n        if (groupId != null && nodeId != null) {\r\n            var group = this.getNodeById(groupId);\r\n            if (group != null) {\r\n                var groupChildNodeIds = group.ids;\r\n                if (groupChildNodeIds != null) {\r\n                    if (groupChildNodeIds.indexOf(nodeId) === -1) {\r\n                        groupChildNodeIds.push(nodeId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    isGroupNode(id) {\r\n        var result = false;\r\n\r\n        var groupNode = this.getNodeById(id);\r\n\r\n        if (groupNode != null) {\r\n            var type = groupNode.type;\r\n\r\n            if (type === 'group') {\r\n                result = true;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    isApplicationNode(id) {\r\n        var result = false;\r\n\r\n        var applicationNode = this.getNodeById(id);\r\n\r\n        if (applicationNode != null) {\r\n            var type = applicationNode.type;\r\n\r\n            if (type !== 'group') {\r\n                result = true;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    getGroups() {\r\n        return this.groupNodes;\r\n    };\r\n\r\n    loadNodes(nodes) {\r\n        if (nodes != null) {\r\n            for (var n = 0 ; n < nodes.length; n++) {\r\n                var node = nodes[n];\r\n\r\n                if (node != null) {\r\n                    var nodeId = node.id;\r\n                    var nodeType = node.type;\r\n                    var content = node.content;\r\n                    var constraints = node.constraints;\r\n\r\n                    if (content != null) {\r\n                        //node.content = this.injectAssetPaths(content);\r\n                    }\r\n\r\n                    this.setIdToNode(nodeId, node);\r\n                    this.setIdToElement(nodeId, node);\r\n\r\n                    this.addNode(node);\r\n\r\n                    if (nodeType === 'group') {\r\n                        this.addGroupNode(node);\r\n                    } else {\r\n                        this.addApplicationNode(node);\r\n                    }\r\n\r\n                    var groupId = node.groupId;\r\n\r\n                    if (groupId != null) {\r\n                        this.addNodeToGroupNode(groupId, nodeId);\r\n                    }\r\n\r\n                    if (constraints != null) {\r\n\r\n                        if (this.ConfigService.isPreview() == true && this.ConfigService.getConfigParam('constraints') === false) {\r\n                            /*\r\n                             * if we are in preview mode and constraints are set\r\n                             * to false, we will not add the constraints\r\n                             */\r\n                        } else {\r\n                            // all other cases we will add the constraints\r\n\r\n                            for (var c = 0; c < constraints.length; c++) {\r\n                                var constraint = constraints[c];\r\n\r\n                                this.activeConstraints.push(constraint);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Load the planning template nodes\r\n     * @param planning template nodes\r\n     */\r\n    loadPlanningNodes(planningNodes) {\r\n        if (planningNodes != null) {\r\n\r\n            // loop through all the planning template nodes\r\n            for (var p = 0; p < planningNodes.length; p++) {\r\n                var planningNode = planningNodes[p];\r\n\r\n                if (planningNode != null) {\r\n                    var nodeId = planningNode.id;\r\n\r\n                    this.setIdToNode(nodeId, planningNode);\r\n                    this.setIdToElement(nodeId, planningNode);\r\n\r\n                    // TODO: may need to add more function calls here to add the planning\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    parseProject() {\r\n        var project = this.project;\r\n        if (project != null) {\r\n\r\n            // clear and initialize our project data structures\r\n            this.clearProjectFields();\r\n\r\n            if (project.metadata) {\r\n                this.metadata = project.metadata;\r\n            }\r\n\r\n            var nodes = project.nodes;\r\n            this.loadNodes(nodes);\r\n\r\n            // load the planning node templates\r\n            var planningNodes = project.planningNodes;\r\n            this.loadPlanningNodes(planningNodes);\r\n\r\n            // load the inactive nodes\r\n            var inactiveNodes = project.inactiveNodes;\r\n            this.loadInactiveNodes(inactiveNodes);\r\n\r\n            var constraints = project.constraints;\r\n\r\n            if (constraints != null) {\r\n                for (var c = 0; c < constraints.length; c++) {\r\n                    var constraint = constraints[c];\r\n\r\n                    if (constraint != null) {\r\n                        var constraintId = constraint.id;\r\n                        constraint.active = true;\r\n\r\n                        this.setIdToElement(constraintId, constraint);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // set root node\r\n            this.rootNode = this.getRootNode(nodes[0].id);\r\n\r\n            // set project order\r\n            this.setNodeOrder(this.rootNode, this.nodeCount);\r\n            //this.nodeCount = 0;\r\n\r\n            var n = nodes.length;\r\n            var branches = this.getBranches();\r\n            var branchNodeIds = [];\r\n\r\n            // set node positions\r\n            var id, pos;\r\n\r\n            while (n--) {\r\n                id = nodes[n].id;\r\n                if (id === this.rootNode.id) {\r\n                    this.setIdToPosition(id, '0');\r\n                } else if (this.isNodeIdInABranch(branches, id)) {\r\n                    // node is in a branch, so process later\r\n                    branchNodeIds.push(id);\r\n                } else {\r\n                    pos = this.getPositionById(id);\r\n                    this.setIdToPosition(id, pos);\r\n                }\r\n            }\r\n\r\n            // set branch node positions\r\n            var b = branchNodeIds.length;\r\n            while (b--) {\r\n                id = branchNodeIds[b];\r\n                pos = this.getBranchNodePositionById(id);\r\n                this.setIdToPosition(id, pos);\r\n            }\r\n\r\n            /*\r\n             * calculate the node numbers\r\n             * e.g. if the step is called\r\n             * 1.5 View the Potential Energy\r\n             * then the node number is 1.5\r\n             */\r\n            this.calculateNodeNumbers();\r\n\r\n            if (this.project.achievements != null) {\r\n                // get the project achievements\r\n                this.achievements = this.project.achievements;\r\n            }\r\n        }\r\n    };\r\n\r\n    setNodeOrder(node) {\r\n        this.idToOrder[node.id] = {'order': this.nodeCount};\r\n        this.nodeCount++;\r\n        if (this.isGroupNode(node.id)) {\r\n            let childIds = node.ids;\r\n            for (let i = 0; i < childIds.length; i++) {\r\n                let child = this.getNodeById(childIds[i]);\r\n                this.setNodeOrder(child);\r\n            }\r\n\r\n            if (this.ConfigService.getMode() === 'classroomMonitor') {\r\n                // we're viewing the classroom monitor, so include planning nodes in the project structure\r\n                let planningIds = node.availablePlanningNodes;\r\n                if (planningIds) {\r\n                    for (let a = 0; a < planningIds.length; a++) {\r\n                        let child = this.getNodeById(planningIds[a].nodeId);\r\n                        this.setNodeOrder(child);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the node order mappings of the project\r\n     * @param project the project JSOn\r\n     * @return an object containing the idToOrder mapping and also the array\r\n     * of nodes\r\n     */\r\n    getNodeOrderOfProject(project) {\r\n\r\n        var idToOrder = {};\r\n\r\n        // initialize the node count used for counting the nodes\r\n        idToOrder.nodeCount = 0;\r\n\r\n        // get the start group id\r\n        var startGroupId = project.startGroupId;\r\n\r\n        // get the root node\r\n        var rootNode = this.getNodeById(startGroupId, project);\r\n\r\n        // initialize the step number\r\n        var stepNumber = '';\r\n\r\n        // initialize the nodes\r\n        var nodes = [];\r\n\r\n        // recursively traverse the project to calculate the node counts and step numbers\r\n        var importProjectIdToOrder = this.getNodeOrderOfProjectHelper(project, rootNode, idToOrder, stepNumber, nodes);\r\n\r\n        // remove the node count from the mapping since we don't need it anymore\r\n        delete importProjectIdToOrder.nodeCount;\r\n\r\n        // create the object we will return\r\n        var result = {};\r\n        result.idToOrder = importProjectIdToOrder;\r\n        result.nodes = nodes;\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Recursively traverse the project to calculate the node order and step numbers\r\n     * @param project the project JSON\r\n     * @param node the current node we are on\r\n     * @param idToOrder the mapping of node id to item\r\n     * @param stepNumber the current step number\r\n     * @param nodes the array of nodes\r\n     */\r\n    getNodeOrderOfProjectHelper(project, node, idToOrder, stepNumber, nodes) {\r\n\r\n        /*\r\n         * Create the item that we will add to the idToOrder mapping.\r\n         * The 'order' field determines how the project nodes are displayed\r\n         * when we flatten the project for displaying.\r\n         */\r\n        var item = {\r\n            'order': idToOrder.nodeCount,\r\n            'node': node,\r\n            'stepNumber': stepNumber\r\n        };\r\n\r\n        // set the mapping of node id to item\r\n        idToOrder[node.id] = item;\r\n\r\n        // increment the node count\r\n        idToOrder.nodeCount++;\r\n\r\n        // add the item to the nodes array\r\n        nodes.push(item);\r\n\r\n        if (node.type == 'group') {\r\n            // the node is group so we also need to loop through its children\r\n\r\n            // get the child node ids\r\n            var childIds = node.ids;\r\n\r\n            // loop through all the children\r\n            for (var c = 0; c < childIds.length; c++) {\r\n                var childId = childIds[c];\r\n\r\n                // get a child node\r\n                var child = this.getNodeById(childId, project);\r\n\r\n                // get the current step number e.g. 1\r\n                var childStepNumber = stepNumber;\r\n\r\n                if (childStepNumber != '') {\r\n                    // add the . separator for the step number e.g. 1.\r\n                    childStepNumber += '.';\r\n                }\r\n\r\n                // update the step number e.g. 1.1\r\n                childStepNumber += (c + 1);\r\n\r\n                // recursively traverse the child\r\n                this.getNodeOrderOfProjectHelper(project, child, idToOrder, childStepNumber, nodes);\r\n            }\r\n        }\r\n\r\n        return idToOrder;\r\n    }\r\n\r\n    /**\r\n     * Returns the position in the project for the node with the given id. Returns null if no node with id exists.\r\n     * @param id a node id\r\n     * @return string position of the given node id in the project\r\n     */\r\n    getPositionById(id) {\r\n        for (var i = 0; i < this.rootNode.ids.length; i++) {\r\n            var node = this.getNodeById(this.rootNode.ids[i]);\r\n            var path = this.getPathToNode(node, i+1, id);\r\n            if (path != undefined && path != null) {\r\n                return path;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Returns the order of the given node id in the project. Returns null if no node with id exists.\r\n     * @param id String node id\r\n     * @return Number order of the given node id in the project\r\n     */\r\n    getOrderById(id) {\r\n        if (this.idToOrder[id]) {\r\n            return this.idToOrder[id].order;\r\n        }\r\n\r\n        return null;\r\n    };\r\n    /**\r\n     * Returns the id of the node with the given order in the project. Returns null if no order with node exists.\r\n     * @param order Number\r\n     * @return Number node id of the given order in the project\r\n     */\r\n    getIdByOrder(order) {\r\n        var nodeId = null;\r\n\r\n        for (var id in this.idToOrder) {\r\n            if (this.idToOrder[id].order === order) {\r\n                if (this.isGroupNode(id) && order > 1) {\r\n                    nodeId = this.getIdByOrder(order-1);\r\n                } else {\r\n                    nodeId = id;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        return nodeId;\r\n    };\r\n\r\n    /**\r\n     * Returns the position in the project for the branch node with the given id. Returns null if no node with id exists or node is not a branch node.\r\n     * @param id a node id\r\n     * @return string position of the given node id in the project\r\n     */\r\n    getBranchNodePositionById(id) {\r\n        var branches = this.getBranches();\r\n        var b = branches.length;\r\n\r\n        // TODO: should we localize this? should we support more than 26?\r\n        var integerToAlpha = function(int) {\r\n            var alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\r\n            if (int > -1 && int < 26) {\r\n                return alphabet[int];\r\n            } else {\r\n                return int;\r\n            }\r\n        };\r\n\r\n        while (b--) {\r\n            var branch = branches[b];\r\n            var branchPaths = branch.branchPaths;\r\n            for (var p = 0; p < branchPaths.length; p++) {\r\n                var branchPath = branchPaths[p];\r\n                var nodeIndex = branchPath.indexOf(id);\r\n                if (nodeIndex > -1) {\r\n                    var startPoint = branch.branchStartPoint;\r\n                    var startPointPos = this.idToPosition[startPoint];\r\n                    var branchPathPos = startPointPos + ' ' + integerToAlpha(p);\r\n                    return branchPathPos + (nodeIndex+1);\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Recursively searches for the given node id from the point of the given node down and returns the path number (position)\r\n     * @param node a node to start searching down\r\n     * @param path the position of the given node\r\n     * @param id the node id to search for\r\n     * @return string path of the given node id in the project\r\n     */\r\n    getPathToNode(node, path, id) {\r\n        if (node.id === id) {\r\n            return path + '';\r\n        } else if (node.type === 'group') {\r\n            var num = 0;\r\n            var branches = this.getBranches();\r\n            for (var i = 0; i < node.ids.length; i++) {\r\n                var nodeId = node.ids[i];\r\n                if (this.isNodeIdInABranch(branches, nodeId)) {\r\n                    this.getBranchNodePositionById(nodeId);\r\n                } else {\r\n                    ++num;\r\n                    var pos = this.getPathToNode(this.getNodeById(nodeId), (path) + '.' + (num), id);\r\n                    if (pos) {\r\n                        return pos;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    setIdToPosition(id, pos) {\r\n        if (id != null) {\r\n            this.idToPosition[id] = pos;\r\n        }\r\n    };\r\n\r\n    getNodePositionById(id) {\r\n        let position = null;\r\n\r\n        if (id != null) {\r\n            //position = this.idToPosition[id] ? this.idToPosition[id] : null;\r\n            position = this.nodeIdToNumber[id];\r\n        }\r\n\r\n        return position;\r\n    };\r\n\r\n    getNodeIdByOrder(order) {\r\n        let id = null;\r\n\r\n        if (order != null) {\r\n            for (let [nodeId, value] of Object.entries(this.idToOrder)) {\r\n                if (value.order === order) {\r\n                    id = nodeId;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return id;\r\n    }\r\n\r\n    getNodeOrderById(id) {\r\n        let order = null;\r\n\r\n        if (id != null) {\r\n            order = this.idToOrder[id] ? this.idToOrder[id].order : null;\r\n        }\r\n\r\n        return order;\r\n    };\r\n\r\n    setIdToNode(id, element) {\r\n        if (id != null) {\r\n            this.idToNode[id] = element;\r\n        }\r\n    };\r\n\r\n    setIdToElement(id, element) {\r\n        if (id != null) {\r\n            this.idToElement[id] = element;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Replace relative asset paths with absolute paths\r\n     * e.g.\r\n     * assets/myimage.jpg\r\n     * will be replaced with\r\n     * http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg\r\n     * @param content a string or JSON object\r\n     * @return the same type of object that was passed in as the content\r\n     * but with relative asset paths replaced with absolute paths\r\n     */\r\n    injectAssetPaths(content) {\r\n\r\n        if (content != null) {\r\n\r\n            if (typeof content === 'object') {\r\n\r\n                var contentString = JSON.stringify(content);\r\n\r\n                if (contentString != null) {\r\n\r\n                    // replace the relative asset paths with the absolute paths\r\n                    contentString = this.replaceAssetPaths(contentString);\r\n\r\n                    content = JSON.parse(contentString);\r\n                }\r\n            } else if (typeof content === 'string') {\r\n\r\n                // replace the relative asset paths with the absolute paths\r\n                content = this.replaceAssetPaths(content);\r\n            }\r\n        }\r\n\r\n        return content;\r\n    };\r\n\r\n    /**\r\n     * Replace the relative asset paths with absolute paths\r\n     * @param contentString the content string\r\n     * @return the content string with relative asset paths replaced\r\n     * with absolute asset paths\r\n     */\r\n    replaceAssetPaths(contentString) {\r\n\r\n        if (contentString != null) {\r\n\r\n            // get the content base url e.g. http://wise.berkeley.edu/curriculum/123456/\r\n            var contentBaseURL = this.ConfigService.getConfigParam('projectBaseURL');\r\n\r\n            // only look for string that starts with ' or \" and ends in png, jpg, jpeg, pdf, etc.\r\n            // the string we're looking for can't start with '/ and \"/.\r\n            // note that this also works for \\\"abc.png and \\'abc.png, where the quotes are escaped\r\n            contentString = contentString.replace(\r\n                new RegExp('(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")[^:][^\\/]?[^\\/]?[a-zA-Z0-9@\\\\._\\\\/\\\\s\\\\-]*[\\.](png|jpe?g|pdf|gif|mov|mp4|mp3|wav|swf|css|txt|json|xlsx?|doc|html.*?|js)(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")', 'gi'),\r\n                (matchedString) => {\r\n                    // once found, we prepend the contentBaseURL + \"assets/\" to the string within the quotes and keep everything else the same.\r\n                    var delimiter = '';\r\n                    var matchedStringWithoutQuotes = '';\r\n\r\n                    if (matchedString.length > 2 && matchedString.substr(0,1) == '\\\\') {\r\n                        // the string has escaped quotes for example \\\"hello.png\\\"\r\n\r\n                        // get everything between the escaped quotes\r\n                        matchedStringWithoutQuotes = matchedString.substr(2, matchedString.length - 4);\r\n\r\n                        // get the delimiter which will be \\' or \\\"\r\n                        delimiter = matchedString.substr(0,2);\r\n                    } else {\r\n                        // the string does not have escaped quotes for example \"hello.png\"\r\n\r\n                        // get everything between the quotes\r\n                        matchedStringWithoutQuotes = matchedString.substr(1, matchedString.length - 2);\r\n\r\n                        // get the delimiter which will be ' or \"\r\n                        delimiter = matchedString.substr(0,1);\r\n                    }\r\n\r\n                    if (matchedStringWithoutQuotes != null && matchedStringWithoutQuotes.length > 0 && matchedStringWithoutQuotes.charAt(0) == \"/\") {\r\n                        /*\r\n                         * the matched string starts with a \"/\" which means it's\r\n                         * an absolute path and does not require path prepending\r\n                         * so we will just return the original unmodified string\r\n                         */\r\n                        return delimiter + matchedStringWithoutQuotes + delimiter;\r\n                    } else {\r\n                        //var matchedStringWithoutFirstAndLastQuote = matchedString.substr(1, matchedString.length - 2);  // everything but the beginning and end quote (' or \")\r\n                        // make a new string with the contentBaseURL + assets/ prepended to the path\r\n                        return delimiter + contentBaseURL + \"assets/\" + matchedStringWithoutQuotes + delimiter;\r\n                    }\r\n                }\r\n            );\r\n        }\r\n\r\n        return contentString;\r\n    };\r\n\r\n    /**\r\n     * Inject the ng-click attribute that will call the snipImage function\r\n     * @param content the content\r\n     * @returns the modified content\r\n     */\r\n    injectClickToSnipImage(content) {\r\n        if (content != null) {\r\n\r\n            if (typeof content === 'object') {\r\n\r\n                var contentString = JSON.stringify(content);\r\n\r\n                if (contentString != null) {\r\n\r\n                    // replace the relative asset paths with the absolute paths\r\n                    contentString = this.injectClickToSnipImageIntoContentString(contentString);\r\n\r\n                    content = JSON.parse(contentString);\r\n                }\r\n            } else if (typeof content === 'string') {\r\n\r\n                // replace the relative asset paths with the absolute paths\r\n                content = this.injectClickToSnipImageIntoContentString(content);\r\n            }\r\n        }\r\n\r\n        return content;\r\n    }\r\n\r\n    /**\r\n     * Inject the ng-click attribute that will call the snipImage function\r\n     * @param contentString the content in string format\r\n     * @returns the modified content string\r\n     */\r\n    injectClickToSnipImageIntoContentString(contentString) {\r\n\r\n        if (contentString != null) {\r\n\r\n            // regex to match image elements\r\n            var imgMatcher = new RegExp('<img.*?src=\\\\\\\\?[\\'\"](.*?)\\\\\\\\?[\\'\"].*?>', 'gi');\r\n\r\n            // replace all instances that match\r\n            contentString = contentString.replace(imgMatcher,\r\n                (matchedString, matchGroup1) => {\r\n\r\n                    /*\r\n                     * insert the ng-click attribute\r\n                     * Before: <img src=\"abc.png\"/>\r\n                     * After: <img ng-click=\"vleController.snipImage($event)\" src=\"abc.png\" />\r\n                     */\r\n                    var newString = matchedString.replace('img', 'img ng-click=\\\\\\\"$emit(\\'snipImage\\', $event)\\\\\\\"');\r\n\r\n                    return newString;\r\n                }\r\n            );\r\n        }\r\n\r\n        return contentString;\r\n    }\r\n\r\n    /**\r\n     * Returns the node specified by the nodeId\r\n     * @param nodeId get the node with this node id\r\n     * @param (optional) the project to retrieve the node from. this is used in\r\n     * the case when we want the node from another project such as when we are\r\n     * importing a step from another project\r\n     * Return null if nodeId param is null or the specified node does not exist in the project.\r\n     */\r\n    getNodeById(nodeId, project) {\r\n        var element = null;\r\n\r\n        if (project == null) {\r\n            // the project argument is null so we will get it from the current project\r\n            if (nodeId != null && this.idToNode[nodeId]) {\r\n                element = this.idToNode[nodeId];\r\n            }\r\n        } else {\r\n            /*\r\n             * the project argument is not null so we will get the node from\r\n             * project that was passed in\r\n             */\r\n\r\n            // loop through all the active nodes in the project\r\n            for (var n = 0; n < project.nodes.length; n++) {\r\n                var tempNode = project.nodes[n];\r\n\r\n                if (tempNode != null && tempNode.id == nodeId) {\r\n                    // we have found the node we are looking for\r\n                    return tempNode;\r\n                }\r\n            }\r\n\r\n            // loop through all the inactive nodes in the project\r\n            for (var n = 0; n < project.inactiveNodes.length; n++) {\r\n                var tempNode = project.inactiveNodes[n];\r\n\r\n                if (tempNode != null && tempNode.id == nodeId) {\r\n                    // we have found the node we are looking for\r\n                    return tempNode;\r\n                }\r\n            }\r\n        }\r\n\r\n        return element;\r\n    };\r\n\r\n    /**\r\n     * Returns the title of the node with the nodeId\r\n     * Return null if nodeId param is null or the specified node does not exist in the project.\r\n     */\r\n    getNodeTitleByNodeId(nodeId) {\r\n        var title = null;\r\n\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node != null) {\r\n            title = node.title;\r\n        }\r\n\r\n        return title;\r\n    };\r\n\r\n    /**\r\n     * Get the node position and title\r\n     * @param nodeId the node id\r\n     * @returns the node position and title, e.g. \"1.1 Introduction\"\r\n     */\r\n    getNodePositionAndTitleByNodeId(nodeId) {\r\n        var title = null;\r\n\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node != null) {\r\n\r\n            var position = this.getNodePositionById(nodeId);\r\n\r\n            if (position != null) {\r\n                title = position + ': ' + node.title;\r\n            } else {\r\n                title = node.title;\r\n            }\r\n        }\r\n\r\n        return title;\r\n    };\r\n\r\n    getNodeIconByNodeId(nodeId) {\r\n        var node = this.getNodeById(nodeId);\r\n        var nodeIcon = null;\r\n\r\n        if (node != null) {\r\n            var nodeType = node.type;\r\n\r\n            // set defaults (TODO: get from configService?)\r\n            var defaultName = (nodeType === 'group') ? 'explore' : 'school';\r\n            nodeIcon = {\r\n                color: 'rgba(0,0,0,0.54)',\r\n                type: 'font',\r\n                fontSet: 'material-icons',\r\n                fontName: defaultName,\r\n                imgSrc: '',\r\n                imgAlt: 'node icon'\r\n            };\r\n\r\n            // TODO: check for different statuses\r\n            var icons = node.icons;\r\n            if (!!icons && !!icons.default) {\r\n                var icon = icons.default;\r\n                nodeIcon = $.extend(true, nodeIcon, icon);\r\n            }\r\n\r\n            // check for empty image source\r\n            if (!nodeIcon.imgSrc) {\r\n                // revert to font icon\r\n                nodeIcon.type = 'font';\r\n            }\r\n        }\r\n\r\n        return nodeIcon;\r\n    };\r\n\r\n    getParentGroup(nodeId) {\r\n        var result = null;\r\n\r\n        if (nodeId != null) {\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n                var groupNodes = this.getGroupNodes();\r\n\r\n                for (var g = 0; g < groupNodes.length; g++) {\r\n                    var groupNode = groupNodes[g];\r\n\r\n                    if (this.isNodeDirectChildOfGroup(node, groupNode)) {\r\n                        result = groupNode;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Get the parent group id\r\n     * @param nodeId the parent group id\r\n     * @returns the parent group id\r\n     */\r\n    getParentGroupId(nodeId) {\r\n\r\n        var parentGroupId = null;\r\n\r\n        if (nodeId != null) {\r\n            var parentGroup = this.getParentGroup(nodeId);\r\n\r\n            if (parentGroup != null) {\r\n                parentGroupId = parentGroup.id;\r\n            }\r\n        }\r\n\r\n        return parentGroupId;\r\n    }\r\n\r\n    getNodeDepth(nodeId, val) {\r\n        var result = null;\r\n\r\n        if (nodeId != null) {\r\n            var depth = (typeof val === \"number\") ? val : 0;\r\n            var parent = this.getParentGroup(nodeId);\r\n            if (parent) {\r\n                depth = this.getNodeDepth(parent.id, depth + 1);\r\n            }\r\n            result = depth;\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    getRootNode(nodeId) {\r\n        var result = null;\r\n\r\n        var parentGroup = this.getParentGroup(nodeId);\r\n\r\n        if (parentGroup == null) {\r\n            result = this.getNodeById(nodeId);\r\n        } else {\r\n            result = this.getRootNode(parentGroup.id);\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    isNodeDirectChildOfGroup(node, group) {\r\n        var result = false;\r\n\r\n        if (node != null && group != null) {\r\n            var nodeId = node.id;\r\n            var groupIds = group.ids;\r\n\r\n            if (groupIds != null && groupIds.indexOf(nodeId) != -1) {\r\n                result = true;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    isNodeDescendentOfGroup(node, group) {\r\n        var result = false;\r\n\r\n        if (node != null && group != null) {\r\n            var descendents = this.getDescendentsOfGroup(group);\r\n            var nodeId = node.id;\r\n\r\n            if (descendents.indexOf(nodeId) != -1) {\r\n                result = true;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    getDescendentsOfGroup(group) {\r\n        var descendents = [];\r\n\r\n        if (group != null) {\r\n            var childIds = group.ids;\r\n\r\n            if (childIds != null) {\r\n                descendents = childIds;\r\n\r\n                for (var c = 0; c < childIds.length; c++) {\r\n                    var childId = childIds[c];\r\n\r\n                    var node = this.getNodeById(childId);\r\n\r\n                    if (node != null) {\r\n                        var childDescendents = this.getDescendentsOfGroup(node);\r\n\r\n                        descendents = descendents.concat(childDescendents);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return descendents;\r\n    };\r\n\r\n    isStartNode(node) {\r\n        var result = false;\r\n\r\n        if (node != null) {\r\n            var nodeId = node.id;\r\n\r\n            var projectStartId = this.getStartNodeId();\r\n\r\n            if (nodeId === projectStartId) {\r\n                result = true;\r\n            }\r\n\r\n            var groups = this.getGroups();\r\n\r\n            for (var g = 0; g < groups.length; g++) {\r\n                var group = groups[g];\r\n\r\n                if (group != null) {\r\n                    var groupStartId = group.startId;\r\n\r\n                    if (nodeId === groupStartId) {\r\n                        result = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns the Project's start node id, or null if it's not defined in the project\r\n     */\r\n    getStartNodeId() {\r\n        var startNodeId = null;\r\n        var project = this.project;\r\n        if (project != null) {\r\n            startNodeId = project.startNodeId;\r\n        }\r\n        return startNodeId;\r\n    };\r\n\r\n    /**\r\n     * Set the start node id\r\n     * @param nodeId the new start node id\r\n     */\r\n    setStartNodeId(nodeId) {\r\n\r\n        if (nodeId != null) {\r\n            var project = this.project;\r\n            if (project != null) {\r\n                project.startNodeId = nodeId;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the start group id\r\n     * @return the start group id\r\n     */\r\n    getStartGroupId() {\r\n        var startGroupId = null;\r\n\r\n        var project = this.project;\r\n        if (project != null) {\r\n            startGroupId = project.startGroupId;\r\n        }\r\n\r\n        return startGroupId;\r\n    }\r\n\r\n    /**\r\n     * Check if the given node id is the start node id\r\n     * @return whether the node id is the start node id\r\n     */\r\n    isStartNodeId(nodeId) {\r\n\r\n        var result = false;\r\n\r\n        var project = this.project;\r\n\r\n        if (project != null) {\r\n            var startNodeId = project.startNodeId;\r\n\r\n            if (nodeId === startNodeId) {\r\n                result = true;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    getConstraintsForNode(node) {\r\n        var constraints = [];\r\n\r\n        var allConstraints = this.activeConstraints;\r\n\r\n        for (var c = 0; c < allConstraints.length; c++) {\r\n            var constraint = allConstraints[c];\r\n\r\n            if (this.isNodeAffectedByConstraint(node, constraint)) {\r\n                constraints.push(constraint);\r\n            }\r\n        }\r\n\r\n        return constraints;\r\n    };\r\n\r\n    /**\r\n     * Check if a node is affected by the constraint\r\n     * @param node check if the node is affected\r\n     * @param constraint the constraint that might affect the node\r\n     * @returns whether the node is affected by the constraint\r\n     */\r\n    isNodeAffectedByConstraint(node, constraint) {\r\n        var result = false;\r\n\r\n        if (node != null && constraint != null) {\r\n            var nodeId = node.id;\r\n            var targetId = constraint.targetId;\r\n            var action = constraint.action;\r\n\r\n            if (action === 'makeAllNodesAfterThisNotVisible') {\r\n                if (this.isNodeIdAfter(targetId, node.id)) {\r\n                    result = true;\r\n                }\r\n            } else if (action === 'makeAllNodesAfterThisNotVisitable') {\r\n                if (this.isNodeIdAfter(targetId, node.id)) {\r\n                    result = true;\r\n                }\r\n            } else {\r\n                var targetNode = this.getNodeById(targetId);\r\n\r\n                if (targetNode != null) {\r\n                    var nodeType = targetNode.type;\r\n\r\n                    if (nodeType === 'node') {\r\n                        // the target is an application\r\n\r\n                        if (nodeId === targetId) {\r\n                            result = true;\r\n                        }\r\n                    } else if (nodeType === 'group') {\r\n                        // the target is a group\r\n\r\n                        if (nodeId === targetId) {\r\n                            result = true;\r\n                        }\r\n\r\n                        if (this.isNodeDescendentOfGroup(node, targetNode)) {\r\n                            result = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Check if a node id comes after another node id in the project\r\n     * @param nodeIdBefore the node id before\r\n     * @param nodeIdAfter the node id after\r\n     */\r\n    isNodeIdAfter(nodeIdBefore, nodeIdAfter) {\r\n        var result = false;\r\n\r\n        if (nodeIdBefore != null && nodeIdAfter != null) {\r\n\r\n            if (this.isApplicationNode(nodeIdBefore)) {\r\n                // the node id before is a step\r\n\r\n                // get all the paths from the beforeNodeId to the end of the project\r\n                var pathsToEnd = this.getAllPaths([], nodeIdBefore, true);\r\n\r\n                if (pathsToEnd != null) {\r\n\r\n                    // loop through all the paths\r\n                    for (var p = 0; p < pathsToEnd.length; p++) {\r\n\r\n                        var pathToEnd = pathsToEnd[p];\r\n\r\n                        if (pathToEnd != null) {\r\n\r\n                            /*\r\n                             * remove the first node id and its parent id because\r\n                             * we will check the remaining node ids in the array\r\n                             * for the nodeIdAfter\r\n                             */\r\n\r\n                            // get the index of the node id before\r\n                            var index = pathToEnd.indexOf(nodeIdBefore);\r\n\r\n                            if (index != -1) {\r\n                                // remove the node id before\r\n                                pathToEnd.splice(index, 1);\r\n                            }\r\n\r\n                            // get the parent group of the node id before\r\n                            var parentGroup = this.getParentGroup(nodeIdBefore);\r\n\r\n                            if (parentGroup != null) {\r\n                                // remove the parent group of the node id before\r\n                                var parentGroupId = parentGroup.id;\r\n                                var parentGroupIndex = pathToEnd.indexOf(parentGroupId);\r\n                                if (parentGroupIndex != -1) {\r\n                                    pathToEnd.splice(parentGroupIndex, 1);\r\n                                }\r\n                            }\r\n\r\n                            if (pathToEnd.indexOf(nodeIdAfter) != -1) {\r\n                                // we have found the nodeIdAfter in the path to the end of the project\r\n                                result = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // the node id before is an activity\r\n\r\n                // get the group\r\n                var group = this.getNodeById(nodeIdBefore);\r\n\r\n                if (group != null) {\r\n\r\n                    // get the transitions from the group\r\n                    var transitions = this.getTransitionsByFromNodeId(nodeIdBefore);\r\n\r\n                    if (transitions != null) {\r\n\r\n                        // loop through all the transitions\r\n                        for (var t = 0; t < transitions.length; t++) {\r\n                            var transition = transitions[t];\r\n\r\n                            if (transition != null) {\r\n                                var toNodeId = transition.to;\r\n\r\n                                // get the paths between to toNodeId and the end of the project\r\n                                var pathsToEnd = this.getAllPaths([], toNodeId, true);\r\n\r\n                                // loop through all the paths\r\n                                for (var p = 0; p < pathsToEnd.length; p++) {\r\n\r\n                                    // get a path\r\n                                    var pathToEnd = pathsToEnd[p];\r\n\r\n                                    if (pathToEnd != null) {\r\n                                        if (pathToEnd.indexOf(nodeIdAfter) != -1) {\r\n                                            // we have found the nodeIdAfter in the path to the end of the project\r\n                                            result = true;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    getNavigationMode() {\r\n        var navigationMode = null;\r\n        var project = this.project;\r\n        if (project != null) {\r\n            navigationMode = project.navigationMode;\r\n        }\r\n        return navigationMode;\r\n    };\r\n\r\n    getTransitions() {\r\n        var transitions = null;\r\n        var project = this.project;\r\n        if (project != null) {\r\n            transitions = project.transitions;\r\n        }\r\n        return transitions;\r\n    };\r\n\r\n    /**\r\n     * Returns all possible transition criteria for the specified node and component.\r\n     */\r\n    getPossibleTransitionCriteria(nodeId, componentId) {\r\n        let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\r\n        if (component != null) {\r\n            let componentType = component.type;\r\n            let componentService = this.$injector.get(componentType + 'Service');\r\n            if (componentService.getPossibleTransitionCriteria) {\r\n                return componentService.getPossibleTransitionCriteria(nodeId, componentId, component);\r\n            } else {\r\n                return [];\r\n            }\r\n        } else {\r\n            return [];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the transition logic for a node\r\n     * @param fromNodeId the from node id\r\n     * @returns the transition logic object\r\n     */\r\n    getTransitionLogicByFromNodeId(fromNodeId) {\r\n        var transitionLogic = null;\r\n\r\n        if (fromNodeId != null) {\r\n\r\n            // get the node\r\n            var node = this.getNodeById(fromNodeId);\r\n\r\n            if (node != null) {\r\n                // get the transition logic\r\n                transitionLogic = node.transitionLogic;\r\n            }\r\n        }\r\n\r\n        return transitionLogic;\r\n    };\r\n\r\n    /**\r\n     * Get the transitions for a node\r\n     * @param fromNodeId the node to get transitions from\r\n     * @returns an array of transitions\r\n     */\r\n    getTransitionsByFromNodeId(fromNodeId) {\r\n\r\n        var transitions = null;\r\n\r\n        if (fromNodeId != null) {\r\n            // get the transition logic\r\n            var transitionLogic = this.getTransitionLogicByFromNodeId(fromNodeId);\r\n\r\n            if (transitionLogic != null) {\r\n                // get the transitions\r\n                transitions = transitionLogic.transitions;\r\n            }\r\n        }\r\n\r\n        return transitions;\r\n    }\r\n\r\n    /**\r\n     * Get nodes that have a transition to the given node id\r\n     * @param toNodeId the node id\r\n     * @returns an array of node objects that transition to the\r\n     * given node id\r\n     */\r\n    getNodesByToNodeId(toNodeId) {\r\n        var nodesByToNodeId = [];\r\n\r\n        if (toNodeId != null) {\r\n\r\n            // get all the nodes\r\n            var nodes = this.project.nodes;\r\n\r\n            // loop through all the nodes\r\n            for (var n = 0; n < nodes.length; n++) {\r\n                var node = nodes[n];\r\n\r\n                var transitionLogic = node.transitionLogic;\r\n\r\n                if (transitionLogic != null) {\r\n                    var transitions = transitionLogic.transitions;\r\n\r\n                    if (transitions != null) {\r\n\r\n                        // loop through all the transitions for the node\r\n                        for (var t = 0; t < transitions.length; t++) {\r\n                            var transition = transitions[t];\r\n\r\n                            if (transition != null) {\r\n                                if (toNodeId === transition.to) {\r\n                                    // this node has a transition to the node id\r\n                                    nodesByToNodeId.push(node);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodesByToNodeId;\r\n    };\r\n\r\n    /**\r\n     * Get node ids of all the nodes that have a to transition to the given node id\r\n     * @param toNodeId\r\n     * @returns all the node ids that have a transition to the given node id\r\n     */\r\n    getNodeIdsByToNodeId(toNodeId) {\r\n        var nodeIds = [];\r\n\r\n        // get all the nodes that transition to the toNodeId\r\n        var nodes = this.getNodesByToNodeId(toNodeId);\r\n\r\n        if (nodes != null) {\r\n\r\n            // loop through all the nodes to get the node ids\r\n            for (var n = 0; n < nodes.length; n++) {\r\n                var node = nodes[n];\r\n\r\n                if (node != null) {\r\n                    nodeIds.push(node.id);\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodeIds;\r\n    }\r\n\r\n    /**\r\n     * Get the group nodes that point to a given node id\r\n     * @param toNodeId\r\n     */\r\n    getGroupNodesByToNodeId(toNodeId) {\r\n        var groupsThatPointToNodeId = [];\r\n\r\n        if (toNodeId != null) {\r\n            var groups = this.getGroups();\r\n\r\n            for (var g = 0; g < groups.length; g++) {\r\n                var group = groups[g];\r\n\r\n                if (group != null) {\r\n                    if (this.hasTransitionTo(group, toNodeId)) {\r\n                        groupsThatPointToNodeId.push(group);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return groupsThatPointToNodeId;\r\n    }\r\n\r\n    /**\r\n     * Check if a node has a transition to a node id\r\n     * @param node check if this node has a transition to the node id\r\n     * @param toNodeId we will look for a transition to this node id\r\n     * @returns whether the node has a transition to the node id\r\n     */\r\n    hasTransitionTo(node, toNodeId) {\r\n        var result = false;\r\n\r\n        if (node != null && toNodeId != null) {\r\n            var transitionLogic = node.transitionLogic;\r\n\r\n            if (transitionLogic != null) {\r\n                var transitions = transitionLogic.transitions;\r\n\r\n                if (transitions != null) {\r\n                    for (var t = 0; t < transitions.length; t++) {\r\n                        var transition = transitions[t];\r\n\r\n                        if (toNodeId === transition.to) {\r\n                            result = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the transitions that traverse from the fromNodeId and to the toNodeId\r\n     * @param fromNodeId the from node id\r\n     * @param toNodeId the to node id\r\n     * @returns an array of transitions that traverse from the fromNodeId and\r\n     * to the toNodeId\r\n     */\r\n    getTransitionsByFromAndToNodeId(fromNodeId, toNodeId) {\r\n        var transitionsResults = [];\r\n\r\n        if (fromNodeId != null && toNodeId != null) {\r\n            var node = this.getNodeById(fromNodeId);\r\n\r\n            if (node != null) {\r\n                var transitionLogic = node.transitionLogic;\r\n\r\n                if (transitionLogic != null) {\r\n                    var transitions = transitionLogic.transitions;\r\n\r\n                    if (transitions != null) {\r\n\r\n                        for (var t = 0; t < transitions.length; t++) {\r\n                            var transition = transitions[t];\r\n\r\n                            if (transition != null) {\r\n                                var to = transition.to;\r\n\r\n                                if (toNodeId === to) {\r\n                                    transitionsResults.push(transition);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return transitionsResults;\r\n    };\r\n\r\n    /**\r\n     * Retrieves the project JSON from Config.projectURL and returns it.\r\n     * If Config.projectURL is undefined, returns null.\r\n     */\r\n    retrieveProject() {\r\n        var projectURL = this.ConfigService.getConfigParam('projectURL');\r\n\r\n        if (projectURL == null) {\r\n            return null;\r\n        } else {\r\n            /*\r\n             * add a unique GET parameter value so that it always retrieves the\r\n             * latest version of the project file from the server and never\r\n             * retrieves the project from cache.\r\n             */\r\n            projectURL += '?noCache=' + (new Date()).getTime();\r\n        }\r\n\r\n        return this.$http.get(projectURL).then((result) => {\r\n            var projectJSON = result.data;\r\n            this.setProject(projectJSON);\r\n            return projectJSON;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Retrieve the project JSON\r\n     * @param projectId retrieve the project JSON with this id\r\n     * @return a promise to return the project JSON\r\n     */\r\n    retrieveProjectById(projectId) {\r\n\r\n        if (projectId != null) {\r\n\r\n            // get the config URL for the project\r\n            var configURL = window.configURL + '/' + projectId;\r\n\r\n            // get the config for the project\r\n            return this.$http.get(configURL).then((result) => {\r\n                var configJSON = result.data;\r\n\r\n                if (configJSON != null) {\r\n\r\n                    // get the project URL and preview project URL\r\n                    var projectURL = configJSON.projectURL;\r\n                    var previewProjectURL = configJSON.previewProjectURL;\r\n\r\n                    if (projectURL != null) {\r\n\r\n                        // get the project JSON\r\n                        return this.$http.get(projectURL).then((result) => {\r\n                            var projectJSON = result.data;\r\n\r\n                            /*\r\n                             * set the preview project URL into the project JSON\r\n                             * so that we easily obtain the preview project URL\r\n                             * later\r\n                             */\r\n                            projectJSON.previewProjectURL = previewProjectURL;\r\n\r\n                            return projectJSON;\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the project to Config.saveProjectURL and returns commit history promise.\r\n     * if Config.saveProjectURL or Config.projectId are undefined, does not save and returns null\r\n     */\r\n    saveProject(commitMessage = \"\") {\r\n        this.$rootScope.$broadcast('savingProject');\r\n        // perform any cleanup before saving the project\r\n        this.cleanupBeforeSave();\r\n\r\n        var projectId = this.ConfigService.getProjectId();\r\n        var saveProjectURL = this.ConfigService.getConfigParam('saveProjectURL');\r\n        if (projectId == null || saveProjectURL == null) {\r\n            return null;\r\n        }\r\n\r\n        // Get the project from this service\r\n        var projectJSONString = angular.toJson(this.project, 4);\r\n\r\n        var httpParams = {};\r\n        httpParams.method = 'POST';\r\n        httpParams.url = saveProjectURL;\r\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\r\n\r\n        var params = {};\r\n        params.projectId = projectId;\r\n        params.commitMessage = commitMessage;\r\n        params.projectJSONString = projectJSONString;\r\n        httpParams.data = $.param(params);\r\n\r\n        return this.$http(httpParams).then((result) => {\r\n            var commitHistory = result.data;\r\n            this.$rootScope.$broadcast('projectSaved');\r\n            return commitHistory;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Notifies others that the specified project is being authored\r\n     * @param projectId id of the project\r\n     */\r\n    notifyAuthorProjectBegin(projectId = null) {\r\n        if (projectId == null) {\r\n            if (this.project != null) {\r\n                projectId = this.project.id;\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n        let notifyProjectBeginURL = this.ConfigService.getConfigParam('notifyProjectBeginURL') + projectId;\r\n        let httpParams = {\r\n            method: \"POST\",\r\n            url: notifyProjectBeginURL\r\n        };\r\n\r\n        return this.$http(httpParams).then((result) => {\r\n            let otherAuthors = result.data;\r\n            return otherAuthors;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Notifies others that the specified project is being authored\r\n     * @param projectId id of the project\r\n     */\r\n    notifyAuthorProjectEnd(projectId = null) {\r\n        return this.$q((resolve, reject) => {\r\n            if (projectId == null) {\r\n                if (this.project != null) {\r\n                    projectId = this.ConfigService.getProjectId();\r\n                } else {\r\n                    resolve();\r\n                }\r\n            }\r\n            let notifyProjectEndURL = this.ConfigService.getConfigParam('notifyProjectEndURL') + projectId;\r\n            let httpParams = {};\r\n            httpParams.method = 'POST';\r\n            httpParams.url = notifyProjectEndURL;\r\n\r\n            this.$http(httpParams).then(() => {\r\n                resolve();\r\n            })\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Perform any necessary cleanup before we save the project.\r\n     * For example we need to remove the checked field in the inactive node\r\n     * objects.\r\n     */\r\n    cleanupBeforeSave() {\r\n        var inactiveNodes = this.project.inactiveNodes;\r\n\r\n        if (inactiveNodes != null) {\r\n\r\n            // loop through all the inactive nodes\r\n            for (var i = 0; i < inactiveNodes.length; i++) {\r\n                var inactiveNode = inactiveNodes[i];\r\n\r\n                if (inactiveNode != null) {\r\n                    // remove the checked field\r\n                    delete inactiveNode.checked;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copies the project with the specified id and returns a new project id if the project is\r\n     * successfully copied\r\n     */\r\n    copyProject(projectId) {\r\n        var copyProjectURL = this.ConfigService.getConfigParam('copyProjectURL');\r\n\r\n        if (copyProjectURL == null) {\r\n            return null;\r\n        }\r\n\r\n        var httpParams = {};\r\n        httpParams.method = 'POST';\r\n        httpParams.url = copyProjectURL + \"/\" + projectId;\r\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\r\n\r\n        var params = {};\r\n        httpParams.data = $.param(params);\r\n\r\n        return this.$http(httpParams).then((result) => {\r\n            var projectId = result.data;\r\n            return projectId;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Registers a new project having the projectJSON content with the server.\r\n     * Returns a new project Id if the project is successfully registered.\r\n     * Returns null if Config.registerNewProjectURL is undefined.\r\n     * Throws an error if projectJSONString is invalid JSON string\r\n     */\r\n    registerNewProject(projectJSONString, commitMessage) {\r\n        var registerNewProjectURL = this.ConfigService.getConfigParam('registerNewProjectURL');\r\n\r\n        if (registerNewProjectURL == null) {\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            // Try parsing the JSON string and throw an error if there's an issue parsing it.\r\n            JSON.parse(projectJSONString);\r\n        } catch (e) {\r\n            throw new Error(\"Invalid projectJSONString.\");\r\n        }\r\n\r\n        if (!commitMessage) {\r\n            commitMessage = \"\";\r\n        }\r\n\r\n        var httpParams = {};\r\n        httpParams.method = 'POST';\r\n        httpParams.url = registerNewProjectURL;\r\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\r\n\r\n        var params = {};\r\n        params.commitMessage = commitMessage;\r\n        params.projectJSONString = projectJSONString;\r\n        httpParams.data = $.param(params);\r\n\r\n        return this.$http(httpParams).then((result) => {\r\n            var projectId = result.data;\r\n            return projectId;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Retrieves and returns the project's commit history.\r\n     */\r\n    getCommitHistory() {\r\n        var commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\r\n\r\n        return this.$http({\r\n            url: commitProjectURL,\r\n            method: 'GET'\r\n        }).then((result) => {\r\n            return result.data;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Returns the theme path for the current project\r\n     */\r\n    getThemePath() {\r\n        let wiseBaseURL = this.ConfigService.getWISEBaseURL();\r\n        let project = this.project;\r\n        if (project && project.theme) {\r\n            // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\r\n            return wiseBaseURL + '/wise5/themes/' + project.theme;\r\n        } else {\r\n            // TODO: get default theme name from ConfigService\r\n            return wiseBaseURL + '/wise5/themes/default';\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the theme settings for the current project\r\n     */\r\n    getThemeSettings() {\r\n        let themeSettings = {};\r\n        let project = this.project;\r\n\r\n        if (project && project.themeSettings) {\r\n            if (project.theme) {\r\n                // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\r\n                themeSettings = project.themeSettings[project.theme];\r\n            } else {\r\n                // TODO: get default theme name from ConfigService\r\n                themeSettings = project.themeSettings[\"default\"];\r\n            }\r\n        }\r\n\r\n        return themeSettings ? themeSettings : {};\r\n    };\r\n\r\n    /**\r\n     * Flatten the project to obtain a list of node ids\r\n     */\r\n    getFlattenedProjectAsNodeIds() {\r\n        var nodeIds = [];\r\n\r\n        // get the start node id\r\n        var startNodeId = this.getStartNodeId();\r\n\r\n        /*\r\n         * an array to keep track of the node ids in the path that\r\n         * we are currently on as we traverse the nodes in the project\r\n         * depth first\r\n         */\r\n        var pathsSoFar = [];\r\n\r\n        // get all the possible paths through the project\r\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\r\n\r\n        // consolidate all the paths to create a single list of node ids\r\n        nodeIds = this.consolidatePaths(allPaths);\r\n        //nodeIds = this.consolidatePaths(allPaths.reverse());\r\n\r\n        return nodeIds;\r\n    };\r\n\r\n    /**\r\n     * Get all the possible paths through the project. This function\r\n     * recursively calls itself to traverse the project depth first.\r\n     * @param pathSoFar the node ids in the path so far. the node ids\r\n     * in this array are referenced to make sure we don't loop back\r\n     * on the path.\r\n     * @param nodeId the node id we want to get the paths from\r\n     * @param includeGroups whether to include the group node ids in the paths\r\n     * @return an array of paths. each path is an array of node ids.\r\n     */\r\n    getAllPaths(pathSoFar, nodeId, includeGroups) {\r\n        var allPaths = [];\r\n\r\n        if (nodeId != null) {\r\n            if (this.isApplicationNode(nodeId)) {\r\n                // the node is an application node\r\n\r\n                var path = [];\r\n\r\n                // get all the transitions from this node\r\n                var transitions = this.getTransitionsByFromNodeId(nodeId);\r\n\r\n                if (transitions != null) {\r\n\r\n                    if (includeGroups) {\r\n                        // get the parent group\r\n                        var parentGroup = this.getParentGroup(nodeId);\r\n                        if (parentGroup != null) {\r\n\r\n                            // get the parent group id\r\n                            var parentGroupId = parentGroup.id;\r\n\r\n                            if (parentGroupId != null && pathSoFar.indexOf(parentGroupId) == -1) {\r\n                                // add the parent group id\r\n                                pathSoFar.push(parentGroup.id);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    /*\r\n                     * add the node id to the path so far so we can later check\r\n                     * which nodes are already in the path to prevent looping\r\n                     * back in the path\r\n                     */\r\n                    pathSoFar.push(nodeId);\r\n\r\n                    if (transitions.length === 0) {\r\n                        /*\r\n                         * there are no transitions from the node id so we will\r\n                         * look for a transition in the parent group\r\n                         */\r\n\r\n                        var addedCurrentNodeId = false;\r\n\r\n                        var parentGroupId = this.getParentGroupId(nodeId);\r\n                        var parentGroupTransitions = this.getTransitionsByFromNodeId(parentGroupId);\r\n\r\n                        if (parentGroupTransitions != null) {\r\n                            for (var p = 0; p < parentGroupTransitions.length; p++) {\r\n                                var parentGroupTransition = parentGroupTransitions[p];\r\n\r\n                                if (parentGroupTransition != null) {\r\n\r\n                                    var toNodeId = parentGroupTransition.to;\r\n\r\n                                    if (pathSoFar.indexOf(toNodeId) == -1) {\r\n                                        /*\r\n                                         * recursively get the paths by getting all\r\n                                         * the paths for the to node\r\n                                         */\r\n                                        var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\r\n\r\n                                        for (var a = 0; a < allPathsFromToNode.length; a++) {\r\n\r\n                                            // get a path\r\n                                            var tempPath = allPathsFromToNode[a];\r\n\r\n                                            // prepend the current node id to the path\r\n                                            tempPath.unshift(nodeId);\r\n\r\n                                            // add the path to our collection of paths\r\n                                            allPaths.push(tempPath);\r\n\r\n                                            addedCurrentNodeId = true;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        if (!addedCurrentNodeId) {\r\n                            /*\r\n                             * if the parent group doesn't have any transitions we will\r\n                             * need to add the current node id to the path\r\n                             */\r\n\r\n                            // add the node id to the path\r\n                            path.push(nodeId);\r\n\r\n                            // add the path to the all paths array\r\n                            allPaths.push(path);\r\n                        }\r\n                    } else {\r\n                        // there are transitions from this node id\r\n\r\n                        // loop through all the transitions from this node id\r\n                        for (var t = 0; t < transitions.length; t++) {\r\n                            var transitionResult = [];\r\n\r\n                            // get a transition\r\n                            var transition = transitions[t];\r\n\r\n                            if (transition != null) {\r\n                                // get the to node id\r\n                                var toNodeId = transition.to;\r\n\r\n                                if (toNodeId != null && pathSoFar.indexOf(toNodeId) == -1) {\r\n                                    // we have not found the to node in the path yet so we can traverse it\r\n\r\n                                    /*\r\n                                     * recursively get the paths by getting all\r\n                                     * the paths from the to node\r\n                                     */\r\n                                    var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\r\n\r\n                                    if (allPathsFromToNode != null) {\r\n                                        // loop through all the paths from the to node\r\n                                        for (var a = 0; a < allPathsFromToNode.length; a++) {\r\n\r\n                                            // get a path\r\n                                            var tempPath = allPathsFromToNode[a];\r\n\r\n                                            if (includeGroups) {\r\n                                                // we need to add the group id to the path\r\n\r\n                                                if (tempPath.length > 0) {\r\n\r\n                                                    // get the first node id in the path\r\n                                                    var firstNodeId = tempPath[0];\r\n\r\n                                                    // get the parent id of the first node\r\n                                                    var firstParentGroupId = this.getParentGroupId(firstNodeId);\r\n\r\n                                                    // get the parent id of the current node\r\n                                                    var parentGroupId = this.getParentGroupId(nodeId);\r\n\r\n                                                    if (parentGroupId != firstParentGroupId) {\r\n                                                        /*\r\n                                                         * the parent ids are different which means this is a boundary\r\n                                                         * between two groups. for example if the project looked like\r\n                                                         * group1>node1>node2>group2>node3>node4\r\n                                                         * and the current node was node2 then the first node in the\r\n                                                         * path would be node3 which means we would need to place\r\n                                                         * group2 on the path before node3\r\n                                                         */\r\n                                                        tempPath.unshift(firstParentGroupId);\r\n                                                    }\r\n                                                }\r\n                                            }\r\n\r\n                                            // prepend the current node id to the path\r\n                                            tempPath.unshift(nodeId);\r\n\r\n                                            // add the path to our collection of paths\r\n                                            allPaths.push(tempPath);\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    /*\r\n                                     * the node is already in the path so far which means\r\n                                     * the transition is looping back to a previous node.\r\n                                     * we do not want to take this transition because\r\n                                     * it will lead to an infinite loop. we will just\r\n                                     * add the current node id to the path and not take\r\n                                     * the transition which essentially ends the path.\r\n                                     */\r\n                                    // add the node id to the path\r\n                                    path.push(nodeId);\r\n\r\n                                    // add the path to the all paths array\r\n                                    allPaths.push(path);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (pathSoFar.length > 0) {\r\n                        // get the last node id\r\n                        var lastNodeId = pathSoFar[pathSoFar.length - 1];\r\n\r\n                        // check if the last node id is a group id\r\n                        if (this.isGroupNode(lastNodeId)) {\r\n                            /*\r\n                             * the last node id is a group id so we will remove it\r\n                             * since we are moving back up the path as we traverse\r\n                             * the nodes depth first\r\n                             */\r\n                            pathSoFar.pop();\r\n                        }\r\n                    }\r\n\r\n                    /*\r\n                     * remove the latest node id (this will be a step node id)\r\n                     * since we are moving back up the path as we traverse the\r\n                     * nodes depth first\r\n                     */\r\n                    pathSoFar.pop();\r\n\r\n                    if (includeGroups) {\r\n                        if (pathSoFar.length == 1) {\r\n\r\n                            /*\r\n                             * we are including groups and we have traversed\r\n                             * back up to the start node id for the project.\r\n                             * the only node id left in pathSoFar is now the\r\n                             * parent group of the start node id. we will\r\n                             * now add this parent group of the start node id\r\n                             * to all of the paths\r\n                             */\r\n\r\n                            // loop through all the paths\r\n                            for (var ap = 0; ap < allPaths.length; ap++) {\r\n\r\n                                // get a path\r\n                                var path = allPaths[ap];\r\n\r\n                                if (path != null) {\r\n                                    /*\r\n                                     * prepend the parent group of the start node id\r\n                                     * to the path\r\n                                     */\r\n                                    path.unshift(pathSoFar[0]);\r\n                                }\r\n                            }\r\n\r\n                            /*\r\n                             * remove the parent group of the start node id from\r\n                             * pathSoFar which leaves us with an empty pathSoFar\r\n                             * which means we are completely done with\r\n                             * calculating all the paths\r\n                             */\r\n                            pathSoFar.pop();\r\n                        }\r\n                    }\r\n                }\r\n            } else if (this.isGroupNode(nodeId)) {\r\n                // the node is a group node\r\n\r\n                /*\r\n                 * add the node id to the path so far so we can later check\r\n                 * which nodes are already in the path to prevent looping\r\n                 * back in the path\r\n                 */\r\n                pathSoFar.push(nodeId);\r\n\r\n                // get the group node\r\n                var groupNode = this.getNodeById(nodeId);\r\n\r\n                if (groupNode != null) {\r\n                    var startId = groupNode.startId;\r\n\r\n                    if (startId == null || startId == \"\") {\r\n                        // there is no start id so we will take the transition from the group\r\n                        // TODO? there is no start id so we will loop through all the child nodes\r\n\r\n                        // get the transitions from the group\r\n                        var transitions = this.getTransitionsByFromNodeId(groupNode.id);\r\n\r\n                        if (transitions != null && transitions.length > 0) {\r\n\r\n                            // loop through all the transitions from the group\r\n                            for (var t = 0; t < transitions.length; t++) {\r\n                                var transition = transitions[t];\r\n\r\n                                if (transition != null) {\r\n                                    var toNodeId = transition.to;\r\n\r\n                                    // get the paths from the to node to the end of the project\r\n                                    var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\r\n\r\n                                    if (allPathsFromToNode != null) {\r\n                                        // loop through all the paths from the to node\r\n                                        for (var a = 0; a < allPathsFromToNode.length; a++) {\r\n\r\n                                            // get a path\r\n                                            var tempPath = allPathsFromToNode[a];\r\n\r\n                                            // prepend the current node id to the path\r\n                                            tempPath.unshift(nodeId);\r\n\r\n                                            // add the path to our collection of paths\r\n                                            allPaths.push(tempPath);\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            /*\r\n                             * this activity does not have any transitions so\r\n                             * we have reached the end of this path\r\n                             */\r\n\r\n                            var tempPath = [];\r\n\r\n                            // prepend the current node id to the path\r\n                            tempPath.unshift(nodeId);\r\n\r\n                            // add the path to our collection of paths\r\n                            allPaths.push(tempPath);\r\n                        }\r\n                    } else {\r\n                        // there is a start id so we will traverse it\r\n\r\n                        // get the paths from the start id to the end of the project\r\n                        var allPathsFromToNode = this.getAllPaths(pathSoFar, startId, includeGroups);\r\n\r\n                        if (allPathsFromToNode != null) {\r\n                            // loop through all the paths from the to node\r\n                            for (var a = 0; a < allPathsFromToNode.length; a++) {\r\n\r\n                                // get a path\r\n                                var tempPath = allPathsFromToNode[a];\r\n\r\n                                // prepend the current node id to the path\r\n                                tempPath.unshift(nodeId);\r\n\r\n                                // add the path to our collection of paths\r\n                                allPaths.push(tempPath);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                /*\r\n                 * remove the latest node id since we are moving back\r\n                 * up the path as we traverse the nodes depth first\r\n                 */\r\n                pathSoFar.pop();\r\n            }\r\n        }\r\n\r\n        return allPaths;\r\n    };\r\n\r\n    /**\r\n     * Consolidate all the paths into a linear list of node ids\r\n     * @param paths an array of paths. each path is an array of node ids.\r\n     * @return an array of node ids that have been properly ordered\r\n     */\r\n    consolidatePaths(paths) {\r\n        var consolidatedPath = [];\r\n\r\n        if (paths != null) {\r\n\r\n            /*\r\n             * continue until all the paths are empty. as we consolidate\r\n             * node ids, we will remove them from the paths. once all the\r\n             * paths are empty we will be done consolidating the paths.\r\n             */\r\n            while(!this.arePathsEmpty(paths)) {\r\n\r\n                // start with the first path\r\n                var currentPath = this.getNonEmptyPathIndex(paths);\r\n\r\n                // get the first node id in the current path\r\n                var nodeId = this.getFirstNodeIdInPathAtIndex(paths, currentPath);\r\n\r\n                if (this.areFirstNodeIdsInPathsTheSame(paths)) {\r\n                    // the first node ids in all the paths are the same\r\n\r\n                    // remove the node id from all the paths\r\n                    this.removeNodeIdFromPaths(nodeId, paths);\r\n\r\n                    // add the node id to our consolidated path\r\n                    consolidatedPath.push(nodeId);\r\n                } else {\r\n                    // not all the top node ids are the same which means we have branched\r\n\r\n                    // get all the paths that contain the node id\r\n                    var pathsThatContainNodeId = this.getPathsThatContainNodeId(nodeId, paths);\r\n\r\n                    if (pathsThatContainNodeId != null) {\r\n                        if (pathsThatContainNodeId.length === 1) {\r\n                            // only the current path we are on has the node id\r\n\r\n                            // remove the node id from the path\r\n                            this.removeNodeIdFromPath(nodeId, paths, currentPath);\r\n\r\n                            // add the node id to our consolidated path\r\n                            consolidatedPath.push(nodeId);\r\n                        } else {\r\n                            // there are multiple paths that have this node id\r\n\r\n                            // consume all the node ids up to the given node id\r\n                            var consumedPath = this.consumePathsUntilNodeId(paths, nodeId);\r\n\r\n                            // remove the node id from the paths\r\n                            this.removeNodeIdFromPaths(nodeId, paths);\r\n\r\n                            // add the node id to the end of the consumed path\r\n                            consumedPath.push(nodeId);\r\n\r\n                            // add the consumed path to our consolidated path\r\n                            consolidatedPath = consolidatedPath.concat(consumedPath);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n        return consolidatedPath;\r\n    };\r\n\r\n    /**\r\n     * Consume the node ids in the paths until we get to the given node id\r\n     * @param paths the paths to consume\r\n     * @param nodeId the node id to stop consuming at\r\n     * @return an array of node ids that we have consumed\r\n     */\r\n    consumePathsUntilNodeId(paths, nodeId) {\r\n        var consumedNodeIds = [];\r\n\r\n        if (paths != null && nodeId != null) {\r\n\r\n            // loop through all the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                // check if the path contains the node id to stop consuming at\r\n                if (path != null && path.indexOf(nodeId) != -1) {\r\n                    /*\r\n                     * the path does contain the node id to stop consuming at\r\n                     * so we will consume the node ids in this path until\r\n                     * we get to the given node id to stop consuming at\r\n                     */\r\n\r\n                    // loop through the node ids in the path\r\n                    for (var x = 0; x < path.length; x++) {\r\n\r\n                        // get a node id\r\n                        var tempNodeId = path[x];\r\n\r\n                        if (nodeId === tempNodeId) {\r\n                            /*\r\n                             * the node id is the same as the one we need to\r\n                             * stop consuming at so we will stop looking\r\n                             * at this path\r\n                             */\r\n                            break;\r\n                        } else {\r\n                            /*\r\n                             * the node id is not the one that we need to stop consuming at\r\n                             * so we will consume it\r\n                             */\r\n\r\n                            // get all the paths that contain the node id\r\n                            var pathsThatContainNodeId = this.getPathsThatContainNodeId(tempNodeId, paths);\r\n\r\n                            if (pathsThatContainNodeId.length === 1) {\r\n                                // there is only one path with this node id\r\n\r\n                                // remove the node id from the path\r\n                                this.removeNodeIdFromPath(tempNodeId, paths, p);\r\n\r\n                                // move the counter back one since we have just removed a node id\r\n                                x--;\r\n\r\n                                // add the node id to the consumed node ids array\r\n                                consumedNodeIds.push(tempNodeId);\r\n                            } else {\r\n                                // there are multiple paths with this node id\r\n\r\n                                // tempNodeId must come before nodeId\r\n\r\n                                var pathsToConsume = [];\r\n\r\n                                // loop through all the paths that contain the node id\r\n                                for (var g = 0; g < pathsThatContainNodeId.length; g++) {\r\n\r\n                                    // get a path that contains the node id\r\n                                    var pathThatContainsNodeId = pathsThatContainNodeId[g];\r\n\r\n                                    // get the index of the node id we want to remove\r\n                                    var tempNodeIdIndex = pathThatContainsNodeId.indexOf(tempNodeId);\r\n\r\n                                    // get the index of the node id we want to stop consuming at\r\n                                    var nodeIdIndex = pathThatContainsNodeId.indexOf(nodeId);\r\n\r\n                                    /*\r\n                                     * check if the node id we want to remove comes before\r\n                                     * the node id we want to stop consuming at. we need to\r\n                                     * do this to prevent an infinite loop. an example of\r\n                                     * when this can happen is if there are two paths\r\n                                     *\r\n                                     * path1 = 1, 2, 3, 4, 5\r\n                                     * path2 = 1, 2, 4, 3, 5\r\n                                     *\r\n                                     * as we consume path1 we will need to consume 3. in order to\r\n                                     * consume 3, we must consume consume up to 3 in path2.\r\n                                     * in order to consume up to 3 in path2 we must consume 4.\r\n                                     * in order to consume 4, we must consume everything before\r\n                                     * 4 in path1. everything before 4 in path1 is 1, 2, 3.\r\n                                     * this means we need to consume 3 which brings us back up\r\n                                     * to the top of this paragraph creating an infinite loop.\r\n                                     *\r\n                                     * this check below will prevent infinite loops by only\r\n                                     * adding paths that have the tempNodeId come before the\r\n                                     * nodeId to stop consuming at.\r\n                                     */\r\n                                    if (tempNodeIdIndex < nodeIdIndex) {\r\n                                        pathsToConsume.push(pathThatContainsNodeId);\r\n                                    }\r\n                                }\r\n\r\n                                /*\r\n                                 * take the paths that contain the given node id and consume\r\n                                 * the paths until the given node id\r\n                                 */\r\n                                var tempConsumedNodeIds = this.consumePathsUntilNodeId(pathsToConsume, tempNodeId);\r\n\r\n                                // remove the node id from the paths that contain it\r\n                                this.removeNodeIdFromPaths(tempNodeId, pathsThatContainNodeId);\r\n\r\n                                // add the temp consumed node ids to our consumed node ids array\r\n                                consumedNodeIds = consumedNodeIds.concat(tempConsumedNodeIds);\r\n\r\n                                // move the counter back one since we have just removed a node id\r\n                                x--;\r\n\r\n                                // add the node id to the consumed node ids array\r\n                                consumedNodeIds.push(tempNodeId);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return consumedNodeIds;\r\n    };\r\n\r\n    /**\r\n     * Get the path at the given index and get the first node id in\r\n     * the path\r\n     * @param paths an array of paths. each path is an array of node ids\r\n     * @param index the index of the path we want\r\n     * @return the first node in the given path\r\n     */\r\n    getFirstNodeIdInPathAtIndex(paths, index) {\r\n        var nodeId = null;\r\n\r\n        if (paths != null && index != null) {\r\n            // get the path at the given index\r\n            var path = paths[index];\r\n\r\n            if (path != null && path.length > 0) {\r\n                // get the first node id in the path\r\n                nodeId = path[0];\r\n            }\r\n        }\r\n\r\n        return nodeId;\r\n    };\r\n\r\n    /**\r\n     * Remove the node ifrom the paths\r\n     * @param nodeId the node id to remove\r\n     * @param paths an array of paths. each path is an array of node ids\r\n     */\r\n    removeNodeIdFromPaths(nodeId, paths) {\r\n\r\n        if (nodeId != null && paths != null) {\r\n            // loop through all the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                // loop through all the node ids in the path\r\n                for (var x = 0; x < path.length; x++) {\r\n                    // get a node id\r\n                    var tempNodeId = path[x];\r\n\r\n                    /*\r\n                     * check if the node id matches the one we are looking\r\n                     * for\r\n                     */\r\n                    if (nodeId === tempNodeId) {\r\n                        /*\r\n                         * we have found the node id we are looking for so\r\n                         * we will remove it from the path\r\n                         */\r\n                        path.splice(x, 1);\r\n\r\n                        /*\r\n                         * move the counter back since we just removed a\r\n                         * node id. we will continue searching this path\r\n                         * for the node id in case the path contains it\r\n                         * multiple times.\r\n                         */\r\n                        x--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Remove the node id from the path\r\n     * @param nodeId the node id to remove\r\n     * @param paths an array of paths. each path is an array of node ids\r\n     * @param pathIndex the path to remove from\r\n     */\r\n    removeNodeIdFromPath(nodeId, paths, pathIndex) {\r\n\r\n        if (nodeId != null && paths != null && pathIndex != null) {\r\n\r\n            // get the path at the given index\r\n            var path = paths[pathIndex];\r\n\r\n            if (path != null) {\r\n\r\n                // loop through all the node ids in the path\r\n                for (var x = 0; x < path.length; x++) {\r\n                    // get a ndoe id\r\n                    var tempNodeId = path[x];\r\n\r\n                    /*\r\n                     * check if the node id matches the one we are looking\r\n                     * for\r\n                     */\r\n                    if (nodeId === tempNodeId) {\r\n                        /*\r\n                         * we have found the node id we are looking for so\r\n                         * we will remove it from the path\r\n                         */\r\n                        path.splice(x, 1);\r\n\r\n                        /*\r\n                         * move the counter back since we just removed a\r\n                         * node id. we will continue searching this path\r\n                         * for the node id in case the path contains it\r\n                         * multiple times.\r\n                         */\r\n                        x--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Check if the first node ids in the paths are the same\r\n     * @param paths an array of paths. each path is an array of node ids\r\n     * @return whether all the paths have the same first node id\r\n     */\r\n    areFirstNodeIdsInPathsTheSame(paths) {\r\n        var result = true;\r\n\r\n        var nodeId = null;\r\n\r\n        if (paths != null) {\r\n\r\n            // loop through all the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                // get the first node id in the path\r\n                var tempNodeId = path[0];\r\n\r\n                if (nodeId == null) {\r\n                    /*\r\n                     * this is the first path we have looked at so we will\r\n                     * remember the node id\r\n                     */\r\n                    nodeId = tempNodeId;\r\n                } else if (nodeId != tempNodeId) {\r\n                    /*\r\n                     * the node id does not match the first node id from a\r\n                     * previous path so the paths do not all have the same\r\n                     * first node id\r\n                     */\r\n                    result = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Check if all the paths are empty\r\n     * @param paths an array of paths. each path is an array of node ids\r\n     * @return whether all the paths are empty\r\n     */\r\n    arePathsEmpty(paths) {\r\n        var result = true;\r\n\r\n        if (paths != null) {\r\n\r\n            // loop through all the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                if (path != null) {\r\n\r\n                    // get the length of the path\r\n                    if (path.length !== 0) {\r\n                        // the path is not empty\r\n                        result = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Get the paths that contain the node id\r\n     * @param nodeId the node id we are looking for\r\n     * @param paths an array of paths. each path is an array of node ids\r\n     * @return an array of paths that contain the given node id\r\n     */\r\n    getPathsThatContainNodeId(nodeId, paths) {\r\n        var pathsThatContainNodeId = [];\r\n\r\n        if (nodeId != null && paths != null) {\r\n            // loop through all the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                // check if the path contains the node id\r\n                if (path.indexOf(nodeId) != -1) {\r\n                    /*\r\n                     * add the path to the array of paths that contain\r\n                     * the node id\r\n                     */\r\n                    pathsThatContainNodeId.push(path);\r\n                }\r\n            }\r\n        }\r\n\r\n        return pathsThatContainNodeId;\r\n    };\r\n\r\n    /**\r\n     * Get a non empty path index. It will loop through the paths and\r\n     * return the index of the first non empty path.\r\n     * @param paths an array of paths. each path is an array of node ids\r\n     * @return the index of the path that is not empty\r\n     */\r\n    getNonEmptyPathIndex(paths) {\r\n        var index = null;\r\n\r\n        if (paths != null) {\r\n            // loop through all the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                // check the length of the path\r\n                if (path.length !== 0) {\r\n                    // the path is not empty so we will return this index\r\n                    index = p;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return index;\r\n    };\r\n\r\n    /**\r\n     * Get the branches in the project\r\n     */\r\n    getBranches() {\r\n\r\n        // get the start node id\r\n        var startNodeId = this.getStartNodeId();\r\n\r\n        /*\r\n         * an array to keep track of the node ids in the path that\r\n         * we are currently on as we traverse the nodes in the project\r\n         * depth first\r\n         */\r\n        var pathsSoFar = [];\r\n\r\n        // get all the paths in the project\r\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\r\n\r\n        // find the branches in the project from the paths\r\n        var branches = this.findBranches(allPaths);\r\n\r\n        return branches;\r\n    };\r\n\r\n    /**\r\n     * Find the branches in the project\r\n     * @param paths all the possible paths through the project\r\n     * @return an array of branch objects. each branch object contains\r\n     * the branch start point, the branch paths, and the branch\r\n     * end point\r\n     */\r\n    findBranches(paths) {\r\n        var branches = [];\r\n\r\n        var previousNodeId = null;\r\n\r\n        /*\r\n         * continue until all the paths are empty. we will remove\r\n         * node ids from the paths as we traverse the paths to find\r\n         * the branches\r\n         */\r\n        while (!this.arePathsEmpty(paths)) {\r\n\r\n            // get the first node id in the first path\r\n            var nodeId = this.getFirstNodeIdInPathAtIndex(paths, 0);\r\n\r\n            if (this.areFirstNodeIdsInPathsTheSame(paths)) {\r\n                // the first node ids in all the paths are the same\r\n\r\n                // remove the node id from all the paths\r\n                this.removeNodeIdFromPaths(nodeId, paths);\r\n\r\n                // remember this node id for the next iteration of the loop\r\n                previousNodeId = nodeId;\r\n            } else {\r\n                // not all the top node ids are the same which means we have branched\r\n\r\n                // create a branch object\r\n                var branchMetaObject = this.createBranchMetaObject(previousNodeId);\r\n                branchMetaObject.branchStartPoint = previousNodeId;\r\n\r\n                // find the branch end point\r\n                var nextCommonNodeId = this.findNextCommonNodeId(paths);\r\n                branchMetaObject.branchEndPoint = nextCommonNodeId;\r\n\r\n                // get the branch paths\r\n                var branchPaths = this.extractPathsUpToNodeId(paths, nextCommonNodeId);\r\n                branchPaths = this.removeDuplicatePaths(branchPaths);\r\n                branchMetaObject.branchPaths = branchPaths;\r\n\r\n                // add the branch object to our array\r\n                branches.push(branchMetaObject);\r\n\r\n                // trim the paths so that they start at the branch end point\r\n                this.trimPathsUpToNodeId(paths, nextCommonNodeId);\r\n\r\n                // remember this node id for the next iteration of the loop\r\n                previousNodeId = nextCommonNodeId;\r\n            }\r\n        }\r\n\r\n        return branches;\r\n    };\r\n\r\n    /**\r\n     * Create a branch meta object that will contain the branch start\r\n     * point, branch paths, and branch end point\r\n     * @return an object that contains a branch start point, branch paths,\r\n     * and a branch end point\r\n     */\r\n    createBranchMetaObject() {\r\n        var branchMetaObject = {};\r\n\r\n        branchMetaObject.branchStartPoint = null;\r\n        branchMetaObject.branchPaths = [];\r\n        branchMetaObject.branchEndPoint = null;\r\n\r\n        return branchMetaObject;\r\n    };\r\n\r\n    /**\r\n     * Find the next common node id in all the paths\r\n     * @param paths the paths to find the common node id in\r\n     * @return a node id that is in all the paths or null\r\n     * if there is no node id that is in all the paths\r\n     */\r\n    findNextCommonNodeId(paths) {\r\n        var nextCommonNodeId = null;\r\n        var subPaths = [];\r\n\r\n        if (paths != null) {\r\n            if (paths.length > 0) {\r\n                // get the first path\r\n                var path = paths[0];\r\n\r\n                // loop through all the node ids in the first path\r\n                for (var x = 0; x < path.length; x++) {\r\n                    // get a node id\r\n                    var tempNodeId = path[x];\r\n\r\n                    // check if the node id is in all the paths\r\n                    if (this.allPathsContainNodeId(paths, tempNodeId)) {\r\n                        /*\r\n                         * the node id is in all the paths so we have found\r\n                         * what we were looking for\r\n                         */\r\n                        nextCommonNodeId = tempNodeId;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return nextCommonNodeId;\r\n    };\r\n\r\n    /**\r\n     * Check if all the paths contain the node id\r\n     * @param paths an array of paths. each path contains an array of node ids\r\n     * @param nodeId the node id that we will check is in all the paths\r\n     * @return whether the node id is in all the paths\r\n     */\r\n    allPathsContainNodeId(paths, nodeId) {\r\n        var result = false;\r\n\r\n        if (paths != null) {\r\n\r\n            // loop through all the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                // get the index of the node id in the path\r\n                var index = path.indexOf(nodeId);\r\n\r\n                if (index == -1) {\r\n                    // the node id is not in the path\r\n                    result = false;\r\n                    break;\r\n                } else {\r\n                    // the node id is in the path\r\n                    result = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Trim the paths up to the given node id so that the paths will contain\r\n     * the given node id and all the node ids after it. This function will\r\n     * modify the paths.\r\n     * @param paths the paths to trim\r\n     * @param nodeId the node id to trim up to\r\n     */\r\n    trimPathsUpToNodeId(paths, nodeId) {\r\n        if (paths != null) {\r\n            // loop through all the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                if (path != null) {\r\n                    // get the index of the node id in the path\r\n                    var index = path.indexOf(nodeId);\r\n\r\n                    if (index == -1) {\r\n                        /*\r\n                         * the node id is not in the path so we will\r\n                         * trim the path to the end which will make\r\n                         * the path empty\r\n                         */\r\n                        index = path.length;\r\n                    }\r\n\r\n                    /*\r\n                     * trim the path up to the node id index. this will\r\n                     * modify the path array.\r\n                     */\r\n                    path.splice(0, index);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n\r\n    /**\r\n     * Extract the paths up to a given node id. This will be used to\r\n     * obtain branch paths.\r\n     * @param paths the paths to extract from\r\n     * @param nodeId the node id to extract up to\r\n     * @return paths that go up to but do not include the node id\r\n     */\r\n    extractPathsUpToNodeId(paths, nodeId) {\r\n        var extractedPaths = [];\r\n\r\n        if (paths != null) {\r\n            // loop through the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                if (path != null) {\r\n\r\n                    // get the index of the node id in the path\r\n                    var index = path.indexOf(nodeId);\r\n\r\n                    if (index == -1) {\r\n                        /*\r\n                         * the node id is not in the path so we will\r\n                         * extract up to the end of the path\r\n                         */\r\n                        index = path.length;\r\n                    }\r\n\r\n                    /*\r\n                     * get the path up to the node id index. this does\r\n                     * not modify the path array.\r\n                     */\r\n                    var extractedPath = path.slice(0, index);\r\n\r\n                    // add the\r\n                    extractedPaths.push(extractedPath);\r\n                }\r\n            }\r\n        }\r\n\r\n        return extractedPaths;\r\n    };\r\n\r\n    /**\r\n     * Removes duplicate paths\r\n     * @param paths an array of paths. each path contains an array of node ids\r\n     * @return an array of unique paths\r\n     */\r\n    removeDuplicatePaths(paths) {\r\n        var uniquePaths = [];\r\n\r\n        if (paths != null) {\r\n            // loop through all the paths\r\n            for (var p = 0; p < paths.length; p++) {\r\n                // get a path\r\n                var path = paths[p];\r\n\r\n                var isPathInUniquePaths = false;\r\n\r\n                // loop through all the unique paths so far\r\n                for (var u = 0; u < uniquePaths.length; u++) {\r\n                    // get a unique path\r\n                    var uniquePath = uniquePaths[u];\r\n\r\n                    // check if the paths are equal\r\n                    if (this.pathsEqual(path, uniquePath)) {\r\n                        // the paths are equal\r\n                        isPathInUniquePaths = true;\r\n                    }\r\n                }\r\n\r\n                if (!isPathInUniquePaths) {\r\n                    // the path is not equal to any paths in the unique\r\n                    // paths array so we will add it to the unique paths array\r\n                    uniquePaths.push(path);\r\n                }\r\n            }\r\n        }\r\n\r\n        return uniquePaths;\r\n    };\r\n\r\n    /**\r\n     * Check if two paths are equal\r\n     * @param path1 an array of node ids\r\n     * @param path2 an array of node ids\r\n     * @return whether the two paths contain the same node ids\r\n     * in the same order\r\n     */\r\n    pathsEqual(path1, path2) {\r\n        var result = false;\r\n\r\n        if (path1 != null && path2 != null) {\r\n\r\n            // check if the paths are the same length\r\n            if (path1.length === path2.length) {\r\n                result = true;\r\n\r\n                // loop through each element of the first path\r\n                for (var x = 0; x < path1.length; x++) {\r\n                    // get the node id from the first path\r\n                    var path1NodeId = path1[x];\r\n\r\n                    // get the node id from the second path\r\n                    var path2NodeId = path2[x];\r\n\r\n                    // check if the node ids are the same\r\n                    if (path1NodeId !== path2NodeId) {\r\n                        // the node ids are not the same to the paths are not equal\r\n                        result = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Check if a node id is in any branch\r\n     * @param branches an array of branch objects\r\n     * @param nodeId the node id to check\r\n     * @return whether the node id is in any branch\r\n     */\r\n    isNodeIdInABranch(branches, nodeId) {\r\n\r\n        if (branches != null && nodeId != null) {\r\n\r\n            // loop through all the branch objects\r\n            for (var b = 0; b < branches.length; b++) {\r\n\r\n                // get a branch object\r\n                var branch = branches[b];\r\n\r\n                if (branch != null) {\r\n\r\n                    // get the branch paths for this branch object\r\n                    var branchPaths = branch.branchPaths;\r\n\r\n                    if (branchPaths != null) {\r\n\r\n                        // loop through all the branch paths\r\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\r\n\r\n                            // get a branch path\r\n                            var branchPath = branchPaths[bp];\r\n\r\n                            if (branchPath != null) {\r\n\r\n                                // check if the node id is in the branch path\r\n                                var index = branchPath.indexOf(nodeId);\r\n\r\n                                if (index != -1) {\r\n                                    // the node id is in this branch path\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Get the branch paths that a node id is in\r\n     * @param branches an array of branch objects\r\n     * @param nodeId the node id to check\r\n     * @return an array of the branch paths that the node id is in\r\n     */\r\n    getBranchPathsByNodeId(branches, nodeId) {\r\n        var branchPathsIn = [];\r\n\r\n        if (branches != null && nodeId != null) {\r\n\r\n            // loop through all the branches\r\n            for (var b = 0; b < branches.length; b++) {\r\n\r\n                // get a branch\r\n                var branch = branches[b];\r\n\r\n                if (branch != null) {\r\n\r\n                    // get the branch paths\r\n                    var branchPaths = branch.branchPaths;\r\n\r\n                    if (branchPaths != null) {\r\n\r\n                        // loop through all the branch paths\r\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\r\n\r\n                            // get a branch path\r\n                            var branchPath = branchPaths[bp];\r\n\r\n                            if (branchPath != null) {\r\n\r\n                                // get the index of the node id in the branch path\r\n                                var index = branchPath.indexOf(nodeId);\r\n\r\n                                if (index != -1) {\r\n                                    /*\r\n                                     * the node is in this branch path so we will\r\n                                     * add the branch path to our array\r\n                                     */\r\n                                    branchPathsIn.push(branchPath);\r\n\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return branchPathsIn;\r\n    }\r\n\r\n    /**\r\n     * Get the component by node id and component id\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     * @returns the component or null if the nodeId or componentId are null or does not exist in the project.\r\n     */\r\n    getComponentByNodeIdAndComponentId(nodeId, componentId) {\r\n        var component = null;\r\n\r\n        if (nodeId != null && componentId != null) {\r\n\r\n            var components = this.getComponentsByNodeId(nodeId);\r\n\r\n            // loop through all the components\r\n            for (var c = 0; c < components.length; c++) {\r\n                var tempComponent = components[c];\r\n\r\n                if (tempComponent != null) {\r\n                    var tempComponentId = tempComponent.id;\r\n\r\n                    if (componentId === tempComponentId) {\r\n                        // we have found the component we want\r\n                        component = tempComponent;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        return component;\r\n    };\r\n\r\n    /**\r\n     * Returns the position of the component in the node by node id and component id, 0-indexed.\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     * @returns the component's position or -1 if nodeId or componentId are null or doesn't exist in the project.\r\n     */\r\n    getComponentPositionByNodeIdAndComponentId(nodeId, componentId) {\r\n        var componentPosition = -1;\r\n\r\n        if (nodeId != null && componentId != null) {\r\n\r\n            var components = this.getComponentsByNodeId(nodeId);\r\n\r\n            // loop through all the components\r\n            for (var c = 0; c < components.length; c++) {\r\n                var tempComponent = components[c];\r\n\r\n                if (tempComponent != null) {\r\n                    var tempComponentId = tempComponent.id;\r\n\r\n                    if (componentId === tempComponentId) {\r\n                        // we have found the component we want\r\n                        componentPosition = c;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return componentPosition;\r\n    };\r\n\r\n    /**\r\n     * Get the components in a node\r\n     * @param nodeId the node id\r\n     * @returns an array of components or empty array if nodeId is null or doesn't exist in the project.\r\n     * if the node exists but doesn't have any components, returns an empty array.\r\n     */\r\n    getComponentsByNodeId(nodeId) {\r\n        var components = [];\r\n\r\n        if (nodeId != null) {\r\n\r\n            // get the node\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n\r\n                // get the components\r\n                if (node.components != null) {\r\n                    components = node.components;\r\n                }\r\n            }\r\n        }\r\n\r\n        return components;\r\n    };\r\n\r\n    getNodeContentByNodeId(nodeId) {\r\n        var nodeContent = null;\r\n\r\n        if (nodeId != null) {\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n                nodeContent = node;\r\n            }\r\n        }\r\n\r\n        return nodeContent;\r\n    };\r\n\r\n    /**\r\n     * Replace a component\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     * @param component the new component\r\n     */\r\n    replaceComponent(nodeId, componentId, component) {\r\n\r\n        if (nodeId != null && componentId != null && component != null) {\r\n\r\n            // get all the components for the node\r\n            var components = this.getComponentsByNodeId(nodeId);\r\n\r\n            if (components != null) {\r\n\r\n                // loop through all the components\r\n                for (var c = 0; c < components.length; c++) {\r\n                    var tempComponent = components[c];\r\n\r\n                    if (tempComponent != null) {\r\n\r\n                        if (tempComponent.id === componentId) {\r\n                            // the component id matches the one we want so we will replace it\r\n                            components[c] = component;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Create a new group\r\n     * @param title the title of the group\r\n     * @returns the group object\r\n     */\r\n    createGroup(title) {\r\n\r\n        // get the next available group id\r\n        var newGroupId = this.getNextAvailableGroupId();\r\n\r\n        // create the group object\r\n        var newGroup = {};\r\n        newGroup.id = newGroupId;\r\n        newGroup.type = 'group';\r\n        newGroup.title = title;\r\n        newGroup.startId = '';\r\n        newGroup.ids = [];\r\n\r\n        return newGroup;\r\n    };\r\n\r\n    /**\r\n     * Create a new node\r\n     * @param title the title of the node\r\n     * @returns the node object\r\n     */\r\n    createNode(title) {\r\n\r\n        // get the next available node id\r\n        var newNodeId = this.getNextAvailableNodeId();\r\n\r\n        // create the node object\r\n        var newNode = {};\r\n        newNode.id = newNodeId;\r\n        newNode.title = title;\r\n        newNode.type = 'node';\r\n        newNode.constraints = [];\r\n        newNode.transitionLogic = {};\r\n        newNode.transitionLogic.transitions = [];\r\n\r\n        newNode.showSaveButton = false;\r\n        newNode.showSubmitButton = false;\r\n        newNode.components = [];\r\n\r\n        return newNode;\r\n    };\r\n\r\n    /**\r\n     * Create a node inside the group\r\n     * @param node the new node\r\n     * @param nodeId the node id of the group to create the node in\r\n     */\r\n    createNodeInside(node, nodeId) {\r\n\r\n        if (nodeId == 'inactiveNodes') {\r\n            // add the node to the inactive nodes\r\n\r\n            // add the node to the inactive nodes\r\n            this.addInactiveNode(node);\r\n\r\n            // add the node to our mapping of node id to node\r\n            this.setIdToNode(node.id, node);\r\n            this.setIdToElement(node.id, node);\r\n        } else {\r\n            // add the node to the active nodes\r\n\r\n            // add the node to the project\r\n            this.addNode(node);\r\n\r\n            // add the node to our mapping of node id to node\r\n            this.setIdToNode(node.id, node);\r\n\r\n            // create the transitions for the node\r\n            this.insertNodeInsideInTransitions(node.id, nodeId);\r\n\r\n            // add the node to the group\r\n            this.insertNodeInsideInGroups(node.id, nodeId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a node after the given node id\r\n     * @param node the new node\r\n     * @param nodeId the node to add after\r\n     */\r\n    createNodeAfter(node, nodeId) {\r\n\r\n        if (this.isInactive(nodeId)) {\r\n            // we are adding the node after a node that is inactive\r\n\r\n            // add the node to the inactive nodes\r\n            this.addInactiveNode(node, nodeId);\r\n\r\n            this.setIdToNode(node.id, node);\r\n            this.setIdToElement(node.id, node);\r\n        } else {\r\n            // we are adding the node after a node that is active\r\n\r\n            // add the node to the project\r\n            this.addNode(node);\r\n\r\n            // add the node to our mapping of node id to node\r\n            this.setIdToNode(node.id, node);\r\n\r\n            // insert the new node id into the array of children ids\r\n            this.insertNodeAfterInGroups(node.id, nodeId);\r\n\r\n            // create the transition to the node\r\n            this.insertNodeAfterInTransitions(node, nodeId);\r\n        }\r\n\r\n        if (this.isGroupNode(node.id)) {\r\n            /*\r\n             * we are creating a group node so we will update/create the\r\n             * transitions that traverse from the previous group to this group\r\n             */\r\n\r\n            var oldToGroupIds = [];\r\n\r\n            // get the transitions that come out of the previous group\r\n            var transitionsFromGroup = this.getTransitionsByFromNodeId(nodeId);\r\n\r\n            if (transitionsFromGroup != null) {\r\n\r\n                /*\r\n                 * loop through all the transitions that come out of the previous group\r\n                 * and get the node ids that the group transitions to\r\n                 */\r\n                for (var t = 0; t < transitionsFromGroup.length; t++) {\r\n                    var transitionFromGroup = transitionsFromGroup[t];\r\n\r\n                    if (transitionFromGroup != null) {\r\n                        var toNodeId = transitionFromGroup.to;\r\n\r\n                        if (toNodeId != null) {\r\n                            oldToGroupIds.push(toNodeId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            var fromGroupId = nodeId;\r\n            var oldToGroupIds = oldToGroupIds;\r\n            var newToGroupId = node.id;\r\n\r\n            /*\r\n             * make the transitions point to the new group and make the new\r\n             * group transition to the old group\r\n             */\r\n            this.updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert the node after the given node id in the group's\r\n     * array of children ids\r\n     * @param nodeIdToInsert the node id we want to insert\r\n     * @param nodeIdToInsertAfter the node id we want to insert after\r\n     */\r\n    insertNodeAfterInGroups(nodeIdToInsert, nodeIdToInsertAfter) {\r\n        var groupNodes = this.getGroupNodes();\r\n\r\n        if (groupNodes != null) {\r\n\r\n            // loop through the groups\r\n            for (var g = 0; g < groupNodes.length; g++) {\r\n                var group = groupNodes[g];\r\n\r\n                if (group != null) {\r\n                    var ids = group.ids;\r\n\r\n                    if (ids != null) {\r\n\r\n                        // loop through the children ids\r\n                        for (var i = 0; i < ids.length; i++) {\r\n                            var id = ids[i];\r\n\r\n                            if (nodeIdToInsertAfter === id) {\r\n                                // we have found the node id we want to insert after\r\n\r\n                                // insert the new node id\r\n                                ids.splice(i + 1, 0, nodeIdToInsert);\r\n                                return;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the transitions to handle inserting a node after another node\r\n     * @param node the node to insert\r\n     * @param nodeId the node id to insert after\r\n     */\r\n    insertNodeAfterInTransitions(node, nodeId) {\r\n\r\n        // get the node that will end up before\r\n        var previousNode = this.getNodeById(nodeId);\r\n\r\n        if (previousNode != null) {\r\n\r\n            if (previousNode.transitionLogic == null) {\r\n                previousNode.transitionLogic = {};\r\n                previousNode.transitionLogic.transitions = [];\r\n            }\r\n\r\n            if (node.transitionLogic == null) {\r\n                node.transitionLogic = {};\r\n            }\r\n\r\n            if (node.transitionLogic.transitions == null) {\r\n                node.transitionLogic.transitions = [];\r\n            }\r\n\r\n            if (this.isGroupNode(node.id)) {\r\n                /*\r\n                 * the node we are inserting is a group so we will update\r\n                 * the transitions of its children so that they transition\r\n                 * to the correct node\r\n                 */\r\n                this.updateChildrenTransitionsForMovingGroup(node, nodeId);\r\n            }\r\n\r\n            var previousNodeTransitionLogic = previousNode.transitionLogic;\r\n\r\n            if (previousNodeTransitionLogic != null) {\r\n\r\n                // get the transitions from the before node\r\n                var transitions = previousNodeTransitionLogic.transitions;\r\n\r\n                if (transitions != null) {\r\n\r\n                    // make a copy of the transitions\r\n                    var transitionsJSONString = angular.toJson(transitions);\r\n                    var transitionsCopy = angular.fromJson(transitionsJSONString);\r\n\r\n                    // set the transitions from the before node into the inserted node\r\n                    node.transitionLogic.transitions = transitionsCopy;\r\n                }\r\n            }\r\n\r\n            if (node.transitionLogic.transitions.length == 0) {\r\n                /*\r\n                 * The node does not have any transitions so we will look for\r\n                 * a transition on the parent group. If the parent has a\r\n                 * transition we will use it for the node.\r\n                 */\r\n\r\n                // get the parent group\r\n                var parentGroupId = this.getParentGroupId(nodeId);\r\n\r\n                // get the parent transitions\r\n                var parentTransitions = this.getTransitionsByFromNodeId(parentGroupId);\r\n\r\n                if (parentTransitions != null) {\r\n\r\n                    // loop through all the parent transitions\r\n                    for (var p = 0; p < parentTransitions.length; p++) {\r\n                        var parentTransition = parentTransitions[p];\r\n\r\n                        var newTransition = {};\r\n\r\n                        if (parentTransition != null) {\r\n                            var toNodeId = parentTransition.to;\r\n\r\n                            if (this.isGroupNode(toNodeId)) {\r\n                                // the transition is to a group\r\n\r\n                                // get the start id of the group\r\n                                var startId = this.getGroupStartId(toNodeId);\r\n\r\n                                if (startId == null || startId == '') {\r\n                                    // there is no start id so we will just use the group id\r\n                                    newTransition.to = toNodeId;\r\n                                } else {\r\n                                    // there is a start id so we will use it as the to node\r\n                                    newTransition.to = startId;\r\n                                }\r\n                            } else {\r\n                                // the tranisition is to a step\r\n                                newTransition.to = toNodeId;\r\n                            }\r\n                        }\r\n\r\n                        // add the new transition to the node\r\n                        node.transitionLogic.transitions.push(newTransition);\r\n                    }\r\n                }\r\n            }\r\n\r\n            var newNodeId = node.id;\r\n\r\n            // TODO handle branching case\r\n\r\n            // remove the transitions from the before node\r\n            previousNode.transitionLogic.transitions = [];\r\n\r\n            var transitionObject = {};\r\n            transitionObject.to = newNodeId;\r\n\r\n            // make the before node point to the new node\r\n            previousNode.transitionLogic.transitions.push(transitionObject);\r\n\r\n            // remove the branch path taken constraints from the node we are moving\r\n            this.removeBranchPathTakenNodeConstraints(node.id);\r\n\r\n            // get the branch path taken constraints from the previous node\r\n            var branchPathTakenConstraints = this.getBranchPathTakenConstraintsByNodeId(nodeId);\r\n\r\n            /*\r\n             * if the previous node was in a branch path, we will also put the\r\n             * inserted node into the branch path\r\n             */\r\n            if (branchPathTakenConstraints != null && branchPathTakenConstraints.length > 0) {\r\n\r\n                if (node.constraints == null) {\r\n                    node.constraints = [];\r\n                }\r\n\r\n                // loop through all the branch path taken constraints\r\n                for (var c = 0; c < branchPathTakenConstraints.length; c++) {\r\n\r\n                    // get a branch path taken constraint\r\n                    var branchPathTakenConstraint = branchPathTakenConstraints[c];\r\n\r\n                    if (branchPathTakenConstraint != null) {\r\n\r\n                        // create a new constraint with the same branch path taken parameters\r\n                        var newConstraint = {};\r\n                        newConstraint.id = this.getNextAvailableConstraintIdForNodeId(node.id);\r\n                        newConstraint.action = branchPathTakenConstraint.action;\r\n                        newConstraint.targetId = node.id;\r\n                        newConstraint.removalCriteria = this.UtilService.makeCopyOfJSONObject(branchPathTakenConstraint.removalCriteria);\r\n\r\n                        // add the constraint to the node\r\n                        node.constraints.push(newConstraint);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert a node into a group\r\n     * @param nodeIdToInsert the node id to insert\r\n     * @param nodeIdToInsertInside the node id of the group we will insert into\r\n     */\r\n    insertNodeInsideInGroups(nodeIdToInsert, nodeIdToInsertInside) {\r\n\r\n        // get the group we will insert into\r\n        var group = this.getNodeById(nodeIdToInsertInside);\r\n\r\n        if (group != null) {\r\n            var ids = group.ids;\r\n\r\n            if (ids != null) {\r\n\r\n                // insert the node node id into the beginning of the child ids\r\n                ids.splice(0, 0, nodeIdToInsert);\r\n\r\n                // set the inserted node id as the start id\r\n                group.startId = nodeIdToInsert;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the transitions to handle inserting a node into a group\r\n     * @param nodeIdToInsert node id that we will insert\r\n     * @param nodeIdToInsertInside the node id of the group we are inserting into\r\n     */\r\n    insertNodeInsideInTransitions(nodeIdToInsert, nodeIdToInsertInside) {\r\n\r\n        // get the node we are inserting\r\n        var nodeToInsert = this.getNodeById(nodeIdToInsert);\r\n\r\n        // get the group we are inserting into\r\n        var group = this.getNodeById(nodeIdToInsertInside);\r\n\r\n        if (this.isGroupNode(nodeIdToInsert)) {\r\n            /*\r\n             * the node we are inserting is a group so we will update\r\n             * the transitions of its children so that they transition\r\n             * to the correct node\r\n             */\r\n            this.updateChildrenTransitionsForMovingGroup(nodeToInsert, null);\r\n        }\r\n\r\n        /*\r\n         * since we are inserting a node into a group, the node will become\r\n         * the first node in the group. this means we need to update any nodes\r\n         * that point to the old start id and make them point to the node\r\n         * we are inserting.\r\n         */\r\n        if (nodeToInsert != null && group != null) {\r\n\r\n            // get the start node\r\n            var startId = group.startId;\r\n\r\n            // get transitions that point to the start node\r\n            var previousNodes = this.getNodesByToNodeId(startId);\r\n\r\n            if (previousNodes == null || previousNodes.length == 0) {\r\n                // there are no transitions to the start node\r\n\r\n                // find all the groups that point to this group\r\n                var previousGroups = this.getGroupNodesByToNodeId(nodeIdToInsertInside);\r\n\r\n                // loop through all the groups that point to this group\r\n                for (var g = 0; g < previousGroups.length; g++) {\r\n                    var previousGroup = previousGroups[g];\r\n\r\n                    if (previousGroup != null) {\r\n                        // get the nodes that do not have a transition in the previous group\r\n                        var lastNodesInGroup = this.getLastNodesInGroup(previousGroup.id);\r\n\r\n                        for (var n = 0; n < lastNodesInGroup.length; n++) {\r\n                            // get a node that does not have a transition\r\n                            var node = lastNodesInGroup[n];\r\n\r\n                            // add a transition from the node to the node we are inserting\r\n                            this.addToTransition(node, nodeIdToInsert);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // there are transitions to the start node\r\n\r\n                for (var p = 0; p < previousNodes.length; p++) {\r\n                    var previousNode = previousNodes[p];\r\n\r\n                    if (previousNode != null) {\r\n                        // change the transition to point to the node we are inserting\r\n                        this.updateToTransition(previousNode, startId, nodeIdToInsert);\r\n                    }\r\n                }\r\n            }\r\n\r\n            /*\r\n             * update all the transitions that point to the group and change\r\n             * them to point to the new start id\r\n             */\r\n            var nodesThatTransitionToGroup = this.getNodesByToNodeId(nodeIdToInsertInside);\r\n\r\n            if (nodesThatTransitionToGroup != null) {\r\n                for (var n = 0; n < nodesThatTransitionToGroup.length; n++) {\r\n                    var nodeThatTransitionsToGroup = nodesThatTransitionToGroup[n];\r\n\r\n                    if (!this.isGroupNode(nodeThatTransitionsToGroup.id)) {\r\n                        this.updateToTransition(nodeThatTransitionsToGroup, nodeIdToInsertInside, nodeIdToInsert);\r\n                    }\r\n                }\r\n            }\r\n\r\n            /*\r\n             * create a transition from the node we are inserting to the node that\r\n             * was previously the start node\r\n             */\r\n            if (startId != null && startId != '') {\r\n                // there is a start id\r\n\r\n                var startNode = this.getNodeById(startId);\r\n\r\n                if (startNode != null) {\r\n                    // the group has a start node which will become the transition to node\r\n\r\n                    if (nodeToInsert.transitionLogic == null) {\r\n                        nodeToInsert.transitionLogic = {};\r\n                    }\r\n\r\n                    if (nodeToInsert.transitionLogic.transitions == null) {\r\n                        nodeToInsert.transitionLogic.transitions = [];\r\n                    }\r\n\r\n                    /*\r\n                     * make the inserted node transition to the previous start node\r\n                     */\r\n                    var transitionObject = {};\r\n                    transitionObject.to = startId;\r\n                    nodeToInsert.transitionLogic.transitions.push(transitionObject);\r\n                }\r\n            }\r\n\r\n            //check if the node we inserted has any transitions now\r\n            var transitions = this.getTransitionsByFromNodeId(nodeIdToInsert);\r\n\r\n            if (transitions == null || transitions.length == 0) {\r\n                /*\r\n                 * the node doesn't have any transitions so we will see if\r\n                 * the parent group transitions to anything and use that\r\n                 * transition\r\n                 */\r\n\r\n                // get the transitions from the parent\r\n                var parentTransitions = this.getTransitionsByFromNodeId(nodeIdToInsertInside);\r\n\r\n                if (parentTransitions != null) {\r\n\r\n                    // loop through all the parent transitions\r\n                    for (var t = 0; t < parentTransitions.length; t++) {\r\n                        var parentTransition = parentTransitions[t];\r\n\r\n                        if (parentTransition != null) {\r\n                            var toNodeId = parentTransition.to;\r\n\r\n                            if (this.isGroupNode(toNodeId)) {\r\n                                // the to node is a group\r\n\r\n                                // get the to group\r\n                                var nextGroup = this.getNodeById(toNodeId);\r\n\r\n                                if (nextGroup != null) {\r\n\r\n                                    // get the start id of the to group\r\n                                    var startId = nextGroup.startId;\r\n\r\n                                    if (startId == null || startId == '') {\r\n                                        // there is no start id so we will just transition to the group\r\n                                        this.addToTransition(nodeToInsert, toNodeId);\r\n                                    } else {\r\n                                        // there is a start id so we will transition to that\r\n                                        this.addToTransition(nodeToInsert, startId);\r\n                                    }\r\n                                }\r\n                            } else {\r\n                                // the to node is not a group\r\n\r\n                                /*\r\n                                 * we will add a transition from the node we are inserting to\r\n                                 * to that node\r\n                                 */\r\n                                this.addToTransition(nodeToInsert, toNodeId);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a transition to a node\r\n     * @param node the node we are adding a transition to\r\n     * @param toNodeId the node id we going to transition to\r\n     * @param criteria (optional) a criteria object specifying\r\n     * what needs to be satisfied in order to use this transition\r\n     */\r\n    addToTransition(node, toNodeId, criteria) {\r\n        if (node != null) {\r\n            if (node.transitionLogic == null) {\r\n                node.transitionLogic = {};\r\n            }\r\n\r\n            if (node.transitionLogic.transitions == null) {\r\n                node.transitionLogic.transitions = [];\r\n            }\r\n\r\n            var transition = {};\r\n\r\n            // set the to node id\r\n            transition.to = toNodeId;\r\n\r\n            if (criteria != null) {\r\n                // set the criteria\r\n                transition.criteria = criteria;\r\n            }\r\n\r\n            // add the transition to the node's transitions\r\n            node.transitionLogic.transitions.push(transition);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the to value of aa transition\r\n     * @param node the node to update\r\n     * @param oldToNodeId the previous to node id\r\n     * @param newToNodeId the new to node id\r\n     */\r\n    updateToTransition(node, oldToNodeId, newToNodeId) {\r\n        if (node != null) {\r\n            if (node.transitionLogic == null) {\r\n                node.transitionLogic = {};\r\n            }\r\n\r\n            if (node.transitionLogic.transitions == null) {\r\n                node.transitionLogic.transitions = [];\r\n            }\r\n\r\n            var transitions = node.transitionLogic.transitions;\r\n\r\n            // loop through all the transitions\r\n            for (var t = 0; t < transitions.length; t++) {\r\n                var transition = transitions[t];\r\n\r\n                if (transition != null) {\r\n                    var toNodeId = transition.to;\r\n\r\n                    if (oldToNodeId === toNodeId) {\r\n                        // we have found the transition we want to update\r\n\r\n                        // update the to node id\r\n                        transition.to = newToNodeId;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the nodes in a group that do not have transitions\r\n     * @param groupId the group id\r\n     * @returns the nodes in the group that do not have transitions\r\n     */\r\n    getLastNodesInGroup(groupId) {\r\n        var lastNodes = [];\r\n\r\n        if (groupId != null) {\r\n            var group = this.getNodeById(groupId);\r\n\r\n            if (group != null) {\r\n                var childIds = group.ids;\r\n\r\n                if (childIds != null) {\r\n\r\n                    // loop through all the child ids\r\n                    for (var c = 0; c < childIds.length; c++) {\r\n                        var childId = childIds[c];\r\n\r\n                        if (childId != null) {\r\n                            var child = this.getNodeById(childId);\r\n\r\n                            if (child != null) {\r\n                                var transitionLogic = child.transitionLogic;\r\n\r\n                                if (transitionLogic != null) {\r\n\r\n                                    // get the transitions\r\n                                    var transitions = transitionLogic.transitions;\r\n\r\n                                    if (transitions == null || transitions.length == 0) {\r\n                                        // this child does not have any transitions\r\n                                        lastNodes.push(child);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return lastNodes;\r\n    }\r\n\r\n    /**\r\n     * Get the next available group id\r\n     * @returns the next available group id\r\n     */\r\n    getNextAvailableGroupId() {\r\n\r\n        // get all the group ids\r\n        var groupIds = this.getGroupIds();\r\n\r\n        var largestGroupIdNumber = null;\r\n\r\n        // loop through all the existing group ids\r\n        for (var g = 0; g < groupIds.length; g++) {\r\n            var groupId = groupIds[g];\r\n\r\n            // get the number from the group id e.g. the number of 'group2' would be 2\r\n            var groupIdNumber = groupId.replace('group', '');\r\n\r\n            // make sure the number is an actual number\r\n            if (!isNaN(groupIdNumber)) {\r\n\r\n                groupIdNumber = parseInt(groupIdNumber);\r\n\r\n                // update the largest group id number if necessary\r\n                if (largestGroupIdNumber == null) {\r\n                    largestGroupIdNumber = groupIdNumber;\r\n                } else if (groupIdNumber > largestGroupIdNumber) {\r\n                    largestGroupIdNumber = groupIdNumber;\r\n                }\r\n            }\r\n        }\r\n\r\n        // create the next available group id\r\n        var nextAvailableGroupId = 'group' + (largestGroupIdNumber + 1);\r\n\r\n        return nextAvailableGroupId;\r\n    }\r\n\r\n    /**\r\n     * Get all the group ids\r\n     * @returns an array with all the group ids\r\n     */\r\n    getGroupIds() {\r\n\r\n        var groupIds = [];\r\n\r\n        var groupNodes = this.groupNodes;\r\n\r\n        // loop through all the group nodes\r\n        for (var g = 0; g < groupNodes.length; g++) {\r\n            var group = groupNodes[g];\r\n\r\n            if (group != null) {\r\n                var groupId = group.id;\r\n\r\n                if (groupId != null) {\r\n                    // add the group id\r\n                    groupIds.push(groupId);\r\n                }\r\n            }\r\n        }\r\n\r\n        return groupIds;\r\n    }\r\n\r\n    /**\r\n     * Get the next available node id\r\n     * @returns the next available node id\r\n     */\r\n    getNextAvailableNodeId() {\r\n\r\n        // get all the node ids\r\n        var nodeIds = this.getNodeIds();\r\n\r\n        var largestNodeIdNumber = null;\r\n\r\n        // loop through all the existing node ids\r\n        for (var n = 0; n < nodeIds.length; n++) {\r\n            var nodeId = nodeIds[n];\r\n\r\n            // get the number from the node id e.g. the number of 'node2' would be 2\r\n            var nodeIdNumber = nodeId.replace('node', '');\r\n\r\n            // make sure the number is an actual number\r\n            if (!isNaN(nodeIdNumber)) {\r\n                nodeIdNumber = parseInt(nodeIdNumber);\r\n\r\n                // update the largest node id number if necessary\r\n                if (largestNodeIdNumber == null) {\r\n                    largestNodeIdNumber = nodeIdNumber;\r\n                } else if (nodeIdNumber > largestNodeIdNumber) {\r\n                    largestNodeIdNumber = nodeIdNumber;\r\n                }\r\n            }\r\n        }\r\n\r\n        // get all the inactive node ids\r\n        var inactiveNodeIds = this.getInactiveNodeIds();\r\n\r\n        for (var i = 0; i < inactiveNodeIds.length; i++) {\r\n            var inactiveNodeId = inactiveNodeIds[i];\r\n\r\n            // get the number from the node id e.g. the number of 'node2' would be 2\r\n            var nodeIdNumber = inactiveNodeId.replace('node', '');\r\n\r\n            // make sure the number is an actual number\r\n            if (!isNaN(nodeIdNumber)) {\r\n                nodeIdNumber = parseInt(nodeIdNumber);\r\n\r\n                // update the largest node id number if necessary\r\n                if (largestNodeIdNumber == null) {\r\n                    largestNodeIdNumber = nodeIdNumber;\r\n                } else if (nodeIdNumber > largestNodeIdNumber) {\r\n                    largestNodeIdNumber = nodeIdNumber;\r\n                }\r\n            }\r\n        }\r\n\r\n        // create the next available node id\r\n        var nextAvailableNodeId = 'node' + (largestNodeIdNumber + 1);\r\n\r\n        return nextAvailableNodeId;\r\n    }\r\n\r\n    /**\r\n     * Get all the node ids from steps (not groups)\r\n     * @returns an array with all the node ids\r\n     */\r\n    getNodeIds() {\r\n\r\n        var nodeIds = [];\r\n\r\n        var nodes = this.applicationNodes;\r\n\r\n        // loop through all the nodes\r\n        for (var n = 0; n < nodes.length; n++) {\r\n            var node = nodes[n];\r\n\r\n            if (node != null) {\r\n                var nodeId = node.id;\r\n\r\n                if (nodeId != null) {\r\n                    nodeIds.push(nodeId);\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodeIds;\r\n    }\r\n\r\n    /**\r\n     * Get all the node ids from inactive steps\r\n     * @returns an array with all the inactive node ids\r\n     */\r\n    getInactiveNodeIds() {\r\n\r\n        var nodeIds = [];\r\n\r\n        var inactiveNodes = this.project.inactiveNodes;\r\n\r\n        if (inactiveNodes != null) {\r\n\r\n            // loop through all the inactive nodes\r\n            for (var n = 0; n < inactiveNodes.length; n++) {\r\n                var inactiveNode = inactiveNodes[n];\r\n\r\n                if (inactiveNode != null) {\r\n                    var nodeId = inactiveNode.id;\r\n\r\n                    if (nodeId != null) {\r\n                        nodeIds.push(nodeId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodeIds;\r\n    }\r\n\r\n    /**\r\n     * Move nodes inside a group node\r\n     * @param nodeIds the node ids to move\r\n     * @param nodeId the node id of the group we are moving the nodes inside\r\n     */\r\n    moveNodesInside(nodeIds, nodeId) {\r\n\r\n        // loop through all the nodes we are moving\r\n        for (var n = 0; n < nodeIds.length; n++) {\r\n\r\n            // get the node we are moving\r\n            var tempNodeId = nodeIds[n];\r\n            var tempNode = this.getNodeById(tempNodeId);\r\n\r\n            var movingNodeIsActive = this.isActive(tempNodeId);\r\n            var stationaryNodeIsActive = this.isActive(nodeId);\r\n\r\n            if (movingNodeIsActive && stationaryNodeIsActive) {\r\n                // we are moving from active to active\r\n\r\n                // remove the transitions\r\n                this.removeNodeIdFromTransitions(tempNodeId);\r\n\r\n                // remove the node from the group\r\n                this.removeNodeIdFromGroups(tempNodeId);\r\n\r\n                if (n == 0) {\r\n                    /*\r\n                     * this is the first node we are moving so we will insert it\r\n                     * into the beginning of the group\r\n                     */\r\n                    this.insertNodeInsideInTransitions(tempNodeId, nodeId);\r\n                    this.insertNodeInsideInGroups(tempNodeId, nodeId);\r\n                } else {\r\n                    /*\r\n                     * this is not the first node we are moving so we will insert\r\n                     * it after the node we previously inserted\r\n                     */\r\n                    this.insertNodeAfterInTransitions(tempNode, nodeId);\r\n                    this.insertNodeAfterInGroups(tempNodeId, nodeId);\r\n                }\r\n            } else if (movingNodeIsActive && !stationaryNodeIsActive) {\r\n                // we are moving from active to inactive\r\n\r\n                // remove the transitions\r\n                this.removeNodeIdFromTransitions(tempNodeId);\r\n\r\n                // remove the node from the group\r\n                this.removeNodeIdFromGroups(tempNodeId);\r\n\r\n                // move the node to the inactive array\r\n                this.moveToInactive(tempNode, nodeId);\r\n            } else if (!movingNodeIsActive && stationaryNodeIsActive) {\r\n                // we are moving from inactive to active\r\n\r\n                this.moveToActive(tempNode);\r\n\r\n                if (n == 0) {\r\n                    /*\r\n                     * this is the first node we are moving so we will insert it\r\n                     * into the beginning of the group\r\n                     */\r\n                    this.insertNodeInsideInTransitions(tempNodeId, nodeId);\r\n                    this.insertNodeInsideInGroups(tempNodeId, nodeId);\r\n                } else {\r\n                    /*\r\n                     * this is not the first node we are moving so we will insert\r\n                     * it after the node we previously inserted\r\n                     */\r\n                    this.insertNodeAfterInTransitions(tempNode, nodeId);\r\n                    this.insertNodeAfterInGroups(tempNodeId, nodeId);\r\n                }\r\n            } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\r\n                // we are moving from inactive to inactive\r\n\r\n                // move the node within the inactive nodes\r\n                this.moveInactiveNode(tempNode, nodeId);\r\n            }\r\n\r\n            /*\r\n             * remember the node id so we can put the next node (if any)\r\n             * after this one\r\n             */\r\n            nodeId = tempNode.id;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move nodes after a certain node id\r\n     * @param nodeIds the node ids to move\r\n     * @param nodeId the node id we will put the moved nodes after\r\n     */\r\n    moveNodesAfter(nodeIds, nodeId) {\r\n\r\n        // loop through all the nodes we are moving\r\n        for (var n = 0; n < nodeIds.length; n++) {\r\n\r\n            // get the node we are moving\r\n            var tempNodeId = nodeIds[n];\r\n            var node = this.getNodeById(tempNodeId);\r\n\r\n            var movingNodeIsActive = this.isActive(tempNodeId);\r\n            var stationaryNodeIsActive = this.isActive(nodeId);\r\n\r\n            if (movingNodeIsActive && stationaryNodeIsActive) {\r\n                // we are moving from active to active\r\n\r\n                // remove the transitions\r\n                this.removeNodeIdFromTransitions(tempNodeId);\r\n\r\n                // remove the node from the groups\r\n                this.removeNodeIdFromGroups(tempNodeId);\r\n\r\n                // insert the node into the parent group\r\n                this.insertNodeAfterInGroups(tempNodeId, nodeId);\r\n\r\n                // create the transition\r\n                this.insertNodeAfterInTransitions(node, nodeId);\r\n            } else if (movingNodeIsActive && !stationaryNodeIsActive) {\r\n                // we are moving from active to inactive\r\n\r\n                // remove the transitions\r\n                this.removeNodeIdFromTransitions(tempNodeId);\r\n\r\n                // remove the node from the groups\r\n                this.removeNodeIdFromGroups(tempNodeId);\r\n\r\n                // move the node to the inactive array\r\n                this.moveToInactive(node, nodeId);\r\n            } else if (!movingNodeIsActive && stationaryNodeIsActive) {\r\n                // we are moving from inactive to active\r\n\r\n                // move the node to the active nodes array\r\n                this.moveToActive(node);\r\n\r\n                // insert the node into the parent group\r\n                this.insertNodeAfterInGroups(tempNodeId, nodeId);\r\n\r\n                // create the transition\r\n                this.insertNodeAfterInTransitions(node, nodeId);\r\n            } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\r\n                // we are moving from inactive to inactive\r\n\r\n                // move the node within the inactive nodes\r\n                this.moveInactiveNode(node, nodeId);\r\n            }\r\n\r\n            // remember the node id so we can put the next node (if any) after this one\r\n            nodeId = node.id;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copy nodes and put them after a certain node id\r\n     * @param nodeIds the node ids to copy\r\n     * @param nodeId the node id we will put the copied nodes after\r\n     */\r\n    copyNodesInside(nodeIds, nodeId) {\r\n        // loop through all the nodes we are copying\r\n        for (var n = 0; n < nodeIds.length; n++) {\r\n\r\n            // get the node we are copying\r\n            var nodeIdToCopy = nodeIds[n];\r\n\r\n            // create a copy of the node\r\n            var newNode = this.copyNode(nodeIdToCopy);\r\n            var newNodeId = newNode.id;\r\n\r\n            if (n == 0) {\r\n                // this is the first node we are copying so we will insert it\r\n                // into the beginning of the group\r\n                this.createNodeInside(newNode, nodeId);\r\n            } else {\r\n                // this is not the first node we are copying so we will insert\r\n                // it after the node we previously inserted\r\n                this.createNodeAfter(newNode, nodeId);\r\n            }\r\n\r\n            // remember the node id so we can put the next node (if any) after this one\r\n            nodeId = newNodeId;\r\n            this.parseProject();  // refresh project and update references because a new node have been added.\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copy nodes and put them after a certain node id\r\n     * @param nodeIds the node ids to copy\r\n     * @param nodeId the node id we will put the copied nodes after\r\n     */\r\n    copyNodesAfter(nodeIds, nodeId) {\r\n        // loop through all the nodes we are copying\r\n        for (var n = 0; n < nodeIds.length; n++) {\r\n\r\n            // get the node we are copying\r\n            var nodeIdToCopy = nodeIds[n];\r\n\r\n            // create a copy of the node\r\n            var newNode = this.copyNode(nodeIdToCopy);\r\n            var newNodeId = newNode.id;\r\n\r\n            this.createNodeAfter(newNode, nodeId);\r\n\r\n            // remember the node id so we can put the next node (if any) after this one\r\n            nodeId = newNodeId;\r\n            this.parseProject();  // refresh project and update references because a new node have been added.\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Copy the node with the specified nodeId\r\n     * @param nodeId the node id to copy\r\n     * @return copied node\r\n     */\r\n    copyNode(nodeId) {\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        var nodeCopy = JSON.parse(JSON.stringify(node));\r\n        nodeCopy.id = this.getNextAvailableNodeId();\r\n        nodeCopy.transitionLogic = {};  // clear transition logic\r\n        nodeCopy.constraints = [];  // clear constraints\r\n        for (var c = 0; c < nodeCopy.components.length; c++) {\r\n            var component = nodeCopy.components[c];\r\n            var componentType = component.type;\r\n            // get the service for the node type \r\n            var service = this.$injector.get(componentType + 'Service'); \r\n            // copy the component\r\n            var componentCopy = service.copyComponent(component);\r\n            if (component.maxScore != null) {\r\n                // Also copy the max score if exists in original node\r\n                componentCopy.maxScore = component.maxScore;\r\n            }\r\n            if (component.showPreviousWorkPrompt != null) {\r\n                // Also copy the showPreviousWorkPrompt if exists in original node\r\n                componentCopy.showPreviousWorkPrompt = component.showPreviousWorkPrompt;\r\n            }\r\n            if (component.showPreviousWorkNodeId != null) {\r\n                // Also copy the showPreviousWorkNodeId if exists in original node\r\n                componentCopy.showPreviousWorkNodeId = component.showPreviousWorkNodeId;\r\n            }\r\n            if (component.showPreviousWorkComponentId != null) {\r\n                // Also copy the showPreviousWorkComponentId if exists in original node\r\n                componentCopy.showPreviousWorkComponentId = component.showPreviousWorkComponentId;\r\n            }\r\n\r\n            nodeCopy.components[c] = componentCopy;\r\n        }\r\n        return nodeCopy;\r\n    }\r\n\r\n    /**\r\n     * Delete a node\r\n     * @param nodeId the node id\r\n     */\r\n    deleteNode(nodeId) {\r\n\r\n        /*\r\n         * flag for whether we are deleting the project start node id.\r\n         * if we are deleting the project start node id, we will need\r\n         * to change it to the next logical node id that will be used\r\n         * as the project start.\r\n         */\r\n        var removingProjectStartNodeId = false;\r\n\r\n        if (this.isGroupNode(nodeId)) {\r\n            // the node is a group node so we will also remove all of its children\r\n            var group = this.getNodeById(nodeId);\r\n\r\n            // TODO check if the child is in another group, if so do not remove\r\n\r\n            if (group != null) {\r\n                var ids = group.ids;\r\n\r\n                // loop through all the children\r\n                for (var i = 0; i < ids.length; i++) {\r\n                    var id = ids[i];\r\n\r\n                    // remove the child\r\n                    this.removeNodeIdFromTransitions(id);\r\n                    this.removeNodeIdFromGroups(id);\r\n                    this.removeNodeIdFromNodes(id);\r\n\r\n                    if (this.project.startNodeId == id) {\r\n                        removingProjectStartNodeId = true;\r\n                    }\r\n\r\n                    /*\r\n                     * move the counter back because we have removed a child\r\n                     * from the parent group's array of child ids so all of\r\n                     * the child ids were shifted back one and the next child\r\n                     * we want will be at i--\r\n                     */\r\n                    i--;\r\n                }\r\n            }\r\n        }\r\n\r\n        var parentGroup = this.getParentGroup(nodeId);\r\n\r\n        // check if we need to update the start id of the parent group\r\n        if (parentGroup != null) {\r\n\r\n            /*\r\n             * the node is the start node of the parent group so we need\r\n             * to update the start id of the parent group to point to\r\n             * the next node\r\n             */\r\n            if (nodeId === parentGroup.startId) {\r\n\r\n                var hasSetNewStartId = false;\r\n\r\n                // get the node\r\n                var node = this.getNodeById(nodeId);\r\n\r\n                if (node != null) {\r\n                    var transitionLogic = node.transitionLogic;\r\n\r\n                    if (transitionLogic != null) {\r\n                        var transitions = transitionLogic.transitions;\r\n\r\n                        if (transitions != null && transitions.length > 0) {\r\n                            var transition = transitions[0];\r\n\r\n                            if (transition != null) {\r\n                                var toNodeId = transition.to;\r\n\r\n                                if (toNodeId != null) {\r\n\r\n                                    // check that the to node is in the same group\r\n                                    if (this.isNodeInGroup(toNodeId, parentGroup.id)) {\r\n\r\n                                        // update the parent group start id\r\n                                        parentGroup.startId = toNodeId;\r\n                                        hasSetNewStartId = true;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!hasSetNewStartId) {\r\n                    parentGroup.startId = '';\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nodeId === this.getStartNodeId()) {\r\n            // the node we are removing is the project start node id\r\n            removingProjectStartNodeId = true;\r\n        }\r\n\r\n        if (removingProjectStartNodeId) {\r\n            /*\r\n             * we are removing the project start node id so we need to update\r\n             * the startNodeId to something else\r\n             */\r\n\r\n            if (this.isGroupNode(nodeId)) {\r\n                /*\r\n                 * we are removing a group so we need to set the startNodeId to\r\n                 * the first node of the next group or if the next group doesn't\r\n                 * have any nodes, we will just use the next group\r\n                 */\r\n\r\n                // get the transitions of the group we are removing\r\n                var transitions = this.getTransitionsByFromNodeId(nodeId);\r\n\r\n                if (transitions == null || transitions.length == 0) {\r\n                    /*\r\n                     * the group doesn't have any transitions so we will set\r\n                     * the startNodeId to 'group0'\r\n                     */\r\n                    this.setStartNodeId('group0');\r\n                } else {\r\n                    // the group has transitions\r\n\r\n                    var nextNodeId = null;\r\n\r\n                    if (transitions[0] != null && transitions[0].to != null) {\r\n                        // get the first transition\r\n                        nextNodeId = transitions[0].to;\r\n                    }\r\n\r\n                    if (nextNodeId != null) {\r\n                        if (this.isGroupNode(nextNodeId)) {\r\n                            // the transition is to a group\r\n\r\n                            // get the next group\r\n                            var nextGroupNode = this.getNodeById(nextNodeId);\r\n\r\n                            if (nextGroupNode != null) {\r\n\r\n                                // get the start id of the next group\r\n                                var nextGroupStartId = nextGroupNode.startId;\r\n\r\n                                if (nextGroupStartId == null) {\r\n                                    /*\r\n                                     * the next group does not have a start id so we\r\n                                     * will just use the next group id as the project\r\n                                     * start node id\r\n                                     */\r\n                                    this.setStartNodeId(nextNodeId);\r\n                                } else {\r\n                                    /*\r\n                                     * the next group has a start id so we will use\r\n                                     * it as the project start node id\r\n                                     */\r\n                                    this.setStartNodeId(nextGroupStartId);\r\n                                }\r\n                            }\r\n                        } else {\r\n                            /*\r\n                             * the transition is to a step so we will use it as the\r\n                             * project start node id\r\n                             */\r\n                            this.setStartNodeId(nextNodeId);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                /*\r\n                 * we are removing a step node so we will set the startNodeId to\r\n                 * the next node in the transitions, or if there are no\r\n                 * transitions, we will use the parent group\r\n                 */\r\n\r\n                // get the transitions from the step we are removing\r\n                var transitions = this.getTransitionsByFromNodeId(nodeId);\r\n\r\n                if (transitions == null || transitions.length == 0) {\r\n                    /*\r\n                     * the step doesn't have any transitions so we will use the\r\n                     * its parent group as the start node id\r\n                     */\r\n                    var parentGroupId = this.getParentGroupId(nodeId);\r\n                    this.setStartNodeId(parentGroupId);\r\n                } else {\r\n                    // the step has transitions\r\n\r\n                    if (transitions[0] != null && transitions[0].to != null) {\r\n                        /*\r\n                         * get the first transition and set it as the project\r\n                         * start node id\r\n                         */\r\n                        var transitionToNodeId = transitions[0].to;\r\n                        this.setStartNodeId(transitionToNodeId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // remove the node\r\n        this.removeNodeIdFromTransitions(nodeId);\r\n        this.removeNodeIdFromGroups(nodeId);\r\n        this.removeNodeIdFromNodes(nodeId);\r\n\r\n        if (parentGroup != null) {\r\n            this.recalculatePositionsInGroup(parentGroup.id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the transitions to handle removing a node\r\n     * @param nodeId the node id to remove\r\n     */\r\n    removeNodeIdFromTransitions(nodeId) {\r\n\r\n        // get the node we are removing\r\n        var nodeToRemove = this.getNodeById(nodeId);\r\n\r\n        // get all the nodes that have a transition to the node we are removing\r\n        var nodesByToNodeId = this.getNodesByToNodeId(nodeId);\r\n\r\n        // get the transitions of the node we are removing\r\n        var nodeToRemoveTransitionLogic = nodeToRemove.transitionLogic;\r\n        var nodeToRemoveTransitions = [];\r\n\r\n        if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\r\n            nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\r\n        }\r\n\r\n        var parentIdOfNodeToRemove = this.getParentGroupId(nodeId);\r\n\r\n        var parentGroup = this.getNodeById(parentIdOfNodeToRemove);\r\n\r\n        // update the start id if we are removing the start node of a group\r\n        if (parentGroup != null) {\r\n            var parentGroupStartId = parentGroup.startId;\r\n\r\n            if (parentGroupStartId != null) {\r\n                if (parentGroupStartId === nodeId) {\r\n                    // the node we are removing is the start node\r\n\r\n                    if (nodeToRemoveTransitions != null && nodeToRemoveTransitions.length > 0) {\r\n\r\n                        // loop through all the transitions from the node to choose a new start id\r\n                        for (var t = 0; t < nodeToRemoveTransitions.length; t++) {\r\n                            var nodeToRemoveTransition = nodeToRemoveTransitions[t];\r\n\r\n                            if (nodeToRemoveTransition != null) {\r\n                                var toNodeId = nodeToRemoveTransition.to;\r\n\r\n                                if (toNodeId != null) {\r\n                                    /*\r\n                                     * we need to check that the to node id is in the\r\n                                     * same group. some transitions point to a node id\r\n                                     * in the next group which we would not want to use\r\n                                     * for the start id.\r\n                                     */\r\n                                    if (this.getParentGroupId(toNodeId) == parentIdOfNodeToRemove) {\r\n\r\n                                        // set the new start id\r\n                                        parentGroup.startId = toNodeId;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // there are no transitions so we will have an empty start id\r\n                        parentGroup.startId = '';\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // loop through all the nodes that transition to the node we are removing\r\n        for (var n = 0; n < nodesByToNodeId.length; n++) {\r\n\r\n            // get a node that has a transition to the node we are removing\r\n            var node = nodesByToNodeId[n];\r\n\r\n            if (node != null) {\r\n                var parentIdOfFromNode = this.getParentGroupId(node.id);\r\n\r\n                var transitionLogic = node.transitionLogic;\r\n\r\n                if (transitionLogic != null) {\r\n                    var transitions = transitionLogic.transitions;\r\n\r\n                    // loop through all the transitions of this node\r\n                    for (var t = 0; t < transitions.length; t++) {\r\n                        var transition = transitions[t];\r\n\r\n                        if (nodeId === transition.to) {\r\n                            // we have found the transition to the node we are removing\r\n\r\n                            // copy the transitions from the node we are removing\r\n                            var transitionsCopy = angular.toJson(nodeToRemoveTransitions);\r\n                            transitionsCopy = angular.fromJson(transitionsCopy);\r\n\r\n                            /*\r\n                             * if the parent from group is different than the parent removing group\r\n                             * remove transitions that are to a node in a different group than\r\n                             * the parent removing group\r\n                             */\r\n\r\n                            if (parentIdOfFromNode != parentIdOfNodeToRemove) {\r\n\r\n                                for (var tc = 0; tc < transitionsCopy.length; tc++) {\r\n                                    var tempTransition = transitionsCopy[tc];\r\n\r\n                                    if (tempTransition != null) {\r\n                                        var tempToNodeId = tempTransition.to;\r\n\r\n                                        if (tempToNodeId != null) {\r\n                                            var parentIdOfToNode = this.getParentGroupId(tempToNodeId);\r\n\r\n                                            if (parentIdOfNodeToRemove != parentIdOfToNode) {\r\n                                                // remove the transition\r\n\r\n                                                transitionsCopy.splice(tc, 1);\r\n                                                tc--;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            if (this.isFirstNodeInBranchPath(nodeId)) {\r\n                                /*\r\n                                 * Get the node ids that have a branchPathTaken\r\n                                 * constraint from the before node and to the node\r\n                                 * we are removing. If there are any, we need to\r\n                                 * update the branchPathTaken constraint with the\r\n                                 * next nodeId that comes after the node we are\r\n                                 * removing.\r\n                                 */\r\n                                var nodeIdsInBranch = this.getNodeIdsInBranch(node.id, nodeId);\r\n\r\n                                if (nodeIdsInBranch != null) {\r\n\r\n                                    // loop through all the node ids in the branch\r\n                                    for (var nib = 0; nib < nodeIdsInBranch.length; nib++) {\r\n                                        var nodeIdInBranch = nodeIdsInBranch[nib];\r\n                                        var nodeInBranch = this.getNodeById(nodeIdInBranch);\r\n\r\n                                        // loop through all the transitions in the node we are removing\r\n                                        for (var tc = 0; tc < transitionsCopy.length; tc++) {\r\n                                            var transitionCopy = transitionsCopy[tc];\r\n\r\n                                            if (transitionCopy != null) {\r\n                                                var currentFromNodeId = node.id;\r\n                                                var currentToNodeId = nodeId;\r\n                                                var newFromNodeId = node.id;\r\n                                                var newToNodeId = transitionCopy.to;\r\n\r\n                                                /*\r\n                                                 * change the branch path taken constraint by changing\r\n                                                 * the toNodeId\r\n                                                 */\r\n                                                this.updateBranchPathTakenConstraint(nodeInBranch, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId);\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            } else if (this.isBranchPoint(nodeId)) {\r\n                                // the node we are removing is a branch point\r\n\r\n                                /*\r\n                                 * get all the branches that have the node we\r\n                                 * are removing as the start point\r\n                                 */\r\n                                var branches = this.getBranchesByBranchStartPointNodeId(nodeId);\r\n\r\n                                // loop through all branches\r\n                                for (var b = 0; b < branches.length; b++) {\r\n                                    var branch = branches[b];\r\n\r\n                                    if (branch != null) {\r\n\r\n                                        /*\r\n                                         * get the branch paths. these paths do not\r\n                                         * contain the start point or merge point.\r\n                                         */\r\n                                        var branchPaths = branch.branchPaths;\r\n\r\n                                        if (branchPaths != null) {\r\n\r\n                                            // loop through all the branch paths\r\n                                            for (var bp = 0; bp < branchPaths.length; bp++) {\r\n                                                var branchPath = branchPaths[bp];\r\n\r\n                                                if (branchPath != null) {\r\n\r\n                                                    // get the start point\r\n                                                    var currentFromNodeId = nodeId;\r\n\r\n                                                    // get the first node in this branch\r\n                                                    var currentToNodeId = branchPath[0];\r\n\r\n                                                    // this will be the new start point\r\n                                                    var newFromNodeId = node.id;\r\n\r\n                                                    // get the first node in this branch\r\n                                                    var newToNodeId = branchPath[0];\r\n\r\n                                                    // loop through all the nodes in the branch path\r\n                                                    for (var bpn = 0; bpn < branchPath.length; bpn++) {\r\n\r\n                                                        // get the node id\r\n                                                        var branchPathNodeId = branchPath[bpn];\r\n\r\n                                                        // get the node\r\n                                                        var branchPathNode = this.getNodeById(branchPathNodeId);\r\n\r\n                                                        // update the constraints related to the branching\r\n                                                        this.updateBranchPathTakenConstraint(branchPathNode, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId);\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n\r\n                            // remove the transition to the node we are removing\r\n                            transitions.splice(t, 1);\r\n\r\n                            if (transitionsCopy != null) {\r\n                                var insertIndex = t;\r\n\r\n                                /*\r\n                                 * loop through all the transitions from the node we are removing\r\n                                 * and insert them into the transitions of the from node\r\n                                 * e.g.\r\n                                 * the node that comes before the node we are removing has these transitions\r\n                                 * \"transitions\": [\r\n                                 *     {\r\n                                 *         \"to\": \"node4\"\r\n                                 *     },\r\n                                 *     {\r\n                                 *         \"to\": \"node6\"\r\n                                 *     }\r\n                                 * ]\r\n                                 *\r\n                                 * we are removing node4. node4 has a transition to node5.\r\n                                 *\r\n                                 * the node that comes before the node we are removing now has these transitions\r\n                                 * \"transitions\": [\r\n                                 *     {\r\n                                 *         \"to\": \"node5\"\r\n                                 *     },\r\n                                 *     {\r\n                                 *         \"to\": \"node6\"\r\n                                 *     }\r\n                                 * ]\r\n                                 */\r\n                                for (var tc = 0; tc < transitionsCopy.length; tc++) {\r\n                                    // insert a transition from the node we are removing\r\n                                    transitions.splice(insertIndex, 0, transitionsCopy[tc]);\r\n                                    insertIndex++;\r\n                                }\r\n                            }\r\n\r\n                            // check if the node we are moving is a group\r\n                            if (this.isGroupNode(nodeId)) {\r\n                                /*\r\n                                 * we are moving a group so we need to update transitions that\r\n                                 * go into the group\r\n                                 */\r\n                                var groupIdWeAreMoving = nodeId;\r\n                                var groupThatTransitionsToGroupWeAreMoving = node;\r\n                                this.updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (this.isBranchPoint(nodeId)) {\r\n                        /*\r\n                         * the node we are deleting is a branch point so we to\r\n                         * copy the transition logic to the node that comes\r\n                         * before it\r\n                         */\r\n                        node.transitionLogic = this.UtilService.makeCopyOfJSONObject(nodeToRemoveTransitionLogic);\r\n\r\n                        /*\r\n                         * set the transitions for the node that comes before\r\n                         * the one we are removing\r\n                         */\r\n                        node.transitionLogic.transitions = transitions;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (nodeToRemoveTransitionLogic != null) {\r\n            // clear the transitions of the node we are removing\r\n            nodeToRemoveTransitionLogic.transitions = [];\r\n        }\r\n\r\n        if (this.isGroupNode(nodeId)) {\r\n            /*\r\n             * this is a group node so we will remove all child transitions that\r\n             * go out of this group\r\n             */\r\n\r\n            //this.removeTransitionsIntoGroup(nodeId);\r\n            this.removeTransitionsOutOfGroup(nodeId);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Remove the node id from a group\r\n     * @param nodeId the node id to remove\r\n     */\r\n    removeNodeIdFromGroups(nodeId) {\r\n\r\n        var groups = this.groupNodes;\r\n\r\n        if (groups != null) {\r\n\r\n            // loop through all the groups\r\n            for (var g = 0; g < groups.length; g++) {\r\n                var group = groups[g];\r\n\r\n                if (group != null) {\r\n\r\n                    // get the start id of the group\r\n                    var startId = group.startId;\r\n\r\n                    // get the child ids of the group\r\n                    var ids = group.ids;\r\n\r\n                    // loop through all the child ids\r\n                    for (var i = 0; i < ids.length; i++) {\r\n                        var id = ids[i];\r\n\r\n                        if (nodeId === id) {\r\n                            // we have found the node id we want to remove\r\n                            ids.splice(i, 1);\r\n\r\n                            if (nodeId === startId) {\r\n                                /*\r\n                                 * the node id is also the start id so we will get the\r\n                                 * next node id and set it as the new start id\r\n                                 */\r\n\r\n                                var hasSetNewStartId = false;\r\n\r\n                                // get the node we are removing\r\n                                var node = this.getNodeById(id);\r\n\r\n                                if (node != null) {\r\n                                    var transitionLogic = node.transitionLogic;\r\n\r\n                                    if (transitionLogic != null) {\r\n                                        var transitions = transitionLogic.transitions;\r\n\r\n                                        if (transitions != null && transitions.length > 0) {\r\n\r\n                                            // get the first transition\r\n                                            // TODO handle the case when the node we are removing is a branch point\r\n                                            var transition = transitions[0];\r\n\r\n                                            if (transition != null) {\r\n                                                // get the node that this node transitions to\r\n                                                var to = transition.to;\r\n\r\n                                                if (to != null) {\r\n                                                    // set the to node as the start id\r\n                                                    group.startId = to;\r\n                                                    hasSetNewStartId = true;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                if (!hasSetNewStartId) {\r\n                                    /*\r\n                                     * the node we are removing did not have a transition\r\n                                     * so there will be no start id\r\n                                     */\r\n                                    group.startId = '';\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove the node from the array of nodes\r\n     * @param nodeId the node id to remove\r\n     */\r\n    removeNodeIdFromNodes(nodeId) {\r\n\r\n        // get all the nodes in the project\r\n        var nodes = this.project.nodes;\r\n\r\n        // loop through all the nodes\r\n        for (var n = 0; n < nodes.length; n++) {\r\n            var node = nodes[n];\r\n\r\n            if (node != null) {\r\n                if (nodeId === node.id) {\r\n                    // we have found the node we want to remove\r\n                    nodes.splice(n, 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        // get all the inactive nodes\r\n        var inactiveNodes = this.project.inactiveNodes;\r\n\r\n        if (inactiveNodes != null) {\r\n\r\n            // loop through all the inactive nodes\r\n            for (var i = 0; i < inactiveNodes.length; i++) {\r\n                var inactiveNode = inactiveNodes[i];\r\n\r\n                if (inactiveNode != null) {\r\n                    if (nodeId === inactiveNode.id) {\r\n                        // we have found the inactive node we want to remove\r\n                        inactiveNodes.splice(i, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove the node from the inactive nodes array\r\n     * @param nodeId the node to remove from the inactive nodes array\r\n     */\r\n    removeNodeIdFromInactiveNodes(nodeId) {\r\n\r\n        // get the inactive nodes array\r\n        var inactiveNodes = this.project.inactiveNodes;\r\n\r\n        if (inactiveNodes != null) {\r\n\r\n            // loop through the inactive nodes\r\n            for (var i = 0; i < inactiveNodes.length; i++) {\r\n                var inactiveNode = inactiveNodes[i];\r\n\r\n                if (inactiveNode != null) {\r\n                    var inactiveNodeId = inactiveNode.id;\r\n\r\n                    if (nodeId === inactiveNodeId) {\r\n                        /*\r\n                         * we have found the node we are looking for so we will\r\n                         * remove it\r\n                         */\r\n                        inactiveNodes.splice(i, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new component\r\n     * @param nodeId the node id to create the component in\r\n     * @param componentType the component type\r\n     */\r\n    createComponent(nodeId, componentType) {\r\n\r\n        if (nodeId != null && componentType != null) {\r\n            // get the node we will create the component in\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            // get the service for the component type\r\n            var service = this.$injector.get(componentType + 'Service');\r\n\r\n            if (node != null && service != null) {\r\n\r\n                // create the new component\r\n                var component = service.createComponent();\r\n\r\n                if (service.componentHasWork()) {\r\n                    /*\r\n                     * the component has student work so we will need to\r\n                     * determine if we need to show the save button on the\r\n                     * component or the step\r\n                     */\r\n\r\n                    if (node.showSaveButton == true) {\r\n                        /*\r\n                         * the step is showing a save button so we will not show\r\n                         * the save button on this new component\r\n                         */\r\n                    } else {\r\n                        // the step is not showing a save button\r\n\r\n                        if (this.doesAnyComponentShowSubmitButton(node.id)) {\r\n                            /*\r\n                             * at least one of the other components in the step are\r\n                             * showing a submit button so we will also show the save\r\n                             * button on this new component\r\n                             */\r\n\r\n                            // turn on the component save button\r\n                            component.showSaveButton = true;\r\n                        } else {\r\n                            /*\r\n                             * none of the other components are showing a submit button\r\n                             * so we will show the save button on the step\r\n                             */\r\n\r\n                            // turn on the step save button\r\n                            node.showSaveButton = true;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // add the component to the node\r\n                this.addComponentToNode(node, component);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Does any component in the step generate work\r\n     * @param nodeId the node id\r\n     * @return whether any components in the step generates work\r\n     */\r\n    doesAnyComponentHaveWork(nodeId) {\r\n\r\n        // get the node\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node != null) {\r\n\r\n            // get the components in the node\r\n            var components = node.components;\r\n\r\n            if (components != null) {\r\n\r\n                // loop through all the components\r\n                for (var c = 0; c < components.length; c++) {\r\n\r\n                    // get a component\r\n                    var component = components[c];\r\n\r\n                    if (component != null) {\r\n                        var componentType = component.type;\r\n\r\n                        // get the service for the component type\r\n                        var service = this.$injector.get(componentType + 'Service');\r\n\r\n                        if (service != null) {\r\n                            if (service.componentHasWork()) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Check if any of the components in the node are showing their save button\r\n     * @param nodeId the node id to check\r\n     * @return whether any of the components in the node show their save button\r\n     */\r\n    doesAnyComponentShowSaveButton(nodeId) {\r\n\r\n        var result = false;\r\n\r\n        // get the node\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node != null) {\r\n\r\n            // get the components in the node\r\n            var components = node.components;\r\n\r\n            if (components != null) {\r\n\r\n                // loop through all the components\r\n                for (var c = 0; c < components.length; c++) {\r\n\r\n                    // get a component\r\n                    var component = components[c];\r\n\r\n                    if (component != null) {\r\n                        if (component.showSaveButton == true) {\r\n                            // the component is showing their save button\r\n                            result = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check if any of the components in the node are showing their submit button\r\n     * @param nodeId the node id to check\r\n     * @return whether any of the components in the node show their submit button\r\n     */\r\n    doesAnyComponentShowSubmitButton(nodeId) {\r\n\r\n        var result = false;\r\n\r\n        // get the node\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node != null) {\r\n\r\n            // get the components in the node\r\n            var components = node.components;\r\n\r\n            if (components != null) {\r\n\r\n                // loop through all the components\r\n                for (var c = 0; c < components.length; c++) {\r\n\r\n                    // get a component\r\n                    var component = components[c];\r\n\r\n                    if (component != null) {\r\n                        if (component.showSubmitButton == true) {\r\n                            // the component is showing their save button\r\n                            result = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Turn on the save button in all the components in the step\r\n     * @param nodeId the node id\r\n     */\r\n    turnOnSaveButtonInComponents(nodeId) {\r\n\r\n        // get the node\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node != null) {\r\n\r\n            // get the components in the node\r\n            var components = node.components;\r\n\r\n            if (components != null) {\r\n\r\n                // loop through all the components\r\n                for (var c = 0; c < components.length; c++) {\r\n\r\n                    // get a component\r\n                    var component = components[c];\r\n\r\n                    if (component != null) {\r\n\r\n                        // get the component type\r\n                        var componentType = component.type;\r\n\r\n                        if (componentType != null) {\r\n\r\n                            // get the service for the component type\r\n                            var service = this.$injector.get(componentType + 'Service');\r\n\r\n                            if (service != null) {\r\n\r\n                                // check if this component uses a save button\r\n                                if (service.componentUsesSaveButton()) {\r\n\r\n                                    // turn on the save button in the component\r\n                                    component.showSaveButton = true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Turn off the submit button in all the components in the step\r\n     * @param nodeId the node id\r\n     */\r\n    turnOffSaveButtonInComponents(nodeId) {\r\n        // get the node\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node != null) {\r\n\r\n            // get the components in the node\r\n            var components = node.components;\r\n\r\n            if (components != null) {\r\n\r\n                // loop through all the components\r\n                for (var c = 0; c < components.length; c++) {\r\n\r\n                    // get a component\r\n                    var component = components[c];\r\n\r\n                    if (component != null) {\r\n\r\n                        // get the component type\r\n                        var componentType = component.type;\r\n\r\n                        if (componentType != null) {\r\n\r\n                            // get the service for the component type\r\n                            var service = this.$injector.get(componentType + 'Service');\r\n\r\n                            if (service != null) {\r\n\r\n                                // check if this component uses a save button\r\n                                if (service.componentUsesSaveButton()) {\r\n\r\n                                    // turn on the save button in the component\r\n                                    component.showSaveButton = false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the component to the node\r\n     * @param node the node\r\n     * @param component the component\r\n     */\r\n    addComponentToNode(node, component) {\r\n\r\n        if (node != null && component != null) {\r\n            node.components.push(component);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move the component up within the node\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     */\r\n    moveComponentUp(nodeId, componentId) {\r\n        if (nodeId != null && componentId != null) {\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n                var components = node.components;\r\n\r\n                if (components != null) {\r\n\r\n                    // loop through all the components\r\n                    for (var c = 0; c < components.length; c++) {\r\n                        var component = components[c];\r\n\r\n                        if (component.id === componentId) {\r\n                            // we have found the component we want to move\r\n\r\n                            /*\r\n                             * make sure this is not the first component because\r\n                             * the first component can't be moved up\r\n                             */\r\n                            if (c != 0) {\r\n                                // this is not the first component\r\n\r\n                                // remove the component\r\n                                components.splice(c, 1);\r\n\r\n                                // put the component back in at the position one index back\r\n                                components.splice(c - 1, 0, component);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move the component down within the node\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     */\r\n    moveComponentDown(nodeId, componentId) {\r\n        if (nodeId != null && componentId != null) {\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n                var components = node.components;\r\n\r\n                if (components != null) {\r\n\r\n                    // loop through all the components\r\n                    for (var c = 0; c < components.length; c++) {\r\n                        var component = components[c];\r\n\r\n                        if (component.id === componentId) {\r\n                            // we have found the component we want to move\r\n\r\n                            /*\r\n                             * make sure this is not the last component because\r\n                             * the last component can't be moved down\r\n                             */\r\n                            if (c != components.length - 1) {\r\n                                // this is not the last component\r\n\r\n                                // remove the component\r\n                                components.splice(c, 1);\r\n\r\n                                // put the component back in at the position one index ahead\r\n                                components.splice(c + 1, 0, component);\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete the component\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     */\r\n    deleteComponent(nodeId, componentId) {\r\n        if (nodeId != null && componentId != null) {\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n                var components = node.components;\r\n\r\n                if (components != null) {\r\n\r\n                    // loop through all the components\r\n                    for (var c = 0; c < components.length; c++) {\r\n                        var component = components[c];\r\n\r\n                        if (component.id === componentId) {\r\n                            // we have found the component we want to delete\r\n\r\n                            // remove the component\r\n                            components.splice(c, 1);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the max score for the project. If the project contains branches, we\r\n     * will only calculate the max score for a single path from the first node\r\n     * to the last node in the project.\r\n     * @returns the max score for the project or null if none of the components in the project\r\n     * has max scores.\r\n     */\r\n    getMaxScore() {\r\n\r\n        var maxScore = null;\r\n\r\n        // get the start node id of the project\r\n        var startNodeId = this.getStartNodeId()\r\n\r\n        // get all the paths in the project\r\n        var allPaths = this.getAllPaths([], startNodeId);\r\n\r\n        if (allPaths != null && allPaths.length > 0) {\r\n\r\n            // get the first path\r\n            var firstPath = allPaths[0];\r\n\r\n            // loop through all the node ids in the path\r\n            for (var n = 0; n < firstPath.length; n++) {\r\n\r\n                // get a node id\r\n                var nodeId = firstPath[n];\r\n\r\n                // get the max score for the node\r\n                var nodeMaxScore = this.getMaxScoreForNode(nodeId);\r\n\r\n                if (nodeMaxScore != null) {\r\n                    if (maxScore == null) {\r\n                        maxScore = nodeMaxScore;\r\n                    } else {\r\n                        maxScore += nodeMaxScore;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return maxScore;\r\n    }\r\n\r\n    /**\r\n     * Get the max score for the node\r\n     * @param nodeId the node id\r\n     * @returns the max score for the node\r\n     */\r\n    getMaxScoreForNode(nodeId) {\r\n        var maxScore = null;\r\n\r\n        // get the node\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node != null) {\r\n            var components = node.components;\r\n\r\n            if (components != null) {\r\n\r\n                // loop through all the components\r\n                for (var c = 0; c < components.length; c++) {\r\n                    var component = components[c];\r\n\r\n                    if (component != null) {\r\n\r\n                        // get the max score for the component\r\n                        var componentMaxScore = component.maxScore;\r\n\r\n                        // check if the component has a max score\r\n                        if (componentMaxScore != null) {\r\n\r\n                            // make sure the max score is a valid number\r\n                            if (!isNaN(componentMaxScore)) {\r\n\r\n                                if (maxScore == null) {\r\n                                    maxScore = componentMaxScore;\r\n                                } else {\r\n                                    // accumulate the max score\r\n                                    maxScore += componentMaxScore;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return maxScore;\r\n    }\r\n\r\n    /**\r\n     * Get the max score for a component\r\n     * @param nodeId get the max score from a component in this node\r\n     * @param componentId get the max score from this component\r\n     */\r\n    getMaxScoreForComponent(nodeId, componentId) {\r\n        var maxScore = null;\r\n\r\n        var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\r\n\r\n        if (component != null) {\r\n            maxScore = component.maxScore;\r\n        }\r\n\r\n        return maxScore;\r\n    }\r\n\r\n    /**\r\n     * Set the max score for a component\r\n     * @param nodeId set the max score from a component in this node\r\n     * @param componentId set the max score from this component\r\n     * @param maxScore set it to this maxScore\r\n     */\r\n    setMaxScoreForComponent(nodeId, componentId, maxScore) {\r\n        if (nodeId != null && componentId != null && maxScore != null && typeof maxScore === 'number') {\r\n            let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\r\n\r\n            if (component != null) {\r\n                component.maxScore = maxScore;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine if a node id is a direct child of a group\r\n     * @param nodeId the node id\r\n     * @param groupId the group id\r\n     */\r\n    isNodeInGroup(nodeId, groupId) {\r\n\r\n        var result = false;\r\n\r\n        var group = this.getNodeById(groupId);\r\n\r\n        var childIds = group.ids;\r\n\r\n        if (childIds != null) {\r\n            if (childIds.indexOf(nodeId) != -1) {\r\n                result = true;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the first leaf node by traversing all the start ids\r\n     * until a leaf node id is found\r\n     */\r\n    getFirstLeafNodeId() {\r\n\r\n        var firstLeafNodeId = null;\r\n\r\n        // get the start group id\r\n        var startGroupId = this.project.startGroupId;\r\n\r\n        // get the start group node\r\n        var node = this.getNodeById(startGroupId);\r\n\r\n        var done = false;\r\n\r\n        // loop until we have found a leaf node id or something went wrong\r\n        while (!done) {\r\n\r\n            if (node == null) {\r\n                done = true;\r\n            } else if (this.isGroupNode(node.id)) {\r\n                // set the first leaf node id to the group id for now\r\n                firstLeafNodeId = node.id;\r\n\r\n                // the current node is a group\r\n                node = this.getNodeById(node.startId);\r\n            } else if (this.isApplicationNode(node.id)) {\r\n                // the current node is a leaf\r\n                firstLeafNodeId = node.id;\r\n                done = true;\r\n            } else {\r\n                done = true;\r\n            }\r\n        }\r\n\r\n        return firstLeafNodeId;\r\n    }\r\n\r\n    /**\r\n     * Replace a node. This is used when we want to revert a node back to a\r\n     * previous version in the authoring tool.\r\n     * @param nodeId the node id\r\n     * @param node the node object\r\n     */\r\n    replaceNode(nodeId, node) {\r\n\r\n        if (nodeId != null && node != null) {\r\n\r\n            // set the id to node mapping\r\n            this.setIdToNode(nodeId, node);\r\n\r\n            // set the id to element mapping\r\n            this.setIdToElement(nodeId, node);\r\n\r\n            // update the nodes array\r\n            var nodes = this.getNodes();\r\n\r\n            if (nodes != null) {\r\n\r\n                for (var n = 0; n < nodes.length; n++) {\r\n                    var tempNode = nodes[n];\r\n\r\n                    if (tempNode != null) {\r\n                        var tempNodeId = tempNode.id;\r\n\r\n                        if (nodeId === tempNodeId) {\r\n                            // we have found the node we want to replace\r\n                            nodes.splice(n, 1, node);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // update the application nodes array\r\n            var applicationNodes = this.applicationNodes;\r\n\r\n            if (applicationNodes != null) {\r\n                for (var a = 0; a < applicationNodes.length; a++) {\r\n                    var tempApplicationNode = applicationNodes[a];\r\n\r\n                    if (tempApplicationNode != null) {\r\n                        var tempApplicationNodeId = tempApplicationNode.id;\r\n\r\n                        if (nodeId === tempApplicationNodeId) {\r\n                            // we have found the node we want to replace\r\n                            applicationNodes.splice(a, 1, node);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a node is a planning node\r\n     * @param nodeId the node id\r\n     * @returns whether the node is a planning node\r\n     */\r\n    isPlanning(nodeId) {\r\n        var result = false;\r\n\r\n        if (nodeId != null) {\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n                if (node.planning) {\r\n                    result = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check if a node is a planning node instance\r\n     * @param nodeId the node id\r\n     * @returns whether the node is a planning node instance\r\n     */\r\n    isPlanningInstance(nodeId) {\r\n        var result = false;\r\n\r\n        if (nodeId != null) {\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node.planningNodeTemplateId) {\r\n                result = true;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the available planning node ids for a node\r\n     * @param nodeId the node we want available planning nodes for\r\n     * @returns an array of available planning node ids\r\n     */\r\n    getAvailablePlanningNodeIds(nodeId) {\r\n        var availablePlanningNodeIds = [];\r\n\r\n        if (nodeId != null) {\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null && node.availablePlanningNodeIds != null) {\r\n                availablePlanningNodeIds = node.availablePlanningNodeIds;\r\n            }\r\n        }\r\n\r\n        return availablePlanningNodeIds;\r\n    }\r\n\r\n    /**\r\n     * Get the available planning nodes for a given group\r\n     * @param nodeId the node id of the group\r\n     * @returns an array of planning node templates\r\n     */\r\n    getAvailablePlanningNodes(nodeId) {\r\n        var availablePlanningNodesSoFar = [];\r\n\r\n        if (nodeId != null) {\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null && node.availablePlanningNodes != null) {\r\n                let availablePlanningNodes = node.availablePlanningNodes;\r\n\r\n                // loop through all the nodes and retrieve the actual node\r\n                for (var a = 0; a < availablePlanningNodes.length; a++) {\r\n                    var availablePlanningNode = availablePlanningNodes[a];\r\n\r\n                    if (availablePlanningNode != null) {\r\n\r\n                        // get the node\r\n                        var availablePlanningNodeActual = this.getNodeById(availablePlanningNode.nodeId);\r\n\r\n                        if (availablePlanningNodeActual != null) {\r\n                            if (availablePlanningNode.max != null) {\r\n                                availablePlanningNodeActual.max = availablePlanningNode.max;\r\n                            }\r\n                            availablePlanningNodesSoFar.push(availablePlanningNodeActual);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return availablePlanningNodesSoFar;\r\n    }\r\n\r\n    /**\r\n     * Create a planning node instance and add it to the project\r\n     * @param groupId the group id to add the planning node instance to\r\n     * @param nodeId the node id of the planning node template\r\n     */\r\n    createPlanningNodeInstance(groupId, nodeId, nextAvailablePlanningNodeId) {\r\n\r\n        var planningNodeInstance = null;\r\n\r\n        if (nodeId != null && nextAvailablePlanningNodeId != null) {\r\n            // get the planning node template\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            // create a planning node instance by copying the planning node template\r\n            planningNodeInstance = this.copyNode(nodeId);\r\n\r\n            // set the template id to point back to the planning template node\r\n            planningNodeInstance.planningNodeTemplateId = nodeId;\r\n\r\n            // set the planning node instance node id\r\n            planningNodeInstance.id = nextAvailablePlanningNodeId;\r\n        }\r\n\r\n        return planningNodeInstance;\r\n    }\r\n\r\n    /**\r\n     * Add a planning node instance inside a group node\r\n     * @param nodeIdToInsertInside the group id to insert into\r\n     * @param planningNodeInstance the planning node instance to add\r\n     */\r\n    addPlanningNodeInstanceInside(nodeIdToInsertInside, planningNodeInstance) {\r\n        // get the node id\r\n        var planningNodeInstanceNodeId = planningNodeInstance.id;\r\n\r\n        // add an entry in our mapping data structures of node id to object\r\n        this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\r\n        this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\r\n\r\n        // add the node to the nodes array in the project\r\n        this.addNode(planningNodeInstance);\r\n\r\n        // update the transitions\r\n        this.insertNodeInsideInTransitions(planningNodeInstanceNodeId, nodeIdToInsertInside);\r\n\r\n        // update the child ids of the group\r\n        this.insertNodeInsideInGroups(planningNodeInstanceNodeId, nodeIdToInsertInside);\r\n\r\n        // recalculate all the position values in the group\r\n        this.recalculatePositionsInGroup(nodeIdToInsertInside);\r\n\r\n        /*\r\n         * set the order of the planning node instance so that it shows up\r\n         * in the select step drop down in the correct order\r\n         */\r\n        this.setNodeOrder(this.rootNode, 0);\r\n    }\r\n\r\n    /**\r\n     * Add a planning node instance after a node\r\n     * @param nodeIdToInsertAfter the node to insert after\r\n     * @param planningNodeInstance the planning node instance to add\r\n     */\r\n    addPlanningNodeInstanceAfter(nodeIdToInsertAfter, planningNodeInstance) {\r\n        // get the node id\r\n        var planningNodeInstanceNodeId = planningNodeInstance.id;\r\n\r\n        // add an entry in our mapping data structures of node id to object\r\n        this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\r\n        this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\r\n\r\n        // add the node to the nodes array in the project\r\n        this.addNode(planningNodeInstance);\r\n\r\n        // update the transitions\r\n        this.insertNodeAfterInTransitions(planningNodeInstance, nodeIdToInsertAfter);\r\n\r\n        // update the child ids of the group\r\n        this.insertNodeAfterInGroups(planningNodeInstanceNodeId, nodeIdToInsertAfter);\r\n\r\n        var parentGroup = this.getParentGroup(nodeIdToInsertAfter);\r\n\r\n        if (parentGroup != null) {\r\n            var parentGroupId = parentGroup.id;\r\n\r\n            // recalculate all the position values in the group\r\n            this.recalculatePositionsInGroup(parentGroupId);\r\n        }\r\n\r\n        /*\r\n         * set the order of the planning node instance so that it shows up\r\n         * in the select step drop down in the correct order\r\n         */\r\n        this.setNodeOrder(this.rootNode, 0);\r\n    }\r\n\r\n    /**\r\n     * Move a planning node instance inside a group\r\n     * @param nodeIdToMove the node to move\r\n     * @param nodeIdToInsertInside the group to move the node into\r\n     */\r\n    movePlanningNodeInstanceInside(nodeIdToMove, nodeIdToInsertInside) {\r\n\r\n        // move the node inside the group node\r\n        this.moveNodesInside([nodeIdToMove], nodeIdToInsertInside);\r\n\r\n        // recalculate all the position values in the group\r\n        this.recalculatePositionsInGroup(nodeIdToInsertInside);\r\n\r\n        /*\r\n         * set the order of the planning node instance so that it shows up\r\n         * in the select step drop down in the correct order\r\n         */\r\n        this.setNodeOrder(this.rootNode, 0);\r\n    }\r\n\r\n    /**\r\n     * Move a planning node instance after a node\r\n     * @param nodeIdToMove the node to move\r\n     * @param nodeIdToInsertAfter the other node to move the node after\r\n     */\r\n    movePlanningNodeInstanceAfter(nodeIdToMove, nodeIdToInsertAfter) {\r\n\r\n        // move the node after the other node\r\n        this.moveNodesAfter([nodeIdToMove], nodeIdToInsertAfter);\r\n\r\n        var parentGroup = this.getParentGroup(nodeIdToInsertAfter);\r\n\r\n        if (parentGroup != null) {\r\n            var parentGroupId = parentGroup.id;\r\n\r\n            // recalculate all the position values in the group\r\n            this.recalculatePositionsInGroup(parentGroupId);\r\n        }\r\n\r\n        /*\r\n         * set the order of the planning node instance so that it shows up\r\n         * in the select step drop down in the correct order\r\n         */\r\n        this.setNodeOrder(this.rootNode, 0);\r\n    }\r\n\r\n    /**\r\n     * Recalculate the positions of the children in the group.\r\n     * The positions are the numbers usually seen before the title\r\n     * e.g. if the step is seen as 1.3: Gather Evidence, then 1.3\r\n     * is the position\r\n     * @param groupId recalculate all the children of this group\r\n     */\r\n    recalculatePositionsInGroup(groupId) {\r\n\r\n        if (groupId != null) {\r\n            let childIds = this.getChildNodeIdsById(groupId);\r\n\r\n            // loop through all the children\r\n            for (let c = 0; c < childIds.length; c++) {\r\n                let childId = childIds[c];\r\n\r\n                // calculate the position of the child id\r\n                let pos = this.getPositionById(childId);\r\n\r\n                // set the mapping of node id to position\r\n                this.setIdToPosition(childId, pos);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the message that describes how to disable the constraint\r\n     * @param nodeId the node the student is trying to go to\r\n     * @param constraint the constraint that is preventing the student\r\n     * from going to the node\r\n     * @returns the message to display to the student that describes how\r\n     * to disable the constraint\r\n     */\r\n    getConstraintMessage(nodeId, constraint) {\r\n\r\n        var message = '';\r\n\r\n        if (nodeId != null && constraint != null) {\r\n\r\n            // get the node title the student is trying to go to\r\n            var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\r\n\r\n            var removalConditional = constraint.removalConditional;\r\n            var removalCriteria = constraint.removalCriteria;\r\n\r\n            if (removalConditional === 'any') {\r\n                message += this.$translate('TO_VISIT_STEP_YOU_MUST_PERFORM_ONE_OF_THE_ACTIONS_BELOW', { nodeTitle: nodeTitle }) + ':<br/>';\r\n            } else {\r\n                message += this.$translate('TO_VISIT_STEP_YOU_MUST_PERFORM_ALL_OF_THE_ACTIONS_BELOW', { nodeTitle: nodeTitle }) + ':<br/>';\r\n            }\r\n\r\n            if (removalCriteria != null) {\r\n\r\n                var criteriaMessages = '';\r\n\r\n                // loop through all the criteria\r\n                for (var x = 0; x < removalCriteria.length; x++) {\r\n                    var tempRemovalCriteria = removalCriteria[x];\r\n\r\n                    if (tempRemovalCriteria != null) {\r\n\r\n                        // get the message that describes the criteria that needs to be satisfied\r\n                        var criteriaMessage = this.getCriteriaMessage(tempRemovalCriteria);\r\n\r\n                        if (criteriaMessage != null && criteriaMessage != '') {\r\n                            // separate criteria messages with a line break\r\n                            if (criteriaMessages != '') {\r\n                                criteriaMessages += '<br/>';\r\n                            }\r\n                            criteriaMessages += criteriaMessage;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                message += criteriaMessages;\r\n            }\r\n        }\r\n\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Get the message that describes how to satisfy the criteria\r\n     * TODO: check if the criteria is satisfied\r\n     * @param criteria the criteria object that needs to be satisfied\r\n     * @returns the message to display to the student that describes how to\r\n     * satisfy the criteria\r\n     */\r\n    getCriteriaMessage(criteria) {\r\n        var message = '';\r\n\r\n        if (criteria != null) {\r\n            var name = criteria.name;\r\n            var params = criteria.params;\r\n\r\n            if (name === 'isCompleted') {\r\n                var nodeId = params.nodeId;\r\n                if (nodeId != null) {\r\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\r\n                    message += this.$translate('completeNodeTitle', { nodeTitle: nodeTitle });\r\n                }\r\n            } else if (name === 'isVisited') {\r\n                var nodeId = params.nodeId;\r\n                if (nodeId != null) {\r\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\r\n                    message += this.$translate('visitNodeTitle', { nodeTitle: nodeTitle });\r\n                }\r\n            } else if (name === 'isCorrect') {\r\n                var nodeId = params.nodeId;\r\n                if (nodeId != null) {\r\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\r\n                    message += this.$translate('correctlyAnswerNodeTitle', { nodeTitle: nodeTitle });\r\n                }\r\n            } else if (name === 'score') {\r\n                var nodeId = params.nodeId;\r\n                var nodeTitle = '';\r\n                var scoresString = '';\r\n\r\n                if (nodeId != null) {\r\n                    // get the step number and title\r\n                    nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\r\n                }\r\n\r\n                var scores = params.scores;\r\n\r\n                if (scores != null) {\r\n                    // get the required score\r\n                    scoresString = scores.join(', ');\r\n                }\r\n\r\n                // generate the message\r\n                message += this.$translate('obtainAScoreOfXOnNodeTitle', { score: scoresString, nodeTitle: nodeTitle });\r\n            } else if (name === 'choiceChosen') {\r\n\r\n            } else if (name === 'usedXSubmits') {\r\n                var nodeId = params.nodeId;\r\n                var nodeTitle = '';\r\n\r\n                // get the number of times the student must submit\r\n                var requiredSubmitCount = params.requiredSubmitCount;\r\n\r\n                if (nodeId != null) {\r\n                    // get the step number and title\r\n                    nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\r\n                }\r\n\r\n                // generate the message\r\n                if (requiredSubmitCount == 1) {\r\n                    message += this.$translate('submitXTimeOnNodeTitle', { requiredSubmitCount: requiredSubmitCount, nodeTitle: nodeTitle });\r\n                } else {\r\n                    message += this.$translate('submitXTimesOnNodeTitle', { requiredSubmitCount: requiredSubmitCount, nodeTitle: nodeTitle });\r\n                }\r\n            } else if (name === 'branchPathTaken') {\r\n\r\n            } else if (name === 'isPlanningActivityCompleted') {\r\n                var nodeId = params.nodeId;\r\n                if (nodeId != null) {\r\n                    var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\r\n                    message += this.$translate('completeNodeTitle', { nodeTitle: nodeTitle });\r\n                }\r\n            }\r\n        }\r\n\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Get the start id of a group\r\n     * @param nodeId get the start id of this group\r\n     * @returns the start id of the group\r\n     */\r\n    getGroupStartId(nodeId) {\r\n\r\n        var startId = null;\r\n\r\n        if (nodeId != null) {\r\n\r\n            // get the group\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n                // get the start id\r\n                startId = node.startId;\r\n            }\r\n        }\r\n\r\n\r\n        return startId;\r\n    }\r\n\r\n    /**\r\n     * Get the start id of the node's parent group\r\n     * @param nodeId we will get the parent of this node and then look\r\n     * for the start id of the parent\r\n     * @returns the start id of the parent\r\n     */\r\n    getParentGroupStartId(nodeId) {\r\n        var parentGroupStartId = null;\r\n\r\n        if (nodeId != null) {\r\n            var parentGroup = this.getParentGroup(nodeId);\r\n\r\n            if (parentGroup != null) {\r\n                parentGroupStartId = parentGroup.startId;\r\n            }\r\n        }\r\n\r\n        return parentGroupStartId;\r\n    }\r\n\r\n    /**\r\n     * Update the transitions so that the fromGroup points to the newToGroup\r\n     *\r\n     * Before\r\n     * fromGroup -> oldToGroup -> newToGroup\r\n     *\r\n     * After\r\n     * fromGroup -> newToGroup\r\n     * oldToGroup becomes dangling and has no transitions to or from it\r\n     */\r\n    updateTransitionsForExtractingGroup(fromGroupId, oldToGroupId, newToGroupId) {\r\n\r\n        /*\r\n         * make the transitions\r\n         * fromGroup -> newToGroup\r\n         */\r\n        if (fromGroupId != null && oldToGroupId != null) {\r\n            var fromGroup = this.getNodeById(fromGroupId);\r\n            var oldToGroup = this.getNodeById(oldToGroupId);\r\n            var newToGroup = null;\r\n            var newToGroupStartId = null;\r\n\r\n            if (newToGroupId != null) {\r\n                newToGroup = this.getNodeById(newToGroupId);\r\n            }\r\n\r\n            if (newToGroup != null) {\r\n                newToGroupStartId = newToGroup.startId;\r\n            }\r\n\r\n            if (fromGroup != null && oldToGroup != null) {\r\n                var childIds = fromGroup.ids;\r\n\r\n                // update the children of the from group to point to the new to group\r\n                if (childIds != null) {\r\n                    for (var c = 0; c < childIds.length; c++) {\r\n                        var childId = childIds[c];\r\n                        var child = this.getNodeById(childId);\r\n                        var transitions = this.getTransitionsByFromNodeId(childId);\r\n\r\n                        if (transitions != null) {\r\n\r\n                            // loop through all the transitions from the from group\r\n                            for (var t = 0; t < transitions.length; t++) {\r\n                                var transition = transitions[t];\r\n\r\n                                if (transition != null) {\r\n                                    var toNodeId = transition.to;\r\n\r\n                                    if (toNodeId === oldToGroupId) {\r\n                                        // the transition is to the group\r\n                                        if (newToGroupId == null && newToGroupStartId == null) {\r\n                                            // there is no new to group so we will remove the transition\r\n                                            transitions.splice(t, 1);\r\n                                            t--;\r\n                                        } else {\r\n                                            // make the transition point to the new to group\r\n                                            transition.to = newToGroupId;\r\n                                        }\r\n                                    } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\r\n                                        // the transition is to a node in the group\r\n                                        if (newToGroupId == null && newToGroupStartId == null) {\r\n                                            // there is no new to group so we will remove the transition\r\n                                            transitions.splice(t, 1);\r\n                                            t--;\r\n                                        } else if (newToGroupStartId == null || newToGroupStartId == '') {\r\n                                            // make the transition point to the new to group\r\n                                            transition.to = newToGroupId;\r\n                                        } else {\r\n                                            // make the transition point to the new group start id\r\n                                            transition.to = newToGroupStartId;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /*\r\n         * remove the transitions from the oldToGroup\r\n         */\r\n        if (oldToGroupId != null && newToGroupId != null) {\r\n\r\n            var oldToGroup = this.getNodeById(oldToGroupId);\r\n\r\n            if (oldToGroup != null) {\r\n                var childIds = oldToGroup.ids;\r\n\r\n                // remove the transitions from the old to group that point to the new to group\r\n                if (childIds != null) {\r\n                    for (var c = 0; c < childIds.length; c++) {\r\n                        var childId = childIds[c];\r\n                        var child = this.getNodeById(childId);\r\n                        var transitions = this.getTransitionsByFromNodeId(childId);\r\n\r\n                        if (transitions != null) {\r\n\r\n                            // loop through all the transitions from the old to group\r\n                            for (var t = 0; t < transitions.length; t++) {\r\n                                var transition = transitions[t];\r\n\r\n                                if (transition != null) {\r\n                                    var toNodeId = transition.to;\r\n\r\n                                    if (toNodeId === newToGroupId) {\r\n                                        // the transition is to the group so we will remove it\r\n                                        transitions.splice(t, 1);\r\n                                        t--;\r\n                                    } else if (this.isNodeInGroup(toNodeId, newToGroupId)) {\r\n                                        // the transition is to a node in the group so we will remove it\r\n                                        transitions.splice(t, 1);\r\n                                        t--;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the transitions so that the fromGroup points to the newToGroup\r\n     *\r\n     * Before\r\n     * fromGroup -> oldToGroup\r\n     * newToGroup is dangling and has no transitions to or from it\r\n     *\r\n     * After\r\n     * fromGroup -> newToGroup -> oldToGroup\r\n     */\r\n    updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId) {\r\n\r\n        var fromGroup = null;\r\n        var newToGroup = null;\r\n\r\n        if (fromGroupId != null) {\r\n            fromGroup = this.getNodeById(fromGroupId);\r\n        }\r\n\r\n        if (newToGroupId != null) {\r\n            newToGroup = this.getNodeById(newToGroupId);\r\n        }\r\n\r\n        /*\r\n         * make the transitions that point to the old group now point\r\n         * to the new group\r\n         * fromGroup -> newToGroup\r\n         */\r\n        if (fromGroup != null && newToGroup != null) {\r\n            var childIds = fromGroup.ids;\r\n            var newToGroupStartId = newToGroup.startId;\r\n\r\n            if (childIds != null) {\r\n\r\n                // loop through all the nodes in the from group\r\n                for (var c = 0; c < childIds.length; c++) {\r\n                    var childId = childIds[c];\r\n                    var child = this.getNodeById(childId);\r\n\r\n                    // get the transitions from the child\r\n                    var transitions = this.getTransitionsByFromNodeId(childId);\r\n\r\n                    if (transitions == null || transitions.length == 0) {\r\n                        /*\r\n                         * the child does not have any transitions so we will make it\r\n                         * point to the new group\r\n                         */\r\n                        if (newToGroupStartId == null || newToGroupStartId == '') {\r\n                            this.addToTransition(child, newToGroupId);\r\n                        } else {\r\n                            this.addToTransition(child, newToGroupStartId)\r\n                        }\r\n                    } else if (transitions != null) {\r\n\r\n                        // loop through all the transitions from the child\r\n                        for (var t = 0; t < transitions.length; t++) {\r\n                            var transition = transitions[t];\r\n\r\n                            if (transition != null) {\r\n                                var toNodeId = transition.to;\r\n\r\n                                if (oldToGroupIds != null) {\r\n\r\n                                    /*\r\n                                     * loop through all the old to group ids to find transitions\r\n                                     * to the old to group\r\n                                     */\r\n                                    for (var ot = 0; ot < oldToGroupIds.length; ot++) {\r\n                                        var oldToGroupId = oldToGroupIds[ot];\r\n\r\n                                        if (toNodeId === oldToGroupId) {\r\n                                            /*\r\n                                             * the transition is to the group so we will update the transition\r\n                                             * to the new group\r\n                                             */\r\n                                            transition.to = newToGroupId;\r\n                                        } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\r\n                                            /*\r\n                                             * the transition is to a node in the old group so we will update\r\n                                             * the transition to point to the new group\r\n                                             */\r\n                                            if (newToGroupStartId == null || newToGroupStartId == '') {\r\n                                                transition.to = newToGroupId;\r\n                                            } else {\r\n                                                transition.to = newToGroupStartId;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        /*\r\n         * make the steps that do not have a transition now point to the old\r\n         * group\r\n         * newToGroup -> oldToGroup\r\n         */\r\n        if (newToGroup != null) {\r\n            var childIds = newToGroup.ids;\r\n\r\n            if (childIds != null) {\r\n\r\n                // loop through all the children in the new group\r\n                for (var c = 0; c < childIds.length; c++) {\r\n                    var childId = childIds[c];\r\n                    var child = this.getNodeById(childId);\r\n\r\n                    // get the transitions for the child\r\n                    var transitions = this.getTransitionsByFromNodeId(childId);\r\n\r\n                    if (transitions == null || transitions.length == 0) {\r\n\r\n                        if (oldToGroupIds != null) {\r\n\r\n                            // loop through all the old groups\r\n                            for (var ot = 0; ot < oldToGroupIds.length; ot++) {\r\n                                var oldToGroupId = oldToGroupIds[ot];\r\n                                var oldToGroup = this.getNodeById(oldToGroupId);\r\n\r\n                                if (oldToGroup != null) {\r\n\r\n                                    var oldToGroupStartId = oldToGroup.startId;\r\n\r\n                                    var transition = {};\r\n\r\n                                    var toNodeId = '';\r\n\r\n                                    if (oldToGroupStartId == null) {\r\n                                        // there is no start node id so we will just point to the group\r\n                                        toNodeId = oldToGroup;\r\n                                    } else {\r\n                                        // there is a start node id so we will point to it\r\n                                        toNodeId = oldToGroupStartId;\r\n                                    }\r\n\r\n                                    // create the transition from the child to the old group\r\n                                    this.addToTransition(child, toNodeId);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the child transitions because we are moving a group. We will\r\n     * update the transitions into and out of the group in the location\r\n     * we are extracting the group from and also in the location we are\r\n     * inserting the group into.\r\n     * @param node the group we are moving\r\n     * @param nodeId we will put the group after this node id\r\n     */\r\n    updateChildrenTransitionsForMovingGroup(node, nodeId) {\r\n        var transitionsBefore = null;\r\n\r\n        // get the group nodes that point to the group we are moving\r\n        var previousGroupNodes = this.getGroupNodesByToNodeId(node.id);\r\n\r\n        // get all the transitions from the group we are moving\r\n        var transitionsAfter = this.getTransitionsByFromNodeId(node.id);\r\n\r\n        var extracted = false;\r\n\r\n        /*\r\n         * extract the group we are moving by updating the transitions of the\r\n         * from group and the new to group. also remove the transitions from the\r\n         * group we are moving.\r\n         */\r\n\r\n        // loop through all the groups that point to the group we are moving\r\n        for (var p = 0; p < previousGroupNodes.length; p++) {\r\n            var previousGroupNode = previousGroupNodes[p];\r\n\r\n            if (transitionsAfter == null || transitionsAfter.length == 0) {\r\n                // the group we are moving does not have any transitions\r\n\r\n                /*\r\n                 * remove the transitions to the group we are moving and make\r\n                 * new transitions from the from group to the new to group\r\n                 */\r\n                this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, null);\r\n                extracted = true;\r\n            } else {\r\n                // the group we are moving has transitions\r\n\r\n                // make the previous group point to the new to group\r\n                for (var t = 0; t < transitionsAfter.length; t++) {\r\n                    var transitionAfter = transitionsAfter[t];\r\n\r\n                    if (transitionAfter != null) {\r\n                        var toNodeId = transitionAfter.to;\r\n\r\n                        /*\r\n                         * remove the transitions to the group we are moving and make\r\n                         * new transitions from the from group to the new to group\r\n                         */\r\n                        this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, toNodeId);\r\n                        extracted = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!extracted) {\r\n            /*\r\n             * we have not removed the transitions yet because the group\r\n             * we are moving does not have any groups before it\r\n             */\r\n\r\n            if (transitionsAfter != null) {\r\n                // remove the transitions from the group we are moving\r\n                for (var t = 0; t < transitionsAfter.length; t++) {\r\n                    var transitionAfter = transitionsAfter[t];\r\n\r\n                    if (transitionAfter != null) {\r\n                        var toNodeId = transitionAfter.to;\r\n\r\n                        // remove the transitions to the group we are moving\r\n                        this.updateTransitionsForExtractingGroup(null, node.id, toNodeId);\r\n                        extracted = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var inserted = false;\r\n\r\n        /*\r\n         * create the transitions from the from group to the group we are moving\r\n         * and the transitions from the group we are moving to the old to group\r\n         */\r\n        if (nodeId != null) {\r\n            // get the transitions from the previous group to the next group\r\n            var transitionsAfter = this.getTransitionsByFromNodeId(nodeId);\r\n\r\n            for (var t = 0; t < transitionsAfter.length; t++) {\r\n                var transitionAfter = transitionsAfter[t];\r\n\r\n                if (transitionAfter != null) {\r\n                    var toNodeId = transitionAfter.to;\r\n\r\n                    /*\r\n                     * create the transitions that traverse from the from group\r\n                     * to the group we are moving. also create the transitions\r\n                     * that traverse from the group we are moving to the old\r\n                     * to group.\r\n                     */\r\n                    this.updateTransitionsForInsertingGroup(nodeId, [toNodeId], node.id);\r\n                    inserted = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!inserted) {\r\n            /*\r\n             * we have not inserted the transitions yet because there were no\r\n             * previous group transitions\r\n             */\r\n\r\n            if (nodeId == null) {\r\n                /*\r\n                 * the previous node id is null which means there was no previous\r\n                 * group. this means the group we are inserting will become the\r\n                 * first group. this happens when the group we are moving\r\n                 * is moved inside the root (group0).\r\n                 */\r\n\r\n                var startGroupId = this.getStartGroupId();\r\n\r\n                if (startGroupId != null) {\r\n\r\n                    // get the start group for the whole project (group0)\r\n                    var startGroup = this.getNodeById(startGroupId);\r\n\r\n                    if (startGroup != null) {\r\n\r\n                        // get the first activity\r\n                        var firstGroupId = startGroup.startId;\r\n\r\n                        /*\r\n                         * create the transitions that traverse from the group\r\n                         * we are moving to the previous first activity.\r\n                         */\r\n                        this.updateTransitionsForInsertingGroup(nodeId, [firstGroupId], node.id);\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                /*\r\n                 * we have not inserted the group yet because the from group doesn't\r\n                 * have a group after it\r\n                 */\r\n\r\n                /*\r\n                 * create the transitions that traverse from the from group\r\n                 * to the group we are moving.\r\n                 */\r\n                this.updateTransitionsForInsertingGroup(nodeId, null, node.id);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if a component is a connected component\r\n     * @param nodeId the node id of the component\r\n     * @param componentId the component that is listening for connected changes\r\n     * @param connectedComponentId the component that is broadcasting connected changes\r\n     * @returns whether the componentId is connected to the connectedComponentId\r\n     */\r\n    isConnectedComponent(nodeId, componentId, connectedComponentId) {\r\n\r\n        var result = false;\r\n\r\n        // get the component\r\n        var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\r\n\r\n        if (component != null) {\r\n\r\n            var connectedComponents = component.connectedComponents;\r\n\r\n            if (connectedComponents != null) {\r\n\r\n                // loop through all the connected components\r\n                for (var c = 0; c < connectedComponents.length; c++) {\r\n                    var connectedComponent = connectedComponents[c];\r\n\r\n                    if (connectedComponent != null) {\r\n\r\n                        /*\r\n                         * check if the connected component id matches the one\r\n                         * we are looking for. connectedComponent.id is the old\r\n                         * field we used to store the component id in so we will\r\n                         * look for that field for the sake of backwards\r\n                         * compatibility. connectedComponent.componentId is the\r\n                         * new field we store the component id in.\r\n                         */\r\n                        if (connectedComponentId === connectedComponent.id ||\r\n                            connectedComponentId === connectedComponent.componentId) {\r\n                            // we have found the connected component id we are looking for\r\n                            result = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a connected component params\r\n     * @param componentId the connected component id\r\n     * @returns the params for the connected component\r\n     */\r\n    getConnectedComponentParams(componentContent, componentId) {\r\n\r\n        var connectedComponentParams = null;\r\n\r\n        if (componentContent != null && componentId != null) {\r\n\r\n            // get the connected components\r\n            var connectedComponents = componentContent.connectedComponents;\r\n\r\n            if (connectedComponents != null) {\r\n\r\n                // loop through all the connected components\r\n                for (var c = 0; c < connectedComponents.length; c++) {\r\n                    var connectedComponent = connectedComponents[c];\r\n\r\n                    if (connectedComponent != null) {\r\n\r\n                        /*\r\n                         * check if the connected component id matches the one\r\n                         * we are looking for. connectedComponent.id is the old\r\n                         * field we used to store the component id in so we will\r\n                         * look for that field for the sake of backwards\r\n                         * compatibility. connectedComponent.componentId is the\r\n                         * new field we store the component id in.\r\n                         */\r\n                        if (componentId === connectedComponent.id ||\r\n                            componentId === connectedComponent.componentId) {\r\n                            // we have found the connected component we are looking for\r\n                            connectedComponentParams = connectedComponent;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return connectedComponentParams;\r\n    }\r\n\r\n    /**\r\n     * Get the inactive groups\r\n     * @returns the inactive groups\r\n     */\r\n    getInactiveGroups() {\r\n        var inactiveGroups = [];\r\n\r\n        if (this.project != null) {\r\n\r\n            if (this.project.inactiveGroups == null) {\r\n                this.project.inactiveGroups = [];\r\n            }\r\n\r\n            inactiveGroups = this.project.inactiveGroups;\r\n        }\r\n\r\n        return inactiveGroups;\r\n    }\r\n\r\n    /**\r\n     * Get the inactive nodes\r\n     * @returns the inactive nodes\r\n     */\r\n    getInactiveNodes() {\r\n        var inactiveNodes = [];\r\n\r\n        if (this.project != null) {\r\n\r\n            if (this.project.inactiveNodes == null) {\r\n                this.project.inactiveNodes = [];\r\n            }\r\n\r\n            inactiveNodes = this.project.inactiveNodes;\r\n        }\r\n\r\n        return inactiveNodes;\r\n    }\r\n\r\n    /**\r\n     * Remove the node from the active nodes\r\n     * @param nodeId the node to remove\r\n     * @returns the node that we have removed\r\n     */\r\n    removeNodeFromActiveNodes(nodeId) {\r\n        var node = null;\r\n\r\n        if (nodeId != null) {\r\n\r\n            // get the active nodes\r\n            var activeNodes = this.project.nodes;\r\n\r\n            if (activeNodes != null) {\r\n\r\n                // loop through all the active nodes\r\n                for (var a = 0; a < activeNodes.length; a++) {\r\n                    var activeNode = activeNodes[a];\r\n\r\n                    if (activeNode != null) {\r\n                        if (nodeId === activeNode.id) {\r\n                            // we have found the node we want to remove\r\n                            node = activeNode;\r\n\r\n                            // remove the node from the array\r\n                            activeNodes.splice(a, 1);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Remove the node from the inactive nodes array\r\n     * @param nodeId the node to remove\r\n     * @returns the node that was removed\r\n     */\r\n    removeNodeFromInactiveNodes(nodeId) {\r\n        var node = null;\r\n\r\n        if (nodeId != null) {\r\n\r\n            // get all the inactive nodes\r\n            var inactiveNodes = this.project.inactiveNodes;\r\n\r\n            if (inactiveNodes != null) {\r\n\r\n                // loop through all the inactive nodes\r\n                for (var i = 0; i < inactiveNodes.length; i++) {\r\n                    var inactiveNode = inactiveNodes[i];\r\n\r\n                    if (inactiveNode != null) {\r\n                        if (nodeId === inactiveNode.id) {\r\n                            // we have found the node we want to remove\r\n                            node = inactiveNode;\r\n\r\n                            // remove the node from the array\r\n                            inactiveNodes.splice(i, 1);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Load the inactive nodes\r\n     * @param nodes the inactive nodes\r\n     */\r\n    loadInactiveNodes(nodes) {\r\n\r\n        if (nodes != null) {\r\n            for (var n = 0; n < nodes.length; n++) {\r\n                var node = nodes[n];\r\n\r\n                if (node != null) {\r\n                    var nodeId = node.id;\r\n\r\n                    // set the node into the mapping data structures\r\n                    this.setIdToNode(nodeId, node);\r\n                    this.setIdToElement(nodeId, node);\r\n\r\n                    this.inactiveNodes.push(node);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if the node is active\r\n     * @param nodeId the node to check\r\n     * @param componentId (optional) the component to check\r\n     * @returns whether the node or component is active\r\n     */\r\n    isActive(nodeId, componentId) {\r\n\r\n        if (nodeId != null) {\r\n\r\n            if (nodeId === 'inactiveNodes') {\r\n                // this occurs when the author puts a step into the inactive nodes\r\n                return false;\r\n            } else if (nodeId === 'inactiveGroups') {\r\n                // this occurs when the author puts a group into the inactive groups\r\n                return false;\r\n            } else if (this.isGroupNode(nodeId)) {\r\n                // the node is a group node\r\n\r\n                /*\r\n                 * all group nodes are active since we don't have an inactive\r\n                 * groups section\r\n                 */\r\n                return true;\r\n            } else {\r\n                // the node is a step node\r\n\r\n                // get all the active nodes\r\n                var activeNodes = this.project.nodes;\r\n\r\n                if (activeNodes != null) {\r\n\r\n                    // loop through all the active nodes\r\n                    for (var n = 0; n < activeNodes.length; n++) {\r\n\r\n                        // get an active node\r\n                        var activeNode = activeNodes[n];\r\n\r\n                        if (activeNode != null) {\r\n\r\n                            // get the active node id\r\n                            var activeNodeId = activeNode.id;\r\n\r\n                            if (nodeId == activeNodeId) {\r\n                                // we have found the node id we are looking for\r\n\r\n                                if (componentId != null) {\r\n                                    // we need to find the node id and component id\r\n\r\n                                    // get the components in the node\r\n                                    var activeComponents = activeNode.components;\r\n\r\n                                    if (activeComponents != null) {\r\n\r\n                                        // loop through all the components\r\n                                        for (var c = 0; c < activeComponents.length; c++) {\r\n\r\n                                            // get a component\r\n                                            var activeComponent = activeComponents[c];\r\n\r\n                                            if (activeComponent != null) {\r\n                                                var activeComponentId = activeComponent.id;\r\n\r\n                                                if (componentId == activeComponentId) {\r\n                                                    /*\r\n                                                     * we have found the component id we are\r\n                                                     * looking for so we are done\r\n                                                     */\r\n                                                    return true;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    //we only need to find the node id so we are done\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Move the node to the active nodes array\r\n     */\r\n    moveToActive(node) {\r\n        if (node != null) {\r\n\r\n            // make sure the node is inactive\r\n            if (!this.isActive(node.id)) {\r\n                // the node is inactive so we will move it to the active array\r\n\r\n                // remove the node from inactive nodes array\r\n                this.removeNodeFromInactiveNodes(node.id);\r\n\r\n                // add the node to the active array\r\n                this.addNode(node);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move the node to the inactive nodes array\r\n     * @param node the node to move\r\n     * @param nodeIdToInsertAfter place the node after this\r\n     */\r\n    moveToInactive(node, nodeIdToInsertAfter) {\r\n        if (node != null) {\r\n\r\n            // make sure the node is active\r\n            if (this.isActive(node.id)) {\r\n                // the node is active so we will move it to the inactive array\r\n\r\n                // remove the node from the active array\r\n                this.removeNodeFromActiveNodes(node.id);\r\n\r\n                // add the node to the inactive array\r\n                this.addInactiveNode(node, nodeIdToInsertAfter);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the node to the inactive nodes array\r\n     * @param node the node to move\r\n     * @param nodeIdToInsertAfter place the node after this\r\n     */\r\n    addInactiveNode(node, nodeIdToInsertAfter) {\r\n        if (node != null) {\r\n            var inactiveNodes = this.project.inactiveNodes;\r\n\r\n            if (inactiveNodes != null) {\r\n\r\n                // clear the transitions from this node\r\n                if (node.transitionLogic != null) {\r\n                    node.transitionLogic.transitions = [];\r\n                }\r\n\r\n                if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveSteps' || nodeIdToInsertAfter === 'inactiveNodes') {\r\n                    // put the node at the beginning of the inactive steps\r\n                    inactiveNodes.splice(0, 0, node);\r\n                } else {\r\n                    // put the node after one of the inactive nodes\r\n\r\n                    var added = false;\r\n\r\n                    // loop through all the inactive nodes\r\n                    for (var i = 0; i < inactiveNodes.length; i++) {\r\n                        var inactiveNode = inactiveNodes[i];\r\n\r\n                        if (inactiveNode != null) {\r\n                            if (nodeIdToInsertAfter === inactiveNode.id) {\r\n                                // we have found the position to place the node\r\n                                inactiveNodes.splice(i + 1, 0, node);\r\n                                added = true;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (!added) {\r\n                        /*\r\n                         * we haven't added the node yet so we will just add it\r\n                         * to the end of the array\r\n                         */\r\n                        inactiveNodes.push(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move an inactive node within the inactive nodes array\r\n     * @param node the node to move\r\n     * @param nodeIdToInsertAfter place the node after this\r\n     */\r\n    moveInactiveNode(node, nodeIdToInsertAfter) {\r\n\r\n        if (node != null) {\r\n            var inactiveNodes = this.project.inactiveNodes;\r\n\r\n            if (inactiveNodes != null) {\r\n\r\n                // remove the node from inactive nodes\r\n\r\n                // loop through all the inactive nodes\r\n                for (var i = 0; i < inactiveNodes.length; i++) {\r\n                    var inactiveNode = inactiveNodes[i];\r\n\r\n                    if (inactiveNode != null) {\r\n                        if (node.id === inactiveNode.id) {\r\n                            // we have found the node we want to remove\r\n                            inactiveNodes.splice(i, 1);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // add the node back into the inactive nodes\r\n\r\n                if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveSteps' || nodeIdToInsertAfter === 'inactiveNodes') {\r\n                    // put the node at the beginning of the inactive nodes\r\n                    inactiveNodes.splice(0, 0, node);\r\n                } else {\r\n                    // put the node after one of the inactive nodes\r\n\r\n                    var added = false;\r\n\r\n                    // loop through all the inactive nodes\r\n                    for (var i = 0; i < inactiveNodes.length; i++) {\r\n                        var inactiveNode = inactiveNodes[i];\r\n\r\n                        if (inactiveNode != null) {\r\n                            if (nodeIdToInsertAfter === inactiveNode.id) {\r\n                                // we have found the position to place the node\r\n                                inactiveNodes.splice(i + 1, 0, node);\r\n                                added = true;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if (!added) {\r\n                        /*\r\n                         * we haven't added the node yet so we will just add it\r\n                         * to the end of the array\r\n                         */\r\n                        inactiveNodes.push(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove transitions that go into the group\r\n     * @param nodeId the group id\r\n     */\r\n    removeTransitionsIntoGroup(nodeId) {\r\n\r\n        if (nodeId != null) {\r\n\r\n            var group = this.getNodeById(nodeId);\r\n\r\n            if (group != null) {\r\n                var childIds = group.ids;\r\n\r\n                if (childIds != null) {\r\n\r\n                    // loop through all the children\r\n                    for (var c = 0; c < childIds.length; c++) {\r\n                        var childId = childIds[c];\r\n\r\n                        if (childId != null) {\r\n                            this.removeTransitionsThatPointToNodeIdFromOutsideGroup(childId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove the transitions that point to the node that does not have\r\n     * the same parent\r\n     * @param nodeId remove transitions to this node\r\n     */\r\n    removeTransitionsThatPointToNodeIdFromOutsideGroup(nodeId) {\r\n\r\n        if (nodeId != null) {\r\n\r\n            // get the parent of the node\r\n            var parentGroupId = this.getParentGroupId(nodeId);\r\n\r\n            // get all the nodes that point to the node\r\n            var nodesThatPointToTargetNode = this.getNodesByToNodeId(nodeId);\r\n\r\n            if (nodesThatPointToTargetNode != null) {\r\n\r\n                // loop through all the nodes that point to the node\r\n                for (var n = 0; n < nodesThatPointToTargetNode.length; n++) {\r\n                    var nodeThatPointsToTargetNode = nodesThatPointToTargetNode[n];\r\n\r\n                    if (nodeThatPointsToTargetNode != null) {\r\n\r\n                        // get the parent of the node that points to the node target node\r\n                        var nodeThatPointsToTargetNodeParentGroupId = this.getParentGroupId(nodeThatPointsToTargetNode.id);\r\n\r\n                        if (parentGroupId != nodeThatPointsToTargetNodeParentGroupId) {\r\n                            /*\r\n                             * the parent groups are different so we will remove\r\n                             * the transition\r\n                             */\r\n                            this.removeTransition(nodeThatPointsToTargetNode, nodeId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a transition\r\n     * @param node remove a transition in this node\r\n     * @param toNodeId remove the transition that goes to this node id\r\n     */\r\n    removeTransition(node, toNodeId) {\r\n\r\n        if (node != null && toNodeId != null) {\r\n\r\n            var transitionLogic = node.transitionLogic;\r\n\r\n            if (transitionLogic != null) {\r\n                var transitions = transitionLogic.transitions;\r\n\r\n                if (transitions != null) {\r\n\r\n                    // loop through all the transitions\r\n                    for (var t = 0; t < transitions.length; t++) {\r\n                        var transition = transitions[t];\r\n\r\n                        if (transition != null) {\r\n                            if (toNodeId === transition.to) {\r\n                                // we have found a transition that goes to the toNodeId\r\n\r\n                                // remove the transition\r\n                                transitions.splice(t, 1);\r\n                                t--;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove transitions that go out of the group\r\n     * @param nodeId the group id\r\n     */\r\n    removeTransitionsOutOfGroup(nodeId) {\r\n        if (nodeId != null) {\r\n            var group = this.getNodeById(nodeId);\r\n\r\n            if (group != null) {\r\n                var childIds = group.ids;\r\n\r\n                if (childIds != null) {\r\n\r\n                    // loop through all the child ids\r\n                    for (var c = 0; c < childIds.length; c++) {\r\n                        var childId = childIds[c];\r\n\r\n                        if (childId != null) {\r\n\r\n                            // get the transitions of the child\r\n                            var transitions = this.getTransitionsByFromNodeId(childId);\r\n\r\n                            if (transitions != null) {\r\n\r\n                                // loop through all the transitions\r\n                                for (var t = 0; t < transitions.length; t++) {\r\n                                    var transition = transitions[t];\r\n\r\n                                    if (transition != null) {\r\n\r\n                                        // get the to node id of the transition\r\n                                        var toNodeId = transition.to;\r\n\r\n                                        if (toNodeId != null) {\r\n\r\n                                            // get the parent group id of the toNodeId\r\n                                            var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\r\n\r\n                                            if (nodeId != toNodeIdParentGroupId) {\r\n                                                /*\r\n                                                 * the parent group is different which means it is a\r\n                                                 * transition that goes out of the group\r\n                                                 */\r\n\r\n                                                // remove the transition\r\n                                                transitions.splice(t, 1);\r\n                                                t--;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Update the step transitions that point into the group we are moving\r\n     * For example\r\n     * group1 has children node1 and node2 (node2 transitions to node3)\r\n     * group2 has children node3 and node4 (node4 transitions to node5)\r\n     * group3 has children node5 and node6\r\n     * if we move group2 after group3 we will need to change the\r\n     * transition from node2 to node3 and make node2 transition to node5\r\n     * the result will be\r\n     * group1 has children node1 and node2 (node2 transitions to node5)\r\n     * group3 has children node5 and node6\r\n     * group2 has children node3 and node4 (node4 transitions to node5)\r\n     * note: the (node4 transition to node5) will be removed later\r\n     * when is called removeTransitionsOutOfGroup\r\n     * note: when group2 is added in a later function call, we will add\r\n     * the node6 to node3 transition\r\n     * @param groupThatTransitionsToGroupWeAreMoving the group object\r\n     * that transitions to the group we are moving. we may need to update\r\n     * the transitions of this group's children.\r\n     * @param groupIdWeAreMoving the group id of the group we are moving\r\n     */\r\n    updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving) {\r\n\r\n        if (groupThatTransitionsToGroupWeAreMoving != null && groupIdWeAreMoving != null) {\r\n            var group = this.getNodeById(groupIdWeAreMoving);\r\n\r\n            if (group != null) {\r\n                // get all the nodes that have a transition to the node we are removing\r\n                var nodesByToNodeId = this.getNodesByToNodeId(groupIdWeAreMoving);\r\n\r\n                // get the transitions of the node we are removing\r\n                var nodeToRemoveTransitionLogic = group.transitionLogic;\r\n                var nodeToRemoveTransitions = [];\r\n\r\n                if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\r\n                    nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\r\n                }\r\n\r\n                if (nodeToRemoveTransitions.length == 0) {\r\n                    /*\r\n                     * The group we are moving is the last group in the project\r\n                     * and does not have any transitions. We will loop through\r\n                     * all the nodes that transition into this group and remove\r\n                     * those transitions.\r\n                     */\r\n\r\n                    // get child ids of the group that comes before the group we are moving\r\n                    var childIds = groupThatTransitionsToGroupWeAreMoving.ids;\r\n\r\n                    if (childIds != null) {\r\n\r\n                        // loop through all the children\r\n                        for (var c = 0; c < childIds.length; c++) {\r\n                            var childId = childIds[c];\r\n\r\n                            var transitionsFromChild = this.getTransitionsByFromNodeId(childId);\r\n\r\n                            if (transitionsFromChild != null) {\r\n\r\n                                // loop through all the transitions from the child\r\n                                for (var tfc = 0; tfc < transitionsFromChild.length; tfc++) {\r\n                                    var transitionFromChild = transitionsFromChild[tfc];\r\n\r\n                                    if (transitionFromChild != null) {\r\n                                        var toNodeId = transitionFromChild.to;\r\n\r\n                                        // get the parent group id of the toNodeId\r\n                                        var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\r\n\r\n                                        if (groupIdWeAreMoving === toNodeIdParentGroupId) {\r\n                                            // the transition is to a child in the group we are moving\r\n\r\n                                            // remove the transition\r\n                                            transitionsFromChild.splice(tfc, 1);\r\n\r\n                                            /*\r\n                                             * move the counter back one because we have just removed an\r\n                                             * element from the array\r\n                                             */\r\n                                            tfc--;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else if (nodeToRemoveTransitions.length > 0) {\r\n\r\n                    // get the first group that comes after the group we are removing\r\n                    var firstNodeToRemoveTransition = nodeToRemoveTransitions[0];\r\n                    var firstNodeToRemoveTransitionToNodeId = firstNodeToRemoveTransition.to;\r\n\r\n                    if (this.isGroupNode(firstNodeToRemoveTransitionToNodeId)) {\r\n\r\n                        // get the group that comes after the group we are moving\r\n                        var groupNode = this.getNodeById(firstNodeToRemoveTransitionToNodeId);\r\n\r\n                        // get child ids of the group that comes before the group we are moving\r\n                        var childIds = groupThatTransitionsToGroupWeAreMoving.ids;\r\n\r\n                        if (childIds != null) {\r\n\r\n                            // loop through all the children\r\n                            for (var c = 0; c < childIds.length; c++) {\r\n                                var childId = childIds[c];\r\n\r\n                                var transitionsFromChild = this.getTransitionsByFromNodeId(childId);\r\n\r\n                                if (transitionsFromChild != null) {\r\n\r\n                                    // loop through all the transitions from the child\r\n                                    for (var tfc = 0; tfc < transitionsFromChild.length; tfc++) {\r\n                                        var transitionFromChild = transitionsFromChild[tfc];\r\n\r\n                                        if (transitionFromChild != null) {\r\n                                            var toNodeId = transitionFromChild.to;\r\n\r\n                                            // get the parent group id of the toNodeId\r\n                                            var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\r\n\r\n                                            if (groupIdWeAreMoving === toNodeIdParentGroupId) {\r\n                                                // the transition is to a child in the group we are moving\r\n\r\n                                                if (groupNode.startId == null) {\r\n                                                    // change the transition to point to the after group\r\n                                                    transitionFromChild.to = firstNodeToRemoveTransitionToNodeId;\r\n                                                } else {\r\n                                                    // change the transition to point to the start id of the after group\r\n                                                    transitionFromChild.to = groupNode.startId;\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the node ids and component ids in a node\r\n     * @param nodeId get the node ids and component ids in this node\r\n     * @returns an array of objects. the objects contain a node id\r\n     * and component id.\r\n     */\r\n    getNodeIdsAndComponentIds(nodeId) {\r\n\r\n        var nodeIdAndComponentIds = [];\r\n\r\n        if (nodeId != null) {\r\n\r\n            var nodeContent = this.getNodeContentByNodeId(nodeId);\r\n\r\n            if (nodeContent != null) {\r\n\r\n                var components = nodeContent.components;\r\n\r\n                if (components != null) {\r\n\r\n                    // loop through all the components in the node\r\n                    for (var c = 0; c < components.length; c++) {\r\n                        var component = components[c];\r\n\r\n                        if (component != null) {\r\n\r\n                            var componentId = component.id;\r\n\r\n                            // create an object to hold the node id and component id\r\n                            var nodeIdAndComponentId = {};\r\n                            nodeIdAndComponentId.nodeId = nodeId;\r\n                            nodeIdAndComponentId.componentId = componentId;\r\n\r\n                            // add the object to the array\r\n                            nodeIdAndComponentIds.push(nodeIdAndComponentId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodeIdAndComponentIds;\r\n    }\r\n\r\n    /**\r\n     * Get the show previous work node ids and component ids in a node\r\n     * @param nodeId get the show previous work node ids and component ids in\r\n     * this node\r\n     * @returns an array of objects. the objects contain a node id\r\n     * and component id.\r\n     */\r\n    getShowPreviousWorkNodeIdsAndComponentIds(nodeId) {\r\n\r\n        var nodeIdAndComponentIds = [];\r\n\r\n        if (nodeId != null) {\r\n            var nodeContent = this.getNodeContentByNodeId(nodeId);\r\n\r\n            if (nodeContent != null) {\r\n\r\n                var components = nodeContent.components;\r\n\r\n                if (components != null) {\r\n\r\n                    // loop through all the components\r\n                    for (var c = 0; c < components.length; c++) {\r\n                        var component = components[c];\r\n\r\n                        if (component != null) {\r\n                            var showPreviousWorkNodeId = component.showPreviousWorkNodeId;\r\n                            var showPreviousWorkComponentId = component.showPreviousWorkComponentId;\r\n\r\n                            if (showPreviousWorkNodeId != null && showPreviousWorkComponentId != null) {\r\n\r\n                                // create an object to hold the node id and component id\r\n                                var nodeIdAndComponentId = {};\r\n                                nodeIdAndComponentId.nodeId = showPreviousWorkNodeId;\r\n                                nodeIdAndComponentId.componentId = showPreviousWorkComponentId;\r\n\r\n                                // add the object to the array\r\n                                nodeIdAndComponentIds.push(nodeIdAndComponentId);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodeIdAndComponentIds;\r\n    }\r\n\r\n    /**\r\n     * Check if we need to display the annotation to the student\r\n     * @param annotation the annotation\r\n     * @returns whether we need to display the annotation to the student\r\n     */\r\n    displayAnnotation(annotation) {\r\n\r\n        var result = true;\r\n\r\n        if (annotation != null) {\r\n            var nodeId = annotation.nodeId;\r\n            var componentId = annotation.componentId;\r\n\r\n            // get the component content\r\n            var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\r\n\r\n            if (component != null) {\r\n                var componentType = component.type;\r\n\r\n                // get the component service\r\n                var componentService = this.$injector.get(componentType + 'Service');\r\n\r\n                if (componentService != null && componentService.displayAnnotation != null) {\r\n                    // check if we need to display the annotation to the student\r\n                    result = componentService.displayAnnotation(component, annotation);\r\n                    /*if (annotation.data != null && annotation.data.isGlobal && annotation.data.isPopup) {\r\n                        result = false;  // don't display annotation inline; it will be displayed in a popup\r\n                    }*/\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the global annotation properties for the specified component and score, if exists.\r\n     * @param component the component content\r\n     * @param previousScore the previousScore we want the annotation properties for, can be null, which means we just want to look at\r\n     * the currentScore\r\n     * @param currentScore the currentScore we want the annotation properties for\r\n     * @returns the annotation properties for the given score\r\n     */\r\n    getGlobalAnnotationGroupByScore(component, previousScore, currentScore) {\r\n\r\n        let annotationGroup = null;\r\n\r\n        if (component.globalAnnotationSettings != null && component.globalAnnotationSettings.globalAnnotationGroups != null) {\r\n            let globalAnnotationGroups = component.globalAnnotationSettings.globalAnnotationGroups;\r\n\r\n            for (let g = 0; g < globalAnnotationGroups.length; g++) {\r\n                let globalAnnotationGroup = globalAnnotationGroups[g];\r\n\r\n                if (globalAnnotationGroup.enableCriteria != null && globalAnnotationGroup.enableCriteria.scoreSequence != null) {\r\n                    let scoreSequence = globalAnnotationGroup.enableCriteria.scoreSequence;\r\n\r\n                    if (scoreSequence != null) {\r\n                        /*\r\n                         * get the expected previous score and current score\r\n                         * that will satisfy the rule\r\n                         */\r\n                        let previousScoreMatch = scoreSequence[0];\r\n                        let currentScoreMatch = scoreSequence[1];\r\n\r\n                        if (previousScore == null) {\r\n                            // just matching on the current score\r\n                            if (previousScoreMatch == \"\" &&\r\n                                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\r\n                                // found a match\r\n                                annotationGroup = globalAnnotationGroup;\r\n                                break;\r\n                            }\r\n                        } else {\r\n                            if (previousScore.toString().match(\"[\" + previousScoreMatch + \"]\") &&\r\n                                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\r\n                                /*\r\n                                 * the previous score and current score match the\r\n                                 * expected scores so we have found the rule we want\r\n                                 */\r\n                                annotationGroup = globalAnnotationGroup;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return annotationGroup;\r\n    }\r\n\r\n    /**\r\n     * Get the notification for the given score, if exists.\r\n     * @param component the component content\r\n     * @param previousScore the previousScore we want notification for, can be null, which means we just want to look at\r\n     * the currentScore\r\n     * @param currentScore the currentScore we want notification for\r\n     * @returns the notification for the given score\r\n     */\r\n    getNotificationByScore(component, previousScore, currentScore) {\r\n\r\n        let notificationResult = null;\r\n\r\n        if (component.notificationSettings != null && component.notificationSettings.notifications != null) {\r\n            let notifications = component.notificationSettings.notifications;\r\n            for (let n = 0; n < notifications.length; n++) {\r\n                let notification = notifications[n];\r\n                if (notification.enableCriteria != null && notification.enableCriteria.scoreSequence != null) {\r\n                    let scoreSequence = notification.enableCriteria.scoreSequence;\r\n\r\n                    if (scoreSequence != null) {\r\n\r\n                        /*\r\n                         * get the expected previous score and current score\r\n                         * that will satisfy the rule\r\n                         */\r\n                        let previousScoreMatch = scoreSequence[0];\r\n                        let currentScoreMatch = scoreSequence[1];\r\n\r\n                        if (previousScore == null) {\r\n                            // just matching on the current score\r\n                            if (previousScoreMatch == \"\" &&\r\n                                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\r\n                                // found a match\r\n                                notificationResult = notification;\r\n                                break;\r\n                            }\r\n                        } else {\r\n                            if (previousScore.toString().match(\"[\" + previousScoreMatch + \"]\") &&\r\n                                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\r\n                                /*\r\n                                 * the previous score and current score match the\r\n                                 * expected scores so we have found the rule we want\r\n                                 */\r\n                                notificationResult = notification;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return notificationResult;\r\n    }\r\n\r\n    /**\r\n     * Returns a project template for new projects\r\n     */\r\n    getNewProjectTemplate() {\r\n        return {\r\n            \"nodes\": [\r\n                {\r\n                    \"id\": \"group0\",\r\n                    \"type\": \"group\",\r\n                    \"title\": \"Master\",\r\n                    \"startId\": \"group1\",\r\n                    \"ids\": [\r\n                        \"group1\"\r\n                    ]\r\n                },\r\n                {\r\n                    \"id\": \"group1\",\r\n                    \"type\": \"group\",\r\n                    \"title\": this.$translate('FIRST_ACTIVITY'),\r\n                    \"startId\": \"\",\r\n                    \"ids\": [\r\n                    ],\r\n                    \"icons\": {\r\n                        \"default\": {\r\n                            \"color\": \"#2196F3\",\r\n                            \"type\": \"font\",\r\n                            \"fontSet\": \"material-icons\",\r\n                            \"fontName\": \"info\"\r\n                        }\r\n                    }\r\n                }\r\n            ],\r\n            \"constraints\": [],\r\n            \"startGroupId\": \"group0\",\r\n            \"startNodeId\": \"group0\",\r\n            \"navigationMode\": \"guided\",\r\n            \"layout\": {\r\n                \"template\": \"starmap|leftNav|rightNav\"\r\n            },\r\n            \"metadata\": {\r\n                \"title\": this.$translate('MY_NEW_PROJECT')\r\n            },\r\n            \"notebook\": {\r\n                \"enabled\": false,\r\n                \"label\": this.$translate('NOTEBOOK'),\r\n                \"enableAddNew\": true,\r\n                \"itemTypes\": {\r\n                    \"note\": {\r\n                        \"type\": \"note\",\r\n                        \"enabled\": true,\r\n                        \"enableLink\": true,\r\n                        \"enableAddNote\": true,\r\n                        \"enableClipping\": true,\r\n                        \"enableStudentUploads\": true,\r\n                        \"requireTextOnEveryNote\": false,\r\n                        \"label\": {\r\n                            \"singular\": this.$translate('NOTE_LOWERCASE'),\r\n                            \"plural\": this.$translate('NOTES_LOWERCASE'),\r\n                            \"link\": this.$translate('NOTES'),\r\n                            \"icon\": \"note\",\r\n                            \"color\": \"#1565C0\"\r\n                        }\r\n                    },\r\n                    \"question\": {\r\n                        \"type\": \"question\",\r\n                        \"enabled\": false,\r\n                        \"enableLink\": true,\r\n                        \"enableClipping\": true,\r\n                        \"enableStudentUploads\": true,\r\n                        \"label\": {\r\n                            \"singular\": this.$translate('QUESTION_LOWER_CASE'),\r\n                            \"plural\": this.$translate('QUESTIONS_LOWER_CASE'),\r\n                            \"link\": this.$translate('QUESTIONS'),\r\n                            \"icon\": \"live_help\",\r\n                            \"color\": \"#F57C00\"\r\n                        }\r\n                    },\r\n                    \"report\": {\r\n                        \"enabled\": false,\r\n                        \"label\": {\r\n                            \"singular\": this.$translate('REPORT_LOWERCASE'),\r\n                            \"plural\": this.$translate('REPORTS_LOWERCASE'),\r\n                            \"link\": this.$translate('REPORT'),\r\n                            \"icon\": \"assignment\",\r\n                            \"color\": \"#AD1457\"\r\n                        },\r\n                        \"notes\": [\r\n                            {\r\n                                \"reportId\": \"finalReport\",\r\n                                \"title\": this.$translate('FINAL_REPORT'),\r\n                                \"description\": this.$translate('REPORT_DESCRIPTION'),\r\n                                \"prompt\": this.$translate('REPORT_PROMPT'),\r\n                                \"content\": this.$translate('REPORT_CONTENT')\r\n                            }\r\n                        ]\r\n                    }\r\n                }\r\n            },\r\n            \"inactiveGroups\": [],\r\n            \"inactiveNodes\": []\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Check if a node generates work by looking at all of its components\r\n     * @param nodeId the node id\r\n     * @return whether the node generates work\r\n     */\r\n    nodeHasWork(nodeId) {\r\n        var result = false;\r\n\r\n        if (nodeId != null) {\r\n\r\n            // get the node content object\r\n            var nodeContent = this.getNodeContentByNodeId(nodeId);\r\n\r\n            if (nodeContent != null) {\r\n                var components = nodeContent.components;\r\n\r\n                if (components != null) {\r\n\r\n                    // loop through all the components in the node\r\n                    for (var c = 0; c < components.length; c++) {\r\n                        var component = components[c];\r\n\r\n                        if (component != null) {\r\n\r\n                            // check if the component generates work\r\n                            var componentHasWork = this.componentHasWork(component);\r\n\r\n                            if (componentHasWork) {\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check if a component generates work\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     * @return whether the component generates work\r\n     */\r\n    componentHasWorkByNodeIdAndComponentId(nodeId, componentId) {\r\n        var result = false;\r\n\r\n        if (nodeId != null) {\r\n\r\n            // get the node content object\r\n            var nodeContent = this.getNodeContentByNodeId(nodeId);\r\n\r\n            if (nodeContent != null) {\r\n                var components = nodeContent.components;\r\n\r\n                if (components != null) {\r\n\r\n                    // loop through the components\r\n                    for (var c = 0; c < components.length; c++) {\r\n                        var component = components[c];\r\n\r\n                        if (component != null && componentId == component.id) {\r\n                            // we have found the component we are looking for\r\n\r\n                            // check if the component generates work\r\n                            var componentHasWork = this.componentHasWork(component);\r\n\r\n                            if (componentHasWork) {\r\n                                // the component generates work\r\n                                return true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check if a component generates work\r\n     * @param component check if this component generates work\r\n     * @return whether the component generates work\r\n     */\r\n    componentHasWork(component) {\r\n        var result = false;\r\n\r\n        if (component != null) {\r\n            var componentType = component.type;\r\n\r\n            // get the component service\r\n            var componentService = this.getComponentService(componentType);\r\n\r\n            if (componentService != null) {\r\n                // check if the component generates work\r\n                result = componentService.componentHasWork(component);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get a component service\r\n     * @param componentType the component type\r\n     * @return the component service\r\n     */\r\n    getComponentService(componentType) {\r\n\r\n        var componentService = null;\r\n\r\n        if (componentType != null) {\r\n\r\n            // get the component service name e.g. 'OpenResponseService'\r\n            var componentServiceName = componentType + 'Service';\r\n\r\n            /*\r\n             * check if we have previously retrieved the component service.\r\n             * if have previously retrieved the component service it will\r\n             * be in the componentServices map\r\n             */\r\n            componentService = this.componentServices[componentServiceName];\r\n\r\n            if (componentService == null) {\r\n                /*\r\n                 * we have not previously retrieved the component service so\r\n                 * we will get it now\r\n                 */\r\n                componentService = this.$injector.get(componentServiceName);\r\n\r\n                /*\r\n                 * save the component service to the map so we can easily\r\n                 * retrieve it later\r\n                 */\r\n                this.componentServices[componentServiceName] = componentService;\r\n            }\r\n        }\r\n\r\n        return componentService;\r\n    }\r\n\r\n    /**\r\n     * Check if a node is inactive. At the moment only step nodes can be\r\n     * inactive.\r\n     * @param nodeId the node id of the step\r\n     */\r\n    isInactive(nodeId) {\r\n\r\n        var result = false;\r\n\r\n        if (nodeId != null && this.project.inactiveNodes != null) {\r\n\r\n            // loop through all the inactive nodes\r\n            for (var i = 0; i < this.project.inactiveNodes.length; i++) {\r\n\r\n                // get an inactive node\r\n                var inactiveNode = this.project.inactiveNodes[i];\r\n\r\n                if (inactiveNode != null) {\r\n\r\n                    if (nodeId === inactiveNode.id) {\r\n                        /*\r\n                         * we have found the node id we are looking for which\r\n                         * means the node is inactive\r\n                         */\r\n                        result = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get an unused component id\r\n     * @return a component id that isn't already being used in the project\r\n     */\r\n    getUnusedComponentId() {\r\n        // we want to make an id with 10 characters\r\n        var idLength = 10;\r\n\r\n        // generate a new id\r\n        var newComponentId = this.UtilService.generateKey(idLength);\r\n\r\n        // check if the component id is already used in the project\r\n        if (this.isComponentIdUsed(newComponentId)) {\r\n            /*\r\n             * the component id is already used in the project so we need to\r\n             * try generating another one\r\n             */\r\n            var alreadyUsed = true;\r\n\r\n            /*\r\n             * keep trying to generate a new component id until we have found\r\n             * one that isn't already being used\r\n             */\r\n            while(!alreadyUsed) {\r\n                // generate a new id\r\n                newComponentId = this.UtilService.generateKey(idLength);\r\n\r\n                // check if the id is already being used in the project\r\n                alreadyUsed = this.isComponentIdUsed(newComponentId);\r\n            }\r\n        }\r\n\r\n        return newComponentId;\r\n    }\r\n\r\n    /**\r\n     * Check if the component id is already being used in the project\r\n     * @param componentId check if this component id is already being used in\r\n     * the project\r\n     * @return whether the component id is already being used in the project\r\n     */\r\n    isComponentIdUsed(componentId) {\r\n        var isUsed = false;\r\n\r\n        // loop through all the active nodes\r\n        for (var n = 0; n < this.project.nodes.length; n++) {\r\n\r\n            // get an active node\r\n            var node = this.project.nodes[n];\r\n\r\n            if (node != null) {\r\n                var components = node.components;\r\n\r\n                if (components != null) {\r\n\r\n                    // loop through all the components\r\n                    for (var c = 0; c < components.length; c++) {\r\n                        var component = components[c];\r\n\r\n                        if (component != null) {\r\n                            if (componentId === component.id) {\r\n                                // the component id is already being used\r\n                                isUsed = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // loop through all the inactive nodes\r\n        for (var n = 0; n < this.project.inactiveNodes.length; n++) {\r\n\r\n            // get an inactive node\r\n            var node = this.project.inactiveNodes[n];\r\n\r\n            if (node != null) {\r\n                var components = node.components;\r\n\r\n                if (components != null) {\r\n\r\n                    // loop through all the components\r\n                    for (var c = 0; c < components.length; c++) {\r\n                        var component = components[c];\r\n\r\n                        if (component != null) {\r\n                            if (componentId === component.id) {\r\n                                // the component id is already being used\r\n                                isUsed = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return isUsed;\r\n    }\r\n\r\n    /**\r\n     * Check if a node id is already being used in the project\r\n     * @param nodeId check if this node id is already being used in the project\r\n     * @return whether the node id is already being used in the project\r\n     */\r\n    isNodeIdUsed(nodeId) {\r\n        var isUsed = false;\r\n\r\n        // loop through all the active nodes\r\n        for (var n = 0; n < this.project.nodes.length; n++) {\r\n\r\n            // get an active node\r\n            var node = this.project.nodes[n];\r\n\r\n            if (node != null) {\r\n\r\n                if (nodeId === node.id) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // loop through all the inactive nodes\r\n        for (var n = 0; n < this.project.inactiveNodes.length; n++) {\r\n\r\n            // get an inactive node\r\n            var node = this.project.inactiveNodes[n];\r\n\r\n            if (node != null) {\r\n\r\n                if (nodeId === node.id) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return isUsed;\r\n    }\r\n\r\n    /**\r\n     * Copy the nodes into the project\r\n     * @param selectedNodes the nodes to import\r\n     * @param fromProjectId copy the nodes from this project\r\n     * @param toProjectId copy the nodes into this project\r\n     */\r\n    copyNodes(selectedNodes, fromProjectId, toProjectId) {\r\n\r\n        // get the import steps URL\r\n        var importStepsURL = this.ConfigService.getConfigParam('importStepsURL');\r\n\r\n        var httpParams = {};\r\n        httpParams.method = 'POST';\r\n        httpParams.url = importStepsURL;\r\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\r\n\r\n        // set the POST params\r\n        var params = {};\r\n        params.steps = angular.toJson(selectedNodes);\r\n        params.fromProjectId = fromProjectId;\r\n        params.toProjectId = toProjectId;\r\n        httpParams.data = $.param(params);\r\n\r\n        /*\r\n         * Make the request to import the steps. This will copy the asset files\r\n         * and change file names if necessary. If an asset file with the same\r\n         * name exists in both projects we will check if their content is the\r\n         * same. If the content is the same we don't need to copy the file. If\r\n         * the content is different, we need to make a copy of the file with a\r\n         * new name and change all the references in the steps to use the new\r\n         * name.\r\n         */\r\n        return this.$http(httpParams).then((result) => {\r\n\r\n            // get the selected nodes from the result that may have been modified\r\n            selectedNodes = result.data;\r\n\r\n            // get the inactive nodes from the project\r\n            var inactiveNodes = this.getInactiveNodes();\r\n\r\n            // we will insert the steps into the inactive steps\r\n            var nodeIdToInsertAfter = 'inactiveSteps';\r\n\r\n            // loop through the nodes we will import\r\n            for (var n = 0; n < selectedNodes.length; n++) {\r\n\r\n                // get a node\r\n                var selectedNode = selectedNodes[n];\r\n\r\n                if (selectedNode != null) {\r\n\r\n                    /*\r\n                     * Insert the node after the last inactive node. If there\r\n                     * are no inactive nodes it will just be placed in the\r\n                     * inactive nodes section. In the latter case we do this by\r\n                     * setting nodeIdToInsertAfter to 'inactiveSteps'.\r\n                     */\r\n                    if (inactiveNodes != null && inactiveNodes.length > 0) {\r\n                        nodeIdToInsertAfter = inactiveNodes[inactiveNodes.length - 1];\r\n                    }\r\n\r\n                    // make a copy of the node so that we don't modify the source\r\n                    var tempNode = this.UtilService.makeCopyOfJSONObject(selectedNode);\r\n\r\n                    // check if the node id is already being used in the current project\r\n                    if (this.isNodeIdUsed(tempNode.id)) {\r\n                        // the node id is already being used in the current project\r\n\r\n                        // get the next available node id\r\n                        var nextAvailableNodeId = this.getNextAvailableNodeId();\r\n\r\n                        // change the node id of the node we are importing\r\n                        tempNode.id = nextAvailableNodeId;\r\n                    }\r\n\r\n                    // get the components in the node\r\n                    var tempComponents = tempNode.components;\r\n\r\n                    if (tempComponents != null) {\r\n\r\n                        // loop through all the components in the node we are importing\r\n                        for (var c = 0; c < tempComponents.length; c++) {\r\n\r\n                            // get a component\r\n                            var tempComponent = tempComponents[c];\r\n\r\n                            if (tempComponent != null) {\r\n\r\n                                // check if the component id is already being used\r\n                                if (this.isComponentIdUsed(tempComponent.id)) {\r\n                                    // we are already using the component id so we will need to change it\r\n\r\n                                    // find a component id that isn't currently being used\r\n                                    var newComponentId = this.getUnusedComponentId();\r\n\r\n                                    // set the new component id into the component\r\n                                    tempComponent.id = newComponentId;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // clear the constraints\r\n                    tempNode.constraints = [];\r\n\r\n                    // add the imported node to the end of the inactive nodes\r\n                    this.addInactiveNode(tempNode, nodeIdToInsertAfter);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the next available constraint id for a node\r\n     * @param nodeId get the next available constraint id for this node\r\n     * e.g. node8Constraint2\r\n     * @return the next available constraint id for the node\r\n     */\r\n    getNextAvailableConstraintIdForNodeId(nodeId) {\r\n\r\n        var nextAvailableConstraintId = null;\r\n\r\n        if (nodeId != null) {\r\n\r\n            // an array to hold the constraint ids that are already being used\r\n            var usedConstraintIds = [];\r\n\r\n            // get the node\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n                var constraints = node.constraints;\r\n\r\n                if (constraints != null) {\r\n\r\n                    // loop through all the constraints\r\n                    for (var c = 0; c < constraints.length; c++) {\r\n                        var constraint = constraints[c];\r\n\r\n                        if (constraint != null) {\r\n                            var constraintId = constraint.id;\r\n\r\n                            // add the constraint id to the array of used constraint ids\r\n                            usedConstraintIds.push(constraintId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            var foundNextAvailableConstraintId = false;\r\n            var counter = 1;\r\n\r\n            // loop until we have found a constraint id that hasn't been used\r\n            while(!foundNextAvailableConstraintId) {\r\n\r\n                // generate a constraint id\r\n                var potentialConstraintId = nodeId + 'Constraint' + counter;\r\n\r\n                // check if the constraint id has been used\r\n                if (usedConstraintIds.indexOf(potentialConstraintId) == -1) {\r\n                    // we have found a constraint id that has not been used\r\n                    nextAvailableConstraintId = potentialConstraintId;\r\n\r\n                    // we are done looping\r\n                    foundNextAvailableConstraintId = true;\r\n                } else {\r\n                    // we have found a constraint id that has been used\r\n                    counter++;\r\n                }\r\n            }\r\n        }\r\n\r\n        return nextAvailableConstraintId;\r\n    }\r\n\r\n    /**\r\n     * Set a field in the transition logic of a node\r\n     */\r\n    setTransitionLogicField(nodeId, field, value) {\r\n\r\n        if (nodeId != null && field != null) {\r\n\r\n            // get the node\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n\r\n                // get the transition logic\r\n                var transitionLogic = node.transitionLogic;\r\n\r\n                if (transitionLogic != null) {\r\n\r\n                    // set the value of the field\r\n                    transitionLogic[field] = value;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the criteria params field\r\n     * @param criteria the criteria object\r\n     * @param field the field name\r\n     * @param value the value to set into the field\r\n     */\r\n    setCriteriaParamsField(criteria, field, value) {\r\n\r\n        if (criteria != null) {\r\n\r\n            if (criteria.params == null) {\r\n\r\n                // create a params field since it does not exist\r\n                criteria.params = {};\r\n            }\r\n\r\n            // set the value of the field\r\n            criteria.params[field] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the criteria params field\r\n     * @param criteria the criteria object\r\n     * @param field the field name\r\n     */\r\n    getCriteriaParamsField(criteria, field) {\r\n\r\n        if (criteria != null) {\r\n\r\n            // get the params\r\n            var params = criteria.params;\r\n\r\n            if (params != null) {\r\n                // get the field value\r\n                return params[field];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Set the transition to value of a node\r\n     * @param fromNodeId the from node\r\n     * @param toNodeId the to node\r\n     */\r\n    setTransition(fromNodeId, toNodeId) {\r\n        var node = this.getNodeById(fromNodeId);\r\n\r\n        if (node != null) {\r\n            // get the transition logic of the node\r\n            var transitionLogic = node.transitionLogic;\r\n\r\n            if (transitionLogic != null) {\r\n\r\n                // get the transitions\r\n                var transitions = transitionLogic.transitions;\r\n\r\n                if (transitions == null || transitions.length == 0) {\r\n                    // there are no transitions so we will create one\r\n                    transitionLogic.transitions = [];\r\n\r\n                    // create a transition object\r\n                    var transition = {};\r\n                    transitionLogic.transitions.push(transition);\r\n\r\n                    transitions = transitionLogic.transitions;\r\n                }\r\n\r\n                if (transitions != null && transitions.length > 0) {\r\n\r\n                    // get the first transition. we will assume there is only one transition.\r\n                    var transition = transitions[0];\r\n\r\n                    if (transition != null) {\r\n                        // set the to value\r\n                        transition.to = toNodeId;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the node id that comes after a given node id\r\n     * @param nodeId get the node id that comes after this node id\r\n     * @param the node id that comes after the one that is passed in as a parameter\r\n     */\r\n    getNodeIdAfter(nodeId) {\r\n\r\n        var nodeIdAfter = null;\r\n\r\n        // get an array of ordered items. each item represents a node\r\n        var orderedItems = this.$filter('orderBy')(this.$filter('toArray')(this.idToOrder), 'order');\r\n\r\n        if (orderedItems != null) {\r\n\r\n            var foundNodeId = false;\r\n\r\n            // loop through all the items\r\n            for (var i = 0; i < orderedItems.length; i++) {\r\n\r\n                // get an item\r\n                var item = orderedItems[i];\r\n\r\n                if (item != null) {\r\n                    // get the node id of the item\r\n                    var tempNodeId = item.$key;\r\n\r\n                    // check if we have found the node id that was passed in as a parameter\r\n                    if (foundNodeId) {\r\n                        /*\r\n                         * we have previously found the node id that was passed in which means\r\n                         * the current temp node id is the one that comes after it\r\n                         */\r\n                        nodeIdAfter = tempNodeId;\r\n                        break;\r\n                    } else {\r\n\r\n                        if (nodeId == tempNodeId) {\r\n                            // we have found the node id that was passed in as a parameter\r\n                            foundNodeId = true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodeIdAfter;\r\n    }\r\n\r\n    /**\r\n     * Get the node ids in the branch by looking for nodes that have branch\r\n     * path taken constraints with the given fromNodeId and toNodeId\r\n     * @param fromNodeId the from node id\r\n     * @param toNodeId the to node id\r\n     * @return an array of nodes that are in the branch path\r\n     */\r\n    getNodeIdsInBranch(fromNodeId, toNodeId) {\r\n\r\n        var nodesInBranch = [];\r\n\r\n        // get all the nodes in the project\r\n        var nodes = this.getNodes();\r\n\r\n        if (nodes != null) {\r\n\r\n            // loop through all the nodes\r\n            for (var n = 0; n < nodes.length; n++) {\r\n                var node = nodes[n];\r\n\r\n                if (node != null) {\r\n                    if (this.hasBranchPathTakenConstraint(node, fromNodeId, toNodeId)) {\r\n                        /*\r\n                         * this node has the the branch path taken constraint we are\r\n                         * looking for\r\n                         */\r\n                        nodesInBranch.push(node.id);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return nodesInBranch;\r\n    }\r\n\r\n    /**\r\n     * Check if a node has a branch path taken constraint\r\n     * @param node the node to check\r\n     * @param fromNodeId the from node id of the branch path taken\r\n     * @param toNodeId the to node id of the branch path taken\r\n     * @return whether the node has a branch path taken constraint with the\r\n     * given from node id and to node id\r\n     */\r\n    hasBranchPathTakenConstraint(node, fromNodeId, toNodeId) {\r\n\r\n        if (node != null) {\r\n\r\n            // get the constraints in the node\r\n            var constraints = node.constraints;\r\n\r\n            if (constraints != null) {\r\n\r\n                // loop through all the constraints\r\n                for (var c = 0; c < constraints.length; c++) {\r\n                    var constraint = constraints[c];\r\n\r\n                    if (constraint != null) {\r\n\r\n                        // get the removal criteria of the constraint\r\n                        var removalCriteria = constraint.removalCriteria;\r\n\r\n                        if (removalCriteria != null) {\r\n\r\n                            // loop through all the removal criterion\r\n                            for (var r = 0; r < removalCriteria.length; r++) {\r\n\r\n                                // get a removal criterion\r\n                                var removalCriterion = removalCriteria[r];\r\n\r\n                                if (removalCriterion != null) {\r\n\r\n                                    // get the removal criterion name\r\n                                    var name = removalCriterion.name;\r\n\r\n                                    if (name == 'branchPathTaken') {\r\n                                        // this is a branch path taken constraint\r\n\r\n                                        // get the removal criterion params\r\n                                        var params = removalCriterion.params;\r\n\r\n                                        if (params != null) {\r\n                                            if (fromNodeId == params.fromNodeId && toNodeId == params.toNodeId) {\r\n                                                // the params match the from node id and to node id\r\n                                                return true;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add branch path taken constraints to the node\r\n     * @param targetNodeId the node to add the constraints to\r\n     * @param fromNodeId the from node id of the branch path taken constraint\r\n     * @param toNodeId the to node id of the branch path taken constraint\r\n     */\r\n    addBranchPathTakenConstraints(targetNodeId, fromNodeId, toNodeId) {\r\n\r\n        if (targetNodeId != null) {\r\n\r\n            // get the node\r\n            var node = this.getNodeById(targetNodeId);\r\n\r\n            if (node != null) {\r\n\r\n                /*\r\n                 * create the constraint that makes the node not visible until\r\n                 * the given branch path is taken\r\n                 */\r\n                var makeThisNodeNotVisibleConstraint = {};\r\n                makeThisNodeNotVisibleConstraint.id = this.getNextAvailableConstraintIdForNodeId(targetNodeId);\r\n                makeThisNodeNotVisibleConstraint.action = 'makeThisNodeNotVisible';\r\n                makeThisNodeNotVisibleConstraint.targetId = targetNodeId;\r\n                makeThisNodeNotVisibleConstraint.removalCriteria = [];\r\n                var notVisibleRemovalCriterion = {};\r\n                notVisibleRemovalCriterion.name = 'branchPathTaken';\r\n                notVisibleRemovalCriterion.params = {};\r\n                notVisibleRemovalCriterion.params.fromNodeId = fromNodeId;\r\n                notVisibleRemovalCriterion.params.toNodeId = toNodeId;\r\n                makeThisNodeNotVisibleConstraint.removalConditional = 'all';\r\n                makeThisNodeNotVisibleConstraint.removalCriteria.push(notVisibleRemovalCriterion);\r\n                node.constraints.push(makeThisNodeNotVisibleConstraint);\r\n\r\n                /*\r\n                 * create the constraint that makes the node not visitable until\r\n                 * the given branch path is taken\r\n                 */\r\n                var makeThisNodeNotVisitableConstraint = {};\r\n                makeThisNodeNotVisitableConstraint.id = this.getNextAvailableConstraintIdForNodeId(targetNodeId);\r\n                makeThisNodeNotVisitableConstraint.action = 'makeThisNodeNotVisitable';\r\n                makeThisNodeNotVisitableConstraint.targetId = targetNodeId;\r\n                makeThisNodeNotVisitableConstraint.removalCriteria = [];\r\n                var notVisitableRemovalCriterion = {};\r\n                notVisitableRemovalCriterion.name = 'branchPathTaken';\r\n                notVisitableRemovalCriterion.params = {};\r\n                notVisitableRemovalCriterion.params.fromNodeId = fromNodeId;\r\n                notVisitableRemovalCriterion.params.toNodeId = toNodeId;\r\n                makeThisNodeNotVisitableConstraint.removalConditional = 'all';\r\n                makeThisNodeNotVisitableConstraint.removalCriteria.push(notVisitableRemovalCriterion);\r\n                node.constraints.push(makeThisNodeNotVisitableConstraint);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove the branch path taken constraints from a node\r\n     * @param nodeId remove the constraints from this node\r\n     */\r\n    removeBranchPathTakenNodeConstraints(nodeId) {\r\n\r\n        // get a node\r\n        var node = this.getNodeById(nodeId);\r\n\r\n        if (node != null) {\r\n\r\n            // get the constraints\r\n            var constraints = node.constraints;\r\n\r\n            if (constraints != null) {\r\n\r\n                // loop through all the constraints\r\n                for (var c = 0; c < constraints.length; c++) {\r\n                    var constraint = constraints[c];\r\n\r\n                    if (constraint != null) {\r\n\r\n                        // get the removal criteria\r\n                        var removalCriteria = constraint.removalCriteria;\r\n\r\n                        if (removalCriteria != null) {\r\n\r\n                            // loop through all the removal criteria\r\n                            for (var rc = 0; rc < removalCriteria.length; rc++) {\r\n\r\n                                // get a removal criterion\r\n                                var removalCriterion = removalCriteria[rc];\r\n\r\n                                if (removalCriterion != null) {\r\n                                    if (removalCriterion.name == 'branchPathTaken') {\r\n                                        // this is a branch path taken removal criterion\r\n                                        var params = removalCriterion.params;\r\n\r\n                                        // remove the constraint\r\n                                        constraints.splice(c, 1);\r\n\r\n                                        // move the counter back one because we just removed a constraint\r\n                                        c--;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the branch path taken constraints from a node\r\n     * @param nodeId get the branch path taken constraints from this node\r\n     * @return an array of branch path taken constraints from the node\r\n     */\r\n    getBranchPathTakenConstraintsByNodeId(nodeId) {\r\n\r\n        var branchPathTakenConstraints = [];\r\n\r\n        if (nodeId != null) {\r\n\r\n            // get the node\r\n            var node = this.getNodeById(nodeId);\r\n\r\n            if (node != null) {\r\n\r\n                // get the constraints from the node\r\n                var constraints = node.constraints;\r\n\r\n                if (constraints != null) {\r\n\r\n                    // loop through all the constraints\r\n                    for (var c = 0; c < constraints.length; c++) {\r\n                        var constraint = constraints[c];\r\n\r\n                        if (constraint != null) {\r\n\r\n                            // get the removal criteria from the constraint\r\n                            var removalCriteria = constraint.removalCriteria;\r\n\r\n                            if (removalCriteria != null) {\r\n\r\n                                // loop through all the removal criteria\r\n                                for (var rc = 0; rc < removalCriteria.length; rc++) {\r\n                                    var removalCriterion = removalCriteria[rc];\r\n\r\n                                    if (removalCriterion != null) {\r\n                                        if (removalCriterion.name == 'branchPathTaken') {\r\n                                            /*\r\n                                             * we have found a branch path taken constraint so\r\n                                             * we will add the constraint to the array\r\n                                             */\r\n                                            branchPathTakenConstraints.push(constraint);\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return branchPathTakenConstraints;\r\n    }\r\n\r\n    /**\r\n     * Update the branch path taken constraint\r\n     * @param node update the branch path taken constraints in this node\r\n     * @param currentFromNodeId the current from node id\r\n     * @param currentToNodeId the current to node id\r\n     * @param newFromNodeId the new from node id\r\n     * @param newToNodeId the new to node id\r\n     */\r\n    updateBranchPathTakenConstraint(node, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId) {\r\n\r\n        if (node != null) {\r\n            var constraints = node.constraints;\r\n\r\n            if (constraints != null) {\r\n\r\n                // loop through all the constraints for the node\r\n                for (var c = 0; c < constraints.length; c++) {\r\n                    var constraint = constraints[c];\r\n\r\n                    if (constraint != null) {\r\n\r\n                        var removalCriteria = constraint.removalCriteria;\r\n\r\n                        if (removalCriteria != null) {\r\n\r\n                            // loop through all the removal criteria\r\n                            for (var r = 0; r < removalCriteria.length; r++) {\r\n                                var removalCriterion = removalCriteria[r];\r\n\r\n                                if (removalCriterion != null) {\r\n\r\n                                    if (removalCriterion.name === 'branchPathTaken') {\r\n                                        // we have found a branchPathTaken removal criterion\r\n\r\n                                        var params = removalCriterion.params;\r\n\r\n                                        if (params != null) {\r\n\r\n                                            if (params.fromNodeId === currentFromNodeId &&\r\n                                                params.toNodeId === currentToNodeId) {\r\n\r\n                                                /*\r\n                                                 * we have found a branchPathTaken removal criterion\r\n                                                 * with the fromNodeId and toNodeId that we are\r\n                                                 * looking for so we will now update the values\r\n                                                 */\r\n                                                params.fromNodeId = newFromNodeId;\r\n                                                params.toNodeId = newToNodeId;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the project level rubric\r\n     * @return the project level rubric\r\n     */\r\n    getProjectRubric() {\r\n        return this.project.rubric;\r\n    }\r\n\r\n    /**\r\n     * Set the project level rubric\r\n     */\r\n    setProjectRubric(html) {\r\n        this.project.rubric = html;\r\n    }\r\n\r\n    /**\r\n     * Check if a node is a branch point\r\n     * @param nodeId the node id\r\n     * @return whether the node is a branch point\r\n     */\r\n    isBranchPoint(nodeId) {\r\n\r\n        var transitions = this.getTransitionsByFromNodeId(nodeId);\r\n\r\n        if (transitions != null) {\r\n            if (transitions.length > 1) {\r\n                /*\r\n                 * the node contains more than one transition which means it is\r\n                 * a branch point\r\n                 */\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Check if a node is the first node in a branch path\r\n     * @param nodeId the node id\r\n     * @return whether the node is the first node in a branch path\r\n     */\r\n    isFirstNodeInBranchPath(nodeId) {\r\n\r\n        var nodes = this.getNodes();\r\n\r\n        if (nodes != null) {\r\n            for (var n = 0; n < nodes.length; n++) {\r\n                var node = nodes[n];\r\n\r\n                if (node != null &&\r\n                    node.transitionLogic != null &&\r\n                    node.transitionLogic.transitions != null) {\r\n\r\n                    var transitions = node.transitionLogic.transitions;\r\n\r\n                    if (transitions.length > 1) {\r\n                        /*\r\n                         * there is more than one transition from this node\r\n                         * which means it is a branch point\r\n                         */\r\n\r\n                        for (var t = 0; t < transitions.length; t++) {\r\n                            var transition = transitions[t];\r\n\r\n                            if (transition != null) {\r\n                                var transitionTo = transition.to;\r\n\r\n                                if (transitionTo === nodeId) {\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Check if the node is in any branch path\r\n     * @param nodeId the node id of the node\r\n     * @return whether the node is in any branch path\r\n     */\r\n    isNodeInAnyBranchPath(nodeId) {\r\n\r\n        var result = false;\r\n\r\n        if (this.nodeIdToIsInBranchPath[nodeId] == null) {\r\n            /*\r\n             * we have not calculated whether the node id is in a branch path\r\n             * before so we will now\r\n             */\r\n\r\n            // get the branches in the project\r\n            var branches = this.getBranches();\r\n\r\n            // check if the node id is in any of the branches\r\n            result = this.isNodeIdInABranch(branches, nodeId);\r\n\r\n            // remember the result for this node id\r\n            this.nodeIdToIsInBranchPath[nodeId] = result;\r\n        } else {\r\n            /*\r\n             * we have calculated whether the node id is in a branch path\r\n             * before\r\n             */\r\n            result = this.nodeIdToIsInBranchPath[nodeId];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check if a node is a branch start point\r\n     * @param nodeId look for a branch with this start node id\r\n     * @return whether the node is a branch start point\r\n     */\r\n    isBranchStartPoint(nodeId) {\r\n\r\n        /*\r\n         * Get all the branches. Each branch is represented as an object that\r\n         * contains the branchStartPoint, branchEndPoint, and branchPaths.\r\n         */\r\n        var branches = this.getBranches();\r\n\r\n        if (branches != null) {\r\n\r\n            // loop through all the branches\r\n            for (var b = 0; b < branches.length; b++) {\r\n                var branch = branches[b];\r\n\r\n                if (branch != null) {\r\n                    if (branch.branchStartPoint == nodeId) {\r\n                        /*\r\n                         * we have found a branch with the given nodeId as the\r\n                         * start point\r\n                         */\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Check if a node is a branch end point\r\n     * @param nodeId look for a branch with this end node id\r\n     * @return whether the node is a branch end point\r\n     */\r\n    isBranchMergePoint(nodeId) {\r\n\r\n        /*\r\n         * Get all the branches. Each branch is represented as an object that\r\n         * contains the branchStartPoint, branchEndPoint, and branchPaths.\r\n         */\r\n        var branches = this.getBranches();\r\n\r\n        if (branches != null) {\r\n\r\n            // loop through all the branches\r\n            for (var b = 0; b < branches.length; b++) {\r\n                var branch = branches[b];\r\n\r\n                if (branch != null) {\r\n                    if (branch.branchEndPoint == nodeId) {\r\n                        /*\r\n                         * we have found a branch with the given nodeId as the\r\n                         * end point\r\n                         */\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get all the branches whose branch start point is the given node id\r\n     * @param nodeId the branch start point\r\n     * @return an array of branches that have the given branch start point\r\n     */\r\n    getBranchesByBranchStartPointNodeId(nodeId) {\r\n\r\n        var branches = [];\r\n\r\n        // get all the branches in the project\r\n        var allBranches = this.getBranches();\r\n\r\n        if (allBranches != null) {\r\n\r\n            // loop through all the branches in the project\r\n            for (var b = 0; b < allBranches.length; b++) {\r\n                var branch = allBranches[b];\r\n\r\n                if (branch != null) {\r\n\r\n                    if (nodeId == branch.branchStartPoint) {\r\n                        /*\r\n                         * the branch start point matches the node id we are\r\n                         * looking for\r\n                         */\r\n                        branches.push(branch);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return branches;\r\n    }\r\n\r\n    /**\r\n     * Calculate the node numbers and set them into the nodeIdToNumber map\r\n     */\r\n    calculateNodeNumbers() {\r\n\r\n        // clear the node id to number mapping\r\n        this.nodeIdToNumber = {};\r\n\r\n        // get the start node id\r\n        var startNodeId = this.getStartNodeId();\r\n\r\n        var currentActivityNumber = 0;\r\n        var currentStepNumber = 0;\r\n\r\n        /*\r\n         * recursively calculate the node numbers by traversing the project\r\n         * tree\r\n         */\r\n        this.calculateNodeNumbersHelper(startNodeId, currentActivityNumber, currentStepNumber);\r\n    }\r\n\r\n    /**\r\n     * Recursively calcualte the node numbers by traversing the project tree\r\n     * using transitions\r\n     * @param nodeId the current node id we are on\r\n     * @param currentActivityNumber the current activity number\r\n     * @param currentStepNumber the current step number\r\n     * @param branchLetterCode (optional) the character code for the branch\r\n     * letter e.g. 1=A, 2=B, etc.\r\n     */\r\n    calculateNodeNumbersHelper(nodeId, currentActivityNumber, currentStepNumber, branchLetterCode) {\r\n\r\n        if (nodeId != null) {\r\n            if (this.isApplicationNode(nodeId)) {\r\n                // the node is a step node\r\n\r\n                // get the node object\r\n                var node = this.getNodeById(nodeId);\r\n\r\n                if (node != null) {\r\n\r\n                    // get the parent group of the node\r\n                    var parentGroup = this.getParentGroup(nodeId);\r\n\r\n                    if (parentGroup != null) {\r\n\r\n                        // check if the parent group has previously been assigned a number\r\n                        if (this.nodeIdToNumber[parentGroup.id] == null) {\r\n                            /*\r\n                             * the parent group has not been assigned a number so\r\n                             * we will assign a number now\r\n                             */\r\n\r\n                            // set the activity number\r\n                            currentActivityNumber = parseInt(currentActivityNumber) + 1;\r\n\r\n                            /*\r\n                             * set the current step number to 1 now that we have\r\n                             * entered a new group\r\n                             */\r\n                            currentStepNumber = 1;\r\n\r\n                            // set the activity number\r\n                            this.nodeIdToNumber[parentGroup.id] = \"\" + currentActivityNumber;\r\n                        } else {\r\n                            /*\r\n                             * the parent group has previously been assigned a number so we\r\n                             * will use it\r\n                             */\r\n                            currentActivityNumber = this.nodeIdToNumber[parentGroup.id];\r\n                        }\r\n                    }\r\n\r\n                    if (this.isBranchMergePoint(nodeId)) {\r\n                        /*\r\n                         * the node is a merge point so we will not use a letter\r\n                         * anymore now that we are no longer in a branch path\r\n                         */\r\n                        branchLetterCode = null;\r\n                    }\r\n\r\n                    if (this.isBranchStartPoint(nodeId)) {\r\n                        // the node is a branch start point\r\n\r\n                        // get the branch that this node is a start point for\r\n                        var branchesByBranchStartPointNodeId = this.getBranchesByBranchStartPointNodeId(nodeId);\r\n\r\n                        // get the branch object, there should only be one\r\n                        var branchesObject = branchesByBranchStartPointNodeId[0];\r\n\r\n                        /*\r\n                         * this is used to obtain the max step number that has\r\n                         * been used in the branch paths so that we know what\r\n                         * step number to give the merge end point\r\n                         */\r\n                        var maxCurrentStepNumber = 0;\r\n\r\n                        // set the step number for the branch start point\r\n                        this.nodeIdToNumber[nodeId] = currentActivityNumber + '.' + currentStepNumber;\r\n\r\n                        // increment the step counteer\r\n                        currentStepNumber++;\r\n\r\n                        // get the branch paths\r\n                        var branchPaths = branchesObject.branchPaths;\r\n\r\n                        // loop through all the branch paths\r\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\r\n\r\n                            // get a branch path\r\n                            var branchPath = branchPaths[bp];\r\n\r\n                            // step number counter for this branch path\r\n                            var branchCurrentStepNumber = currentStepNumber;\r\n\r\n                            // get the letter code e.g. 1=A, 2=B, etc.\r\n                            var branchLetterCode = bp;\r\n\r\n                            // loop through all the nodes in the branch path\r\n                            for (var bpn = 0; bpn < branchPath.length; bpn++) {\r\n                                if (bpn == 0) {\r\n\r\n                                    /*\r\n                                     * Recursively call calculateNodeNumbersHelper on the\r\n                                     * first step in this branch path. This will recursively\r\n                                     * calculate the numbers for all the nodes in this\r\n                                     * branch path.\r\n                                     */\r\n                                    var branchPathNodeId = branchPath[bpn];\r\n                                    this.calculateNodeNumbersHelper(branchPathNodeId, currentActivityNumber, branchCurrentStepNumber, branchLetterCode);\r\n                                }\r\n\r\n                                // increment the step counter for this branch path\r\n                                branchCurrentStepNumber++;\r\n\r\n                                /*\r\n                                 * update the max current step number if we have found\r\n                                 * a larger number\r\n                                 */\r\n                                if (branchCurrentStepNumber > maxCurrentStepNumber) {\r\n                                    maxCurrentStepNumber = branchCurrentStepNumber;\r\n                                }\r\n                            }\r\n                        }\r\n\r\n                        // get the step number we should use for the end point\r\n                        currentStepNumber = maxCurrentStepNumber;\r\n\r\n                        var branchEndPointNodeId = branchesObject.branchEndPoint;\r\n\r\n                        /*\r\n                         * calculate the node number for the branch end point and\r\n                         * continue calculating node numbers for the nodes that\r\n                         * come after it\r\n                         */\r\n                        this.calculateNodeNumbersHelper(branchEndPointNodeId, currentActivityNumber, currentStepNumber);\r\n                    } else {\r\n                        // the node is not a branch start point\r\n\r\n                        /*\r\n                         * check if we have already set the number for this node so\r\n                         * that we don't need to unnecessarily re-calculate the\r\n                         * node number\r\n                         */\r\n                        if (this.nodeIdToNumber[nodeId] == null) {\r\n                            // we have not calculated the node number yet\r\n\r\n                            var number = null;\r\n\r\n                            if (branchLetterCode == null) {\r\n                                // we do not need to add a branch letter\r\n\r\n                                // get the node number e.g. 1.5\r\n                                number = currentActivityNumber + '.' + currentStepNumber;\r\n                            } else {\r\n                                // we need to add a branch letter\r\n\r\n                                // get the branch letter\r\n                                var branchLetter = String.fromCharCode(65 + branchLetterCode);\r\n\r\n                                // get the node number e.g. 1.5 A\r\n                                number = currentActivityNumber + '.' + currentStepNumber + ' ' + branchLetter;\r\n                            }\r\n\r\n                            // set the number for the node\r\n                            this.nodeIdToNumber[nodeId] = number;\r\n                        } else {\r\n                            /*\r\n                             * We have calculated the node number before so we\r\n                             * will return. This will prevent infinite looping\r\n                             * within the project.\r\n                             */\r\n                            return;\r\n                        }\r\n\r\n                        // increment the step number for the next node to use\r\n                        currentStepNumber++;\r\n\r\n                        var transitions = [];\r\n\r\n                        if (node.transitionLogic != null && node.transitionLogic.transitions) {\r\n                            transitions = node.transitionLogic.transitions;\r\n                        }\r\n\r\n                        if (transitions.length > 0) {\r\n\r\n                            /*\r\n                             * loop through all the transitions, there should only\r\n                             * be one but we will loop through them just to be complete.\r\n                             * if there was more than one transition, it would mean\r\n                             * this node is a branch start point in which case we\r\n                             * would have gone inside the other block of code where\r\n                             * this.isBranchStartPoint() is true.\r\n                             */\r\n                            for (var t = 0; t < transitions.length; t++) {\r\n                                var transition = transitions[t];\r\n\r\n                                if (transition != null) {\r\n                                    if (this.isBranchMergePoint(transition.to)) {\r\n\r\n                                    } else {\r\n                                        this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\r\n                                    }\r\n                                }\r\n                            }\r\n                        } else {\r\n                            // if there are no transitions, check if the parent group has a transition\r\n\r\n                            if (parentGroup != null &&\r\n                                parentGroup.transitionLogic != null &&\r\n                                parentGroup.transitionLogic.transitions != null &&\r\n                                parentGroup.transitionLogic.transitions.length > 0) {\r\n\r\n                                for (var pg = 0; pg < parentGroup.transitionLogic.transitions.length; pg++) {\r\n                                    var transition = parentGroup.transitionLogic.transitions[pg];\r\n\r\n                                    if (transition != null) {\r\n                                        this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // the node is a group node\r\n\r\n                // get the node object\r\n                var node = this.getNodeById(nodeId);\r\n\r\n                if (node != null) {\r\n                    // check if the group has previously been assigned a number\r\n                    if (this.nodeIdToNumber[nodeId] == null) {\r\n                        /*\r\n                         * the group has not been assigned a number so\r\n                         * we will assign a number now\r\n                         */\r\n\r\n                        if (nodeId == 'group0') {\r\n                            // group 0 will always be given the activity number of 0\r\n                            this.nodeIdToNumber[nodeId] = \"\" + 0;\r\n                        } else {\r\n                            // set the activity number\r\n                            currentActivityNumber = parseInt(currentActivityNumber) + 1;\r\n\r\n                            /*\r\n                             * set the current step number to 1 now that we have\r\n                             * entered a new group\r\n                             */\r\n                            currentStepNumber = 1;\r\n\r\n                            // set the activity number\r\n                            this.nodeIdToNumber[nodeId] = \"\" + currentActivityNumber;\r\n                        }\r\n                    } else {\r\n                        /*\r\n                         * We have calculated the node number before so we\r\n                         * will return. This will prevent infinite looping\r\n                         * within the project.\r\n                         */\r\n                        return;\r\n                    }\r\n\r\n                    if (node.startId != null && node.startId != '') {\r\n                        /*\r\n                         * calculate the node number for the first step in this\r\n                         * activity and any steps after it\r\n                         */\r\n                        this.calculateNodeNumbersHelper(node.startId, currentActivityNumber, currentStepNumber, branchLetterCode);\r\n                    } else {\r\n                        /*\r\n                         * this activity doesn't have a start step so we will\r\n                         * look for a transition\r\n                         */\r\n\r\n                        if (node != null &&\r\n                            node.transitionLogic != null &&\r\n                            node.transitionLogic.transitions != null &&\r\n                            node.transitionLogic.transitions.length > 0) {\r\n\r\n                            // loop through all the transitions\r\n                            for (var t = 0; t < node.transitionLogic.transitions.length; t++) {\r\n                                var transition = node.transitionLogic.transitions[t];\r\n\r\n                                if (transition != null) {\r\n                                    /*\r\n                                     * calculate the node number for the next group\r\n                                     * and all its children steps\r\n                                     */\r\n                                    this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get script for this project\r\n     */\r\n    getProjectScript() {\r\n        return this.project.script;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the script with the provided script filename\r\n     * @param scriptFilename\r\n     */\r\n    retrieveScript(scriptFilename) {\r\n        let assetDirectoryPath = this.ConfigService.getProjectAssetsDirectoryPath();\r\n        let scriptPath = assetDirectoryPath + \"/\" + scriptFilename;\r\n        return this.$http.get(scriptPath).then((result) => {\r\n            return result.data;\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Registers an additionalProcessingFunction for the specified node and component\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     * @param additionalProcessingFunction the function to register for the node and component.\r\n     */\r\n    addAdditionalProcessingFunction(nodeId, componentId, additionalProcessingFunction) {\r\n        let key = nodeId + \"_\" + componentId;\r\n        if (this.additionalProcessingFunctionsMap[key] == null) {\r\n            this.additionalProcessingFunctionsMap[key] = [];\r\n        }\r\n        this.additionalProcessingFunctionsMap[key].push(additionalProcessingFunction);\r\n    }\r\n\r\n    /**\r\n     * Returns true iff the specified node and component has any registered additionalProcessingFunctions\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     * @returns true/false\r\n     */\r\n    hasAdditionalProcessingFunctions(nodeId, componentId) {\r\n        return this.getAdditionalProcessingFunctions(nodeId, componentId) != null;\r\n    }\r\n\r\n    /**\r\n     * Returns an array of registered additionalProcessingFunctions for the specified node and component\r\n     * @param nodeId the node id\r\n     * @param componentId the component id\r\n     * @returns an array of additionalProcessingFunctions\r\n     */\r\n    getAdditionalProcessingFunctions(nodeId, componentId) {\r\n        let key = nodeId + \"_\" + componentId;\r\n        return this.additionalProcessingFunctionsMap[key];\r\n    }\r\n\r\n    /**\r\n     * Get the previous node\r\n     * @param nodeId get the node id that comes before this one\r\n     * @return the node id that comes before\r\n     */\r\n    getPreviousNodeId(nodeId) {\r\n        var previousNodeId = null;\r\n\r\n        // get the node ids in the project as a flat array\r\n        var flattenedNodeIds = this.getFlattenedProjectAsNodeIds();\r\n\r\n        if (flattenedNodeIds != null) {\r\n\r\n            // get the index of the node id\r\n            var indexOfNodeId = flattenedNodeIds.indexOf(nodeId);\r\n\r\n            if (indexOfNodeId != -1) {\r\n\r\n                // get the index of the previous node id\r\n                var indexOfPreviousNodeId = indexOfNodeId - 1;\r\n\r\n                // get the previous node id\r\n                previousNodeId = flattenedNodeIds[indexOfPreviousNodeId];\r\n            }\r\n        }\r\n\r\n        return previousNodeId;\r\n    }\r\n\r\n    /**\r\n     * Get the next node\r\n     * @param nodeId get the node id that comes after this one\r\n     * @return the node id that comes after\r\n     */\r\n    getNextNodeId(nodeId) {\r\n\r\n        var nextNodeId = null;\r\n\r\n        // get the node ids in the project as a flat array\r\n        var flattenedNodeIds = this.getFlattenedProjectAsNodeIds();\r\n\r\n        if (flattenedNodeIds != null) {\r\n\r\n            // get the index of the node id\r\n            var indexOfNodeId = flattenedNodeIds.indexOf(nodeId);\r\n\r\n            if (indexOfNodeId != -1) {\r\n\r\n                // get the index of the next node id\r\n                var indexOfNextNodeId = indexOfNodeId + 1;\r\n\r\n                // get the next node id\r\n                nextNodeId = flattenedNodeIds[indexOfNextNodeId];\r\n            }\r\n        }\r\n\r\n        return nextNodeId;\r\n    }\r\n\r\n    /**\r\n     * Set the project script filename\r\n     * @param script the script filename\r\n     */\r\n    setProjectScriptFilename(scriptFilename) {\r\n        this.project.script = scriptFilename;\r\n    }\r\n\r\n    /**\r\n     * Get the project script filename\r\n     */\r\n    getProjectScriptFilename() {\r\n\r\n        var scriptFilename = null;\r\n\r\n        if (this.project != null && this.project.script != null) {\r\n            scriptFilename = this.project.script;\r\n        }\r\n\r\n        return scriptFilename;\r\n    }\r\n\r\n    /**\r\n     * Get all the achievements object in the project. The achievements object\r\n     * contains the isEnabled field and an array of items.\r\n     * @return the achievement object\r\n     */\r\n    getAchievements() {\r\n        var achievements = null;\r\n\r\n        if (this.project != null) {\r\n            if (this.project.achievements == null) {\r\n                this.project.achievements = {\r\n                    isEnabled: true,\r\n                    items: []\r\n                };\r\n            }\r\n            achievements = this.project.achievements;\r\n        }\r\n\r\n        return achievements;\r\n    }\r\n\r\n    /**\r\n     * Get the achievement items in the project\r\n     * @return the achievement items\r\n     */\r\n    getAchievementItems() {\r\n        var achievementItems = null;\r\n\r\n        // get the achievements object\r\n        var achievements = this.getAchievements();\r\n\r\n        if (achievements != null) {\r\n            if (achievements.items == null) {\r\n                achievements.items = [];\r\n            }\r\n\r\n            // get the achievement items\r\n            achievementItems = achievements.items;\r\n        }\r\n\r\n        return achievementItems;\r\n    }\r\n\r\n    /**\r\n     * Get an achievement by the 10 character alphanumeric achievement id\r\n     * @param achievementId the 10 character alphanumeric achievement id\r\n     * @return the achievement with the given achievement id\r\n     */\r\n    getAchievementByAchievementId(achievementId) {\r\n\r\n        if (achievementId != null) {\r\n\r\n            // get the achievements object\r\n            var achievements = this.getAchievements();\r\n\r\n            if (achievements != null) {\r\n\r\n                // get the achievement items\r\n                var achievementItems = achievements.items;\r\n\r\n                if (achievementItems != null) {\r\n\r\n                    // loop through the achievement items\r\n                    for (var a = 0; a < achievementItems.length; a++) {\r\n\r\n                        // get an achievement\r\n                        var achievement = achievementItems[a];\r\n\r\n                        if (achievement != null && achievement.id == achievementId) {\r\n                            /*\r\n                             * the achievement id matches so we have found the\r\n                             * achievement we are looking for\r\n                             */\r\n                            return achievement;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Check if there are any rubrics in the project. There can potentially be\r\n     * a project rubric, node rubrics, and component rubrics.\r\n     * @return whether there are any rubrics in the project\r\n     */\r\n    hasRubrics() {\r\n\r\n        if (this.project != null) {\r\n\r\n            if (this.project.rubric != null && this.project.rubric != \"\") {\r\n                // there is a project rubric\r\n                return true;\r\n            }\r\n\r\n            // loop through all the nodes\r\n            for (var n = 0; n < this.project.nodes.length; n++) {\r\n                var node = this.project.nodes[n];\r\n\r\n                if (node != null) {\r\n                    if (node.rubric != null && node.rubric != \"\") {\r\n                        // there is a node rubric\r\n                        return true;\r\n                    }\r\n\r\n                    if (node.components != null) {\r\n                        // loop through all the components\r\n                        for (var c = 0; c < node.components.length; c++) {\r\n                            var component = node.components[c];\r\n\r\n                            if (component != null) {\r\n                                if (component.rubric != null && component.rubric != \"\") {\r\n                                    // there is a component rubric\r\n                                    return true;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the branch letter in the node position string if the node is in a\r\n     * branch path\r\n     * @param nodeId the node id we want the branch letter for\r\n     * @return the branch letter in the node position if the node is in a branch\r\n     * path\r\n     */\r\n    getBranchLetter(nodeId) {\r\n\r\n        var branchLetter = null;\r\n\r\n        if (nodeId != null) {\r\n\r\n            // get the node position e.g. \"1.8\" or \"1.9 A\"\r\n            var nodePosition = this.getNodePositionById(nodeId);\r\n\r\n            if (nodePosition != null) {\r\n\r\n                // regex for extracting the branch letter\r\n                var branchLetterRegex = /.*([A-Z])/;\r\n\r\n                // run the regex on the node position string\r\n                var match = branchLetterRegex.exec(nodePosition);\r\n\r\n                if (match != null) {\r\n                    /*\r\n                     * the node position has a branch letter so we will get it\r\n                     * from the matched group\r\n                     */\r\n                    branchLetter = match[1];\r\n                }\r\n            }\r\n        }\r\n\r\n        return branchLetter;\r\n    }\r\n\r\n    /**\r\n     * Get the total number of rubrics (step + components) for the given nodeId\r\n     * @param nodeId the node id\r\n     * @return Number of rubrics for the node\r\n     */\r\n    getNumberOfRubricsByNodeId(nodeId) {\r\n        let n = 0;\r\n        let nodeContent = this.getNodeContentByNodeId(nodeId);\r\n\r\n        if (nodeContent) {\r\n\r\n            // get the step rubric if any\r\n            let nodeRubric = nodeContent.rubric;\r\n\r\n            if (nodeRubric != null && nodeRubric != '') {\r\n                // the step has a rubric\r\n                n++;\r\n            }\r\n\r\n            // get the components\r\n            let components = nodeContent.components;\r\n\r\n            if (components && components.length) {\r\n\r\n                // loop through all the components\r\n                for (let c = 0; c < components.length; c++) {\r\n                    var component = components[c];\r\n\r\n                    if (component) {\r\n\r\n                        // get a component rubric\r\n                        var componentRubric = component.rubric;\r\n\r\n                        if (componentRubric != null && componentRubric != '') {\r\n                            // a component has a rubric\r\n                            n++;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return n;\r\n    }\r\n}\r\n\r\nProjectService.$inject = [\r\n    '$filter',\r\n    '$http',\r\n    '$injector',\r\n    '$q',\r\n    '$rootScope',\r\n    'ConfigService',\r\n    'UtilService'\r\n];\r\n\r\nexport default ProjectService;\r\n"]}