{"version":3,"sources":["projectService.es6"],"names":[],"mappings":"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","file":"projectService.js","sourcesContent":["class ProjectService {\n    constructor($http, $rootScope, ConfigService) {\n        this.$http = $http;\n        this.$rootScope = $rootScope;\n        this.ConfigService = ConfigService;\n        this.project = null;\n        this.transitions = [];\n        this.applicationNodes = [];\n        this.groupNodes = [];\n        this.idToNode = {};\n        this.idToElement = {};\n        this.idToTransition = {};\n        this.metadata = {};\n        this.idToContent = {};\n        this.activeConstraints = [];\n        this.rootNode = null;\n        this.idToPosition = {};\n        this.idToOrder = {};\n        this.nodeCount = 0;\n\n        // filtering options for navigation displays\n        this.filters = [\n            {'name': 'all', 'label': 'All'},\n            //{'name': 'todo', 'label': 'Todo'},\n            //{'name': 'completed', 'label': 'Completed'},\n            {'name': 'bookmark', 'label': 'Bookmarks'} // TODO: Add when bookmarks are active\n        ];\n    }\n\n    getProject() {\n        return this.project;\n    };\n\n    setProject(project) {\n        this.project = project;\n        if (project.metadata) {\n            this.metadata = project.metadata;\n        }\n        this.parseProject();\n    };\n\n    getStyle() {\n        var style = '';\n        var project = this.project;\n        if (project != null) {\n            style = project.style;\n        }\n        return style;\n    };\n\n    getFilters(){\n        return this.filters;\n    };\n\n    getName() {\n        var name = this.getProjectMetadata().title;\n        name = name ? name : 'A WISE Project (No name)';\n        return name;\n    };\n\n    getProjectMetadata() {\n        return this.metadata;\n    };\n\n    getNodes() {\n        var nodes = null;\n        var project = this.project;\n\n        if (project != null) {\n            nodes = project.nodes;\n        }\n\n        return nodes;\n    };\n\n    getChildNodeIdsById(nodeId) {\n        var childIds = [];\n        var node = this.getNodeById(nodeId);\n\n        if (node.ids) {\n            childIds = node.ids;\n        }\n\n        return childIds;\n    };\n\n    getApplicationNodes() {\n        return this.applicationNodes;\n    };\n\n    getGroupNodes() {\n        return this.groupNodes;\n    };\n\n    getIdToNode() {\n        return this.idToNode;\n    };\n\n    isNode(id) {\n        var result = false;\n        var nodes = this.getNodes();\n\n        if (nodes != null) {\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeId = node.id;\n\n                    if (nodeId === id) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    // adds or update transition if exists\n    addTransition(transition) {\n\n        var existingTransitions = this.getTransitions();\n        var replaced = false;\n        for (var t = 0; t < existingTransitions.length; t++) {\n            var existingTransition = existingTransitions[t];\n            if (existingTransition.id === transition.id) {\n                existingTransitions.splice(t, 1, transition);\n                replaced = true;\n            }\n        }\n        if (!replaced) {\n            existingTransitions.push(transition);\n        }\n    };\n\n    addNode(node) {\n        var existingNodes = this.project.nodes;\n\n        var replaced = false;\n        if (node != null && existingNodes != null) {\n            for (var n = 0; n < existingNodes.length; n++) {\n                var existingNode = existingNodes[n];\n                var existingNodeId = existingNode.id;\n                if (existingNodeId === node.id) {\n                    existingNodes.splice(n, 1, node);\n                    replaced = true;\n                }\n            }\n        }\n        if (!replaced) {\n            existingNodes.push(node);\n        }\n    };\n\n    addApplicationNode(node) {\n\n        var applicationNodes = this.applicationNodes;\n\n        if (node != null && applicationNodes != null) {\n            applicationNodes.push(node);\n        }\n    };\n\n    addGroupNode(node) {\n\n        var groupNodes = this.groupNodes;\n\n        if (node != null && groupNodes != null) {\n            groupNodes.push(node);\n        }\n\n        this.$rootScope.$broadcast('groupsChanged');\n    };\n\n    addNodeToGroupNode(groupId, nodeId) {\n        if (groupId != null && nodeId != null) {\n            var group = this.getNodeById(groupId);\n            if (group != null) {\n                var groupChildNodeIds = group.ids;\n                if (groupChildNodeIds != null) {\n                    if (groupChildNodeIds.indexOf(nodeId) === -1) {\n                        groupChildNodeIds.push(nodeId);\n                    }\n                }\n            }\n        }\n    };\n\n    isGroupNode(id) {\n        var result = false;\n\n        var groupNode = this.getNodeById(id);\n\n        if (groupNode != null) {\n            var type = groupNode.type;\n\n            if (type === 'group') {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    isApplicationNode(id) {\n        var result = false;\n\n        var applicationNode = this.getNodeById(id);\n\n        if (applicationNode != null) {\n            var type = applicationNode.type;\n\n            if (type !== 'group') {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    getGroups() {\n        return this.groupNodes;\n    };\n\n    loadNodes(nodes) {\n        if (nodes != null) {\n            for (var n = 0 ; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeId = node.id;\n                    var nodeType = node.type;\n                    var content = node.content;\n                    var constraints = node.constraints;\n\n                    if (content != null) {\n                        //node.content = this.injectAssetPaths(content);\n                    }\n\n                    this.setIdToNode(nodeId, node);\n                    this.setIdToElement(nodeId, node);\n\n                    this.addNode(node);\n\n                    if (nodeType === 'group') {\n                        this.addGroupNode(node);\n                    } else {\n                        this.addApplicationNode(node);\n                    }\n\n                    var groupId = node.groupId;\n\n                    if (groupId != null) {\n                        this.addNodeToGroupNode(groupId, nodeId);\n                    }\n\n                    if (constraints != null) {\n                        for (var c = 0; c < constraints.length; c++) {\n                            var constraint = constraints[c];\n\n                            this.activeConstraints.push(constraint);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    loadTransitions(transitions) {\n        if (transitions != null) {\n            for (var t = 0; t < transitions.length; t++) {\n                var transition = transitions[t];\n\n                if (transition != null) {\n                    var transitionId = transition.id;\n\n                    this.setIdToElement(transitionId, transition);\n                    this.setIdToTransition(transitionId, transition);\n\n                    this.addTransition(transition);\n                }\n            }\n        }\n    };\n\n    parseProject() {\n        var project = this.project;\n        if (project != null) {\n            var nodes = project.nodes;\n            this.loadNodes(nodes);\n\n            var transitions = project.transitions;\n            this.loadTransitions(transitions);\n\n            var constraints = project.constraints;\n\n            if (constraints != null) {\n                for (var c = 0; c < constraints.length; c++) {\n                    var constraint = constraints[c];\n\n                    if (constraint != null) {\n                        var constraintId = constraint.id;\n                        constraint.active = true;\n\n                        this.setIdToElement(constraintId, constraint);\n                    }\n                }\n            }\n\n            // set root node\n            this.rootNode = this.getRootNode(nodes[0].id);\n\n            // set project order\n            this.setNodeOrder(this.rootNode, this.nodeCount);\n            this.nodeCount = 0;\n\n            var n = nodes.length;\n            var branches = this.getBranches();\n            var branchNodeIds = [];\n\n            // set node positions\n            var id, pos;\n\n            while (n--) {\n                id = nodes[n].id;\n                if(id === this.rootNode.id) {\n                    this.setIdToPosition(id, '0');\n                } else if (this.isNodeIdInABranch(branches, id)) {\n                    // node is in a branch, so process later\n                    branchNodeIds.push(id);\n                } else {\n                    pos = this.getPositionById(id);\n                    this.setIdToPosition(id, pos);\n                }\n            }\n\n            // set branch node positions\n            var b = branchNodeIds.length;\n            while (b--) {\n                id = branchNodeIds[b];\n                pos = this.getBranchNodePositionById(id);\n                this.setIdToPosition(id, pos);\n            }\n        }\n    };\n\n    setNodeOrder(node) {\n        this.idToOrder[node.id] = {'order': this.nodeCount};\n        this.nodeCount++;\n        if (this.isGroupNode(node.id)){\n            var childIds = node.ids;\n            for(var i=0; i<childIds.length; i++){\n                var child = this.getNodeById(childIds[i]);\n                this.setNodeOrder(child);\n            }\n        }\n    };\n\n    /**\n     * Returns the position in the project for the node with the given id. Returns null if no node with id exists.\n     * @param id a node id\n     * @return string position of the given node id in the project\n     */\n    getPositionById(id) {\n        for (var i=0;i<this.rootNode.ids.length;i++) {\n            var node = this.getNodeById(this.rootNode.ids[i]);\n            var path = this.getPathToNode(node, i+1, id);\n            if (path!=undefined && path!=null) {\n                return path;\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Returns the order of the given node id in the project. Returns null if no node with id exists.\n     * @param id String node id\n     * @return Number order of the given node id in the project\n     */\n    getOrderById(id) {\n        if(this.idToOrder[id]) {\n            return this.idToOrder[id].order;\n        }\n\n        return null;\n    };\n    /**\n     * Returns the id of the node with the given order in the project. Returns null if no order with node exists.\n     * @param order Number\n     * @return Number node id of the given order in the project\n     */\n    getIdByOrder(order) {\n        var nodeId = null;\n\n        for (var id in this.idToOrder) {\n            if (this.idToOrder[id].order === order) {\n                if (this.isGroupNode(id) && order > 1) {\n                    nodeId = this.getIdByOrder(order-1);\n                } else {\n                    nodeId = id;\n                }\n                break;\n            }\n        }\n\n        return nodeId;\n    };\n\n    /**\n     * Returns the position in the project for the branch node with the given id. Returns null if no node with id exists or node is not a branch node.\n     * @param id a node id\n     * @return string position of the given node id in the project\n     */\n    getBranchNodePositionById(id) {\n        var branches = this.getBranches();\n        var b = branches.length;\n\n        // TODO: should we localize this? should we support more than 26?\n        var integerToAlpha = function(int) {\n            var alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n            if(int > -1 && int < 26){\n                return alphabet[int];\n            } else {\n                return int;\n            }\n        };\n\n\n        while (b--) {\n            var branch = branches[b];\n            var branchPaths = branch.branchPaths;\n            for (var p=0; p<branchPaths.length; p++) {\n                var branchPath = branchPaths[p];\n                var nodeIndex = branchPath.indexOf(id);\n                if (nodeIndex > -1) {\n                    var startPoint = branch.branchStartPoint;\n                    var startPointPos = this.idToPosition[startPoint];\n                    var branchPathPos = startPointPos + ' ' + integerToAlpha(p);\n                    return branchPathPos + (nodeIndex+1);\n                }\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Recursively searches for the given node id from the point of the given node down and returns the path number (position)\n     * @param node a node to start searching down\n     * @param path the position of the given node\n     * @param id the node id to search for\n     * @return string path of the given node id in the project\n     */\n    getPathToNode(node, path, id) {\n        if (node.id===id) {\n            return path + '';\n        } else if (node.type==='group'){\n            var num = 0;\n            var branches = this.getBranches();\n            for (var i=0;i<node.ids.length;i++) {\n                var nodeId = node.ids[i];\n                if (this.isNodeIdInABranch(branches, nodeId)) {\n                    this.getBranchNodePositionById(nodeId);\n                } else {\n                    ++num;\n                    var pos = this.getPathToNode(this.getNodeById(nodeId), (path) + '.' + (num), id);\n                    if (pos) {\n                        return pos;\n                    }\n                }\n            }\n        }\n    };\n\n    setIdToPosition(id, pos) {\n        if (id != null) {\n            this.idToPosition[id] = pos;\n        }\n    };\n\n    getNodePositionById(id) {\n        if (id != null) {\n            return this.idToPosition[id];\n        }\n    };\n\n    setIdToNode(id, element) {\n        if (id != null) {\n            this.idToNode[id] = element;\n        }\n    };\n\n    setIdToElement(id, element) {\n        if (id != null) {\n            this.idToElement[id] = element;\n        }\n    };\n\n    /**\n     * Replace relative asset paths with absolute paths\n     * e.g.\n     * assets/myimage.jpg\n     * will be replaced with\n     * http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg\n     * @param content a string or JSON object\n     * @return the same type of object that was passed in as the content\n     * but with relative asset paths replaced with absolute paths\n     */\n    injectAssetPaths(content) {\n\n        if (content != null) {\n\n            if (typeof content === 'object') {\n\n                var contentString = JSON.stringify(content);\n\n                if (contentString != null) {\n\n                    // replace the relative asset paths with the absolute paths\n                    contentString = this.replaceAssetPaths(contentString);\n\n                    content = JSON.parse(contentString);\n                }\n            } else if (typeof content === 'string') {\n\n                // replace the relative asset paths with the absolute paths\n                content = this.replaceAssetPaths(content);\n            }\n        }\n\n        return content;\n    };\n\n    /**\n     * Replace the relative asset paths with absolute paths\n     * @param contentString the content string\n     * @return the content string with relative asset paths replaced\n     * with absolute asset paths\n     */\n    replaceAssetPaths(contentString) {\n\n        if (contentString != null) {\n\n            // get the content base url e.g. http://wise.berkeley.edu/curriculum/123456\n            var contentBaseUrl = this.ConfigService.getConfigParam('projectBaseURL');\n\n            // replace instances of 'assets/myimage.jpg' with 'http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg'\n            contentString = contentString.replace(new RegExp('\\'(\\\\.)*(/)*assets', 'g'), '\\'' + contentBaseUrl + 'assets');\n\n            // replace instances of \"assets/myimage.jpg\" with \"http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg\"\n            contentString = contentString.replace(new RegExp('\\\"(\\\\.)*(/)*assets', 'g'), '\\\"' + contentBaseUrl + 'assets');\n\n        }\n\n        return contentString;\n    };\n\n    getElementById(id) {\n        var element = null;\n\n        if (id != null) {\n            element = this.idToElement[id];\n        }\n\n        return element;\n    };\n\n    getNodeById(id) {\n        var element = null;\n\n        if (id != null) {\n            element = this.idToNode[id];\n        }\n\n        return element;\n    };\n\n    setIdToTransition(id, transition) {\n        if (id != null) {\n            this.idToTransition[id] = transition;\n        }\n    };\n\n    getTransitionById(id) {\n        var element = null;\n\n        if (id != null) {\n            element = this.idToTransition[id];\n        }\n\n        return element;\n    };\n\n    getConstraintById(id) {\n        var element = null;\n\n        if (id != null) {\n            element = this.idToElement[id];\n        }\n\n        return element;\n    };\n\n    getParentGroup(nodeId) {\n        var result = null;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var groupNodes = this.getGroupNodes();\n\n                for (var g = 0; g < groupNodes.length; g++) {\n                    var groupNode = groupNodes[g];\n\n                    if (this.isNodeDirectChildOfGroup(node, groupNode)) {\n                        result = groupNode;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    getNodeDepth(nodeId, val) {\n        var result = null;\n\n        if(nodeId != null){\n            var depth = (typeof val === \"number\") ? val : 0;\n            var parent = this.getParentGroup(nodeId);\n            if(parent){\n                depth = this.getNodeDepth(parent.id, depth+1);\n            }\n            result = depth;\n        }\n\n        return result;\n    };\n\n    getRootNode(nodeId) {\n        var result = null;\n\n        var parentGroup = this.getParentGroup(nodeId);\n\n        if (parentGroup == null) {\n            result = this.getNodeById(nodeId);\n        } else {\n            result = this.getRootNode(parentGroup.id);\n        }\n\n        return result;\n    };\n\n    isNodeDirectChildOfGroup(node, group) {\n        var result = false;\n\n        if (node != null && group != null) {\n            var nodeId = node.id;\n            var groupIds = group.ids;\n\n            if (groupIds != null && groupIds.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    isNodeDescendentOfGroup(node, group) {\n        var result = false;\n\n        if (node != null && group != null) {\n            var descendents = this.getDescendentsOfGroup(group);\n            var nodeId = node.id;\n\n            if (descendents.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    getDescendentsOfGroup(group) {\n        var descendents = [];\n\n        if (group != null) {\n            var childIds = group.ids;\n\n            if (childIds != null) {\n                descendents = childIds;\n\n                for (var c = 0; c < childIds.length; c++) {\n                    var childId = childIds[c];\n\n                    var node = this.getNodeById(childId);\n\n                    if (node != null) {\n                        var childDescendents = this.getDescendentsOfGroup(node);\n\n                        descendents = descendents.concat(childDescendents);\n                    }\n                }\n            }\n        }\n\n        return descendents;\n    };\n\n    isStartNode(node) {\n        var result = false;\n\n        if (node != null) {\n            var nodeId = node.id;\n\n            var projectStartId = this.getStartNodeId();\n\n            if (nodeId === projectStartId) {\n                result = true;\n            }\n\n            var groups = this.getGroups();\n\n            for (var g = 0; g < groups.length; g++) {\n                var group = groups[g];\n\n                if (group != null) {\n                    var groupStartId = group.startId;\n\n                    if (nodeId === groupStartId) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    getStartNodeId() {\n        var startNodeId = null;\n        var project = this.getProject();\n        if (project != null) {\n            startNodeId = project.startNodeId;\n        }\n        return startNodeId;\n    };\n\n    getConstraints() {\n        var constraints = this.activeConstraints;\n\n        return constraints;\n    };\n\n    getConstraintsForNode(node) {\n        var constraints = [];\n\n        var allConstraints = this.getConstraints();\n\n        for (var c = 0; c < allConstraints.length; c++) {\n            var constraint = allConstraints[c];\n\n            if (this.isNodeAffectedByConstraint(node, constraint)) {\n                constraints.push(constraint);\n            }\n        }\n\n        return constraints;\n    };\n\n    isNodeAffectedByConstraint(node, constraint) {\n        var result = false;\n\n        if (node != null && constraint != null) {\n            var nodeId = node.id;\n            var targetId = constraint.targetId;\n\n            var targetNode = this.getNodeById(targetId);\n\n            if (targetNode != null) {\n                var nodeType = targetNode.type;\n\n                if (nodeType === 'node') {\n                    // the target is an application\n\n                    if (nodeId === targetId) {\n                        result = true;\n                    }\n                } else if (nodeType === 'group') {\n                    // the target is a group\n\n                    if (this.isNodeDescendentOfGroup(node, targetNode)) {\n                        result = true;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    getNavigationMode() {\n        var navigationMode = null;\n        var project = this.getProject();\n        if (project != null) {\n            navigationMode = project.navigationMode;\n        }\n        return navigationMode;\n    };\n\n    getNavigationApplications() {\n        var navigationApplications = null;\n        var project = this.getProject();\n        if (project != null) {\n            navigationApplications = project.navigationApplications;\n        }\n        return navigationApplications;\n    };\n\n    getTransitions() {\n        var transitions = null;\n        var project = this.getProject();\n        if (project != null) {\n            transitions = project.transitions;\n        }\n        return transitions;\n    };\n\n    getTransitionsByGroupId(groupId) {\n        var transitionsInGroup = [];\n\n        if (groupId != null) {\n            var group = this.getNodeById(groupId);\n\n            if (group != null) {\n                var childIds = group.ids;\n\n                if (childIds != null) {\n                    var allTransitions = this.getTransitions();\n\n                    // loop through all the transitions\n\n                    for (var t = 0; t < allTransitions.length; t++) {\n                        var tempTransition = allTransitions[t];\n\n                        if (tempTransition != null) {\n                            var from = tempTransition.from;\n                            var to = tempTransition.to;\n\n                            if (childIds.indexOf(from) != -1 || childIds.indexOf(to) != -1) {\n                                transitionsInGroup.push(tempTransition);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        var project = this.getProject();\n        if (project != null) {\n\n\n            transitions = project.transitions;\n        }\n        return transitionsInGroup;\n    };\n\n    getTransitionsByFromNodeId0(fromNodeId) {\n        var transitionsResults = [];\n        if (fromNodeId != null) {\n            var transitions = this.getTransitions();\n\n            if (transitions != null) {\n                for (var i = 0; i < transitions.length; i++) {\n                    var transition = transitions[i];\n                    if (transition.from === fromNodeId && !transition.disabled) {\n                        transitionsResults.push(transition);\n                    }\n                }\n            }\n        }\n\n        return transitionsResults;\n    };\n\n    /**\n     * Get the transition logic for a node\n     * @param fromNodeId the from node id\n     * @returns the transition logic object\n     */\n    getTransitionLogicByFromNodeId(fromNodeId) {\n        var transitionLogic = null;\n\n        if (fromNodeId != null) {\n\n            // get the node\n            var node = this.getNodeById(fromNodeId);\n\n            if (node != null) {\n                // get the transition logic\n                transitionLogic = node.transitionLogic;\n            }\n        }\n\n        return transitionLogic;\n    };\n\n    getTransitionsByToNodeId(toNodeId) {\n        var transitionsResults = [];\n        if (toNodeId != null) {\n            var transitions = this.getTransitions();\n\n            if (transitions != null) {\n                for (var i = 0; i < transitions.length; i++) {\n                    var transition = transitions[i];\n                    if (transition.to === toNodeId) {\n                        transitionsResults.push(transition);\n                    }\n                }\n            }\n        }\n\n        return transitionsResults;\n    };\n\n    getTransitionsByFromAndToNodeId(fromNodeId, toNodeId) {\n        var transitionsResults = [];\n\n        if (fromNodeId != null && toNodeId != null) {\n            var node = this.getNodeById(fromNodeId);\n\n            if (node != null) {\n                var transitionLogic = node.transitionLogic;\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    if (transitions != null) {\n\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                var to = transition.to;\n\n                                if (toNodeId === to) {\n                                    transitionsResults.push(transition);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return transitionsResults;\n    };\n\n    getLayoutLogic() {\n        var layoutLogic = null;\n        var project = this.getProject();\n        if (project != null) {\n            layoutLogic = project.layoutLogic;\n        }\n        return layoutLogic;\n    };\n\n    retrieveProject() {\n        var projectFileUrl = this.ConfigService.getConfigParam('projectURL');\n\n        return this.$http.get(projectFileUrl).then(angular.bind(this, function(result) {\n            var projectJSON = result.data;\n            this.setProject(projectJSON);\n            return projectJSON;\n        }));\n    };\n\n    saveProject(projectJSON, commitMessage) {\n\n        if (projectJSON == null) {\n            // get the project from this service\n            projectJSON = angular.toJson(this.project, 4);\n        }\n\n        var httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = this.ConfigService.getConfigParam('saveProjectURL');\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n        var params = {};\n        params.projectId = this.ConfigService.getProjectId();\n        params.commitMessage = commitMessage;\n        params.projectJSONString = projectJSON;\n        httpParams.data = $.param(params);\n\n        return this.$http(httpParams).then(angular.bind(this, function(result) {\n            var commitHistory = result.data;\n            return commitHistory;\n        }));\n    };\n\n    commitChanges(commitMessage) {\n        var commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\n\n        return this.$http({\n            url: commitProjectURL,\n            method: 'POST',\n            params: {commitMessage: commitMessage}\n        }).then(angular.bind(this, function(result) {\n            var commitResult = result.data;\n            return commitResult;\n        }));\n    };\n\n    getCommitHistory() {\n        var commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\n\n        return this.$http({\n            url: commitProjectURL,\n            method: 'GET'\n        }).then(angular.bind(this, function(result) {\n            return result.data;\n        }));\n    };\n\n    getThemePath() {\n        var project = this.getProject();\n        if (project && project.theme) { // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n            return 'wise5/vle/themes/' + project.theme;\n        } else {\n            return \"wise5/vle/themes/default\"; // TODO: get default theme name from ConfigService\n        }\n    };\n\n    getNodeTypeByNode(node) {\n        var nodeType = null;\n\n        if (node != null) {\n            nodeType = node.type;\n        }\n\n        return nodeType;\n    };\n\n    getApplicationTypeByNode(node) {\n        var applicationType = null;\n\n        if (node != null) {\n            applicationType = node.applicationType;\n        }\n\n        return applicationType;\n    };\n\n    getNodeSrcByNodeId(nodeId) {\n        var nodeSrc = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n            nodeSrc = node.src;\n        }\n\n        if(nodeSrc != null) {\n            var projectBaseURL = this.ConfigService.getConfigParam('projectBaseURL');\n            nodeSrc = projectBaseURL + nodeSrc;\n        }\n\n        return nodeSrc;\n    };\n\n    getNodeTitleByNodeId(nodeId) {\n        var title = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n            title = node.title;\n        }\n\n        return title;\n    };\n\n    /**\n     * Get the node position and title\n     * @param nodeId the node id\n     * @returns the node position and title\n     */\n    getNodePositionAndTitleByNodeId(nodeId) {\n        var title = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n\n            var position = this.getNodePositionById(nodeId);\n\n            if (position != null) {\n                title = position + ' ' + node.title;\n            } else {\n                title = node.title;\n            }\n        }\n\n        return title;\n    };\n\n    getNodeIconByNodeId(nodeId) {\n        var node = this.getNodeById(nodeId);\n        var nodeIcon = null;\n\n        if (node != null) {\n            var nodeType = this.getNodeTypeByNode(node);\n\n            // set defaults (TODO: get from configService?)\n            var defaultName = (nodeType === 'group') ? 'explore' : 'school';\n            nodeIcon = {\n                color: 'rgba(0,0,0,0.54)',\n                type: 'font',\n                fontSet: 'material-icons',\n                fontName: defaultName,\n                imgSrc: '',\n                imgAlt: 'node icon'\n            };\n\n            // TODO: check for different statuses\n            var icons = node.icons;\n            if (!!icons && !!icons.default){\n                var icon = icons.default;\n                nodeIcon = $.extend(true, nodeIcon, icon);\n            }\n\n            // check for empty image source\n            if(!nodeIcon.imgSrc){\n                // revert to font icon\n                nodeIcon.type = 'font';\n            }\n        }\n\n        return nodeIcon;\n    };\n\n    getStudentIsOnGroupNodeClass() {\n        var studentIsOnGroupNodeClass = null;\n        var project = this.getProject();\n\n        if (project != null) {\n            var layout = project.layout\n\n            if (layout != null) {\n                studentIsOnGroupNodeClass = layout.studentIsOnGroupNode;\n            }\n        }\n\n        return studentIsOnGroupNodeClass;\n    };\n\n    getStudentIsOnApplicationNodeClass() {\n        var studentIsOnApplicationNodeClass = null;\n        var project = this.getProject();\n\n        if (project != null) {\n            var layout = project.layout\n\n            if (layout != null) {\n                studentIsOnApplicationNodeClass = layout.studentIsOnApplicationNode;\n            }\n        }\n\n        return studentIsOnApplicationNodeClass;\n    };\n\n    getStartGroupId() {\n        var startGroupId = null;\n        var project = this.getProject();\n        if (project != null) {\n            startGroupId = project.startGroupId;\n        }\n        return startGroupId;\n    };\n\n    /**\n     * Flatten the project to obtain a list of node ids\n     */\n    getFlattenedProjectAsNodeIds() {\n        var nodeIds = [];\n\n        // get the start node id\n        var startNodeId = this.getStartNodeId();\n\n        /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n        var pathsSoFar = [];\n\n        // get all the possible paths through the project\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n        // consolidate all the paths to create a single list of node ids\n        nodeIds = this.consolidatePaths(allPaths);\n        //nodeIds = this.consolidatePaths(allPaths.reverse());\n\n        return nodeIds;\n    };\n\n    /**\n     * Get all the possible paths through the project. This function\n     * recursively calls itself to traverse the project depth first.\n     * @param pathSoFar the node ids in the path so far. the node ids\n     * in this array are referenced to make sure we don't loop back\n     * on the path.\n     * @param nodeId the node id we are want to get the paths from\n     * @return an array of paths. each path is an array of node ids.\n     */\n    getAllPaths(pathSoFar, nodeId) {\n        var allPaths = [];\n\n        if (nodeId != null) {\n            if (this.isApplicationNode(nodeId)) {\n                // the node is an application node\n\n                // get the transition logic from the node id\n                var transitionLogic = this.getTransitionLogicByFromNodeId(nodeId);\n\n                if (transitionLogic != null) {\n\n                    // get all the transitions from this node\n                    var transitions = transitionLogic.transitions;\n\n                    var path = [];\n\n                    if (transitions != null) {\n\n                        // add the node id to the path so far\n                        pathSoFar.push(nodeId);\n\n                        if (transitions.length === 0) {\n                            /*\n                             * there are no transitions from the node id so this path\n                             * only contains this node id\n                             */\n\n                            // add the node id to the path\n                            path.push(nodeId);\n\n                            // add the path to the all paths array\n                            allPaths.push(path);\n                        } else {\n                            // loop through all the transitions from this node id\n                            for (var t = 0; t < transitions.length; t++) {\n                                var transitionResult = [];\n\n                                // get a transition\n                                var transition = transitions[t];\n\n                                if (transition != null) {\n                                    // get the to node id\n                                    var toNodeId = transition.to;\n\n                                    if (pathSoFar.indexOf(toNodeId) == -1) {\n                                        /*\n                                         * recursively get the paths by getting all\n                                         * the paths for the to node\n                                         */\n                                        var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId);\n\n                                        if (allPathsFromToNode != null) {\n                                            // loop through all the paths for the to node\n                                            for (var a = 0; a<allPathsFromToNode.length; a++) {\n\n                                                // get a path\n                                                var tempPath = allPathsFromToNode[a];\n\n                                                // prepend the current node id to the path\n                                                tempPath.unshift(nodeId);\n\n                                                // add the path to our collection of paths\n                                                allPaths.push(tempPath);\n                                            }\n                                        }\n                                    } else {\n                                        /*\n                                         * the node is already in the path so far which means\n                                         * the transition is looping back to a previous node.\n                                         * we do not want to take this transition because\n                                         * it will lead to an infinite loop. we will just\n                                         * add the current node id to the path and not take\n                                         * the transition which essentially ends the path.\n                                         */\n                                        // add the node id to the path\n                                        path.push(nodeId);\n\n                                        // add the path to the all paths array\n                                        allPaths.push(path);\n                                    }\n                                }\n                            }\n                        }\n\n                        /*\n                         * remove the latest node id since we are moving back\n                         * up the path as we traverse the nodes depth first\n                         */\n                        pathSoFar.pop();\n                    }\n                }\n            } else if (this.isGroupNode(nodeId)) {\n                // the node is a group node\n            }\n        }\n\n        return allPaths;\n    };\n\n    /**\n     * Consolidate all the paths into a linear list of node ids\n     * @param paths an array of paths. each path is an array of node ids.\n     * @return an array of node ids that have been properly ordered\n     */\n    consolidatePaths(paths) {\n        var consolidatedPath = [];\n\n        if (paths != null) {\n\n            /*\n             * continue until all the paths are empty. as we consolidate\n             * node ids, we will remove them from the paths. once all the\n             * paths are empty we will be done consolidating the paths.\n             */\n            while(!this.arePathsEmpty(paths)) {\n\n                // start with the first path\n                var currentPath = this.getNonEmptyPathIndex(paths);\n\n                // get the first node id in the current path\n                var nodeId = this.getFirstNodeIdInPathAtIndex(paths, currentPath);\n\n                if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n                    // the first node ids in all the paths are the same\n\n                    // remove the node id from all the paths\n                    this.removeNodeIdFromPaths(nodeId, paths);\n\n                    // add the node id to our consolidated path\n                    consolidatedPath.push(nodeId);\n                } else {\n                    // not all the top node ids are the same which means we have branched\n\n                    // get all the paths that contain the node id\n                    var pathsThatContainNodeId = this.getPathsThatContainNodeId(nodeId, paths);\n\n                    if (pathsThatContainNodeId != null) {\n                        if(pathsThatContainNodeId.length === 1) {\n                            // only the current path we are on has the node id\n\n                            // remove the node id from the path\n                            this.removeNodeIdFromPath(nodeId, paths, currentPath);\n\n                            // add the node id to our consolidated path\n                            consolidatedPath.push(nodeId);\n                        } else {\n                            // there are multiple paths that have this node id\n\n                            // consume all the node ids up to the given node id\n                            var consumedPath = this.consumePathsUntilNodeId(paths, nodeId);\n\n                            // remove the node id from the paths\n                            this.removeNodeIdFromPaths(nodeId, paths);\n\n                            // add the node id to the end of the consumed path\n                            consumedPath.push(nodeId);\n\n                            // add the consumed path to our consolidated path\n                            consolidatedPath = consolidatedPath.concat(consumedPath);\n                        }\n                    }\n                }\n\n            }\n        }\n\n        return consolidatedPath;\n    };\n\n    /**\n     * Consume the node ids in the paths until we get to the given node id\n     * @param paths the paths to consume\n     * @param nodeId the node id to stop consuming at\n     * @return an array of node ids that we have consumed\n     */\n    consumePathsUntilNodeId(paths, nodeId) {\n        var consumedNodeIds = [];\n\n        if (paths != null && nodeId != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // check if the path contains the node id to stop consuming at\n                if (path != null && path.indexOf(nodeId) != -1) {\n                    /*\n                     * the path does contain the node id to stop consuming at\n                     * so we will consume the node ids in this path until\n                     * we get to the given node id to stop consuming at\n                     */\n\n                    // loop through the node ids in the path\n                    for (var x = 0; x < path.length; x++) {\n\n                        // get a node id\n                        var tempNodeId = path[x];\n\n                        if (nodeId === tempNodeId) {\n                            /*\n                             * the node id is the same as the one we need to\n                             * stop consuming at so we will stop looking\n                             * at this path\n                             */\n                            break;\n                        } else {\n                            /*\n                             * the node id is not the one that we need to stop consuming at\n                             * so we will consume it\n                             */\n\n                            // get all the paths that contain the node id\n                            var pathsThatContainNodeId = this.getPathsThatContainNodeId(tempNodeId, paths);\n\n                            if (pathsThatContainNodeId.length === 1) {\n                                // there is only one path with this node id\n\n                                // remove the node id from the path\n                                this.removeNodeIdFromPath(tempNodeId, paths, p);\n\n                                // move the counter back one since we have just removed a node id\n                                x--;\n\n                                // add the node id to the consumed node ids array\n                                consumedNodeIds.push(tempNodeId);\n                            } else {\n                                // there are multiple paths with this node id\n\n                                // tempNodeId must come before nodeId\n\n                                var pathsToConsume = [];\n\n                                // loop through all the paths that contain the node id\n                                for (var g = 0; g < pathsThatContainNodeId.length; g++) {\n\n                                    // get a path that contains the node id\n                                    var pathThatContainsNodeId = pathsThatContainNodeId[g];\n\n                                    // get the index of the node id we want to remove\n                                    var tempNodeIdIndex = pathThatContainsNodeId.indexOf(tempNodeId);\n\n                                    // get the index of the node id we want to stop consuming at\n                                    var nodeIdIndex = pathThatContainsNodeId.indexOf(nodeId);\n\n                                    /*\n                                     * check if the node id we want to remove comes before\n                                     * the node id we want to stop consuming at. we need to\n                                     * do this to prevent an infinite loop. an example of\n                                     * when this can happen is if there are two paths\n                                     *\n                                     * path1 = 1, 2, 3, 4, 5\n                                     * path2 = 1, 2, 4, 3, 5\n                                     *\n                                     * as we consume path1 we will need to consume 3. in order to\n                                     * consume 3, we must consume consume up to 3 in path2.\n                                     * in order to consume up to 3 in path2 we must consume 4.\n                                     * in order to consume 4, we must consume everything before\n                                     * 4 in path1. everything before 4 in path1 is 1, 2, 3.\n                                     * this means we need to consume 3 which brings us back up\n                                     * to the top of this paragraph creating an infinite loop.\n                                     *\n                                     * this check below will prevent infinite loops by only\n                                     * adding paths that have the tempNodeId come before the\n                                     * nodeId to stop consuming at.\n                                     */\n                                    if (tempNodeIdIndex < nodeIdIndex) {\n                                        pathsToConsume.push(pathThatContainsNodeId);\n                                    }\n                                }\n\n                                /*\n                                 * take the paths that contain the given node id and consume\n                                 * the paths until the given node id\n                                 */\n                                var tempConsumedNodeIds = this.consumePathsUntilNodeId(pathsToConsume, tempNodeId);\n\n                                // remove the node id from the paths that contain it\n                                this.removeNodeIdFromPaths(tempNodeId, pathsThatContainNodeId);\n\n                                // add the temp consumed node ids to our consumed node ids array\n                                consumedNodeIds = consumedNodeIds.concat(tempConsumedNodeIds);\n\n                                // move the counter back one since we have just removed a node id\n                                x--;\n\n                                // add the node id to the consumed node ids array\n                                consumedNodeIds.push(tempNodeId);\n                            }\n                        }\n                    }\n                }\n            }\n\n        }\n\n        return consumedNodeIds;\n    };\n\n    /**\n     * Get the path at the given index and get the first node id in\n     * the path\n     * @param paths an array of paths. each path is an array of node ids\n     * @param index the index of the path we want\n     * @return the first node in the given path\n     */\n    getFirstNodeIdInPathAtIndex(paths, index) {\n        var nodeId = null;\n\n        if (paths != null && index != null) {\n            // get the path at the given index\n            var path = paths[index];\n\n            if (path != null && path.length > 0) {\n                // get the first node id in the path\n                nodeId = path[0];\n            }\n        }\n\n        return nodeId;\n    };\n\n    /**\n     * Remove the node ifrom the paths\n     * @param nodeId the node id to remove\n     * @param paths an array of paths. each path is an array of node ids\n     */\n    removeNodeIdFromPaths(nodeId, paths) {\n\n        if (nodeId != null && paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // loop through all the node ids in the path\n                for (var x = 0; x < path.length; x++) {\n                    // get a node id\n                    var tempNodeId = path[x];\n\n                    /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n                    if (nodeId === tempNodeId) {\n                        /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n                        path.splice(x, 1);\n\n                        /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n                        x--;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Remove the node id from the path\n     * @param nodeId the node id to remove\n     * @param paths an array of paths. each path is an array of node ids\n     * @param pathIndex the path to remove from\n     */\n    removeNodeIdFromPath(nodeId, paths, pathIndex) {\n\n        if (nodeId != null && paths != null && pathIndex != null) {\n\n            // get the path at the given index\n            var path = paths[pathIndex];\n\n            if (path != null) {\n\n                // loop through all the node ids in the path\n                for (var x = 0; x < path.length; x++) {\n                    // get a ndoe id\n                    var tempNodeId = path[x];\n\n                    /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n                    if (nodeId === tempNodeId) {\n                        /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n                        path.splice(x, 1);\n\n                        /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n                        x--;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Check if the first node ids in the paths are the same\n     * @param paths an array of paths. each path is an array of node ids\n     * @return whether all the paths have the same first node id\n     */\n    areFirstNodeIdsInPathsTheSame(paths) {\n        var result = true;\n\n        var nodeId = null;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // get the first node id in the path\n                var tempNodeId = path[0];\n\n                if (nodeId == null) {\n                    /*\n                     * this is the first path we have looked at so we will\n                     * remember the node id\n                     */\n                    nodeId = tempNodeId;\n                } else if (nodeId != tempNodeId) {\n                    /*\n                     * the node id does not match the first node id from a\n                     * previous path so the paths do not all have the same\n                     * first node id\n                     */\n                    result = false;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if all the paths are empty\n     * @param paths an array of paths. each path is an array of node ids\n     * @return whether all the paths are empty\n     */\n    arePathsEmpty(paths) {\n        var result = true;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n\n                    // get the length of the path\n                    if (path.length !== 0) {\n                        // the path is not empty\n                        result = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the paths that contain the node id\n     * @param nodeId the node id we are looking for\n     * @param paths an array of paths. each path is an array of node ids\n     * @return an array of paths that contain the given node id\n     */\n    getPathsThatContainNodeId(nodeId, paths) {\n        var pathsThatContainNodeId = [];\n\n        if (nodeId != null && paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // check if the path contains the node id\n                if (path.indexOf(nodeId) != -1) {\n                    /*\n                     * add the path to the array of paths that contain\n                     * the node id\n                     */\n                    pathsThatContainNodeId.push(path);\n                }\n            }\n        }\n\n        return pathsThatContainNodeId;\n    };\n\n    /**\n     * Get a non empty path index. It will loop through the paths and\n     * return the index of the first non empty path.\n     * @param paths an array of paths. each path is an array of node ids\n     * @return the index of the path that is not empty\n     */\n    getNonEmptyPathIndex(paths) {\n        var index = null;\n\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                // check the length of the path\n                if (path.length !== 0) {\n                    // the path is not empty so we will return this index\n                    index = p;\n                    break;\n                }\n            }\n        }\n\n        return index;\n    };\n\n    /**\n     * Get the branches in the project\n     */\n    getBranches() {\n\n        // get the start node id\n        var startNodeId = this.getStartNodeId();\n\n        /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n        var pathsSoFar = [];\n\n        // get all the paths in the project\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n        // find the branches in the project from the paths\n        var branches = this.findBranches(allPaths);\n\n        return branches;\n    };\n\n    /**\n     * Find the branches in the project\n     * @param paths all the possible paths through the project\n     * @return an array of branch objects. each branch object contains\n     * the branch start point, the branch paths, and the branch\n     * end point\n     */\n    findBranches(paths) {\n        var branches = [];\n\n        var previousNodeId = null;\n\n        /*\n         * continue until all the paths are empty. we will remove\n         * node ids from the paths as we traverse the paths to find\n         * the branches\n         */\n        while(!this.arePathsEmpty(paths)) {\n\n            // get the first node id in the first path\n            var nodeId = this.getFirstNodeIdInPathAtIndex(paths, 0);\n\n            if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n                // the first node ids in all the paths are the same\n\n                // remove the node id from all the paths\n                this.removeNodeIdFromPaths(nodeId, paths);\n\n                // remember this node id for the next iteration of the loop\n                previousNodeId = nodeId;\n            } else {\n                // not all the top node ids are the same which means we have branched\n\n                // create a branch object\n                var branchMetaObject = this.createBranchMetaObject(previousNodeId);\n                branchMetaObject.branchStartPoint = previousNodeId;\n\n                // find the branch end point\n                var nextCommonNodeId = this.findNextCommonNodeId(paths);\n                branchMetaObject.branchEndPoint = nextCommonNodeId;\n\n                // get the branch paths\n                var branchPaths = this.extractPathsUpToNodeId(paths, nextCommonNodeId);\n                branchPaths = this.removeDuplicatePaths(branchPaths);\n                branchMetaObject.branchPaths = branchPaths;\n\n                // add the branch object to our array\n                branches.push(branchMetaObject);\n\n                // trim the paths so that they start at the branch end point\n                this.trimPathsUpToNodeId(paths, nextCommonNodeId);\n\n                // remember this node id for the next iteration of the loop\n                previousNodeId = nextCommonNodeId;\n            }\n        }\n\n        return branches;\n    };\n\n    /**\n     * Create a branch meta object that will contain the branch start\n     * point, branch paths, and branch end point\n     * @return an object that contains a branch start point, branch paths,\n     * and a branch end point\n     */\n    createBranchMetaObject() {\n        var branchMetaObject = {};\n\n        branchMetaObject.branchStartPoint = null;\n        branchMetaObject.branchPaths = [];\n        branchMetaObject.branchEndPoint = null;\n\n        return branchMetaObject;\n    };\n\n    /**\n     * Find the next common node id in all the paths\n     * @param paths the paths to find the common node id in\n     * @return a node id that is in all the paths or null\n     * if there is no node id that is in all the paths\n     */\n    findNextCommonNodeId(paths) {\n        var nextCommonNodeId = null;\n        var subPaths = [];\n\n        if (paths != null) {\n            if (paths.length > 0) {\n                // get the first path\n                var path = paths[0];\n\n                // loop through all the node ids in the first path\n                for (var x = 0; x < path.length; x++) {\n                    // get a node id\n                    var tempNodeId = path[x];\n\n                    // check if the node id is in all the paths\n                    if (this.allPathsContainNodeId(paths, tempNodeId)) {\n                        /*\n                         * the node id is in all the paths so we have found\n                         * what we were looking for\n                         */\n                        nextCommonNodeId = tempNodeId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return nextCommonNodeId;\n    };\n\n    /**\n     * Check if all the paths contain the node id\n     * @param paths an array of paths. each path contains an array of node ids\n     * @param nodeId the node id that we will check is in all the paths\n     * @return whether the node id is in all the paths\n     */\n    allPathsContainNodeId(paths, nodeId) {\n        var result = false;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                // get the index of the node id in the path\n                var index = path.indexOf(nodeId);\n\n                if (index == -1) {\n                    // the node id is not in the path\n                    result = false;\n                    break;\n                } else {\n                    // the node id is in the path\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Trim the paths up to the given node id so that the paths will contain\n     * the given node id and all the node ids after it. This function will\n     * modify the paths.\n     * @param paths the paths to trim\n     * @param nodeId the node id to trim up to\n     */\n    trimPathsUpToNodeId(paths, nodeId) {\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n                    // get the index of the node id in the path\n                    var index = path.indexOf(nodeId);\n\n                    if (index == -1) {\n                        /*\n                         * the node id is not in the path so we will\n                         * trim the path to the end which will make\n                         * the path empty\n                         */\n                        index = path.length;\n                    }\n\n                    /*\n                     * trim the path up to the node id index. this will\n                     * modify the path array.\n                     */\n                    path.splice(0, index);\n                }\n            }\n        }\n    };\n\n\n    /**\n     * Extract the paths up to a given node id. This will be used to\n     * obtain branch paths.\n     * @param paths the paths to extract from\n     * @param nodeId the node id to extract up to\n     * @return paths that go up to but do not include the node id\n     */\n    extractPathsUpToNodeId(paths, nodeId) {\n        var extractedPaths = [];\n\n        if (paths != null) {\n            // loop through the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n\n                    // get the index of the node id in the path\n                    var index = path.indexOf(nodeId);\n\n                    if (index == -1) {\n                        /*\n                         * the node id is not in the path so we will\n                         * extract up to the end of the path\n                         */\n                        index = path.length;\n                    }\n\n                    /*\n                     * get the path up to the node id index. this does\n                     * not modify the path array.\n                     */\n                    var extractedPath = path.slice(0, index);\n\n                    // add the\n                    extractedPaths.push(extractedPath);\n                }\n            }\n        }\n\n        return extractedPaths;\n    };\n\n    /**\n     * Removes duplicate paths\n     * @param paths an array of paths. each path contains an array of node ids\n     * @return an array of unique paths\n     */\n    removeDuplicatePaths(paths) {\n        var uniquePaths = [];\n\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                var isPathInUniquePaths = false;\n\n                // loop through all the unique paths so far\n                for (var u = 0; u < uniquePaths.length; u++) {\n                    // get a unique path\n                    var uniquePath = uniquePaths[u];\n\n                    // check if the paths are equal\n                    if (this.pathsEqual(path, uniquePath)) {\n                        // the paths are equal\n                        isPathInUniquePaths = true;\n                    }\n                }\n\n                if (!isPathInUniquePaths) {\n                    /*\n                     * the path is not equal to any paths in the unique\n                     * paths array so we will add it to the unique paths\n                     * array\n                     */\n                    uniquePaths.push(path);\n                }\n            }\n        }\n\n        return uniquePaths;\n    };\n\n    /**\n     * Check if two paths are equal\n     * @param path1 an array of node ids\n     * @param path2 an array of node ids\n     * @return whether the two paths contain the same node ids\n     * in the same order\n     */\n    pathsEqual(path1, path2) {\n        var result = false;\n\n        if (path1 != null && path2 != null) {\n\n            // check if the paths are the same length\n            if (path1.length === path2.length) {\n                result = true;\n\n                // loop through each element of the first path\n                for (var x = 0; x < path1.length; x++) {\n                    // get the node id from the first path\n                    var path1NodeId = path1[x];\n\n                    // get the node id from the second path\n                    var path2NodeId = path2[x];\n\n                    // check if the node ids are the same\n                    if (path1NodeId !== path2NodeId) {\n                        /*\n                         * the node ids are not the same to the paths\n                         * are not equal\n                         */\n                        result = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if a node id is in any branch\n     * @param branches an array of branch objects\n     * @param nodeId the node id to check\n     * @return whether the node id is in any branch\n     */\n    isNodeIdInABranch(branches, nodeId) {\n\n        if (branches != null && nodeId != null) {\n\n            // loop through all the branch objects\n            for (var b = 0; b < branches.length; b++) {\n\n                // get a branch object\n                var branch = branches[b];\n\n                if (branch != null) {\n\n                    // get the branch paths for this branch object\n                    var branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n\n                        // loop through all the branch paths\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\n\n                            // get a branch path\n                            var branchPath = branchPaths[bp];\n\n                            if (branchPath != null) {\n\n                                // check if the node id is in the branch path\n                                var index = branchPath.indexOf(nodeId);\n\n                                if (index != -1) {\n                                    // the node id is in this branch path\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Get the branch paths that a node id is in\n     * @param branches an array of branch objects\n     * @param nodeId the node id to check\n     * @return an array of the branch paths that the node id is in\n     */\n    getBranchPathsByNodeId(branches, nodeId) {\n        var branchPathsIn = [];\n\n        if (branches != null && nodeId != null) {\n\n            // loop throught all the branches\n            for (var b = 0; b < branches.length; b++) {\n\n                // get a branch\n                var branch = branches[b];\n\n                if (branch != null) {\n\n                    // get the branch paths\n                    var branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n\n                        // loop through all the branch paths\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\n\n                            // get a branch path\n                            var branchPath = branchPaths[bp];\n\n                            if (branchPath != null) {\n\n                                // get the index of the node id in the branch path\n                                var index = branchPath.indexOf(nodeId);\n\n                                if (index != -1) {\n                                    /*\n                                     * the node is in this branch path so we will\n                                     * add the branch path to our array\n                                     */\n                                    branchPathsIn.push(branchPath);\n\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return branchPathsIn;\n    }\n\n    /**\n     * Get the component by node id and component id\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @returns the component\n     */\n    getComponentByNodeIdAndComponentId(nodeId, componentId) {\n        var component = null;\n\n        if (nodeId != null && componentId != null) {\n\n            var components = this.getComponentsByNodeId(nodeId);\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n                        var tempComponentId = tempComponent.id;\n\n                        if (componentId === tempComponentId) {\n                            // we have found the component we want\n                            component = tempComponent;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return component;\n    };\n\n    /**\n     * Returns the position of the component in the node by node id and component id, 0-indexed.\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @returns the component's position\n     */\n    getComponentPositionByNodeIdAndComponentId(nodeId, componentId) {\n        var componentPosition = -1;\n\n        if (nodeId != null && componentId != null) {\n\n            var components = this.getComponentsByNodeId(nodeId);\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n                        var tempComponentId = tempComponent.id;\n\n                        if (componentId === tempComponentId) {\n                            // we have found the component we want\n                            componentPosition = c;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return componentPosition;\n    };\n\n    /**\n     * Get the components in a node\n     * @param nodeId the node id\n     * @returns an array of components\n     */\n    getComponentsByNodeId(nodeId) {\n        var components = [];\n\n        if (nodeId != null) {\n\n            // get the node\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n\n                // get the node content\n                var content = node.content;\n\n                if (content != null) {\n                    var tempComponents = content.components;\n\n                    if (tempComponents != null) {\n                        // we have obtained the components\n                        components = tempComponents;\n                    }\n                }\n            }\n        }\n\n        return components;\n    };\n\n    getNodeContentByNodeId(nodeId) {\n        var nodeContent = null;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                nodeContent = node.content;\n            }\n        }\n\n        return nodeContent;\n    };\n\n    /**\n     * Replace a component\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param component the new component\n     */\n    replaceComponent(nodeId, componentId, component) {\n\n        if (nodeId != null && componentId != null && component != null) {\n\n            // get all the components for the node\n            var components = this.getComponentsByNodeId(nodeId);\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n\n                        if (tempComponent.id === componentId) {\n                            // the component id matches the one we want so we will replace it\n                            components[c] = component;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n}\n\nProjectService.$inject = ['$http', '$rootScope', 'ConfigService'];\n\nexport default ProjectService;\n\n"]}