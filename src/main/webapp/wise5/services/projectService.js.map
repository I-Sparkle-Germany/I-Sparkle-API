{"version":3,"sources":["projectService.es6"],"names":["ProjectService","$filter","$http","$injector","$q","$rootScope","ConfigService","UtilService","project","transitions","applicationNodes","inactiveStepNodes","inactiveGroupNodes","groupNodes","idToNode","idToElement","metadata","activeConstraints","rootNode","idToPosition","idToOrder","nodeCount","componentServices","nodeIdToNumber","nodeIdToIsInBranchPath","nodeIdToBranchPathLetter","achievements","isNodeAffectedByConstraintResult","flattenedProjectAsNodeIds","$translate","additionalProcessingFunctionsMap","filters","parseProject","style","name","getProjectMetadata","title","projectTitle","nodes","planningNodes","nodeId","node","getNodeById","ids","id","getNodes","transition","existingTransitions","getTransitions","replaced","t","length","existingTransition","splice","push","existingNodes","n","existingNode","existingNodeId","$broadcast","groupId","group","groupChildNodeIds","indexOf","groupNode","type","applicationNode","nodeType","content","constraints","setIdToNode","setIdToElement","addNode","addGroupNode","addApplicationNode","addNodeToGroupNode","isPreview","getConfigParam","constraint","planningNode","clearProjectFields","loadNodes","loadPlanningNodes","inactiveNodes","loadInactiveNodes","constraintId","active","getRootNode","setNodeOrder","branches","getBranches","branchNodeIds","pos","setIdToPosition","isNodeIdInABranch","getPositionById","b","getBranchNodePositionById","calculateNodeNumbers","isGroupNode","childIds","childId","child","getMode","planningIds","availablePlanningNodes","planningId","startGroupId","stepNumber","importProjectIdToOrder","getNodeOrderOfProjectHelper","result","item","c","childStepNumber","i","path","getPathToNode","undefined","order","getIdByOrder","integerToAlpha","int","alphabet","branch","branchPaths","p","branchPath","nodeIndex","startPoint","branchStartPoint","startPointPos","branchPathPos","num","position","Object","entries","value","element","contentString","JSON","stringify","replaceAssetPaths","parse","contentBaseURL","replace","RegExp","matchedString","delimiter","matchedStringWithoutQuotes","substr","charAt","injectClickToSnipImageIntoContentString","imgMatcher","matchGroup1","newString","tempNode","getNodePositionById","nodeIcon","defaultName","color","fontSet","fontName","imgSrc","imgAlt","icons","default","icon","$","extend","getGroupNodes","isNodeDirectChildOfGroup","getInactiveGroupNodes","inactiveGroupNode","parentGroup","getParentGroup","val","depth","parent","getNodeDepth","groupIds","descendents","getDescendentsOfGroup","childDescendents","concat","projectStartId","getStartNodeId","groups","getGroups","groupStartId","startId","startNodeId","allConstraints","isNodeAffectedByConstraint","orderedNodeIds","getFlattenedProjectAsNodeIds","sort","constraintsComparatorGenerator","constraintA","constraintB","constraintAIndex","targetId","constraintBIndex","rememberedResult","getIsNodeAffectedByConstraintResult","action","isNodeIdAfter","targetNode","isNodeDescendentOfGroup","setIsNodeAffectedByConstraintResult","nodeIdBefore","nodeIdAfter","isApplicationNode","pathsToEnd","getAllPaths","pathToEnd","index","parentGroupId","parentGroupIndex","getTransitionsByFromNodeId","toNodeId","to","navigationMode","componentId","component","getComponentByNodeIdAndComponentId","componentType","componentService","get","getPossibleTransitionCriteria","fromNodeId","transitionLogic","getTransitionLogicByFromNodeId","nodesByToNodeId","nodeIds","getNodesByToNodeId","groupsThatPointToNodeId","hasTransitionTo","transitionsResults","projectURL","Date","getTime","then","projectJSON","data","setProject","projectId","configURL","window","configJSON","previewProjectURL","commitMessage","cleanupBeforeSave","getProjectId","saveProjectURL","projectJSONString","angular","toJson","httpParams","method","url","headers","params","param","commitHistory","notifyProjectBeginURL","otherAuthors","resolve","reject","notifyProjectEndURL","activeNodes","getActiveNodes","activeNode","checked","getInactiveNodes","inactiveNode","copyProjectURL","registerNewProjectURL","e","Error","commitProjectURL","wiseBaseURL","getWISEBaseURL","theme","themeSettings","recalculate","pathsSoFar","allPaths","consolidatePaths","pathSoFar","includeGroups","addedCurrentNodeId","getParentGroupId","parentGroupTransitions","parentGroupTransition","allPathsFromToNode","tempPath","unshift","firstNodeId","firstParentGroupId","lastNodeId","pop","paths","consolidatedPath","arePathsEmpty","currentPath","getNonEmptyPathIndex","getFirstNodeIdInPathAtIndex","areFirstNodeIdsInPathsTheSame","removeNodeIdFromPaths","pathsThatContainNodeId","getPathsThatContainNodeId","removeNodeIdFromPath","consumedPath","consumePathsUntilNodeId","consumedNodeIds","x","tempNodeId","pathsToConsume","pathThatContainsNodeId","tempNodeIdIndex","nodeIdIndex","tempConsumedNodeIds","pathIndex","findBranches","previousNodeId","branchMetaObject","createBranchMetaObject","nextCommonNodeId","findNextCommonNodeId","branchEndPoint","extractPathsUpToNodeId","removeDuplicatePaths","trimPathsUpToNodeId","allPathsContainNodeId","extractedPaths","extractedPath","slice","uniquePaths","isPathInUniquePaths","uniquePath","pathsEqual","path1","path2","path1NodeId","path2NodeId","branchPathsIn","components","getComponentsByNodeId","tempComponent","tempComponentId","nodeContent","newGroupId","getNextAvailableGroupId","newGroup","newNodeId","getNextAvailableNodeId","newNode","showSaveButton","showSubmitButton","addInactiveNode","insertNodeInsideInTransitions","insertNodeInsideInGroups","isInactive","insertNodeAfterInGroups","insertNodeAfterInTransitions","oldToGroupIds","transitionsFromGroup","transitionFromGroup","fromGroupId","newToGroupId","updateTransitionsForInsertingGroup","nodeIdToInsert","nodeIdToInsertAfter","previousNode","updateChildrenTransitionsForMovingGroup","previousNodeTransitionLogic","transitionsJSONString","transitionsCopy","fromJson","parentTransitions","parentTransition","newTransition","getGroupStartId","transitionObject","removeBranchPathTakenNodeConstraints","branchPathTakenConstraints","getBranchPathTakenConstraintsByNodeId","branchPathTakenConstraint","newConstraint","getNextAvailableConstraintIdForNodeId","removalCriteria","makeCopyOfJSONObject","nodeIdToInsertInside","nodeToInsert","previousNodes","previousGroups","getGroupNodesByToNodeId","previousGroup","lastNodesInGroup","getLastNodesInGroup","addToTransition","updateToTransition","nodesThatTransitionToGroup","nodeThatTransitionsToGroup","startNode","nextGroup","criteria","oldToNodeId","newToNodeId","lastNodes","getGroupIds","largestGroupIdNumber","groupIdNumber","isNaN","parseInt","nextAvailableGroupId","inactiveGroup","inactiveGroupId","nodeIdsToSkip","getNodeIds","largestNodeIdNumber","nodeIdNumber","inactiveNodeIds","getInactiveNodeIds","inactiveNodeId","nodeIdToSkip","nextAvailableNodeId","movedNodes","movingNodeIsActive","isActive","stationaryNodeIsActive","removeNodeIdFromTransitions","removeNodeIdFromGroups","moveToInactive","moveToActive","moveInactiveNode","newNodes","nodeIdToCopy","copyNode","createNodeInside","createNodeAfter","nodeCopy","newComponentIds","newComponentId","getUnusedComponentId","removingProjectStartNodeId","removeNodeIdFromNodes","hasSetNewStartId","isNodeInGroup","setStartNodeId","nextNodeId","nextGroupNode","nextGroupStartId","transitionToNodeId","recalculatePositionsInGroup","nodeToRemove","nodeToRemoveTransitionLogic","nodeToRemoveTransitions","parentIdOfNodeToRemove","parentGroupStartId","nodeToRemoveTransition","parentIdOfFromNode","tc","tempTransition","tempToNodeId","parentIdOfToNode","isFirstNodeInBranchPath","nodeIdsInBranch","getNodeIdsInBranch","nodeIdInBranch","nodeInBranch","transitionCopy","currentFromNodeId","currentToNodeId","newFromNodeId","updateBranchPathTakenConstraint","isBranchPoint","getBranchesByBranchStartPointNodeId","branchPathNodeId","branchPathNode","insertIndex","groupIdWeAreMoving","groupThatTransitionsToGroupWeAreMoving","updateChildrenTransitionsIntoGroupWeAreMoving","removeTransitionsOutOfGroup","insertAfterComponentId","service","createComponent","componentHasWork","doesAnyComponentShowSubmitButton","addComponentToNode","componentUsesSaveButton","added","componentIds","componentsToMove","a","maxScore","firstPath","nodeMaxScore","getMaxScoreForNode","componentMaxScore","firstLeafNodeId","done","tempApplicationNode","tempApplicationNodeId","planning","planningNodeTemplateId","availablePlanningNodeIds","availablePlanningNodesSoFar","availablePlanningNode","availablePlanningNodeActual","max","nextAvailablePlanningNodeId","planningNodeInstance","planningNodeInstanceNodeId","nodeIdToMove","moveNodesInside","moveNodesAfter","getChildNodeIdsById","message","nodeTitle","getNodePositionAndTitleByNodeId","removalConditional","criteriaMessages","tempRemovalCriteria","criteriaMessage","getCriteriaMessage","scoresString","scores","join","score","requiredSubmitCount","requiredNumberOfWords","oldToGroupId","fromGroup","oldToGroup","newToGroup","newToGroupStartId","oldToGroupStartId","transitionsBefore","previousGroupNodes","transitionsAfter","extracted","previousGroupNode","updateTransitionsForExtractingGroup","transitionAfter","inserted","getStartGroupId","startGroup","firstGroupId","connectedComponentId","connectedComponents","connectedComponent","componentContent","connectedComponentParams","removeChildNodesFromActiveNodes","removeNodeFromActiveNodes","removeChildFromParent","removeNodeFromInactiveStepNodes","removeNodeFromInactiveGroupNodes","startIdUpdated","inactiveStepNode","isGroupActive","activeNodeId","activeComponents","activeComponent","activeComponentId","removeNodeFromInactiveNodes","childNode","addGroupChildNodesToInactive","removeTransitionsThatPointToNodeIdFromOutsideGroup","nodesThatPointToTargetNode","nodeThatPointsToTargetNode","nodeThatPointsToTargetNodeParentGroupId","removeTransition","toNodeIdParentGroupId","transitionsFromChild","tfc","transitionFromChild","firstNodeToRemoveTransition","firstNodeToRemoveTransitionToNodeId","nodeIdAndComponentIds","getNodeContentByNodeId","nodeIdAndComponentId","showPreviousWorkNodeId","showPreviousWorkComponentId","annotation","displayAnnotation","previousScore","currentScore","annotationGroup","globalAnnotationSettings","globalAnnotationGroups","globalAnnotationGroup","enableCriteria","scoreSequence","previousScoreMatch","currentScoreMatch","toString","match","notificationResult","notificationSettings","notifications","notification","getComponentService","componentServiceName","componentIdsToSkip","idLength","generateKey","isComponentIdUsed","alreadyUsed","selectedNodes","fromProjectId","toProjectId","nodeIdToInsertInsideOrAfter","importStepsURL","steps","newNodeIds","selectedNode","isNodeIdUsed","tempComponents","nextAvailableConstraintId","usedConstraintIds","foundNextAvailableConstraintId","counter","potentialConstraintId","field","orderedItems","foundNodeId","$key","hasBranchPathTakenConstraint","orderNodeIds","nodeIdsComparatorGenerator","nodeIdA","nodeIdB","nodeIdAIndex","nodeIdBIndex","removalCriterion","targetNodeId","makeThisNodeNotVisibleConstraint","notVisibleRemovalCriterion","makeThisNodeNotVisitableConstraint","notVisitableRemovalCriterion","rubric","html","transitionTo","allBranches","currentActivityNumber","currentStepNumber","calculateNodeNumbersHelper","branchLetterCode","isBranchMergePoint","isBranchStartPoint","branchesByBranchStartPointNodeId","branchesObject","maxCurrentStepNumber","bp","branchCurrentStepNumber","bpn","branchEndPointNodeId","number","branchLetter","String","fromCharCode","script","scriptFilename","assetDirectoryPath","getProjectAssetsDirectoryPath","scriptPath","additionalProcessingFunction","key","getAdditionalProcessingFunctions","flattenedNodeIds","indexOfNodeId","indexOfPreviousNodeId","indexOfNextNodeId","isEnabled","items","getAchievements","achievementId","achievementItems","achievement","nodePosition","branchLetterRegex","exec","nodeRubric","componentRubric","newComponents","newComponent","copyComponent","insertPosition","getComponentPositionByNodeIdAndComponentId","importProjectId","currentComponents","$inject"],"mappings":"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","file":"projectService.js","sourcesContent":["'use strict';\n\nclass ProjectService {\n  constructor($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService) {\n    this.$filter = $filter;\n    this.$http = $http;\n    this.$injector = $injector;\n    this.$q = $q;\n    this.$rootScope = $rootScope;\n    this.ConfigService = ConfigService;\n    this.UtilService = UtilService;\n    this.project = null;\n    this.transitions = [];\n    this.applicationNodes = [];\n    this.inactiveStepNodes = [];\n    this.inactiveGroupNodes = [];\n    this.groupNodes = [];\n    this.idToNode = {};\n    this.idToElement = {};\n    this.metadata = {};\n    this.activeConstraints = [];\n    this.rootNode = null;\n    this.idToPosition = {};\n    this.idToOrder = {};\n    this.nodeCount = 0;\n    this.componentServices = {};\n    this.nodeIdToNumber = {};\n    this.nodeIdToIsInBranchPath = {};\n    this.nodeIdToBranchPathLetter = {};\n    this.achievements = [];\n    this.isNodeAffectedByConstraintResult = {};\n    this.flattenedProjectAsNodeIds = null;\n\n    this.$translate = this.$filter('translate');\n\n    // map from nodeId_componentId to array of additionalProcessingFunctions\n    this.additionalProcessingFunctionsMap = {};\n\n    // filtering options for navigation displays\n    this.filters = [\n      {'name': 'all', 'label': 'All'}\n      //{'name': 'todo', 'label': 'Todo'},\n      //{'name': 'completed', 'label': 'Completed'}\n    ];\n  };\n\n  setProject(project) {\n    this.project = project;\n    this.parseProject();\n  };\n\n  /**\n   * Initialize the data structures used to hold project information\n   */\n  clearProjectFields() {\n    this.transitions = [];\n    this.applicationNodes = [];\n    this.inactiveStepNodes = [];\n    this.inactiveGroupNodes = [];\n    this.groupNodes = [];\n    this.idToNode = {};\n    this.idToElement = {};\n    this.metadata = {};\n    this.activeConstraints = [];\n    this.rootNode = null;\n    this.idToPosition = {};\n    this.idToOrder = {};\n    this.nodeCount = 0;\n    this.nodeIdToIsInBranchPath = {};\n    this.achievements = [];\n  };\n\n  getStyle() {\n    let style = '';\n    const project = this.project;\n    if (project != null) {\n      style = project.style;\n    }\n    return style;\n  };\n\n  getFilters() {\n    return this.filters;\n  };\n\n  /**\n   * Returns the name/title of the current project\n   */\n  getProjectTitle() {\n    const name = this.getProjectMetadata().title;\n    return name ? name : 'A WISE Project (No name)';\n  };\n\n  /**\n   * Set the project title\n   */\n  setProjectTitle(projectTitle) {\n    const metadata = this.getProjectMetadata();\n    if (metadata != null) {\n      metadata.title = projectTitle;\n    }\n  }\n\n  getProjectMetadata() {\n    return this.metadata ? this.metadata : {};\n  };\n\n  getNodes() {\n    const project = this.project;\n    if (project != null) {\n      return project.nodes;\n    }\n    return null;\n  };\n\n  getPlanningNodes() {\n    const project = this.project;\n    if (project != null) {\n      return project.planningNodes;\n    }\n    return null;\n  };\n\n  getChildNodeIdsById(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node.ids) {\n      return node.ids;\n    }\n    return [];\n  };\n\n  getGroupNodes() {\n    return this.groupNodes;\n  };\n\n  isNode(id) {\n    const nodes = this.getNodes();\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null) {\n          const nodeId = node.id;\n          if (nodeId === id) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  // adds or update transition if exists\n  addTransition(transition) {\n    const existingTransitions = this.getTransitions();\n    let replaced = false;\n    for (let t = 0; t < existingTransitions.length; t++) {\n      const existingTransition = existingTransitions[t];\n      if (existingTransition.id === transition.id) {\n        existingTransitions.splice(t, 1, transition);\n        replaced = true;\n      }\n    }\n    if (!replaced) {\n      existingTransitions.push(transition);\n    }\n  };\n\n  addNode(node) {\n    const existingNodes = this.project.nodes;\n    let replaced = false;\n    if (node != null && existingNodes != null) {\n      for (let n = 0; n < existingNodes.length; n++) {\n        const existingNode = existingNodes[n];\n        const existingNodeId = existingNode.id;\n        if (existingNodeId === node.id) {\n          existingNodes.splice(n, 1, node);\n          replaced = true;\n        }\n      }\n    }\n    if (!replaced) {\n      existingNodes.push(node);\n    }\n  };\n\n  addApplicationNode(node) {\n    const applicationNodes = this.applicationNodes;\n    if (node != null && applicationNodes != null) {\n      applicationNodes.push(node);\n    }\n  };\n\n  addGroupNode(node) {\n    const groupNodes = this.groupNodes;\n    if (node != null && groupNodes != null) {\n      groupNodes.push(node);\n    }\n    this.$rootScope.$broadcast('groupsChanged');\n  };\n\n  addNodeToGroupNode(groupId, nodeId) {\n    if (groupId != null && nodeId != null) {\n      const group = this.getNodeById(groupId);\n      if (group != null) {\n        const groupChildNodeIds = group.ids;\n        if (groupChildNodeIds != null) {\n          if (groupChildNodeIds.indexOf(nodeId) === -1) {\n            groupChildNodeIds.push(nodeId);\n          }\n        }\n      }\n    }\n  };\n\n  isGroupNode(id) {\n    const groupNode = this.getNodeById(id);\n    if (groupNode != null) {\n      const type = groupNode.type;\n      if (type === 'group') {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  isApplicationNode(id) {\n    const applicationNode = this.getNodeById(id);\n    if (applicationNode != null) {\n      const type = applicationNode.type;\n      if (type !== 'group') {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  getGroups() {\n    return this.groupNodes;\n  };\n\n  /**\n   * Get the inactive group nodes.\n   * @return An array of inactive group nodes.\n   */\n  getInactiveGroupNodes() {\n    return this.inactiveGroupNodes;\n  }\n\n  /**\n   * Get the inactive step nodes. This will include the inactive steps that\n   * are in an inactive group.\n   * @return An array of inactive step nodes.\n   */\n  getInactiveStepNodes() {\n    return this.inactiveStepNodes;\n  }\n\n  loadNodes(nodes) {\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null) {\n          const nodeId = node.id;\n          const nodeType = node.type;\n          const content = node.content;\n          const constraints = node.constraints;\n\n          if (content != null) {\n            //node.content = this.injectAssetPaths(content);\n          }\n\n          this.setIdToNode(nodeId, node);\n          this.setIdToElement(nodeId, node);\n          this.addNode(node);\n\n          if (nodeType === 'group') {\n            this.addGroupNode(node);\n          } else {\n            this.addApplicationNode(node);\n          }\n\n          const groupId = node.groupId;\n          if (groupId != null) {\n            this.addNodeToGroupNode(groupId, nodeId);\n          }\n\n          if (constraints != null) {\n            if (this.ConfigService.isPreview() == true && this.ConfigService.getConfigParam('constraints') === false) {\n              /*\n               * if we are in preview mode and constraints are set\n               * to false, we will not add the constraints\n               */\n            } else {\n              // all other cases we will add the constraints\n              for (let constraint of constraints) {\n                this.activeConstraints.push(constraint);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Load the planning template nodes\n   * @param planning template nodes\n   */\n  loadPlanningNodes(planningNodes) {\n    if (planningNodes != null) {\n      for (let planningNode of planningNodes) {\n        if (planningNode != null) {\n          const nodeId = planningNode.id;\n          this.setIdToNode(nodeId, planningNode);\n          this.setIdToElement(nodeId, planningNode);\n\n          // TODO: may need to add more function calls here to add the planning\n        }\n      }\n    }\n  }\n\n  /**\n   * Parse the project to detect the nodes, branches, node numbers, etc.\n   */\n  parseProject() {\n    const project = this.project;\n    if (project != null) {\n      this.clearProjectFields();\n\n      if (project.metadata) {\n        this.metadata = project.metadata;\n      }\n\n      const nodes = project.nodes;\n      this.loadNodes(nodes);\n\n      const planningNodes = project.planningNodes;\n      this.loadPlanningNodes(planningNodes);\n\n      const inactiveNodes = project.inactiveNodes;\n      this.loadInactiveNodes(inactiveNodes);\n\n      const constraints = project.constraints;\n\n      if (constraints != null) {\n        for (let constraint of constraints) {\n          if (constraint != null) {\n            const constraintId = constraint.id;\n            constraint.active = true;\n            this.setIdToElement(constraintId, constraint);\n          }\n        }\n      }\n\n      this.rootNode = this.getRootNode(nodes[0].id);\n      this.setNodeOrder(this.rootNode, this.nodeCount);\n\n      let n = nodes.length;\n      const branches = this.getBranches();\n      const branchNodeIds = [];\n\n      // set node positions\n      let id, pos;\n\n      while (n--) {\n        id = nodes[n].id;\n        if (id === this.rootNode.id) {\n          this.setIdToPosition(id, '0');\n        } else if (this.isNodeIdInABranch(branches, id)) {\n          // node is in a branch, so process later\n          branchNodeIds.push(id);\n        } else {\n          pos = this.getPositionById(id);\n          this.setIdToPosition(id, pos);\n        }\n      }\n\n      // set branch node positions\n      let b = branchNodeIds.length;\n      while (b--) {\n        id = branchNodeIds[b];\n        pos = this.getBranchNodePositionById(id);\n        this.setIdToPosition(id, pos);\n      }\n\n      /*\n       * calculate the node numbers\n       * e.g. if the step is called\n       * 1.5 View the Potential Energy\n       * then the node number is 1.5\n       */\n      this.calculateNodeNumbers();\n\n      if (this.project.achievements != null) {\n        this.achievements = this.project.achievements;\n      }\n    }\n\n    this.$rootScope.$broadcast('projectChanged');\n  };\n\n  setNodeOrder(node) {\n    this.idToOrder[node.id] = {'order': this.nodeCount};\n    this.nodeCount++;\n    if (this.isGroupNode(node.id)) {\n      let childIds = node.ids;\n      for (let childId of childIds) {\n        let child = this.getNodeById(childId);\n        this.setNodeOrder(child);\n      }\n\n      if (this.ConfigService.getMode() === 'classroomMonitor') {\n        // we're viewing the classroom monitor, so include planning nodes in the project structure\n        let planningIds = node.availablePlanningNodes;\n        if (planningIds) {\n          for (let planningId of planningIds) {\n            let child = this.getNodeById(planningId.nodeId);\n            this.setNodeOrder(child);\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Get the node order mappings of the project\n   * @param project the project JSOn\n   * @return an object containing the idToOrder mapping and also the array\n   * of nodes\n   */\n  getNodeOrderOfProject(project) {\n    const idToOrder = {};\n    idToOrder.nodeCount = 0;\n    const startGroupId = project.startGroupId;\n    const rootNode = this.getNodeById(startGroupId, project);\n    const stepNumber = '';\n    const nodes = [];\n    const importProjectIdToOrder = this.getNodeOrderOfProjectHelper(project, rootNode, idToOrder, stepNumber, nodes);\n    delete importProjectIdToOrder.nodeCount;\n    const result = {};\n    result.idToOrder = importProjectIdToOrder;\n    result.nodes = nodes;\n    return result;\n  }\n\n  /**\n   * Recursively traverse the project to calculate the node order and step numbers\n   * @param project the project JSON\n   * @param node the current node we are on\n   * @param idToOrder the mapping of node id to item\n   * @param stepNumber the current step number\n   * @param nodes the array of nodes\n   */\n  getNodeOrderOfProjectHelper(project, node, idToOrder, stepNumber, nodes) {\n    /*\n     * Create the item that we will add to the idToOrder mapping.\n     * The 'order' field determines how the project nodes are displayed\n     * when we flatten the project for displaying.\n     */\n    const item = {\n      'order': idToOrder.nodeCount,\n      'node': node,\n      'stepNumber': stepNumber\n    };\n\n    idToOrder[node.id] = item;\n    idToOrder.nodeCount++;\n    nodes.push(item);\n\n    if (node.type == 'group') {\n      const childIds = node.ids;\n      for (let c = 0; c < childIds.length; c++) {\n        const childId = childIds[c];\n        const child = this.getNodeById(childId, project);\n        let childStepNumber = stepNumber;\n\n        if (childStepNumber != '') {\n          // add the . separator for the step number e.g. 1.\n          childStepNumber += '.';\n        }\n\n        childStepNumber += (c + 1);\n        this.getNodeOrderOfProjectHelper(project, child, idToOrder, childStepNumber, nodes);\n      }\n    }\n    return idToOrder;\n  }\n\n  /**\n   * Returns the position in the project for the node with the given id. Returns null if no node with id exists.\n   * @param id a node id\n   * @return string position of the given node id in the project\n   */\n  getPositionById(id) {\n    for (let i = 0; i < this.rootNode.ids.length; i++) {\n      const node = this.getNodeById(this.rootNode.ids[i]);\n      const path = this.getPathToNode(node, i + 1, id);\n      if (path != undefined && path != null) {\n        return path;\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Returns the order of the given node id in the project. Returns null if no node with id exists.\n   * @param id String node id\n   * @return Number order of the given node id in the project\n   */\n  getOrderById(id) {\n    if (this.idToOrder[id]) {\n      return this.idToOrder[id].order;\n    }\n    return null;\n  };\n\n  /**\n   * Returns the id of the node with the given order in the project. Returns null if no order with node exists.\n   * @param order Number\n   * @return Number node id of the given order in the project\n   */\n  getIdByOrder(order) {\n    let nodeId = null;\n    for (let id in this.idToOrder) {\n      if (this.idToOrder[id].order === order) {\n        if (this.isGroupNode(id) && order > 1) {\n          nodeId = this.getIdByOrder(order-1);\n        } else {\n          nodeId = id;\n        }\n        break;\n      }\n    }\n    return nodeId;\n  };\n\n  /**\n   * Returns the position in the project for the branch node with the given id. Returns null if no node with id exists or node is not a branch node.\n   * @param id a node id\n   * @return string position of the given node id in the project\n   */\n  getBranchNodePositionById(id) {\n    const branches = this.getBranches();\n    let b = branches.length;\n\n    // TODO: should we localize this? should we support more than 26?\n    const integerToAlpha = function(int) {\n      const alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n      if (int > -1 && int < 26) {\n        return alphabet[int];\n      } else {\n        return int;\n      }\n    };\n\n    while (b--) {\n      const branch = branches[b];\n      const branchPaths = branch.branchPaths;\n      for (let p = 0; p < branchPaths.length; p++) {\n        const branchPath = branchPaths[p];\n        const nodeIndex = branchPath.indexOf(id);\n        if (nodeIndex > -1) {\n          const startPoint = branch.branchStartPoint;\n          const startPointPos = this.idToPosition[startPoint];\n          const branchPathPos = startPointPos + ' ' + integerToAlpha(p);\n          return branchPathPos + (nodeIndex+1);\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Recursively searches for the given node id from the point of the given node down and returns the path number (position)\n   * @param node a node to start searching down\n   * @param path the position of the given node\n   * @param id the node id to search for\n   * @return string path of the given node id in the project\n   */\n  getPathToNode(node, path, id) {\n    if (node.id === id) {\n      return path + '';\n    } else if (node.type === 'group') {\n      let num = 0;\n      const branches = this.getBranches();\n      for (let nodeId of node.ids) {\n        if (this.isNodeIdInABranch(branches, nodeId)) {\n          this.getBranchNodePositionById(nodeId);\n        } else {\n          ++num;\n          const pos = this.getPathToNode(this.getNodeById(nodeId), (path) + '.' + (num), id);\n          if (pos) {\n            return pos;\n          }\n        }\n      }\n    }\n  };\n\n  setIdToPosition(id, pos) {\n    if (id != null) {\n      this.idToPosition[id] = pos;\n    }\n  };\n\n  getNodePositionById(id) {\n    let position = null;\n    if (id != null) {\n      position = this.nodeIdToNumber[id];\n    }\n    return position;\n  };\n\n  getNodeIdByOrder(order) {\n    let id = null;\n    if (order != null) {\n      for (let [nodeId, value] of Object.entries(this.idToOrder)) {\n        if (value.order === order) {\n          id = nodeId;\n          break;\n        }\n      }\n    }\n    return id;\n  }\n\n  getNodeOrderById(id) {\n    let order = null;\n    if (id != null) {\n      order = this.idToOrder[id] ? this.idToOrder[id].order : null;\n    }\n    return order;\n  };\n\n  setIdToNode(id, element) {\n    if (id != null) {\n      this.idToNode[id] = element;\n    }\n  };\n\n  setIdToElement(id, element) {\n    if (id != null) {\n      this.idToElement[id] = element;\n    }\n  };\n\n  /**\n   * Replace relative asset paths with absolute paths\n   * e.g.\n   * assets/myimage.jpg\n   * will be replaced with\n   * http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg\n   * @param content a string or JSON object\n   * @return the same type of object that was passed in as the content\n   * but with relative asset paths replaced with absolute paths\n   */\n  injectAssetPaths(content) {\n    if (content != null) {\n      if (typeof content === 'object') {\n        let contentString = JSON.stringify(content);\n        if (contentString != null) {\n          // replace the relative asset paths with the absolute paths\n          contentString = this.replaceAssetPaths(contentString);\n          content = JSON.parse(contentString);\n        }\n      } else if (typeof content === 'string') {\n        // replace the relative asset paths with the absolute paths\n        content = this.replaceAssetPaths(content);\n      }\n    }\n    return content;\n  };\n\n  /**\n   * Replace the relative asset paths with absolute paths\n   * @param contentString the content string\n   * @return the content string with relative asset paths replaced\n   * with absolute asset paths\n   */\n  replaceAssetPaths(contentString) {\n    if (contentString != null) {\n      // get the content base url e.g. http://wise.berkeley.edu/curriculum/123456/\n      const contentBaseURL = this.ConfigService.getConfigParam('projectBaseURL');\n\n      // only look for string that starts with ' or \" and ends in png, jpg, jpeg, pdf, etc.\n      // the string we're looking for can't start with '/ and \"/.\n      // note that this also works for \\\"abc.png and \\'abc.png, where the quotes are escaped\n      contentString = contentString.replace(\n        new RegExp('(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")[^:][^\\/]?[^\\/]?[a-zA-Z0-9@\\\\._\\\\/\\\\s\\\\-]*[\\.](png|jpe?g|pdf|gif|mov|mp4|mp3|wav|swf|css|txt|json|xlsx?|doc|html.*?|js).*?(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")', 'gi'),\n        (matchedString) => {\n          // once found, we prepend the contentBaseURL + \"assets/\" to the string within the quotes and keep everything else the same.\n          let delimiter = '';\n          let matchedStringWithoutQuotes = '';\n\n          if (matchedString.length > 2 && matchedString.substr(0,1) == '\\\\') {\n            // the string has escaped quotes for example \\\"hello.png\\\"\n\n            // get everything between the escaped quotes\n            matchedStringWithoutQuotes = matchedString.substr(2, matchedString.length - 4);\n\n            // get the delimiter which will be \\' or \\\"\n            delimiter = matchedString.substr(0,2);\n          } else {\n            // the string does not have escaped quotes for example \"hello.png\"\n\n            // get everything between the quotes\n            matchedStringWithoutQuotes = matchedString.substr(1, matchedString.length - 2);\n\n            // get the delimiter which will be ' or \"\n            delimiter = matchedString.substr(0,1);\n          }\n\n          if (matchedStringWithoutQuotes != null && matchedStringWithoutQuotes.length > 0 && matchedStringWithoutQuotes.charAt(0) == \"/\") {\n            /*\n             * the matched string starts with a \"/\" which means it's\n             * an absolute path and does not require path prepending\n             * so we will just return the original unmodified string\n             */\n            return delimiter + matchedStringWithoutQuotes + delimiter;\n          } else {\n            //const matchedStringWithoutFirstAndLastQuote = matchedString.substr(1, matchedString.length - 2);  // everything but the beginning and end quote (' or \")\n            // make a new string with the contentBaseURL + assets/ prepended to the path\n            return delimiter + contentBaseURL + \"assets/\" + matchedStringWithoutQuotes + delimiter;\n          }\n        }\n      );\n    }\n    return contentString;\n  };\n\n  /**\n   * Inject the ng-click attribute that will call the snipImage function\n   * @param content the content\n   * @returns the modified content\n   */\n  injectClickToSnipImage(content) {\n    if (content != null) {\n      if (typeof content === 'object') {\n        let contentString = JSON.stringify(content);\n        if (contentString != null) {\n          // replace the relative asset paths with the absolute paths\n          contentString = this.injectClickToSnipImageIntoContentString(contentString);\n\n          content = JSON.parse(contentString);\n        }\n      } else if (typeof content === 'string') {\n        // replace the relative asset paths with the absolute paths\n        content = this.injectClickToSnipImageIntoContentString(content);\n      }\n    }\n    return content;\n  }\n\n  /**\n   * Inject the ng-click attribute that will call the snipImage function\n   * @param contentString the content in string format\n   * @returns the modified content string\n   */\n  injectClickToSnipImageIntoContentString(contentString) {\n    if (contentString != null) {\n      // regex to match image elements\n      const imgMatcher = new RegExp('<img.*?src=\\\\\\\\?[\\'\"](.*?)\\\\\\\\?[\\'\"].*?>', 'gi');\n\n      // replace all instances that match\n      contentString = contentString.replace(imgMatcher,\n        (matchedString, matchGroup1) => {\n          /*\n           * insert the ng-click attribute\n           * Before: <img src=\"abc.png\"/>\n           * After: <img ng-click=\"vleController.snipImage($event)\" src=\"abc.png\" />\n           */\n          const newString = matchedString.replace('img', 'img ng-click=\\\\\\\"$emit(\\'snipImage\\', $event)\\\\\\\"');\n          return newString;\n        }\n      );\n    }\n    return contentString;\n  }\n\n  /**\n   * Returns the node specified by the nodeId\n   * @param nodeId get the node with this node id\n   * @param (optional) the project to retrieve the node from. this is used in\n   * the case when we want the node from another project such as when we are\n   * importing a step from another project\n   * Return null if nodeId param is null or the specified node does not exist in the project.\n   */\n  getNodeById(nodeId, project) {\n    if (project == null) {\n      // the project argument is null so we will get it from the current project\n      if (nodeId != null && this.idToNode[nodeId]) {\n        return this.idToNode[nodeId];\n      }\n    } else {\n      /*\n       * the project argument is not null so we will get the node from\n       * project that was passed in\n       */\n      for (let tempNode of project.nodes) {\n        if (tempNode != null && tempNode.id == nodeId) {\n          return tempNode;\n        }\n      }\n\n      for (let tempNode of project.inactiveNodes) {\n        if (tempNode != null && tempNode.id == nodeId) {\n          return tempNode;\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Returns the title of the node with the nodeId\n   * Return null if nodeId param is null or the specified node does not exist in the project.\n   */\n  getNodeTitleByNodeId(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      return node.title;\n    }\n    return null;\n  };\n\n  /**\n   * Get the node position and title\n   * @param nodeId the node id\n   * @returns the node position and title, e.g. \"1.1 Introduction\"\n   */\n  getNodePositionAndTitleByNodeId(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      const position = this.getNodePositionById(nodeId);\n      if (position != null) {\n        return position + ': ' + node.title;\n      } else {\n        return node.title;\n      }\n    }\n    return null;\n  };\n\n  getNodeIconByNodeId(nodeId) {\n    const node = this.getNodeById(nodeId);\n    let nodeIcon = null;\n    if (node != null) {\n      const nodeType = node.type;\n\n      // set defaults (TODO: get from configService?)\n      const defaultName = (nodeType === 'group') ? 'explore' : 'school';\n      nodeIcon = {\n        color: 'rgba(0,0,0,0.54)',\n        type: 'font',\n        fontSet: 'material-icons',\n        fontName: defaultName,\n        imgSrc: '',\n        imgAlt: 'node icon'\n      };\n\n      // TODO: check for different statuses\n      const icons = node.icons;\n      if (!!icons && !!icons.default) {\n        const icon = icons.default;\n        nodeIcon = $.extend(true, nodeIcon, icon);\n      }\n\n      // check for empty image source\n      if (!nodeIcon.imgSrc) {\n        // revert to font icon\n        nodeIcon.type = 'font';\n      }\n    }\n    return nodeIcon;\n  };\n\n  getParentGroup(nodeId) {\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        // Check if the node is a child of an active group.\n        const groupNodes = this.getGroupNodes();\n        for (let groupNode of groupNodes) {\n          if (this.isNodeDirectChildOfGroup(node, groupNode)) {\n            return groupNode;\n          }\n        }\n\n        // Check if the node is a child of an inactive group.\n        const inactiveGroupNodes = this.getInactiveGroupNodes();\n        for (let inactiveGroupNode of inactiveGroupNodes) {\n          if (this.isNodeDirectChildOfGroup(node, inactiveGroupNode)) {\n            return inactiveGroupNode;\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Get the parent group id\n   * @param nodeId the parent group id\n   * @returns the parent group id\n   */\n  getParentGroupId(nodeId) {\n    if (nodeId != null) {\n      const parentGroup = this.getParentGroup(nodeId);\n      if (parentGroup != null) {\n        return parentGroup.id;\n      }\n    }\n    return null;\n  }\n\n  getNodeDepth(nodeId, val) {\n    if (nodeId != null) {\n      let depth = (typeof val === \"number\") ? val : 0;\n      const parent = this.getParentGroup(nodeId);\n      if (parent) {\n        depth = this.getNodeDepth(parent.id, depth + 1);\n      }\n      return depth;\n    }\n    return null;\n  };\n\n  getRootNode(nodeId) {\n    const parentGroup = this.getParentGroup(nodeId);\n    if (parentGroup == null) {\n      return this.getNodeById(nodeId);\n    } else {\n      return this.getRootNode(parentGroup.id);\n    }\n    return null;\n  };\n\n  isNodeDirectChildOfGroup(node, group) {\n    if (node != null && group != null) {\n      const nodeId = node.id;\n      const groupIds = group.ids;\n\n      if (groupIds != null && groupIds.indexOf(nodeId) != -1) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  isNodeDescendentOfGroup(node, group) {\n    if (node != null && group != null) {\n      const descendents = this.getDescendentsOfGroup(group);\n      const nodeId = node.id;\n\n      if (descendents.indexOf(nodeId) != -1) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  getDescendentsOfGroup(group) {\n    let descendents = [];\n    if (group != null) {\n      const childIds = group.ids;\n      if (childIds != null) {\n        descendents = childIds;\n        for (let childId of childIds) {\n          const node = this.getNodeById(childId);\n          if (node != null) {\n            const childDescendents = this.getDescendentsOfGroup(node);\n            descendents = descendents.concat(childDescendents);\n          }\n        }\n      }\n    }\n    return descendents;\n  };\n\n  isStartNode(node) {\n    let result = false;\n    if (node != null) {\n      const nodeId = node.id;\n      const projectStartId = this.getStartNodeId();\n      if (nodeId === projectStartId) {\n        result = true;\n      }\n\n      const groups = this.getGroups();\n      for (let group of groups) {\n        if (group != null) {\n          const groupStartId = group.startId;\n          if (nodeId === groupStartId) {\n            result = true;\n            break;\n          }\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Returns the Project's start node id, or null if it's not defined in the project\n   */\n  getStartNodeId() {\n    const project = this.project;\n    if (project != null) {\n      return project.startNodeId;\n    }\n    return null;\n  };\n\n  /**\n   * Set the start node id\n   * @param nodeId the new start node id\n   */\n  setStartNodeId(nodeId) {\n    if (nodeId != null) {\n      const project = this.project;\n      if (project != null) {\n        project.startNodeId = nodeId;\n      }\n    }\n  }\n\n  /**\n   * Get the start group id\n   * @return the start group id\n   */\n  getStartGroupId() {\n    const project = this.project;\n    if (project != null) {\n      return project.startGroupId;\n    }\n    return null;\n  }\n\n  /**\n   * Check if the given node id is the start node id\n   * @return whether the node id is the start node id\n   */\n  isStartNodeId(nodeId) {\n    const project = this.project;\n    if (project != null) {\n      const startNodeId = project.startNodeId;\n      if (nodeId === startNodeId) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  getConstraintsForNode(node) {\n    const constraints = [];\n    const allConstraints = this.activeConstraints;\n    for (let constraint of allConstraints) {\n      if (this.isNodeAffectedByConstraint(node, constraint)) {\n        constraints.push(constraint);\n      }\n    }\n    return constraints;\n  };\n\n  /**\n   * Order the constraints so that they show up in the same order as in the\n   * project.\n   * @param constraints An array of constraint objects.\n   * @return An array of ordered constraints.\n   */\n  orderConstraints(constraints) {\n    let orderedNodeIds = this.getFlattenedProjectAsNodeIds();\n    return constraints.sort(this.constraintsComparatorGenerator(orderedNodeIds));\n  }\n\n  /**\n   * Create the constraints comparator function that is used for sorting an\n   * array of constraint objects.\n   * @param orderedNodeIds An array of node ids in the order in which they\n   * show up in the project.\n   * @return A comparator that orders constraint objects in the order in which\n   * the target ids show up in the project.\n   */\n  constraintsComparatorGenerator(orderedNodeIds) {\n    return function(constraintA, constraintB) {\n      let constraintAIndex = orderedNodeIds.indexOf(constraintA.targetId);\n      let constraintBIndex = orderedNodeIds.indexOf(constraintB.targetId);\n      if (constraintAIndex < constraintBIndex) {\n        return -1;\n      } else if (constraintAIndex > constraintBIndex) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Check if a node is affected by the constraint\n   * @param node check if the node is affected\n   * @param constraint the constraint that might affect the node\n   * @returns whether the node is affected by the constraint\n   */\n  isNodeAffectedByConstraint(node, constraint) {\n    let result = false;\n    if (node != null && constraint != null) {\n      // check if we have previously calculated the result before\n      const rememberedResult = this.getIsNodeAffectedByConstraintResult(node.id, constraint.id, result);\n      if (rememberedResult != null) {\n        // we have calculated the result before\n\n        // use the remembered result\n        result = rememberedResult;\n      } else {\n        // we have not calculated the result before\n        const nodeId = node.id;\n        const targetId = constraint.targetId;\n        const action = constraint.action;\n\n        if (action === 'makeAllNodesAfterThisNotVisible') {\n          if (this.isNodeIdAfter(targetId, node.id)) {\n            result = true;\n          }\n        } else if (action === 'makeAllNodesAfterThisNotVisitable') {\n          if (this.isNodeIdAfter(targetId, node.id)) {\n            result = true;\n          }\n        } else {\n          const targetNode = this.getNodeById(targetId);\n          if (targetNode != null) {\n            const nodeType = targetNode.type;\n            if (nodeType === 'node') {\n              if (nodeId === targetId) {\n                result = true;\n              }\n            } else if (nodeType === 'group') {\n              if (nodeId === targetId) {\n                result = true;\n              }\n              if (this.isNodeDescendentOfGroup(node, targetNode)) {\n                result = true;\n              }\n            }\n          }\n        }\n\n        // remember the result so we can look it up in the future\n        this.setIsNodeAffectedByConstraintResult(node.id, constraint.id, result);\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Check if a node id comes after another node id in the project\n   * @param nodeIdBefore the node id before\n   * @param nodeIdAfter the node id after\n   */\n  isNodeIdAfter(nodeIdBefore, nodeIdAfter) {\n    let result = false;\n    if (nodeIdBefore != null && nodeIdAfter != null) {\n      if (this.isApplicationNode(nodeIdBefore)) {\n        // the node id before is a step\n\n        // get all the paths from the beforeNodeId to the end of the project\n        const pathsToEnd = this.getAllPaths([], nodeIdBefore, true);\n\n        if (pathsToEnd != null) {\n          for (let pathToEnd of pathsToEnd) {\n            if (pathToEnd != null) {\n              /*\n               * remove the first node id and its parent id because\n               * we will check the remaining node ids in the array\n               * for the nodeIdAfter\n               */\n\n              // get the index of the node id before\n              const index = pathToEnd.indexOf(nodeIdBefore);\n\n              if (index != -1) {\n                // remove the node id before\n                pathToEnd.splice(index, 1);\n              }\n\n              // get the parent group of the node id before\n              const parentGroup = this.getParentGroup(nodeIdBefore);\n\n              if (parentGroup != null) {\n                // remove the parent group of the node id before\n                const parentGroupId = parentGroup.id;\n                const parentGroupIndex = pathToEnd.indexOf(parentGroupId);\n                if (parentGroupIndex != -1) {\n                  pathToEnd.splice(parentGroupIndex, 1);\n                }\n              }\n\n              if (pathToEnd.indexOf(nodeIdAfter) != -1) {\n                // we have found the nodeIdAfter in the path to the end of the project\n                result = true;\n              }\n            }\n          }\n        }\n      } else {\n        // the node id before is an activity\n\n        const group = this.getNodeById(nodeIdBefore);\n        if (group != null) {\n          const transitions = this.getTransitionsByFromNodeId(nodeIdBefore);\n          if (transitions != null) {\n            for (let transition of transitions) {\n              if (transition != null) {\n                const toNodeId = transition.to;\n\n                // get the paths between to toNodeId and the end of the project\n                const pathsToEnd = this.getAllPaths([], toNodeId, true);\n\n                for (let pathToEnd of pathsToEnd) {\n                  if (pathToEnd != null) {\n                    if (pathToEnd.indexOf(nodeIdAfter) != -1) {\n                      // we have found the nodeIdAfter in the path to the end of the project\n                      result = true;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  getNavigationMode() {\n    const project = this.project;\n    if (project != null) {\n      return project.navigationMode;\n    }\n    return null;\n  };\n\n  getTransitions() {\n    const project = this.project;\n    if (project != null) {\n      return project.transitions;\n    }\n    return null;\n  };\n\n  /**\n   * Returns all possible transition criteria for the specified node and component.\n   */\n  getPossibleTransitionCriteria(nodeId, componentId) {\n    let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    if (component != null) {\n      let componentType = component.type;\n      let componentService = this.$injector.get(componentType + 'Service');\n      if (componentService.getPossibleTransitionCriteria) {\n        return componentService.getPossibleTransitionCriteria(nodeId, componentId, component);\n      } else {\n        return [];\n      }\n    } else {\n      return [];\n    }\n  };\n\n  /**\n   * Get the transition logic for a node\n   * @param fromNodeId the from node id\n   * @returns the transition logic object\n   */\n  getTransitionLogicByFromNodeId(fromNodeId) {\n    if (fromNodeId != null) {\n      // get the node\n      const node = this.getNodeById(fromNodeId);\n\n      if (node != null) {\n        // get the transition logic\n        return node.transitionLogic;\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Get the transitions for a node\n   * @param fromNodeId the node to get transitions from\n   * @returns an array of transitions\n   */\n  getTransitionsByFromNodeId(fromNodeId) {\n    if (fromNodeId != null) {\n      // get the transition logic\n      const transitionLogic = this.getTransitionLogicByFromNodeId(fromNodeId);\n\n      if (transitionLogic != null) {\n        // get the transitions\n        return transitionLogic.transitions;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get nodes that have a transition to the given node id\n   * @param toNodeId the node id\n   * @returns an array of node objects that transition to the\n   * given node id\n   */\n  getNodesByToNodeId(toNodeId) {\n    const nodesByToNodeId = [];\n    if (toNodeId != null) {\n      const nodes = this.project.nodes;\n      for (let node of nodes) {\n        const transitionLogic = node.transitionLogic;\n        if (transitionLogic != null) {\n          const transitions = transitionLogic.transitions;\n          if (transitions != null) {\n            for (let transition of transitions) {\n              if (transition != null) {\n                if (toNodeId === transition.to) {\n                  // this node has a transition to the node id\n                  nodesByToNodeId.push(node);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodesByToNodeId;\n  };\n\n  /**\n   * Get node ids of all the nodes that have a to transition to the given node id\n   * @param toNodeId\n   * @returns all the node ids that have a transition to the given node id\n   */\n  getNodeIdsByToNodeId(toNodeId) {\n    const nodeIds = [];\n    const nodes = this.getNodesByToNodeId(toNodeId);\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null) {\n          nodeIds.push(node.id);\n        }\n      }\n    }\n    return nodeIds;\n  }\n\n  /**\n   * Get the group nodes that point to a given node id\n   * @param toNodeId\n   */\n  getGroupNodesByToNodeId(toNodeId) {\n    const groupsThatPointToNodeId = [];\n    if (toNodeId != null) {\n      const groups = this.getGroups();\n      for (let group of groups) {\n        if (group != null) {\n          if (this.hasTransitionTo(group, toNodeId)) {\n            groupsThatPointToNodeId.push(group);\n          }\n        }\n      }\n    }\n    return groupsThatPointToNodeId;\n  }\n\n  /**\n   * Check if a node has a transition to a node id\n   * @param node check if this node has a transition to the node id\n   * @param toNodeId we will look for a transition to this node id\n   * @returns whether the node has a transition to the node id\n   */\n  hasTransitionTo(node, toNodeId) {\n    if (node != null && toNodeId != null) {\n      const transitionLogic = node.transitionLogic;\n      if (transitionLogic != null) {\n        const transitions = transitionLogic.transitions;\n        if (transitions != null) {\n          for (let transition of transitions) {\n            if (toNodeId === transition.to) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the transitions that traverse from the fromNodeId and to the toNodeId\n   * @param fromNodeId the from node id\n   * @param toNodeId the to node id\n   * @returns an array of transitions that traverse from the fromNodeId and\n   * to the toNodeId\n   */\n  getTransitionsByFromAndToNodeId(fromNodeId, toNodeId) {\n    const transitionsResults = [];\n    if (fromNodeId != null && toNodeId != null) {\n      const node = this.getNodeById(fromNodeId);\n      if (node != null) {\n        const transitionLogic = node.transitionLogic;\n        if (transitionLogic != null) {\n          const transitions = transitionLogic.transitions;\n          if (transitions != null) {\n            for (let transition of transitions) {\n              if (transition != null) {\n                const to = transition.to;\n                if (toNodeId === to) {\n                  transitionsResults.push(transition);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return transitionsResults;\n  };\n\n  /**\n   * Retrieves the project JSON from Config.projectURL and returns it.\n   * If Config.projectURL is undefined, returns null.\n   */\n  retrieveProject() {\n    let projectURL = this.ConfigService.getConfigParam('projectURL');\n    if (projectURL == null) {\n      return null;\n    } else {\n      /*\n       * add a unique GET parameter value so that it always retrieves the\n       * latest version of the project file from the server and never\n       * retrieves the project from cache.\n       */\n      projectURL += '?noCache=' + (new Date()).getTime();\n    }\n\n    return this.$http.get(projectURL).then((result) => {\n      const projectJSON = result.data;\n      this.setProject(projectJSON);\n      return projectJSON;\n    });\n  };\n\n  /**\n   * Retrieve the project JSON\n   * @param projectId retrieve the project JSON with this id\n   * @return a promise to return the project JSON\n   */\n  retrieveProjectById(projectId) {\n    if (projectId != null) {\n      // get the config URL for the project\n      const configURL = window.configURL + '/' + projectId;\n\n      // get the config for the project\n      return this.$http.get(configURL).then((result) => {\n        const configJSON = result.data;\n\n        if (configJSON != null) {\n          // get the project URL and preview project URL\n          const projectURL = configJSON.projectURL;\n          const previewProjectURL = configJSON.previewProjectURL;\n\n          if (projectURL != null) {\n            // get the project JSON\n            return this.$http.get(projectURL).then((result) => {\n              const projectJSON = result.data;\n\n              /*\n               * set the preview project URL into the project JSON\n               * so that we easily obtain the preview project URL\n               * later\n               */\n              projectJSON.previewProjectURL = previewProjectURL;\n\n              return projectJSON;\n            });\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Saves the project to Config.saveProjectURL and returns commit history promise.\n   * if Config.saveProjectURL or Config.projectId are undefined, does not save and returns null\n   */\n  saveProject(commitMessage = \"\") {\n    this.$rootScope.$broadcast('savingProject');\n    // perform any cleanup before saving the project\n    this.cleanupBeforeSave();\n\n    const projectId = this.ConfigService.getProjectId();\n    const saveProjectURL = this.ConfigService.getConfigParam('saveProjectURL');\n    if (projectId == null || saveProjectURL == null) {\n      return null;\n    }\n\n    // Get the project from this service\n    const projectJSONString = angular.toJson(this.project, 4);\n\n    const httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = saveProjectURL;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    const params = {};\n    params.projectId = projectId;\n    params.commitMessage = commitMessage;\n    params.projectJSONString = projectJSONString;\n    httpParams.data = $.param(params);\n\n    return this.$http(httpParams).then((result) => {\n      const commitHistory = result.data;\n      this.$rootScope.$broadcast('projectSaved');\n      return commitHistory;\n    });\n  };\n\n  /**\n   * Notifies others that the specified project is being authored\n   * @param projectId id of the project\n   */\n  notifyAuthorProjectBegin(projectId = null) {\n    if (projectId == null) {\n      if (this.project != null) {\n        projectId = this.project.id;\n      } else {\n        return;\n      }\n    }\n    let notifyProjectBeginURL = this.ConfigService\n        .getConfigParam('notifyProjectBeginURL') + projectId;\n    let httpParams = {\n      method: \"POST\",\n      url: notifyProjectBeginURL\n    };\n\n    return this.$http(httpParams).then((result) => {\n      let otherAuthors = result.data;\n      return otherAuthors;\n    });\n  }\n\n  /**\n   * Notifies others that the specified project is being authored\n   * @param projectId id of the project\n   */\n  notifyAuthorProjectEnd(projectId = null) {\n    return this.$q((resolve, reject) => {\n      if (projectId == null) {\n        if (this.project != null) {\n          projectId = this.ConfigService.getProjectId();\n        } else {\n          resolve();\n        }\n      }\n      let notifyProjectEndURL = this.ConfigService.getConfigParam('notifyProjectEndURL') + projectId;\n      let httpParams = {};\n      httpParams.method = 'POST';\n      httpParams.url = notifyProjectEndURL;\n\n      this.$http(httpParams).then(() => {\n        resolve();\n      })\n    });\n  }\n\n  /**\n   * Perform any necessary cleanup before we save the project.\n   * For example we need to remove the checked field in the inactive node\n   * objects.\n   */\n  cleanupBeforeSave() {\n    let activeNodes = this.getActiveNodes();\n    for (let activeNode of activeNodes) {\n      if (activeNode != null) {\n        delete activeNode.checked;\n      }\n    }\n\n    let inactiveNodes = this.getInactiveNodes();\n    for (let inactiveNode of inactiveNodes) {\n      if (inactiveNode != null) {\n        delete inactiveNode.checked;\n      }\n    }\n  }\n\n  /**\n   * Copies the project with the specified id and returns a new project id if the project is\n   * successfully copied\n   */\n  copyProject(projectId) {\n    const copyProjectURL = this.ConfigService.getConfigParam('copyProjectURL');\n    if (copyProjectURL == null) {\n      return null;\n    }\n\n    const httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = copyProjectURL + \"/\" + projectId;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    const params = {};\n    httpParams.data = $.param(params);\n\n    return this.$http(httpParams).then((result) => {\n      const projectId = result.data;\n      return projectId;\n    });\n  };\n\n  /**\n   * Registers a new project having the projectJSON content with the server.\n   * Returns a new project Id if the project is successfully registered.\n   * Returns null if Config.registerNewProjectURL is undefined.\n   * Throws an error if projectJSONString is invalid JSON string\n   */\n  registerNewProject(projectJSONString, commitMessage) {\n    const registerNewProjectURL = this.ConfigService.getConfigParam('registerNewProjectURL');\n    if (registerNewProjectURL == null) {\n      return null;\n    }\n\n    try {\n      // Try parsing the JSON string and throw an error if there's an issue parsing it.\n      JSON.parse(projectJSONString);\n    } catch (e) {\n      throw new Error(\"Invalid projectJSONString.\");\n    }\n\n    if (!commitMessage) {\n      commitMessage = \"\";\n    }\n\n    const httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = registerNewProjectURL;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    const params = {};\n    params.commitMessage = commitMessage;\n    params.projectJSONString = projectJSONString;\n    httpParams.data = $.param(params);\n\n    return this.$http(httpParams).then((result) => {\n      const projectId = result.data;\n      return projectId;\n    });\n  };\n\n  /**\n   * Retrieves and returns the project's commit history.\n   */\n  getCommitHistory() {\n    const commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\n    return this.$http({\n      url: commitProjectURL,\n      method: 'GET'\n    }).then((result) => {\n      return result.data;\n    });\n  };\n\n  /**\n   * Returns the theme path for the current project\n   */\n  getThemePath() {\n    let wiseBaseURL = this.ConfigService.getWISEBaseURL();\n    let project = this.project;\n    if (project && project.theme) {\n      // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n      return wiseBaseURL + '/wise5/themes/' + project.theme;\n    } else {\n      // TODO: get default theme name from ConfigService\n      return wiseBaseURL + '/wise5/themes/default';\n    }\n  };\n\n  /**\n   * Returns the theme settings for the current project\n   */\n  getThemeSettings() {\n    let themeSettings = {};\n    let project = this.project;\n    if (project && project.themeSettings) {\n      if (project.theme) {\n        // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n        themeSettings = project.themeSettings[project.theme];\n      } else {\n        // TODO: get default theme name from ConfigService\n        themeSettings = project.themeSettings[\"default\"];\n      }\n    }\n    return themeSettings ? themeSettings : {};\n  };\n\n  /**\n   * Flatten the project to obtain a list of node ids\n   * @param recalculate Whether to force recalculating the flattened node ids.\n   * @return An array of the flattened node ids in the project.\n   */\n  getFlattenedProjectAsNodeIds(recalculate) {\n    if (!recalculate && this.flattenedProjectAsNodeIds != null) {\n      // use the previously calculated flattened node ids\n      return this.flattenedProjectAsNodeIds;\n    }\n\n    // get the start node id\n    const startNodeId = this.getStartNodeId();\n\n    /*\n     * an array to keep track of the node ids in the path that\n     * we are currently on as we traverse the nodes in the project\n     * depth first\n     */\n    const pathsSoFar = [];\n\n    // get all the possible paths through the project\n    const allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n    // consolidate all the paths to create a single list of node ids\n    const nodeIds = this.consolidatePaths(allPaths);\n\n    /*\n     * Remember the flattened node ids so that we don't have to calculate\n     * it again.\n     */\n    this.flattenedProjectAsNodeIds = nodeIds;\n\n    return nodeIds;\n  };\n\n  /**\n   * Get all the possible paths through the project. This function\n   * recursively calls itself to traverse the project depth first.\n   * @param pathSoFar the node ids in the path so far. the node ids\n   * in this array are referenced to make sure we don't loop back\n   * on the path.\n   * @param nodeId the node id we want to get the paths from\n   * @param includeGroups whether to include the group node ids in the paths\n   * @return an array of paths. each path is an array of node ids.\n   */\n  getAllPaths(pathSoFar, nodeId, includeGroups) {\n    const allPaths = [];\n    if (nodeId != null) {\n      if (this.isApplicationNode(nodeId)) {\n        const path = [];\n        const transitions = this.getTransitionsByFromNodeId(nodeId);\n        if (transitions != null) {\n          if (includeGroups) {\n            const parentGroup = this.getParentGroup(nodeId);\n            if (parentGroup != null) {\n              const parentGroupId = parentGroup.id;\n              if (parentGroupId != null && pathSoFar.indexOf(parentGroupId) == -1) {\n                pathSoFar.push(parentGroup.id);\n              }\n            }\n          }\n\n          /*\n           * add the node id to the path so far so we can later check\n           * which nodes are already in the path to prevent looping\n           * back in the path\n           */\n          pathSoFar.push(nodeId);\n\n          if (transitions.length === 0) {\n            /*\n             * there are no transitions from the node id so we will\n             * look for a transition in the parent group\n             */\n\n            let addedCurrentNodeId = false;\n            const parentGroupId = this.getParentGroupId(nodeId);\n            const parentGroupTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n\n            if (parentGroupTransitions != null) {\n              for (let parentGroupTransition of parentGroupTransitions) {\n                if (parentGroupTransition != null) {\n                  const toNodeId = parentGroupTransition.to;\n                  if (pathSoFar.indexOf(toNodeId) == -1) {\n                    /*\n                     * recursively get the paths by getting all\n                     * the paths for the to node\n                     */\n                    const allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                    for (let tempPath of allPathsFromToNode) {\n                      tempPath.unshift(nodeId);\n                      allPaths.push(tempPath);\n                      addedCurrentNodeId = true;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (!addedCurrentNodeId) {\n              /*\n               * if the parent group doesn't have any transitions we will\n               * need to add the current node id to the path\n               */\n              path.push(nodeId);\n              allPaths.push(path);\n            }\n          } else {\n            // there are transitions from this node id\n\n            for (let transition of transitions) {\n              if (transition != null) {\n                const toNodeId = transition.to;\n                if (toNodeId != null && pathSoFar.indexOf(toNodeId) == -1) {\n                  // we have not found the to node in the path yet so we can traverse it\n\n                  /*\n                   * recursively get the paths by getting all\n                   * the paths from the to node\n                   */\n                  const allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                  if (allPathsFromToNode != null) {\n                    for (let tempPath of allPathsFromToNode) {\n                      if (includeGroups) {\n                        // we need to add the group id to the path\n\n                        if (tempPath.length > 0) {\n                          const firstNodeId = tempPath[0];\n                          const firstParentGroupId = this.getParentGroupId(firstNodeId);\n                          const parentGroupId = this.getParentGroupId(nodeId);\n                          if (parentGroupId != firstParentGroupId) {\n                            /*\n                             * the parent ids are different which means this is a boundary\n                             * between two groups. for example if the project looked like\n                             * group1>node1>node2>group2>node3>node4\n                             * and the current node was node2 then the first node in the\n                             * path would be node3 which means we would need to place\n                             * group2 on the path before node3\n                             */\n                            tempPath.unshift(firstParentGroupId);\n                          }\n                        }\n                      }\n\n                      tempPath.unshift(nodeId);\n                      allPaths.push(tempPath);\n                    }\n                  }\n                } else {\n                  /*\n                   * the node is already in the path so far which means\n                   * the transition is looping back to a previous node.\n                   * we do not want to take this transition because\n                   * it will lead to an infinite loop. we will just\n                   * add the current node id to the path and not take\n                   * the transition which essentially ends the path.\n                   */\n                  path.push(nodeId);\n                  allPaths.push(path);\n                }\n              }\n            }\n          }\n\n          if (pathSoFar.length > 0) {\n            const lastNodeId = pathSoFar[pathSoFar.length - 1];\n            if (this.isGroupNode(lastNodeId)) {\n              /*\n               * the last node id is a group id so we will remove it\n               * since we are moving back up the path as we traverse\n               * the nodes depth first\n               */\n              pathSoFar.pop();\n            }\n          }\n\n          /*\n           * remove the latest node id (this will be a step node id)\n           * since we are moving back up the path as we traverse the\n           * nodes depth first\n           */\n          pathSoFar.pop();\n\n          if (includeGroups) {\n            if (pathSoFar.length == 1) {\n              /*\n               * we are including groups and we have traversed\n               * back up to the start node id for the project.\n               * the only node id left in pathSoFar is now the\n               * parent group of the start node id. we will\n               * now add this parent group of the start node id\n               * to all of the paths\n               */\n\n              for (let path of allPaths) {\n                if (path != null) {\n                  /*\n                   * prepend the parent group of the start node id\n                   * to the path\n                   */\n                  path.unshift(pathSoFar[0]);\n                }\n              }\n\n              /*\n               * remove the parent group of the start node id from\n               * pathSoFar which leaves us with an empty pathSoFar\n               * which means we are completely done with\n               * calculating all the paths\n               */\n              pathSoFar.pop();\n            }\n          }\n        }\n      } else if (this.isGroupNode(nodeId)) {\n\n        /*\n         * add the node id to the path so far so we can later check\n         * which nodes are already in the path to prevent looping\n         * back in the path\n         */\n        pathSoFar.push(nodeId);\n\n        const groupNode = this.getNodeById(nodeId);\n        if (groupNode != null) {\n          const startId = groupNode.startId;\n          if (startId == null || startId == \"\") {\n            // there is no start id so we will take the transition from the group\n            // TODO? there is no start id so we will loop through all the child nodes\n\n            const transitions = this.getTransitionsByFromNodeId(groupNode.id);\n            if (transitions != null && transitions.length > 0) {\n              for (let transition of transitions) {\n                if (transition != null) {\n                  const toNodeId = transition.to;\n\n                  const allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                  if (allPathsFromToNode != null) {\n                    for (let tempPath of allPathsFromToNode) {\n                      tempPath.unshift(nodeId);\n                      allPaths.push(tempPath);\n                    }\n                  }\n                }\n              }\n            } else {\n              /*\n               * this activity does not have any transitions so\n               * we have reached the end of this path\n               */\n\n              const tempPath = [];\n              tempPath.unshift(nodeId);\n              allPaths.push(tempPath);\n            }\n          } else {\n            // there is a start id so we will traverse it\n\n            const allPathsFromToNode = this.getAllPaths(pathSoFar, startId, includeGroups);\n\n            if (allPathsFromToNode != null) {\n              for (let tempPath of allPathsFromToNode) {\n                tempPath.unshift(nodeId);\n                allPaths.push(tempPath);\n              }\n            }\n          }\n        }\n\n        /*\n         * remove the latest node id since we are moving back\n         * up the path as we traverse the nodes depth first\n         */\n        pathSoFar.pop();\n      }\n    }\n    return allPaths;\n  };\n\n  /**\n   * Consolidate all the paths into a linear list of node ids\n   * @param paths an array of paths. each path is an array of node ids.\n   * @return an array of node ids that have been properly ordered\n   */\n  consolidatePaths(paths) {\n    let consolidatedPath = [];\n\n    if (paths != null) {\n      /*\n       * continue until all the paths are empty. as we consolidate\n       * node ids, we will remove them from the paths. once all the\n       * paths are empty we will be done consolidating the paths.\n       */\n      while(!this.arePathsEmpty(paths)) {\n        // start with the first path\n        const currentPath = this.getNonEmptyPathIndex(paths);\n\n        // get the first node id in the current path\n        const nodeId = this.getFirstNodeIdInPathAtIndex(paths, currentPath);\n        if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n          // the first node ids in all the paths are the same\n\n          // remove the node id from all the paths\n          this.removeNodeIdFromPaths(nodeId, paths);\n\n          // add the node id to our consolidated path\n          consolidatedPath.push(nodeId);\n        } else {\n          // not all the top node ids are the same which means we have branched\n\n          // get all the paths that contain the node id\n          const pathsThatContainNodeId = this.getPathsThatContainNodeId(nodeId, paths);\n\n          if (pathsThatContainNodeId != null) {\n            if (pathsThatContainNodeId.length === 1) {\n              // only the current path we are on has the node id\n\n              // remove the node id from the path\n              this.removeNodeIdFromPath(nodeId, paths, currentPath);\n\n              // add the node id to our consolidated path\n              consolidatedPath.push(nodeId);\n            } else {\n              // there are multiple paths that have this node id\n\n              // consume all the node ids up to the given node id\n              const consumedPath = this.consumePathsUntilNodeId(paths, nodeId);\n\n              // remove the node id from the paths\n              this.removeNodeIdFromPaths(nodeId, paths);\n\n              // add the node id to the end of the consumed path\n              consumedPath.push(nodeId);\n\n              // add the consumed path to our consolidated path\n              consolidatedPath = consolidatedPath.concat(consumedPath);\n            }\n          }\n        }\n      }\n    }\n    return consolidatedPath;\n  };\n\n  /**\n   * Consume the node ids in the paths until we get to the given node id\n   * @param paths the paths to consume\n   * @param nodeId the node id to stop consuming at\n   * @return an array of node ids that we have consumed\n   */\n  consumePathsUntilNodeId(paths, nodeId) {\n    let consumedNodeIds = [];\n\n    if (paths != null && nodeId != null) {\n      for (let p = 0; p < paths.length; p++) {\n        const path = paths[p];\n\n        // check if the path contains the node id to stop consuming at\n        if (path != null && path.indexOf(nodeId) != -1) {\n          /*\n           * the path does contain the node id to stop consuming at\n           * so we will consume the node ids in this path until\n           * we get to the given node id to stop consuming at\n           */\n\n          for (let x = 0; x < path.length; x++) {\n            const tempNodeId = path[x];\n\n            if (nodeId === tempNodeId) {\n              /*\n               * the node id is the same as the one we need to\n               * stop consuming at so we will stop looking\n               * at this path\n               */\n              break;\n            } else {\n              /*\n               * the node id is not the one that we need to stop consuming at\n               * so we will consume it\n               */\n\n              // get all the paths that contain the node id\n              const pathsThatContainNodeId = this.getPathsThatContainNodeId(tempNodeId, paths);\n\n              if (pathsThatContainNodeId.length === 1) {\n                // there is only one path with this node id\n\n                // remove the node id from the path\n                this.removeNodeIdFromPath(tempNodeId, paths, p);\n\n                // move the counter back one since we have just removed a node id\n                x--;\n\n                // add the node id to the consumed node ids array\n                consumedNodeIds.push(tempNodeId);\n              } else {\n                // there are multiple paths with this node id\n\n                // tempNodeId must come before nodeId\n\n                const pathsToConsume = [];\n\n                for (let pathThatContainsNodeId of pathsThatContainNodeId) {\n                  // get the index of the node id we want to remove\n                  const tempNodeIdIndex = pathThatContainsNodeId.indexOf(tempNodeId);\n\n                  // get the index of the node id we want to stop consuming at\n                  const nodeIdIndex = pathThatContainsNodeId.indexOf(nodeId);\n\n                  /*\n                   * check if the node id we want to remove comes before\n                   * the node id we want to stop consuming at. we need to\n                   * do this to prevent an infinite loop. an example of\n                   * when this can happen is if there are two paths\n                   *\n                   * path1 = 1, 2, 3, 4, 5\n                   * path2 = 1, 2, 4, 3, 5\n                   *\n                   * as we consume path1 we will need to consume 3. in order to\n                   * consume 3, we must consume consume up to 3 in path2.\n                   * in order to consume up to 3 in path2 we must consume 4.\n                   * in order to consume 4, we must consume everything before\n                   * 4 in path1. everything before 4 in path1 is 1, 2, 3.\n                   * this means we need to consume 3 which brings us back up\n                   * to the top of this paragraph creating an infinite loop.\n                   *\n                   * this check below will prevent infinite loops by only\n                   * adding paths that have the tempNodeId come before the\n                   * nodeId to stop consuming at.\n                   */\n                  if (tempNodeIdIndex < nodeIdIndex) {\n                    pathsToConsume.push(pathThatContainsNodeId);\n                  }\n                }\n\n                /*\n                 * take the paths that contain the given node id and consume\n                 * the paths until the given node id\n                 */\n                const tempConsumedNodeIds = this.consumePathsUntilNodeId(pathsToConsume, tempNodeId);\n\n                // remove the node id from the paths that contain it\n                this.removeNodeIdFromPaths(tempNodeId, pathsThatContainNodeId);\n\n                // add the temp consumed node ids to our consumed node ids array\n                consumedNodeIds = consumedNodeIds.concat(tempConsumedNodeIds);\n\n                // move the counter back one since we have just removed a node id\n                x--;\n\n                // add the node id to the consumed node ids array\n                consumedNodeIds.push(tempNodeId);\n              }\n            }\n          }\n        }\n      }\n    }\n    return consumedNodeIds;\n  };\n\n  /**\n   * Get the path at the given index and get the first node id in\n   * the path\n   * @param paths an array of paths. each path is an array of node ids\n   * @param index the index of the path we want\n   * @return the first node in the given path\n   */\n  getFirstNodeIdInPathAtIndex(paths, index) {\n    let nodeId = null;\n    if (paths != null && index != null) {\n      const path = paths[index];\n      if (path != null && path.length > 0) {\n        nodeId = path[0];\n      }\n    }\n    return nodeId;\n  };\n\n  /**\n   * Remove the node ifrom the paths\n   * @param nodeId the node id to remove\n   * @param paths an array of paths. each path is an array of node ids\n   */\n  removeNodeIdFromPaths(nodeId, paths) {\n    if (nodeId != null && paths != null) {\n      for (let path of paths) {\n        for (let x = 0; x < path.length; x++) {\n          const tempNodeId = path[x];\n\n          /*\n           * check if the node id matches the one we are looking\n           * for\n           */\n          if (nodeId === tempNodeId) {\n            /*\n             * we have found the node id we are looking for so\n             * we will remove it from the path\n             */\n            path.splice(x, 1);\n\n            /*\n             * move the counter back since we just removed a\n             * node id. we will continue searching this path\n             * for the node id in case the path contains it\n             * multiple times.\n             */\n            x--;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Remove the node id from the path\n   * @param nodeId the node id to remove\n   * @param paths an array of paths. each path is an array of node ids\n   * @param pathIndex the path to remove from\n   */\n  removeNodeIdFromPath(nodeId, paths, pathIndex) {\n    if (nodeId != null && paths != null && pathIndex != null) {\n      const path = paths[pathIndex];\n      if (path != null) {\n        for (let x = 0; x < path.length; x++) {\n          const tempNodeId = path[x];\n\n          /*\n           * check if the node id matches the one we are looking\n           * for\n           */\n          if (nodeId === tempNodeId) {\n            /*\n             * we have found the node id we are looking for so\n             * we will remove it from the path\n             */\n            path.splice(x, 1);\n\n            /*\n             * move the counter back since we just removed a\n             * node id. we will continue searching this path\n             * for the node id in case the path contains it\n             * multiple times.\n             */\n            x--;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Check if the first node ids in the paths are the same\n   * @param paths an array of paths. each path is an array of node ids\n   * @return whether all the paths have the same first node id\n   */\n  areFirstNodeIdsInPathsTheSame(paths) {\n    let result = true;\n    let nodeId = null;\n    if (paths != null) {\n      for (let path of paths) {\n        const tempNodeId = path[0];\n        if (nodeId == null) {\n          /*\n           * this is the first path we have looked at so we will\n           * remember the node id\n           */\n          nodeId = tempNodeId;\n        } else if (nodeId != tempNodeId) {\n          /*\n           * the node id does not match the first node id from a\n           * previous path so the paths do not all have the same\n           * first node id\n           */\n          result = false;\n          break;\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Check if all the paths are empty\n   * @param paths an array of paths. each path is an array of node ids\n   * @return whether all the paths are empty\n   */\n  arePathsEmpty(paths) {\n    if (paths != null) {\n      for (let path of paths) {\n        if (path != null) {\n          if (path.length !== 0) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Get the paths that contain the node id\n   * @param nodeId the node id we are looking for\n   * @param paths an array of paths. each path is an array of node ids\n   * @return an array of paths that contain the given node id\n   */\n  getPathsThatContainNodeId(nodeId, paths) {\n    const pathsThatContainNodeId = [];\n    if (nodeId != null && paths != null) {\n      for (let path of paths) {\n        // check if the path contains the node id\n        if (path.indexOf(nodeId) != -1) {\n          /*\n           * add the path to the array of paths that contain\n           * the node id\n           */\n          pathsThatContainNodeId.push(path);\n        }\n      }\n    }\n    return pathsThatContainNodeId;\n  };\n\n  /**\n   * Get a non empty path index. It will loop through the paths and\n   * return the index of the first non empty path.\n   * @param paths an array of paths. each path is an array of node ids\n   * @return the index of the path that is not empty\n   */\n  getNonEmptyPathIndex(paths) {\n    if (paths != null) {\n      for (let p = 0; p < paths.length; p++) {\n        const path = paths[p];\n        if (path.length !== 0) {\n          return p;\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Get the branches in the project\n   */\n  getBranches() {\n    const startNodeId = this.getStartNodeId();\n\n    /*\n     * an array to keep track of the node ids in the path that\n     * we are currently on as we traverse the nodes in the project\n     * depth first\n     */\n    const pathsSoFar = [];\n\n    const allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n    const branches = this.findBranches(allPaths);\n    return branches;\n  };\n\n  /**\n   * Find the branches in the project\n   * @param paths all the possible paths through the project\n   * @return an array of branch objects. each branch object contains\n   * the branch start point, the branch paths, and the branch\n   * end point\n   */\n  findBranches(paths) {\n    let branches = [];\n    let previousNodeId = null;\n\n    /*\n     * continue until all the paths are empty. we will remove\n     * node ids from the paths as we traverse the paths to find\n     * the branches\n     */\n    while (!this.arePathsEmpty(paths)) {\n      const nodeId = this.getFirstNodeIdInPathAtIndex(paths, 0);\n\n      if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n        // the first node ids in all the paths are the same\n\n        this.removeNodeIdFromPaths(nodeId, paths);\n        previousNodeId = nodeId;\n      } else {\n        // not all the top node ids are the same which means we have branched\n\n        const branchMetaObject = this.createBranchMetaObject(previousNodeId);\n        branchMetaObject.branchStartPoint = previousNodeId;\n\n        const nextCommonNodeId = this.findNextCommonNodeId(paths);\n        branchMetaObject.branchEndPoint = nextCommonNodeId;\n\n        let branchPaths = this.extractPathsUpToNodeId(paths, nextCommonNodeId);\n        branchPaths = this.removeDuplicatePaths(branchPaths);\n        branchMetaObject.branchPaths = branchPaths;\n        branches.push(branchMetaObject);\n\n        // trim the paths so that they start at the branch end point\n        this.trimPathsUpToNodeId(paths, nextCommonNodeId);\n\n        // remember this node id for the next iteration of the loop\n        previousNodeId = nextCommonNodeId;\n      }\n    }\n    return branches;\n  };\n\n  /**\n   * Create a branch meta object that will contain the branch start\n   * point, branch paths, and branch end point\n   * @return an object that contains a branch start point, branch paths,\n   * and a branch end point\n   */\n  createBranchMetaObject() {\n    const branchMetaObject = {};\n    branchMetaObject.branchStartPoint = null;\n    branchMetaObject.branchPaths = [];\n    branchMetaObject.branchEndPoint = null;\n    return branchMetaObject;\n  };\n\n  /**\n   * Find the next common node id in all the paths\n   * @param paths the paths to find the common node id in\n   * @return a node id that is in all the paths or null\n   * if there is no node id that is in all the paths\n   */\n  findNextCommonNodeId(paths) {\n    let nextCommonNodeId = null;\n    if (paths != null) {\n      if (paths.length > 0) {\n        const path = paths[0];\n\n        for (let tempNodeId of path) {\n          if (this.allPathsContainNodeId(paths, tempNodeId)) {\n            /*\n             * the node id is in all the paths so we have found\n             * what we were looking for\n             */\n            nextCommonNodeId = tempNodeId;\n            break;\n          }\n        }\n      }\n    }\n    return nextCommonNodeId;\n  };\n\n  /**\n   * Check if all the paths contain the node id\n   * @param paths an array of paths. each path contains an array of node ids\n   * @param nodeId the node id that we will check is in all the paths\n   * @return whether the node id is in all the paths\n   */\n  allPathsContainNodeId(paths, nodeId) {\n    let result = false;\n    if (paths != null) {\n      for (let path of paths) {\n        const index = path.indexOf(nodeId);\n        if (index == -1) {\n          result = false;\n          break;\n        } else {\n          result = true;\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Trim the paths up to the given node id so that the paths will contain\n   * the given node id and all the node ids after it. This function will\n   * modify the paths.\n   * @param paths the paths to trim\n   * @param nodeId the node id to trim up to\n   */\n  trimPathsUpToNodeId(paths, nodeId) {\n    if (paths != null) {\n      for (let path of paths) {\n        if (path != null) {\n          let index = path.indexOf(nodeId);\n\n          if (index == -1) {\n            /*\n             * the node id is not in the path so we will\n             * trim the path to the end which will make\n             * the path empty\n             */\n            index = path.length;\n          }\n\n          /*\n           * trim the path up to the node id index. this will\n           * modify the path array.\n           */\n          path.splice(0, index);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Extract the paths up to a given node id. This will be used to\n   * obtain branch paths.\n   * @param paths the paths to extract from\n   * @param nodeId the node id to extract up to\n   * @return paths that go up to but do not include the node id\n   */\n  extractPathsUpToNodeId(paths, nodeId) {\n    const extractedPaths = [];\n    if (paths != null) {\n      for (let path of paths) {\n        if (path != null) {\n          let index = path.indexOf(nodeId);\n\n          if (index == -1) {\n            /*\n             * the node id is not in the path so we will\n             * extract up to the end of the path\n             */\n            index = path.length;\n          }\n\n          /*\n           * get the path up to the node id index. this does\n           * not modify the path array.\n           */\n          const extractedPath = path.slice(0, index);\n\n          extractedPaths.push(extractedPath);\n        }\n      }\n    }\n    return extractedPaths;\n  };\n\n  /**\n   * Removes duplicate paths\n   * @param paths an array of paths. each path contains an array of node ids\n   * @return an array of unique paths\n   */\n  removeDuplicatePaths(paths) {\n    const uniquePaths = [];\n    if (paths != null) {\n      for (let path of paths) {\n        let isPathInUniquePaths = false;\n        for (let uniquePath of uniquePaths) {\n          if (this.pathsEqual(path, uniquePath)) {\n            isPathInUniquePaths = true;\n          }\n        }\n\n        if (!isPathInUniquePaths) {\n          // the path is not equal to any paths in the unique\n          // paths array so we will add it to the unique paths array\n          uniquePaths.push(path);\n        }\n      }\n    }\n    return uniquePaths;\n  };\n\n  /**\n   * Check if two paths are equal\n   * @param path1 an array of node ids\n   * @param path2 an array of node ids\n   * @return whether the two paths contain the same node ids\n   * in the same order\n   */\n  pathsEqual(path1, path2) {\n    let result = false;\n    if (path1 != null && path2 != null) {\n      if (path1.length === path2.length) {\n        result = true;\n\n        for (let x = 0; x < path1.length; x++) {\n          const path1NodeId = path1[x];\n          const path2NodeId = path2[x];\n          if (path1NodeId !== path2NodeId) {\n            result = false;\n            break;\n          }\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Check if a node id is in any branch\n   * @param branches an array of branch objects\n   * @param nodeId the node id to check\n   * @return whether the node id is in any branch\n   */\n  isNodeIdInABranch(branches, nodeId) {\n    if (branches != null && nodeId != null) {\n      for (let branch of branches) {\n        if (branch != null) {\n          const branchPaths = branch.branchPaths;\n          if (branchPaths != null) {\n            for (let branchPath of branchPaths) {\n              if (branchPath != null) {\n                const index = branchPath.indexOf(nodeId);\n                if (index != -1) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Get the branch paths that a node id is in\n   * @param branches an array of branch objects\n   * @param nodeId the node id to check\n   * @return an array of the branch paths that the node id is in\n   */\n  getBranchPathsByNodeId(branches, nodeId) {\n    const branchPathsIn = [];\n    if (branches != null && nodeId != null) {\n      for (let branch of branches) {\n        if (branch != null) {\n          const branchPaths = branch.branchPaths;\n          if (branchPaths != null) {\n            for (let branchPath of branchPaths) {\n              if (branchPath != null) {\n                const index = branchPath.indexOf(nodeId);\n                if (index != -1) {\n                  /*\n                   * the node is in this branch path so we will\n                   * add the branch path to our array\n                   */\n                  branchPathsIn.push(branchPath);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return branchPathsIn;\n  }\n\n  /**\n   * Get the component by node id and component id\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns the component or null if the nodeId or componentId are null or does not exist in the project.\n   */\n  getComponentByNodeIdAndComponentId(nodeId, componentId) {\n    if (nodeId != null && componentId != null) {\n      const components = this.getComponentsByNodeId(nodeId);\n      for (let tempComponent of components) {\n        if (tempComponent != null) {\n          const tempComponentId = tempComponent.id;\n          if (componentId === tempComponentId) {\n            return tempComponent;\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Returns the position of the component in the node by node id and\n   * component id, 0-indexed.\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns the component's position or -1 if nodeId or componentId are null\n   * or doesn't exist in the project.\n   */\n  getComponentPositionByNodeIdAndComponentId(nodeId, componentId) {\n    if (nodeId != null && componentId != null) {\n      const components = this.getComponentsByNodeId(nodeId);\n      for (let c = 0; c < components.length; c++) {\n        const tempComponent = components[c];\n        if (tempComponent != null) {\n          const tempComponentId = tempComponent.id;\n          if (componentId === tempComponentId) {\n            return c;\n          }\n        }\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * Get the components in a node\n   * @param nodeId the node id\n   * @returns an array of components or empty array if nodeId is null or\n   * doesn't exist in the project.\n   * if the node exists but doesn't have any components, returns an empty array.\n   */\n  getComponentsByNodeId(nodeId) {\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        if (node.components != null) {\n          return node.components;\n        }\n      }\n    }\n    return [];\n  };\n\n\n  // TODO: how is this different from straight-up calling getNodeById?\n  getNodeContentByNodeId(nodeId) {\n    let nodeContent = null;\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        nodeContent = node;\n      }\n    }\n    return nodeContent;\n  };\n\n  /**\n   * Replace a component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @param component the new component\n   */\n  replaceComponent(nodeId, componentId, component) {\n    if (nodeId != null && componentId != null && component != null) {\n      const components = this.getComponentsByNodeId(nodeId);\n      if (components != null) {\n        for (let c = 0; c < components.length; c++) {\n          const tempComponent = components[c];\n          if (tempComponent != null) {\n            if (tempComponent.id === componentId) {\n              components[c] = component;\n              break;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Create a new group\n   * @param title the title of the group\n   * @returns the group object\n   */\n  createGroup(title) {\n    const newGroupId = this.getNextAvailableGroupId();\n    const newGroup = {};\n    newGroup.id = newGroupId;\n    newGroup.type = 'group';\n    newGroup.title = title;\n    newGroup.startId = '';\n    newGroup.ids = [];\n    return newGroup;\n  };\n\n  /**\n   * Create a new node\n   * @param title the title of the node\n   * @returns the node object\n   */\n  createNode(title) {\n    const newNodeId = this.getNextAvailableNodeId();\n    const newNode = {};\n    newNode.id = newNodeId;\n    newNode.title = title;\n    newNode.type = 'node';\n    newNode.constraints = [];\n    newNode.transitionLogic = {};\n    newNode.transitionLogic.transitions = [];\n    newNode.showSaveButton = false;\n    newNode.showSubmitButton = false;\n    newNode.components = [];\n    return newNode;\n  };\n\n  /**\n   * Create a node inside the group\n   * @param node the new node\n   * @param nodeId the node id of the group to create the node in\n   */\n  createNodeInside(node, nodeId) {\n    if (nodeId == 'inactiveNodes') {\n      this.addInactiveNode(node);\n      this.setIdToNode(node.id, node);\n      this.setIdToElement(node.id, node);\n    } else if (nodeId == 'inactiveGroups') {\n      this.addInactiveNode(node);\n      this.setIdToNode(node.id, node);\n      this.setIdToElement(node.id, node);\n    } else {\n      this.addNode(node);\n      this.setIdToNode(node.id, node);\n      this.insertNodeInsideInTransitions(node.id, nodeId);\n      this.insertNodeInsideInGroups(node.id, nodeId);\n    }\n  }\n\n  /**\n   * Create a node after the given node id\n   * @param node the new node\n   * @param nodeId the node to add after\n   */\n  createNodeAfter(node, nodeId) {\n    if (this.isInactive(nodeId)) {\n      // we are adding the node after a node that is inactive\n\n      this.addInactiveNode(node, nodeId);\n      this.setIdToNode(node.id, node);\n      this.setIdToElement(node.id, node);\n    } else {\n      // we are adding the node after a node that is active\n\n      this.addNode(node);\n      this.setIdToNode(node.id, node);\n      this.insertNodeAfterInGroups(node.id, nodeId);\n      this.insertNodeAfterInTransitions(node, nodeId);\n    }\n\n    if (this.isGroupNode(node.id)) {\n      /*\n       * we are creating a group node so we will update/create the\n       * transitions that traverse from the previous group to this group\n       */\n      // TODO geoffreykwan oldToGroupIds is declared here and below. Refactor\n      var oldToGroupIds = [];\n\n      const transitionsFromGroup = this.getTransitionsByFromNodeId(nodeId);\n      if (transitionsFromGroup != null) {\n        /*\n         * loop through all the transitions that come out of the previous group\n         * and get the node ids that the group transitions to\n         */\n        for (let transitionFromGroup of transitionsFromGroup) {\n          if (transitionFromGroup != null) {\n            const toNodeId = transitionFromGroup.to;\n            if (toNodeId != null) {\n              oldToGroupIds.push(toNodeId);\n            }\n          }\n        }\n      }\n\n      const fromGroupId = nodeId;\n      // TODO geoffreykwan oldToGroupIds is declared here and above. Refactor\n      var oldToGroupIds = oldToGroupIds;\n      const newToGroupId = node.id;\n\n      /*\n       * make the transitions point to the new group and make the new\n       * group transition to the old group\n       */\n      this.updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId);\n    }\n  }\n\n  /**\n   * Insert the node after the given node id in the group's\n   * array of children ids\n   * @param nodeIdToInsert the node id we want to insert\n   * @param nodeIdToInsertAfter the node id we want to insert after\n   */\n  insertNodeAfterInGroups(nodeIdToInsert, nodeIdToInsertAfter) {\n    const groupNodes = this.getGroupNodes();\n    if (groupNodes != null) {\n      for (let group of groupNodes) {\n        if (group != null) {\n          const ids = group.ids;\n          if (ids != null) {\n            for (let i = 0; i < ids.length; i++) {\n              const id = ids[i];\n              if (nodeIdToInsertAfter === id) {\n                ids.splice(i + 1, 0, nodeIdToInsert);\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Update the transitions to handle inserting a node after another node\n   * @param node the node to insert\n   * @param nodeId the node id to insert after\n   */\n  insertNodeAfterInTransitions(node, nodeId) {\n    const previousNode = this.getNodeById(nodeId);\n\n    if (previousNode != null) {\n      if (previousNode.transitionLogic == null) {\n        previousNode.transitionLogic = {};\n        previousNode.transitionLogic.transitions = [];\n      }\n\n      if (node.transitionLogic == null) {\n        node.transitionLogic = {};\n      }\n\n      if (node.transitionLogic.transitions == null) {\n        node.transitionLogic.transitions = [];\n      }\n\n      if (this.isGroupNode(node.id)) {\n        /*\n         * the node we are inserting is a group so we will update\n         * the transitions of its children so that they transition\n         * to the correct node\n         */\n        this.updateChildrenTransitionsForMovingGroup(node, nodeId);\n      }\n\n      const previousNodeTransitionLogic = previousNode.transitionLogic;\n\n      if (previousNodeTransitionLogic != null) {\n        const transitions = previousNodeTransitionLogic.transitions;\n\n        if (transitions != null) {\n          const transitionsJSONString = angular.toJson(transitions);\n          const transitionsCopy = angular.fromJson(transitionsJSONString);\n\n          // set the transitions from the before node into the inserted node\n          node.transitionLogic.transitions = transitionsCopy;\n        }\n      }\n\n      if (node.transitionLogic.transitions.length == 0) {\n        /*\n         * The node does not have any transitions so we will look for\n         * a transition on the parent group. If the parent has a\n         * transition we will use it for the node.\n         */\n\n        const parentGroupId = this.getParentGroupId(nodeId);\n\n        if (parentGroupId != null &&\n            parentGroupId != '' &&\n            parentGroupId != 'group0') {\n          const parentTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n\n          if (parentTransitions != null) {\n            for (let parentTransition of parentTransitions) {\n              const newTransition = {};\n              if (parentTransition != null) {\n                const toNodeId = parentTransition.to;\n                if (this.isGroupNode(toNodeId)) {\n                  const startId = this.getGroupStartId(toNodeId);\n                  if (startId == null || startId == '') {\n                    // there is no start id so we will just use the group id\n                    newTransition.to = toNodeId;\n                  } else {\n                    // there is a start id so we will use it as the to node\n                    newTransition.to = startId;\n                  }\n                } else {\n                  newTransition.to = toNodeId;\n                }\n              }\n              node.transitionLogic.transitions.push(newTransition);\n            }\n          }\n        }\n      }\n\n      const newNodeId = node.id;\n\n      // TODO handle branching case\n\n      previousNode.transitionLogic.transitions = [];\n\n      const transitionObject = {};\n      transitionObject.to = newNodeId;\n      previousNode.transitionLogic.transitions.push(transitionObject);\n      this.removeBranchPathTakenNodeConstraints(node.id);\n      const branchPathTakenConstraints = this.getBranchPathTakenConstraintsByNodeId(nodeId);\n\n      /*\n       * if the previous node was in a branch path, we will also put the\n       * inserted node into the branch path\n       */\n      if (branchPathTakenConstraints != null &&\n          branchPathTakenConstraints.length > 0) {\n        if (node.constraints == null) {\n          node.constraints = [];\n        }\n\n        for (let branchPathTakenConstraint of branchPathTakenConstraints) {\n          if (branchPathTakenConstraint != null) {\n            // create a new constraint with the same branch path taken parameters\n            const newConstraint = {};\n            newConstraint.id = this.getNextAvailableConstraintIdForNodeId(node.id);\n            newConstraint.action = branchPathTakenConstraint.action;\n            newConstraint.targetId = node.id;\n            newConstraint.removalCriteria = this.UtilService.makeCopyOfJSONObject(branchPathTakenConstraint.removalCriteria);\n            node.constraints.push(newConstraint);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Insert a node into a group\n   * @param nodeIdToInsert the node id to insert\n   * @param nodeIdToInsertInside the node id of the group we will insert into\n   */\n  insertNodeInsideInGroups(nodeIdToInsert, nodeIdToInsertInside) {\n    const group = this.getNodeById(nodeIdToInsertInside);\n    if (group != null) {\n      const ids = group.ids;\n      if (ids != null) {\n        ids.splice(0, 0, nodeIdToInsert);\n        group.startId = nodeIdToInsert;\n      }\n    }\n  }\n\n  /**\n   * Update the transitions to handle inserting a node into a group\n   * @param nodeIdToInsert node id that we will insert\n   * @param nodeIdToInsertInside the node id of the group we are inserting into\n   */\n  insertNodeInsideInTransitions(nodeIdToInsert, nodeIdToInsertInside) {\n    const nodeToInsert = this.getNodeById(nodeIdToInsert);\n\n    if (nodeToInsert != null &&\n        nodeToInsert.transitionLogic != null &&\n        nodeToInsert.transitionLogic.transitions != null) {\n      nodeToInsert.transitionLogic.transitions = [];\n\n      /*\n       * remove the branch path taken constraints from the node we are\n       * inserting\n       */\n      this.removeBranchPathTakenNodeConstraints(nodeIdToInsert);\n    }\n\n    const group = this.getNodeById(nodeIdToInsertInside);\n    if (this.isGroupNode(nodeIdToInsert)) {\n      /*\n       * the node we are inserting is a group so we will update\n       * the transitions of its children so that they transition\n       * to the correct node\n       */\n      this.updateChildrenTransitionsForMovingGroup(nodeToInsert, null);\n    }\n\n    /*\n     * since we are inserting a node into a group, the node will become\n     * the first node in the group. this means we need to update any nodes\n     * that point to the old start id and make them point to the node\n     * we are inserting.\n     */\n    if (nodeToInsert != null && group != null) {\n      const startId = group.startId;\n      const previousNodes = this.getNodesByToNodeId(startId);\n\n      if (previousNodes == null || previousNodes.length == 0) {\n        const previousGroups = this.getGroupNodesByToNodeId(nodeIdToInsertInside);\n        for (let previousGroup of previousGroups) {\n          if (previousGroup != null) {\n            // get the nodes that do not have a transition in the previous group\n            const lastNodesInGroup = this.getLastNodesInGroup(previousGroup.id);\n\n            for (let node of lastNodesInGroup) {\n              // add a transition from the node to the node we are inserting\n              this.addToTransition(node, nodeIdToInsert);\n            }\n          }\n        }\n      } else {\n        for (let previousNode of previousNodes) {\n          if (previousNode != null && previousNode.id != 'group0') {\n            // change the transition to point to the node we are inserting\n            this.updateToTransition(previousNode, startId, nodeIdToInsert);\n          }\n        }\n      }\n\n      /*\n       * update all the transitions that point to the group and change\n       * them to point to the new start id\n       */\n      const nodesThatTransitionToGroup = this.getNodesByToNodeId(nodeIdToInsertInside);\n\n      if (nodesThatTransitionToGroup != null) {\n        for (let nodeThatTransitionsToGroup of nodesThatTransitionToGroup) {\n          if (!this.isGroupNode(nodeThatTransitionsToGroup.id)) {\n            this.updateToTransition(nodeThatTransitionsToGroup, nodeIdToInsertInside, nodeIdToInsert);\n          }\n        }\n      }\n\n      /*\n       * create a transition from the node we are inserting to the node that\n       * was previously the start node\n       */\n      if (startId != null && startId != '') {\n        const startNode = this.getNodeById(startId);\n\n        if (startNode != null) {\n          // the group has a start node which will become the transition to node\n\n          if (nodeToInsert.transitionLogic == null) {\n            nodeToInsert.transitionLogic = {};\n          }\n\n          if (nodeToInsert.transitionLogic.transitions == null) {\n            nodeToInsert.transitionLogic.transitions = [];\n          }\n\n          /*\n           * make the inserted node transition to the previous start node\n           */\n          const transitionObject = {};\n          transitionObject.to = startId;\n          nodeToInsert.transitionLogic.transitions.push(transitionObject);\n        }\n      }\n\n      // check if the node we inserted has any transitions now\n      const transitions = this.getTransitionsByFromNodeId(nodeIdToInsert);\n\n      if (transitions == null || transitions.length == 0) {\n        /*\n         * the node doesn't have any transitions so we will see if\n         * the parent group transitions to anything and use that\n         * transition\n         */\n\n        const parentTransitions = this.getTransitionsByFromNodeId(nodeIdToInsertInside);\n\n        if (parentTransitions != null) {\n          for (let parentTransition of parentTransitions) {\n            if (parentTransition != null) {\n              const toNodeId = parentTransition.to;\n              if (this.isGroupNode(toNodeId)) {\n                const nextGroup = this.getNodeById(toNodeId);\n\n                if (nextGroup != null) {\n                  const startId = nextGroup.startId;\n\n                  if (startId == null || startId == '') {\n                    // there is no start id so we will just transition to the group\n                    this.addToTransition(nodeToInsert, toNodeId);\n                  } else {\n                    // there is a start id so we will transition to that\n                    this.addToTransition(nodeToInsert, startId);\n                  }\n                }\n              } else {\n                // the to node is not a group\n\n                /*\n                 * we will add a transition from the node we are inserting to\n                 * to that node\n                 */\n                this.addToTransition(nodeToInsert, toNodeId);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Add a transition to a node\n   * @param node the node we are adding a transition to\n   * @param toNodeId the node id we going to transition to\n   * @param criteria (optional) a criteria object specifying\n   * what needs to be satisfied in order to use this transition\n   */\n  addToTransition(node, toNodeId, criteria) {\n    if (node != null) {\n      if (node.transitionLogic == null) {\n        node.transitionLogic = {};\n      }\n      if (node.transitionLogic.transitions == null) {\n        node.transitionLogic.transitions = [];\n      }\n      const transition = {};\n      transition.to = toNodeId;\n      if (criteria != null) {\n        transition.criteria = criteria;\n      }\n      node.transitionLogic.transitions.push(transition);\n    }\n  }\n\n  /**\n   * Update the to value of aa transition\n   * @param node the node to update\n   * @param oldToNodeId the previous to node id\n   * @param newToNodeId the new to node id\n   */\n  updateToTransition(node, oldToNodeId, newToNodeId) {\n    if (node != null) {\n      if (node.transitionLogic == null) {\n        node.transitionLogic = {};\n      }\n\n      if (node.transitionLogic.transitions == null) {\n        node.transitionLogic.transitions = [];\n      }\n\n      const transitions = node.transitionLogic.transitions;\n      for (let transition of transitions) {\n        if (transition != null) {\n          const toNodeId = transition.to;\n          if (oldToNodeId === toNodeId) {\n            transition.to = newToNodeId;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the nodes in a group that do not have transitions\n   * @param groupId the group id\n   * @returns the nodes in the group that do not have transitions\n   */\n  getLastNodesInGroup(groupId) {\n    const lastNodes = [];\n    if (groupId != null) {\n      const group = this.getNodeById(groupId);\n      if (group != null) {\n        const childIds = group.ids;\n        if (childIds != null) {\n          for (let childId of childIds) {\n            if (childId != null) {\n              const child = this.getNodeById(childId);\n              if (child != null) {\n                const transitionLogic = child.transitionLogic;\n                if (transitionLogic != null) {\n                  const transitions = transitionLogic.transitions;\n                  if (transitions == null || transitions.length == 0) {\n                    lastNodes.push(child);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return lastNodes;\n  }\n\n  /**\n   * Get the next available group id\n   * @returns the next available group id\n   */\n  getNextAvailableGroupId() {\n    const groupIds = this.getGroupIds();\n    let largestGroupIdNumber = null;\n    for (let groupId of groupIds) {\n      // get the number from the group id e.g. the number of 'group2' would be 2\n      let groupIdNumber = groupId.replace('group', '');\n\n      // make sure the number is an actual number\n      if (!isNaN(groupIdNumber)) {\n        groupIdNumber = parseInt(groupIdNumber);\n\n        // update the largest group id number if necessary\n        if (largestGroupIdNumber == null) {\n          largestGroupIdNumber = groupIdNumber;\n        } else if (groupIdNumber > largestGroupIdNumber) {\n          largestGroupIdNumber = groupIdNumber;\n        }\n      }\n    }\n\n    const nextAvailableGroupId = 'group' + (largestGroupIdNumber + 1);\n    return nextAvailableGroupId;\n  }\n\n  /**\n   * Get all the group ids\n   * @returns an array with all the group ids\n   */\n  getGroupIds() {\n    const groupIds = [];\n\n    const groupNodes = this.groupNodes;\n    for (let group of groupNodes) {\n      if (group != null) {\n        const groupId = group.id;\n        if (groupId != null) {\n          groupIds.push(groupId);\n        }\n      }\n    }\n\n    const inactiveGroupNodes = this.getInactiveGroupNodes();\n    for (let inactiveGroup of inactiveGroupNodes) {\n      if (inactiveGroup != null) {\n        const inactiveGroupId = inactiveGroup.id;\n        if (inactiveGroupId != null) {\n          groupIds.push(inactiveGroupId);\n        }\n      }\n    }\n    return groupIds;\n  }\n\n  /**\n   * Get the next available node id\n   * @param nodeIdsToSkip (optional) An array of additional node ids to not\n   * use. This parameter is used in cases where we are creating multiple new\n   * nodes at once.\n   * Example\n   * We ask for two new node ids by calling getNextAvailableNodeId() twice.\n   * The first time it returns \"node10\".\n   * If we ask the second time without actually creating and adding node10,\n   * it will return \"node10\" again. If we provide \"node10\" in the\n   * nodeIdsToSkip, then getNextAvailableNodeId() will properly return to us\n   * \"node11\".\n   * @returns the next available node id\n   */\n  getNextAvailableNodeId(nodeIdsToSkip) {\n    const nodeIds = this.getNodeIds();\n    let largestNodeIdNumber = null;\n\n    for (let nodeId of nodeIds) {\n      // get the number from the node id e.g. the number of 'node2' would be 2\n      let nodeIdNumber = nodeId.replace('node', '');\n\n      // make sure the number is an actual number\n      if (!isNaN(nodeIdNumber)) {\n        nodeIdNumber = parseInt(nodeIdNumber);\n\n        // update the largest node id number if necessary\n        if (largestNodeIdNumber == null) {\n          largestNodeIdNumber = nodeIdNumber;\n        } else if (nodeIdNumber > largestNodeIdNumber) {\n          largestNodeIdNumber = nodeIdNumber;\n        }\n      }\n    }\n\n    const inactiveNodeIds = this.getInactiveNodeIds();\n    for (let inactiveNodeId of inactiveNodeIds) {\n      // get the number from the node id e.g. the number of 'node2' would be 2\n      let nodeIdNumber = inactiveNodeId.replace('node', '');\n\n      // make sure the number is an actual number\n      if (!isNaN(nodeIdNumber)) {\n        nodeIdNumber = parseInt(nodeIdNumber);\n\n        // update the largest node id number if necessary\n        if (largestNodeIdNumber == null) {\n          largestNodeIdNumber = nodeIdNumber;\n        } else if (nodeIdNumber > largestNodeIdNumber) {\n          largestNodeIdNumber = nodeIdNumber;\n        }\n      }\n    }\n\n    if (nodeIdsToSkip != null) {\n      // there are node ids to skip\n\n      for (let nodeIdToSkip of nodeIdsToSkip) {\n        // get the number from the node id e.g. the number of 'node2' would be 2\n        let nodeIdNumber = nodeIdToSkip.replace('node', '');\n\n        // make sure the number is an actual number\n        if (!isNaN(nodeIdNumber)) {\n          nodeIdNumber = parseInt(nodeIdNumber);\n\n          // update the largest node id number if necessary\n          if (largestNodeIdNumber == null) {\n            largestNodeIdNumber = nodeIdNumber;\n          } else if (nodeIdNumber > largestNodeIdNumber) {\n            largestNodeIdNumber = nodeIdNumber;\n          }\n        }\n      }\n    }\n\n    const nextAvailableNodeId = 'node' + (largestNodeIdNumber + 1);\n    return nextAvailableNodeId;\n  }\n\n  /**\n   * Get all the node ids from steps (not groups)\n   * @returns an array with all the node ids\n   */\n  getNodeIds() {\n    const nodeIds = [];\n    for (let node of this.applicationNodes) {\n      if (node != null) {\n        const nodeId = node.id;\n        if (nodeId != null) {\n          nodeIds.push(nodeId);\n        }\n      }\n    }\n    return nodeIds;\n  }\n\n  /**\n   * Get all the node ids from inactive steps\n   * @returns an array with all the inactive node ids\n   */\n  getInactiveNodeIds() {\n    const nodeIds = [];\n    const inactiveNodes = this.project.inactiveNodes;\n    if (inactiveNodes != null) {\n      for (let inactiveNode of inactiveNodes) {\n        if (inactiveNode != null) {\n          const nodeId = inactiveNode.id;\n          if (nodeId != null) {\n            nodeIds.push(nodeId);\n          }\n        }\n      }\n    }\n    return nodeIds;\n  }\n\n  /**\n   * Move nodes inside a group node\n   * @param nodeIds the node ids to move\n   * @param nodeId the node id of the group we are moving the nodes inside\n   */\n  moveNodesInside(nodeIds, nodeId) {\n    const movedNodes = [];\n\n    for (let n = 0; n < nodeIds.length; n++) {\n      const tempNodeId = nodeIds[n];\n      const tempNode = this.getNodeById(tempNodeId);\n      movedNodes.push(tempNode);\n\n      const movingNodeIsActive = this.isActive(tempNodeId);\n      const stationaryNodeIsActive = this.isActive(nodeId);\n\n      if (movingNodeIsActive && stationaryNodeIsActive) {\n        // we are moving from active to active\n\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n\n        if (n == 0) {\n          /*\n           * this is the first node we are moving so we will insert it\n           * into the beginning of the group\n           */\n          this.insertNodeInsideInTransitions(tempNodeId, nodeId);\n          this.insertNodeInsideInGroups(tempNodeId, nodeId);\n        } else {\n          /*\n           * this is not the first node we are moving so we will insert\n           * it after the node we previously inserted\n           */\n          this.insertNodeAfterInTransitions(tempNode, nodeId);\n          this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        }\n      } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n        // we are moving from active to inactive\n\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n        this.moveToInactive(tempNode, nodeId);\n      } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n        // we are moving from inactive to active\n\n        this.moveToActive(tempNode);\n\n        if (n == 0) {\n          /*\n           * this is the first node we are moving so we will insert it\n           * into the beginning of the group\n           */\n          this.insertNodeInsideInTransitions(tempNodeId, nodeId);\n          this.insertNodeInsideInGroups(tempNodeId, nodeId);\n        } else {\n          /*\n           * this is not the first node we are moving so we will insert\n           * it after the node we previously inserted\n           */\n          this.insertNodeAfterInTransitions(tempNode, nodeId);\n          this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        }\n      } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n        // we are moving from inactive to inactive\n\n        this.moveInactiveNode(tempNode, nodeId);\n      }\n\n      /*\n       * remember the node id so we can put the next node (if any)\n       * after this one\n       */\n      nodeId = tempNode.id;\n    }\n    return movedNodes;\n  }\n\n  /**\n   * Move nodes after a certain node id\n   * @param nodeIds the node ids to move\n   * @param nodeId the node id we will put the moved nodes after\n   */\n  moveNodesAfter(nodeIds, nodeId) {\n    const movedNodes = [];\n\n    for (let tempNodeId of nodeIds) {\n      const node = this.getNodeById(tempNodeId);\n      movedNodes.push(node);\n\n      const movingNodeIsActive = this.isActive(tempNodeId);\n      const stationaryNodeIsActive = this.isActive(nodeId);\n\n      if (movingNodeIsActive && stationaryNodeIsActive) {\n        // we are moving from active to active\n\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n        this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        this.insertNodeAfterInTransitions(node, nodeId);\n      } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n        // we are moving from active to inactive\n\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n        this.moveToInactive(node, nodeId);\n      } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n        // we are moving from inactive to active\n\n        this.moveToActive(node);\n        this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        this.insertNodeAfterInTransitions(node, nodeId);\n      } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n        // we are moving from inactive to inactive\n\n        this.moveInactiveNode(node, nodeId);\n      }\n\n      // remember the node id so we can put the next node (if any) after this one\n      nodeId = node.id;\n    }\n    return movedNodes;\n  }\n\n  /**\n   * Copy nodes and put them after a certain node id\n   * @param nodeIds the node ids to copy\n   * @param nodeId the node id we will put the copied nodes after\n   */\n  copyNodesInside(nodeIds, nodeId) {\n    const newNodes = [];\n    for (let n = 0; n < nodeIds.length; n++) {\n      const nodeIdToCopy = nodeIds[n];\n      const newNode = this.copyNode(nodeIdToCopy);\n      const newNodeId = newNode.id;\n\n      if (n == 0) {\n        // this is the first node we are copying so we will insert it\n        // into the beginning of the group\n        this.createNodeInside(newNode, nodeId);\n      } else {\n        // this is not the first node we are copying so we will insert\n        // it after the node we previously inserted\n        this.createNodeAfter(newNode, nodeId);\n      }\n\n      // remember the node id so we can put the next node (if any) after this one\n      nodeId = newNodeId;\n      this.parseProject();  // refresh project and update references because a new node have been added.\n\n      newNodes.push(newNode);\n    }\n    return newNodes;\n  }\n\n  /**\n   * Copy nodes and put them after a certain node id\n   * @param nodeIds the node ids to copy\n   * @param nodeId the node id we will put the copied nodes after\n   */\n  copyNodesAfter(nodeIds, nodeId) {\n    const newNodes = [];\n    for (let nodeIdToCopy of nodeIds) {\n      const newNode = this.copyNode(nodeIdToCopy);\n      const newNodeId = newNode.id;\n      this.createNodeAfter(newNode, nodeId);\n\n      // remember the node id so we can put the next node (if any) after this one\n      nodeId = newNodeId;\n      this.parseProject();  // refresh project and update references because a new node have been added.\n\n      newNodes.push(newNode);\n    }\n    return newNodes;\n  }\n\n  /**\n   * Copy the node with the specified nodeId\n   * @param nodeId the node id to copy\n   * @return copied node\n   */\n  copyNode(nodeId) {\n    const node = this.getNodeById(nodeId);\n    const nodeCopy = this.UtilService.makeCopyOfJSONObject(node);\n    nodeCopy.id = this.getNextAvailableNodeId();\n    nodeCopy.transitionLogic = {};  // clear transition logic\n    nodeCopy.constraints = [];  // clear constraints\n\n    const newComponentIds = [];\n    for (let component of nodeCopy.components) {\n      const newComponentId = this.getUnusedComponentId(newComponentIds);\n      newComponentIds.push(newComponentId);\n      component.id = newComponentId;\n    }\n    return nodeCopy;\n  }\n\n  /**\n   * Delete a node\n   * @param nodeId the node id\n   */\n  deleteNode(nodeId) {\n    /*\n     * flag for whether we are deleting the project start node id.\n     * if we are deleting the project start node id, we will need\n     * to change it to the next logical node id that will be used\n     * as the project start.\n     */\n    let removingProjectStartNodeId = false;\n\n    if (this.isGroupNode(nodeId)) {\n      // the node is a group node so we will also remove all of its children\n      const group = this.getNodeById(nodeId);\n\n      // TODO check if the child is in another group, if so do not remove\n\n      if (group != null) {\n        const ids = group.ids;\n        for (let i = 0; i < ids.length; i++) {\n          const id = ids[i];\n          this.removeNodeIdFromTransitions(id);\n          this.removeNodeIdFromGroups(id);\n          this.removeNodeIdFromNodes(id);\n\n          if (this.project.startNodeId == id) {\n            removingProjectStartNodeId = true;\n          }\n\n          /*\n           * move the counter back because we have removed a child\n           * from the parent group's array of child ids so all of\n           * the child ids were shifted back one and the next child\n           * we want will be at i--\n           */\n          i--;\n        }\n      }\n    }\n\n    const parentGroup = this.getParentGroup(nodeId);\n\n    // check if we need to update the start id of the parent group\n    if (parentGroup != null) {\n\n      /*\n       * the node is the start node of the parent group so we need\n       * to update the start id of the parent group to point to\n       * the next node\n       */\n      if (nodeId === parentGroup.startId) {\n        let hasSetNewStartId = false;\n\n        const node = this.getNodeById(nodeId);\n        if (node != null) {\n          const transitionLogic = node.transitionLogic;\n          if (transitionLogic != null) {\n            const transitions = transitionLogic.transitions;\n            if (transitions != null && transitions.length > 0) {\n              const transition = transitions[0];\n              if (transition != null) {\n                const toNodeId = transition.to;\n                if (toNodeId != null) {\n                  if (this.isNodeInGroup(toNodeId, parentGroup.id)) {\n                    parentGroup.startId = toNodeId;\n                    hasSetNewStartId = true;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (!hasSetNewStartId) {\n          parentGroup.startId = '';\n        }\n      }\n    }\n\n    if (nodeId === this.getStartNodeId()) {\n      removingProjectStartNodeId = true;\n    }\n\n    if (removingProjectStartNodeId) {\n      /*\n       * we are removing the project start node id so we need to update\n       * the startNodeId to something else\n       */\n\n      if (this.isGroupNode(nodeId)) {\n        /*\n         * we are removing a group so we need to set the startNodeId to\n         * the first node of the next group or if the next group doesn't\n         * have any nodes, we will just use the next group\n         */\n\n        // get the transitions of the group we are removing\n        const transitions = this.getTransitionsByFromNodeId(nodeId);\n\n        if (transitions == null || transitions.length == 0) {\n          /*\n           * the group doesn't have any transitions so we will set\n           * the startNodeId to 'group0'\n           */\n          this.setStartNodeId('group0');\n        } else {\n          // the group has transitions\n\n          let nextNodeId = null;\n\n          if (transitions[0] != null && transitions[0].to != null) {\n            nextNodeId = transitions[0].to;\n          }\n\n          if (nextNodeId != null) {\n            if (this.isGroupNode(nextNodeId)) {\n              const nextGroupNode = this.getNodeById(nextNodeId);\n\n              if (nextGroupNode != null) {\n                const nextGroupStartId = nextGroupNode.startId;\n\n                if (nextGroupStartId == null) {\n                  /*\n                   * the next group does not have a start id so we\n                   * will just use the next group id as the project\n                   * start node id\n                   */\n                  this.setStartNodeId(nextNodeId);\n                } else {\n                  /*\n                   * the next group has a start id so we will use\n                   * it as the project start node id\n                   */\n                  this.setStartNodeId(nextGroupStartId);\n                }\n              }\n            } else {\n              /*\n               * the transition is to a step so we will use it as the\n               * project start node id\n               */\n              this.setStartNodeId(nextNodeId);\n            }\n          }\n        }\n      } else {\n        /*\n         * we are removing a step node so we will set the startNodeId to\n         * the next node in the transitions, or if there are no\n         * transitions, we will use the parent group\n         */\n\n        // get the transitions from the step we are removing\n        const transitions = this.getTransitionsByFromNodeId(nodeId);\n\n        if (transitions == null || transitions.length == 0) {\n          /*\n           * the step doesn't have any transitions so we will use the\n           * its parent group as the start node id\n           */\n          const parentGroupId = this.getParentGroupId(nodeId);\n          this.setStartNodeId(parentGroupId);\n        } else {\n          // the step has transitions\n\n          if (transitions[0] != null && transitions[0].to != null) {\n            /*\n             * get the first transition and set it as the project\n             * start node id\n             */\n            const transitionToNodeId = transitions[0].to;\n            this.setStartNodeId(transitionToNodeId);\n          }\n        }\n      }\n    }\n\n    this.removeNodeIdFromTransitions(nodeId);\n    this.removeNodeIdFromGroups(nodeId);\n    this.removeNodeIdFromNodes(nodeId);\n\n    if (parentGroup != null) {\n      this.recalculatePositionsInGroup(parentGroup.id);\n    }\n  }\n\n  /**\n   * Update the transitions to handle removing a node\n   * @param nodeId the node id to remove\n   */\n  removeNodeIdFromTransitions(nodeId) {\n    const nodeToRemove = this.getNodeById(nodeId);\n    const nodesByToNodeId = this.getNodesByToNodeId(nodeId);\n\n    const nodeToRemoveTransitionLogic = nodeToRemove.transitionLogic;\n    let nodeToRemoveTransitions = [];\n\n    if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n      nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n    }\n\n    const parentIdOfNodeToRemove = this.getParentGroupId(nodeId);\n    const parentGroup = this.getNodeById(parentIdOfNodeToRemove);\n\n    // update the start id if we are removing the start node of a group\n    if (parentGroup != null) {\n      const parentGroupStartId = parentGroup.startId;\n      if (parentGroupStartId != null) {\n        if (parentGroupStartId === nodeId) {\n          // the node we are removing is the start node\n\n          if (nodeToRemoveTransitions != null && nodeToRemoveTransitions.length > 0) {\n            for (let nodeToRemoveTransition of nodeToRemoveTransitions) {\n              if (nodeToRemoveTransition != null) {\n                const toNodeId = nodeToRemoveTransition.to;\n                if (toNodeId != null) {\n                  /*\n                   * we need to check that the to node id is in the\n                   * same group. some transitions point to a node id\n                   * in the next group which we would not want to use\n                   * for the start id.\n                   */\n                  if (this.getParentGroupId(toNodeId) == parentIdOfNodeToRemove) {\n                    // set the new start id\n                    parentGroup.startId = toNodeId;\n                  }\n                }\n              }\n            }\n          } else {\n            // there are no transitions so we will have an empty start id\n            parentGroup.startId = '';\n          }\n        }\n      }\n    }\n\n    for (let n = 0; n < nodesByToNodeId.length; n++) {\n      const node = nodesByToNodeId[n];\n\n      if (node != null) {\n        const parentIdOfFromNode = this.getParentGroupId(node.id);\n        const transitionLogic = node.transitionLogic;\n\n        if (transitionLogic != null) {\n          const transitions = transitionLogic.transitions;\n          for (let t = 0; t < transitions.length; t++) {\n            const transition = transitions[t];\n            if (nodeId === transition.to) {\n              // we have found the transition to the node we are removing\n\n              // copy the transitions from the node we are removing\n              let transitionsCopy = angular.toJson(nodeToRemoveTransitions);\n              transitionsCopy = angular.fromJson(transitionsCopy);\n\n              /*\n               * if the parent from group is different than the parent removing group\n               * remove transitions that are to a node in a different group than\n               * the parent removing group\n               */\n\n              if (parentIdOfFromNode != parentIdOfNodeToRemove) {\n                for (let tc = 0; tc < transitionsCopy.length; tc++) {\n                  const tempTransition = transitionsCopy[tc];\n                  if (tempTransition != null) {\n                    const tempToNodeId = tempTransition.to;\n                    if (tempToNodeId != null) {\n                      const parentIdOfToNode = this.getParentGroupId(tempToNodeId);\n                      if (parentIdOfNodeToRemove != parentIdOfToNode) {\n                        // remove the transition\n                        transitionsCopy.splice(tc, 1);\n                        tc--;\n                      }\n                    }\n                  }\n                }\n              }\n\n              if (this.isFirstNodeInBranchPath(nodeId)) {\n                /*\n                 * Get the node ids that have a branchPathTaken\n                 * constraint from the before node and to the node\n                 * we are removing. If there are any, we need to\n                 * update the branchPathTaken constraint with the\n                 * next nodeId that comes after the node we are\n                 * removing.\n                 */\n                const nodeIdsInBranch = this.getNodeIdsInBranch(node.id, nodeId);\n\n                if (nodeIdsInBranch != null) {\n                  for (let nodeIdInBranch of nodeIdsInBranch) {\n                    const nodeInBranch = this.getNodeById(nodeIdInBranch);\n                    for (let transitionCopy of transitionsCopy) {\n                      if (transitionCopy != null) {\n                        const currentFromNodeId = node.id;\n                        const currentToNodeId = nodeId;\n                        const newFromNodeId = node.id;\n                        const newToNodeId = transitionCopy.to;\n\n                        /*\n                         * change the branch path taken constraint by changing\n                         * the toNodeId\n                         */\n                        this.updateBranchPathTakenConstraint(nodeInBranch, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId);\n                      }\n                    }\n                  }\n                }\n              } else if (this.isBranchPoint(nodeId)) {\n                /*\n                 * get all the branches that have the node we\n                 * are removing as the start point\n                 */\n                const branches = this.getBranchesByBranchStartPointNodeId(nodeId);\n\n                for (let branch of branches) {\n                  if (branch != null) {\n                    /*\n                     * get the branch paths. these paths do not\n                     * contain the start point or merge point.\n                     */\n                    const branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n                      for (let branchPath of branchPaths) {\n                        if (branchPath != null) {\n                          const currentFromNodeId = nodeId;\n                          const currentToNodeId = branchPath[0];\n                          const newFromNodeId = node.id;\n                          const newToNodeId = branchPath[0];\n                          for (let branchPathNodeId of branchPath) {\n                            const branchPathNode = this.getNodeById(branchPathNodeId);\n                            this.updateBranchPathTakenConstraint(branchPathNode, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n\n              // remove the transition to the node we are removing\n              transitions.splice(t, 1);\n\n              if (transitionsCopy != null) {\n                let insertIndex = t;\n\n                /*\n                 * loop through all the transitions from the node we are removing\n                 * and insert them into the transitions of the from node\n                 * e.g.\n                 * the node that comes before the node we are removing has these transitions\n                 * \"transitions\": [\n                 *     {\n                 *         \"to\": \"node4\"\n                 *     },\n                 *     {\n                 *         \"to\": \"node6\"\n                 *     }\n                 * ]\n                 *\n                 * we are removing node4. node4 has a transition to node5.\n                 *\n                 * the node that comes before the node we are removing now has these transitions\n                 * \"transitions\": [\n                 *     {\n                 *         \"to\": \"node5\"\n                 *     },\n                 *     {\n                 *         \"to\": \"node6\"\n                 *     }\n                 * ]\n                 */\n                for (let transitionCopy of transitionsCopy) {\n                  // insert a transition from the node we are removing\n                  transitions.splice(insertIndex, 0, transitionCopy);\n                  insertIndex++;\n                }\n              }\n\n              // check if the node we are moving is a group\n              if (this.isGroupNode(nodeId)) {\n                /*\n                 * we are moving a group so we need to update transitions that\n                 * go into the group\n                 */\n                const groupIdWeAreMoving = nodeId;\n                const groupThatTransitionsToGroupWeAreMoving = node;\n                this.updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving);\n              }\n            }\n          }\n\n          if (this.isBranchPoint(nodeId)) {\n            /*\n             * the node we are deleting is a branch point so we to\n             * copy the transition logic to the node that comes\n             * before it\n             */\n            node.transitionLogic = this.UtilService.makeCopyOfJSONObject(nodeToRemoveTransitionLogic);\n\n            /*\n             * set the transitions for the node that comes before\n             * the one we are removing\n             */\n            node.transitionLogic.transitions = transitions;\n          }\n        }\n      }\n    }\n\n    if (nodeToRemoveTransitionLogic != null) {\n      nodeToRemoveTransitionLogic.transitions = [];\n    }\n\n    if (this.isGroupNode(nodeId)) {\n      /*\n       * this is a group node so we will remove all child transitions that\n       * go out of this group\n       */\n      this.removeTransitionsOutOfGroup(nodeId);\n    }\n  };\n\n  /**\n   * Remove the node id from a group\n   * @param nodeId the node id to remove\n   */\n  removeNodeIdFromGroups(nodeId) {\n    const groups = this.groupNodes;\n    if (groups != null) {\n      for (let group of groups) {\n        if (group != null) {\n          const startId = group.startId;\n          const ids = group.ids;\n          for (let i = 0; i < ids.length; i++) {\n            const id = ids[i];\n            if (nodeId === id) {\n              ids.splice(i, 1);\n\n              if (nodeId === startId) {\n                /*\n                 * the node id is also the start id so we will get the\n                 * next node id and set it as the new start id\n                 */\n\n                let hasSetNewStartId = false;\n\n                const node = this.getNodeById(id);\n\n                if (node != null) {\n                  const transitionLogic = node.transitionLogic;\n                  if (transitionLogic != null) {\n                    const transitions = transitionLogic.transitions;\n                    if (transitions != null && transitions.length > 0) {\n                      // get the first transition\n                      // TODO handle the case when the node we are removing is a branch point\n                      const transition = transitions[0];\n\n                      if (transition != null) {\n                        const to = transition.to;\n\n                        if (to != null) {\n                          group.startId = to;\n                          hasSetNewStartId = true;\n                        }\n                      }\n                    }\n                  }\n                }\n\n                if (!hasSetNewStartId) {\n                  /*\n                   * the node we are removing did not have a transition\n                   * so there will be no start id\n                   */\n                  group.startId = '';\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the array of nodes\n   * @param nodeId the node id to remove\n   */\n  removeNodeIdFromNodes(nodeId) {\n    const nodes = this.project.nodes;\n    for (let n = 0; n < nodes.length; n++) {\n      const node = nodes[n];\n      if (node != null) {\n        if (nodeId === node.id) {\n          nodes.splice(n, 1);\n        }\n      }\n    }\n\n    const inactiveNodes = this.project.inactiveNodes;\n    if (inactiveNodes != null) {\n      for (let i = 0; i < inactiveNodes.length; i++) {\n        const inactiveNode = inactiveNodes[i];\n        if (inactiveNode != null) {\n          if (nodeId === inactiveNode.id) {\n            inactiveNodes.splice(i, 1);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive nodes array\n   * @param nodeId the node to remove from the inactive nodes array\n   */\n  removeNodeIdFromInactiveNodes(nodeId) {\n    const inactiveNodes = this.project.inactiveNodes;\n\n    if (inactiveNodes != null) {\n      for (let i = 0; i < inactiveNodes.length; i++) {\n        const inactiveNode = inactiveNodes[i];\n        if (inactiveNode != null) {\n          const inactiveNodeId = inactiveNode.id;\n          if (nodeId === inactiveNodeId) {\n            /*\n             * we have found the node we are looking for so we will\n             * remove it\n             */\n            inactiveNodes.splice(i, 1);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a new component\n   * @param nodeId the node id to create the component in\n   * @param componentType the component type\n   * @param insertAfterComponentId Insert the new compnent after the given\n   * component id. If this argument is null, we will place the new component\n   * in the first position.\n   */\n  createComponent(nodeId, componentType, insertAfterComponentId) {\n    let component = null;\n    if (nodeId != null && componentType != null) {\n      // get the node we will create the component in\n      const node = this.getNodeById(nodeId);\n\n      // get the service for the component type\n      const service = this.$injector.get(componentType + 'Service');\n\n      if (node != null && service != null) {\n        // create the new component\n        component = service.createComponent();\n\n        if (service.componentHasWork()) {\n          /*\n           * the component has student work so we will need to\n           * determine if we need to show the save button on the\n           * component or the step\n           */\n\n          if (node.showSaveButton == true) {\n            /*\n             * the step is showing a save button so we will not show\n             * the save button on this new component\n             */\n          } else {\n            // the step is not showing a save button\n\n            if (this.doesAnyComponentShowSubmitButton(node.id)) {\n              /*\n               * at least one of the other components in the step are\n               * showing a submit button so we will also show the save\n               * button on this new component\n               */\n\n              // turn on the component save button\n              component.showSaveButton = true;\n            } else {\n              /*\n               * none of the other components are showing a submit button\n               * so we will show the save button on the step\n               */\n\n              // turn on the step save button\n              node.showSaveButton = true;\n            }\n          }\n        }\n\n        // add the component to the node\n        this.addComponentToNode(node, component, insertAfterComponentId);\n      }\n    }\n    return component;\n  }\n\n  /**\n   * Does any component in the step generate work\n   * @param nodeId the node id\n   * @return whether any components in the step generates work\n   */\n  doesAnyComponentHaveWork(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      const components = node.components;\n      if (components != null) {\n        for (let component of components) {\n          if (component != null) {\n            const componentType = component.type;\n            const service = this.$injector.get(componentType + 'Service');\n            if (service != null) {\n              if (service.componentHasWork()) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if any of the components in the node are showing their save button\n   * @param nodeId the node id to check\n   * @return whether any of the components in the node show their save button\n   */\n  doesAnyComponentShowSaveButton(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      const components = node.components;\n      if (components != null) {\n        for (let component of components) {\n          if (component != null) {\n            if (component.showSaveButton == true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if any of the components in the node are showing their submit button\n   * @param nodeId the node id to check\n   * @return whether any of the components in the node show their submit button\n   */\n  doesAnyComponentShowSubmitButton(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      const components = node.components;\n      if (components != null) {\n        for (let component of components) {\n          if (component != null) {\n            if (component.showSubmitButton == true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Turn on the save button in all the components in the step\n   * @param nodeId the node id\n   */\n  turnOnSaveButtonInComponents(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      const components = node.components;\n      if (components != null) {\n        for (let component of components) {\n          if (component != null) {\n            const componentType = component.type;\n            if (componentType != null) {\n              const service = this.$injector.get(componentType + 'Service');\n              if (service != null) {\n                if (service.componentUsesSaveButton()) {\n                  component.showSaveButton = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Turn off the submit button in all the components in the step\n   * @param nodeId the node id\n   */\n  turnOffSaveButtonInComponents(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      const components = node.components;\n      if (components != null) {\n        for (let component of components) {\n          if (component != null) {\n            const componentType = component.type;\n            if (componentType != null) {\n              const service = this.$injector.get(componentType + 'Service');\n              if (service != null) {\n                if (service.componentUsesSaveButton()) {\n                  component.showSaveButton = false;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Add the component to the node\n   * @param node the node\n   * @param component the component\n   * @param insertAfterComponentId Insert the component after this given\n   * component id. If this argument is null, we will place the new component\n   * in the first position.\n   */\n  addComponentToNode(node, component, insertAfterComponentId) {\n    if (node != null && component != null) {\n      if (insertAfterComponentId == null) {\n        /*\n         * insertAfterComponentId is null so we will place the new\n         * component in the first position\n         */\n        node.components.splice(0, 0, component);\n      } else {\n        // place the new component after the insertAfterComponentId\n\n        // boolean flag for whether we have added the component yet\n        let added = false;\n\n        const components = node.components;\n        for (let c = 0; c < components.length; c++) {\n          const tempComponent = components[c];\n          if (tempComponent != null && tempComponent.id != null &&\n              tempComponent.id == insertAfterComponentId) {\n            /*\n             * we have found the component we want to add the new\n             * one after\n             */\n\n            // add the component\n            components.splice(c + 1, 0, component);\n            added = true;\n            break;\n          }\n        }\n\n        if (!added) {\n          /*\n           * the component has not been added yet so we will just add\n           * it at the end\n           */\n          node.components.push(component);\n        }\n      }\n    }\n  }\n\n  /**\n   * Move the component(s) within the node\n   * @param nodeId we are moving component(s) in this node\n   * @param componentIds the component(s) we are moving\n   * @param insertAfterComponentId Insert the component(s) after this given\n   * component id. If this argument is null, we will place the new\n   * component(s) in the first position.\n   */\n  moveComponent(nodeId, componentIds, insertAfterComponentId) {\n    // get the node for which we are moving components\n    const node = this.getNodeById(nodeId);\n\n    const components = node.components;\n    const componentsToMove = [];\n\n    // remove the component(s)\n    for (let a = components.length - 1; a >= 0; a--) {\n      const tempComponent = components[a];\n      if (tempComponent != null) {\n        if (componentIds.indexOf(tempComponent.id) != -1) {\n          // we have found a component we want to move\n\n          // add the component to our array of components we are moving\n          componentsToMove.splice(0, 0, tempComponent);\n\n          // remove the component from the components array in the node\n          components.splice(a, 1);\n        }\n      }\n    }\n\n    // insert the component(s)\n    if (insertAfterComponentId == null) {\n      // insert the components at the beginning of the components list\n\n      for (let c = 0; c < componentsToMove.length; c++) {\n        // insert a component\n        components.splice(c, 0, componentsToMove[c]);\n      }\n    } else {\n      // insert the component(s) after the given insertAfterComponentId\n\n      for (let b = 0; b < components.length; b++) {\n        const tempComponent = components[b];\n        if (tempComponent != null && tempComponent.id == insertAfterComponentId) {\n          // we have found the component we want to add after\n\n          for (let c = 0; c < componentsToMove.length; c++) {\n            // insert a component\n            components.splice(b + 1 + c, 0, componentsToMove[c]);\n          }\n          break;\n        }\n      }\n    }\n    return componentsToMove;\n  }\n\n  /**\n   * Delete the component\n   * @param nodeId the node id\n   * @param componentId the component id\n   */\n  deleteComponent(nodeId, componentId) {\n    if (nodeId != null && componentId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        const components = node.components;\n        if (components != null) {\n          for (let c = 0; c < components.length; c++) {\n            const component = components[c];\n            if (component.id === componentId) {\n              // we have found the component we want to delete\n\n              // remove the component\n              components.splice(c, 1);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * TODO: Deprecated, should be removed; replaced by getMaxScoreForWorkgroupId in StudentStatusService\n   * Get the max score for the project. If the project contains branches, we\n   * will only calculate the max score for a single path from the first node\n   * to the last node in the project.\n   * @returns the max score for the project or null if none of the components in the project\n   * has max scores.\n   */\n  getMaxScore() {\n    let maxScore = null;\n    const startNodeId = this.getStartNodeId();\n\n    // get all the paths in the project\n    const allPaths = this.getAllPaths([], startNodeId);\n\n    if (allPaths != null && allPaths.length > 0) {\n      const firstPath = allPaths[0];\n      for (let nodeId of firstPath) {\n        const nodeMaxScore = this.getMaxScoreForNode(nodeId);\n        if (nodeMaxScore != null) {\n          if (maxScore == null) {\n            maxScore = nodeMaxScore;\n          } else {\n            maxScore += nodeMaxScore;\n          }\n        }\n      }\n    }\n    return maxScore;\n  }\n\n  /**\n   * Get the max score for the node\n   * @param nodeId the node id\n   * @returns the max score for the node\n   */\n  getMaxScoreForNode(nodeId) {\n    let maxScore = null;\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      const components = node.components;\n      if (components != null) {\n        for (let component of components) {\n          if (component != null) {\n            const componentMaxScore = component.maxScore;\n\n            // check if the component has a max score\n            if (componentMaxScore != null) {\n              // make sure the max score is a valid number\n              if (!isNaN(componentMaxScore)) {\n                if (maxScore == null) {\n                  maxScore = componentMaxScore;\n                } else {\n                  // accumulate the max score\n                  maxScore += componentMaxScore;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return maxScore;\n  }\n\n  /**\n   * Get the max score for a component\n   * @param nodeId get the max score from a component in this node\n   * @param componentId get the max score from this component\n   */\n  getMaxScoreForComponent(nodeId, componentId) {\n    const component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    if (component != null) {\n      return component.maxScore;\n    }\n    return null;\n  }\n\n  /**\n   * Set the max score for a component\n   * @param nodeId set the max score from a component in this node\n   * @param componentId set the max score from this component\n   * @param maxScore set it to this maxScore\n   */\n  setMaxScoreForComponent(nodeId, componentId, maxScore) {\n    if (nodeId != null && componentId != null && maxScore != null && typeof maxScore === 'number') {\n      let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n      if (component != null) {\n        component.maxScore = maxScore;\n      }\n    }\n  }\n\n  /**\n   * Determine if a node id is a direct child of a group\n   * @param nodeId the node id\n   * @param groupId the group id\n   */\n  isNodeInGroup(nodeId, groupId) {\n    const group = this.getNodeById(groupId);\n    const childIds = group.ids;\n    if (childIds != null) {\n      if (childIds.indexOf(nodeId) != -1) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the first leaf node by traversing all the start ids\n   * until a leaf node id is found\n   */\n  getFirstLeafNodeId() {\n    let firstLeafNodeId = null;\n    const startGroupId = this.project.startGroupId;\n    let node = this.getNodeById(startGroupId);\n    let done = false;\n\n    // loop until we have found a leaf node id or something went wrong\n    while (!done) {\n      if (node == null) {\n        done = true;\n      } else if (this.isGroupNode(node.id)) {\n        // set the first leaf node id to the group id for now\n        firstLeafNodeId = node.id;\n\n        node = this.getNodeById(node.startId);\n      } else if (this.isApplicationNode(node.id)) {\n        // the current node is a leaf\n        firstLeafNodeId = node.id;\n        done = true;\n      } else {\n        done = true;\n      }\n    }\n    return firstLeafNodeId;\n  }\n\n  /**\n   * Replace a node. This is used when we want to revert a node back to a\n   * previous version in the authoring tool.\n   * @param nodeId the node id\n   * @param node the node object\n   */\n  replaceNode(nodeId, node) {\n    if (nodeId != null && node != null) {\n      this.setIdToNode(nodeId, node);\n      this.setIdToElement(nodeId, node);\n      const nodes = this.getNodes();\n      if (nodes != null) {\n        for (let n = 0; n < nodes.length; n++) {\n          const tempNode = nodes[n];\n          if (tempNode != null) {\n            const tempNodeId = tempNode.id;\n            if (nodeId === tempNodeId) {\n              nodes.splice(n, 1, node);\n              break;\n            }\n          }\n        }\n      }\n\n      const applicationNodes = this.applicationNodes;\n      if (applicationNodes != null) {\n        for (let a = 0; a < applicationNodes.length; a++) {\n          const tempApplicationNode = applicationNodes[a];\n          if (tempApplicationNode != null) {\n            const tempApplicationNodeId = tempApplicationNode.id;\n            if (nodeId === tempApplicationNodeId) {\n              applicationNodes.splice(a, 1, node);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if a node is a planning node\n   * @param nodeId the node id\n   * @returns whether the node is a planning node\n   */\n  isPlanning(nodeId) {\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        if (node.planning) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a node is a planning node instance\n   * @param nodeId the node id\n   * @returns whether the node is a planning node instance\n   */\n  isPlanningInstance(nodeId) {\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node.planningNodeTemplateId) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the available planning node ids for a node\n   * @param nodeId the node we want available planning nodes for\n   * @returns an array of available planning node ids\n   */\n  getAvailablePlanningNodeIds(nodeId) {\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null && node.availablePlanningNodeIds != null) {\n        return node.availablePlanningNodeIds;\n      }\n    }\n    return [];\n  }\n\n  /**\n   * Get the available planning nodes for a given group\n   * @param nodeId the node id of the group\n   * @returns an array of planning node templates\n   */\n  getAvailablePlanningNodes(nodeId) {\n    const availablePlanningNodesSoFar = [];\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null && node.availablePlanningNodes != null) {\n        let availablePlanningNodes = node.availablePlanningNodes;\n        for (let availablePlanningNode of availablePlanningNodes) {\n          if (availablePlanningNode != null) {\n            const availablePlanningNodeActual =\n                this.getNodeById(availablePlanningNode.nodeId);\n            if (availablePlanningNodeActual != null) {\n              if (availablePlanningNode.max != null) {\n                availablePlanningNodeActual.max = availablePlanningNode.max;\n              }\n              availablePlanningNodesSoFar.push(availablePlanningNodeActual);\n            }\n          }\n        }\n      }\n    }\n    return availablePlanningNodesSoFar;\n  }\n\n  /**\n   * Create a planning node instance and add it to the project\n   * @param groupId the group id to add the planning node instance to\n   * @param nodeId the node id of the planning node template\n   */\n  createPlanningNodeInstance(groupId, nodeId, nextAvailablePlanningNodeId) {\n    let planningNodeInstance = null;\n    if (nodeId != null && nextAvailablePlanningNodeId != null) {\n      // create a planning node instance by copying the planning node template\n      planningNodeInstance = this.copyNode(nodeId);\n\n      // set the template id to point back to the planning template node\n      planningNodeInstance.planningNodeTemplateId = nodeId;\n\n      // set the planning node instance node id\n      planningNodeInstance.id = nextAvailablePlanningNodeId;\n    }\n    return planningNodeInstance;\n  }\n\n  /**\n   * Add a planning node instance inside a group node\n   * @param nodeIdToInsertInside the group id to insert into\n   * @param planningNodeInstance the planning node instance to add\n   */\n  addPlanningNodeInstanceInside(nodeIdToInsertInside, planningNodeInstance) {\n    const planningNodeInstanceNodeId = planningNodeInstance.id;\n\n    // add an entry in our mapping data structures of node id to object\n    this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\n    this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\n\n    // add the node to the nodes array in the project\n    this.addNode(planningNodeInstance);\n\n    // update the transitions\n    this.insertNodeInsideInTransitions(planningNodeInstanceNodeId, nodeIdToInsertInside);\n\n    // update the child ids of the group\n    this.insertNodeInsideInGroups(planningNodeInstanceNodeId, nodeIdToInsertInside);\n\n    // recalculate all the position values in the group\n    this.recalculatePositionsInGroup(nodeIdToInsertInside);\n\n    /*\n     * set the order of the planning node instance so that it shows up\n     * in the select step drop down in the correct order\n     */\n    this.setNodeOrder(this.rootNode, 0);\n  }\n\n  /**\n   * Add a planning node instance after a node\n   * @param nodeIdToInsertAfter the node to insert after\n   * @param planningNodeInstance the planning node instance to add\n   */\n  addPlanningNodeInstanceAfter(nodeIdToInsertAfter, planningNodeInstance) {\n    const planningNodeInstanceNodeId = planningNodeInstance.id;\n\n    // add an entry in our mapping data structures of node id to object\n    this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\n    this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\n\n    // add the node to the nodes array in the project\n    this.addNode(planningNodeInstance);\n\n    // update the transitions\n    this.insertNodeAfterInTransitions(planningNodeInstance, nodeIdToInsertAfter);\n\n    // update the child ids of the group\n    this.insertNodeAfterInGroups(planningNodeInstanceNodeId, nodeIdToInsertAfter);\n\n    const parentGroup = this.getParentGroup(nodeIdToInsertAfter);\n\n    if (parentGroup != null) {\n      const parentGroupId = parentGroup.id;\n\n      // recalculate all the position values in the group\n      this.recalculatePositionsInGroup(parentGroupId);\n    }\n\n    /*\n     * set the order of the planning node instance so that it shows up\n     * in the select step drop down in the correct order\n     */\n    this.setNodeOrder(this.rootNode, 0);\n  }\n\n  /**\n   * Move a planning node instance inside a group\n   * @param nodeIdToMove the node to move\n   * @param nodeIdToInsertInside the group to move the node into\n   */\n  movePlanningNodeInstanceInside(nodeIdToMove, nodeIdToInsertInside) {\n    this.moveNodesInside([nodeIdToMove], nodeIdToInsertInside);\n    this.recalculatePositionsInGroup(nodeIdToInsertInside);\n\n    /*\n     * set the order of the planning node instance so that it shows up\n     * in the select step drop down in the correct order\n     */\n    this.setNodeOrder(this.rootNode, 0);\n  }\n\n  /**\n   * Move a planning node instance after a node\n   * @param nodeIdToMove the node to move\n   * @param nodeIdToInsertAfter the other node to move the node after\n   */\n  movePlanningNodeInstanceAfter(nodeIdToMove, nodeIdToInsertAfter) {\n    this.moveNodesAfter([nodeIdToMove], nodeIdToInsertAfter);\n    const parentGroup = this.getParentGroup(nodeIdToInsertAfter);\n\n    if (parentGroup != null) {\n      const parentGroupId = parentGroup.id;\n      this.recalculatePositionsInGroup(parentGroupId);\n    }\n\n    /*\n     * set the order of the planning node instance so that it shows up\n     * in the select step drop down in the correct order\n     */\n    this.setNodeOrder(this.rootNode, 0);\n  }\n\n  /**\n   * Recalculate the positions of the children in the group.\n   * The positions are the numbers usually seen before the title\n   * e.g. if the step is seen as 1.3: Gather Evidence, then 1.3\n   * is the position\n   * @param groupId recalculate all the children of this group\n   */\n  recalculatePositionsInGroup(groupId) {\n    if (groupId != null) {\n      let childIds = this.getChildNodeIdsById(groupId);\n      for (let childId of childIds) {\n        let pos = this.getPositionById(childId);\n        this.setIdToPosition(childId, pos);\n      }\n    }\n  }\n\n  /**\n   * Get the message that describes how to disable the constraint\n   * @param nodeId the node the student is trying to go to\n   * @param constraint the constraint that is preventing the student\n   * from going to the node\n   * @returns the message to display to the student that describes how\n   * to disable the constraint\n   */\n  getConstraintMessage(nodeId, constraint) {\n    let message = '';\n\n    if (nodeId != null && constraint != null) {\n      // get the node title the student is trying to go to\n      const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n\n      const removalConditional = constraint.removalConditional;\n      const removalCriteria = constraint.removalCriteria;\n\n      if (removalCriteria != null) {\n        let criteriaMessages = '';\n        for (let tempRemovalCriteria of removalCriteria) {\n          if (tempRemovalCriteria != null) {\n            // get the message that describes the criteria that needs to be satisfied\n            const criteriaMessage = this.getCriteriaMessage(tempRemovalCriteria);\n\n            if (criteriaMessage != null && criteriaMessage != '') {\n              // separate criteria messages with a line break\n              if (criteriaMessages != '') {\n                criteriaMessages += '<br/>';\n              }\n              criteriaMessages += criteriaMessage;\n            }\n          }\n        }\n        message += criteriaMessages;\n      }\n    }\n    return message;\n  }\n\n  /**\n   * Get the message that describes how to satisfy the criteria\n   * TODO: check if the criteria is satisfied\n   * @param criteria the criteria object that needs to be satisfied\n   * @returns the message to display to the student that describes how to\n   * satisfy the criteria\n   */\n  getCriteriaMessage(criteria) {\n    let message = '';\n\n    if (criteria != null) {\n      const name = criteria.name;\n      const params = criteria.params;\n\n      if (name === 'isCompleted') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('completeNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'isVisited') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('visitNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'isCorrect') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('correctlyAnswerNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'score') {\n        const nodeId = params.nodeId;\n        let nodeTitle = '';\n        let scoresString = '';\n\n        if (nodeId != null) {\n          nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n        }\n\n        const scores = params.scores;\n        if (scores != null) {\n          // get the required score\n          scoresString = scores.join(', ');\n        }\n\n        // generate the message\n        message += this.$translate('obtainAScoreOfXOnNodeTitle', { score: scoresString, nodeTitle: nodeTitle });\n      } else if (name === 'choiceChosen') {\n\n      } else if (name === 'usedXSubmits') {\n        const nodeId = params.nodeId;\n        let nodeTitle = '';\n\n        // get the number of times the student must submit\n        const requiredSubmitCount = params.requiredSubmitCount;\n\n        if (nodeId != null) {\n          // get the step number and title\n          nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n        }\n\n        // generate the message\n        if (requiredSubmitCount == 1) {\n          message += this.$translate('submitXTimeOnNodeTitle', { requiredSubmitCount: requiredSubmitCount, nodeTitle: nodeTitle });\n        } else {\n          message += this.$translate('submitXTimesOnNodeTitle', { requiredSubmitCount: requiredSubmitCount, nodeTitle: nodeTitle });\n        }\n      } else if (name === 'branchPathTaken') {\n\n      } else if (name === 'isPlanningActivityCompleted') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('completeNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'wroteXNumberOfWords') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const requiredNumberOfWords = params.requiredNumberOfWords;\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('writeXNumberOfWordsOnNodeTitle',\n              { requiredNumberOfWords: requiredNumberOfWords, nodeTitle: nodeTitle });\n        }\n      }\n    }\n    return message;\n  }\n\n  /**\n   * Get the start id of a group\n   * @param nodeId get the start id of this group\n   * @returns the start id of the group\n   */\n  getGroupStartId(nodeId) {\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n\n      if (node != null) {\n        return node.startId;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the start id of the node's parent group\n   * @param nodeId we will get the parent of this node and then look\n   * for the start id of the parent\n   * @returns the start id of the parent\n   */\n  getParentGroupStartId(nodeId) {\n    if (nodeId != null) {\n      const parentGroup = this.getParentGroup(nodeId);\n      if (parentGroup != null) {\n        return parentGroup.startId;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Update the transitions so that the fromGroup points to the newToGroup\n   *\n   * Before\n   * fromGroup -> oldToGroup -> newToGroup\n   *\n   * After\n   * fromGroup -> newToGroup\n   * oldToGroup becomes dangling and has no transitions to or from it\n   */\n  updateTransitionsForExtractingGroup(fromGroupId, oldToGroupId, newToGroupId) {\n    /*\n     * make the transitions\n     * fromGroup -> newToGroup\n     */\n    if (fromGroupId != null && oldToGroupId != null) {\n      const fromGroup = this.getNodeById(fromGroupId);\n      const oldToGroup = this.getNodeById(oldToGroupId);\n      let newToGroup = null;\n      let newToGroupStartId = null;\n\n      if (newToGroupId != null) {\n        newToGroup = this.getNodeById(newToGroupId);\n      }\n\n      if (newToGroup != null) {\n        newToGroupStartId = newToGroup.startId;\n      }\n\n      if (fromGroup != null && oldToGroup != null) {\n        const childIds = fromGroup.ids;\n\n        // update the children of the from group to point to the new to group\n        if (childIds != null) {\n          for (let childId of childIds) {\n            const child = this.getNodeById(childId);\n            const transitions = this.getTransitionsByFromNodeId(childId);\n\n            if (transitions != null) {\n              for (let t = 0; t < transitions.length; t++) {\n                const transition = transitions[t];\n                if (transition != null) {\n                  const toNodeId = transition.to;\n                  if (toNodeId === oldToGroupId) {\n                    // the transition is to the group\n                    if (newToGroupId == null && newToGroupStartId == null) {\n                      // there is no new to group so we will remove the transition\n                      transitions.splice(t, 1);\n                      t--;\n                    } else {\n                      // make the transition point to the new to group\n                      transition.to = newToGroupId;\n                    }\n                  } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                    // the transition is to a node in the group\n                    if (newToGroupId == null && newToGroupStartId == null) {\n                      // there is no new to group so we will remove the transition\n                      transitions.splice(t, 1);\n                      t--;\n                    } else if (newToGroupStartId == null || newToGroupStartId == '') {\n                      // make the transition point to the new to group\n                      transition.to = newToGroupId;\n                    } else {\n                      // make the transition point to the new group start id\n                      transition.to = newToGroupStartId;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /*\n     * remove the transitions from the oldToGroup\n     */\n    if (oldToGroupId != null && newToGroupId != null) {\n      const oldToGroup = this.getNodeById(oldToGroupId);\n      if (oldToGroup != null) {\n        const childIds = oldToGroup.ids;\n\n        // remove the transitions from the old to group that point to the new to group\n        if (childIds != null) {\n          for (let childId of childIds) {\n            const child = this.getNodeById(childId);\n            const transitions = this.getTransitionsByFromNodeId(childId);\n            if (transitions != null) {\n              for (let t = 0; t < transitions.length; t++) {\n                const transition = transitions[t];\n                if (transition != null) {\n                  const toNodeId = transition.to;\n                  if (toNodeId === newToGroupId) {\n                    // the transition is to the group so we will remove it\n                    transitions.splice(t, 1);\n                    t--;\n                  } else if (this.isNodeInGroup(toNodeId, newToGroupId)) {\n                    // the transition is to a node in the group so we will remove it\n                    transitions.splice(t, 1);\n                    t--;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Update the transitions so that the fromGroup points to the newToGroup\n   *\n   * Before\n   * fromGroup -> oldToGroup\n   * newToGroup is dangling and has no transitions to or from it\n   *\n   * After\n   * fromGroup -> newToGroup -> oldToGroup\n   */\n  updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId) {\n    let fromGroup = null;\n    let newToGroup = null;\n    if (fromGroupId != null) {\n      fromGroup = this.getNodeById(fromGroupId);\n    }\n\n    if (newToGroupId != null) {\n      newToGroup = this.getNodeById(newToGroupId);\n    }\n\n    /*\n     * make the transitions that point to the old group now point\n     * to the new group\n     * fromGroup -> newToGroup\n     */\n    if (fromGroup != null && newToGroup != null) {\n      const childIds = fromGroup.ids;\n      const newToGroupStartId = newToGroup.startId;\n      if (childIds != null) {\n        for (let childId of childIds) {\n          const child = this.getNodeById(childId);\n\n          // get the transitions from the child\n          const transitions = this.getTransitionsByFromNodeId(childId);\n\n          if (transitions == null || transitions.length == 0) {\n            /*\n             * the child does not have any transitions so we will make it\n             * point to the new group\n             */\n            if (newToGroupStartId == null || newToGroupStartId == '') {\n              this.addToTransition(child, newToGroupId);\n            } else {\n              this.addToTransition(child, newToGroupStartId)\n            }\n          } else if (transitions != null) {\n            for (let transition of transitions) {\n              if (transition != null) {\n                const toNodeId = transition.to;\n                if (oldToGroupIds != null) {\n                  for (let oldToGroupId of oldToGroupIds) {\n                    if (toNodeId === oldToGroupId) {\n                      /*\n                       * the transition is to the group so we will update the transition\n                       * to the new group\n                       */\n                      transition.to = newToGroupId;\n                    } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                      /*\n                       * the transition is to a node in the old group so we will update\n                       * the transition to point to the new group\n                       */\n                      if (newToGroupStartId == null || newToGroupStartId == '') {\n                        transition.to = newToGroupId;\n                      } else {\n                        transition.to = newToGroupStartId;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /*\n     * make the steps that do not have a transition now point to the old\n     * group\n     * newToGroup -> oldToGroup\n     */\n    if (newToGroup != null) {\n      const childIds = newToGroup.ids;\n      if (childIds != null) {\n        for (let childId of childIds) {\n          const child = this.getNodeById(childId);\n          const transitions = this.getTransitionsByFromNodeId(childId);\n\n          if (transitions == null || transitions.length == 0) {\n            if (oldToGroupIds != null) {\n              for (let oldToGroupId of oldToGroupIds) {\n                const oldToGroup = this.getNodeById(oldToGroupId);\n                if (oldToGroup != null) {\n                  const oldToGroupStartId = oldToGroup.startId;\n                  const transition = {};\n                  let toNodeId = '';\n                  if (oldToGroupStartId == null) {\n                    // there is no start node id so we will just point to the group\n                    toNodeId = oldToGroup;\n                  } else {\n                    // there is a start node id so we will point to it\n                    toNodeId = oldToGroupStartId;\n                  }\n\n                  // create the transition from the child to the old group\n                  this.addToTransition(child, toNodeId);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Update the child transitions because we are moving a group. We will\n   * update the transitions into and out of the group in the location\n   * we are extracting the group from and also in the location we are\n   * inserting the group into.\n   * @param node the group we are moving\n   * @param nodeId we will put the group after this node id\n   */\n  updateChildrenTransitionsForMovingGroup(node, nodeId) {\n    let transitionsBefore = null;\n\n    // get the group nodes that point to the group we are moving\n    const previousGroupNodes = this.getGroupNodesByToNodeId(node.id);\n\n    // get all the transitions from the group we are moving\n    const transitionsAfter = this.getTransitionsByFromNodeId(node.id);\n\n    let extracted = false;\n\n    /*\n     * extract the group we are moving by updating the transitions of the\n     * from group and the new to group. also remove the transitions from the\n     * group we are moving.\n     */\n\n    for (let previousGroupNode of previousGroupNodes) {\n      if (transitionsAfter == null || transitionsAfter.length == 0) {\n        // the group we are moving does not have any transitions\n\n        /*\n         * remove the transitions to the group we are moving and make\n         * new transitions from the from group to the new to group\n         */\n        this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, null);\n        extracted = true;\n      } else {\n        // the group we are moving has transitions\n\n        // make the previous group point to the new to group\n        for (let transitionAfter of transitionsAfter) {\n          if (transitionAfter != null) {\n            const toNodeId = transitionAfter.to;\n\n            /*\n             * remove the transitions to the group we are moving and make\n             * new transitions from the from group to the new to group\n             */\n            this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, toNodeId);\n            extracted = true;\n          }\n        }\n      }\n    }\n\n    if (!extracted) {\n      /*\n       * we have not removed the transitions yet because the group\n       * we are moving does not have any groups before it\n       */\n\n      if (transitionsAfter != null) {\n        // remove the transitions from the group we are moving\n        for (let transitionAfter of transitionsAfter) {\n          if (transitionAfter != null) {\n            const toNodeId = transitionAfter.to;\n\n            // remove the transitions to the group we are moving\n            this.updateTransitionsForExtractingGroup(null, node.id, toNodeId);\n            extracted = true;\n          }\n        }\n      }\n    }\n\n    let inserted = false;\n\n    /*\n     * create the transitions from the from group to the group we are moving\n     * and the transitions from the group we are moving to the old to group\n     */\n    if (nodeId != null) {\n      // get the transitions from the previous group to the next group\n      const transitionsAfter = this.getTransitionsByFromNodeId(nodeId);\n\n      for (let transitionAfter of transitionsAfter) {\n        if (transitionAfter != null) {\n          const toNodeId = transitionAfter.to;\n\n          /*\n           * create the transitions that traverse from the from group\n           * to the group we are moving. also create the transitions\n           * that traverse from the group we are moving to the old\n           * to group.\n           */\n          this.updateTransitionsForInsertingGroup(nodeId, [toNodeId], node.id);\n          inserted = true;\n        }\n      }\n    }\n\n    if (!inserted) {\n      /*\n       * we have not inserted the transitions yet because there were no\n       * previous group transitions\n       */\n\n      if (nodeId == null) {\n        /*\n         * the previous node id is null which means there was no previous\n         * group. this means the group we are inserting will become the\n         * first group. this happens when the group we are moving\n         * is moved inside the root (group0).\n         */\n\n        const startGroupId = this.getStartGroupId();\n\n        if (startGroupId != null) {\n          // get the start group for the whole project (group0)\n          const startGroup = this.getNodeById(startGroupId);\n\n          if (startGroup != null) {\n            // get the first activity\n            const firstGroupId = startGroup.startId;\n\n            /*\n             * create the transitions that traverse from the group\n             * we are moving to the previous first activity.\n             */\n            this.updateTransitionsForInsertingGroup(nodeId, [firstGroupId], node.id);\n          }\n        }\n      } else {\n        /*\n         * we have not inserted the group yet because the from group doesn't\n         * have a group after it\n         */\n\n        /*\n         * create the transitions that traverse from the from group\n         * to the group we are moving.\n         */\n        this.updateTransitionsForInsertingGroup(nodeId, null, node.id);\n      }\n    }\n  }\n\n  /**\n   * Check if a component is a connected component\n   * @param nodeId the node id of the component\n   * @param componentId the component that is listening for connected changes\n   * @param connectedComponentId the component that is broadcasting connected changes\n   * @returns whether the componentId is connected to the connectedComponentId\n   */\n  isConnectedComponent(nodeId, componentId, connectedComponentId) {\n    const component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    if (component != null) {\n      const connectedComponents = component.connectedComponents;\n      if (connectedComponents != null) {\n        for (let connectedComponent of connectedComponents) {\n          if (connectedComponent != null) {\n            /*\n             * check if the connected component id matches the one\n             * we are looking for. connectedComponent.id is the old\n             * field we used to store the component id in so we will\n             * look for that field for the sake of backwards\n             * compatibility. connectedComponent.componentId is the\n             * new field we store the component id in.\n             */\n            if (connectedComponentId === connectedComponent.id ||\n                connectedComponentId === connectedComponent.componentId) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get a connected component params\n   * @param componentId the connected component id\n   * @returns the params for the connected component\n   */\n  getConnectedComponentParams(componentContent, componentId) {\n    let connectedComponentParams = null;\n    if (componentContent != null && componentId != null) {\n      const connectedComponents = componentContent.connectedComponents;\n      if (connectedComponents != null) {\n        for (let connectedComponent of connectedComponents) {\n          if (connectedComponent != null) {\n            /*\n             * check if the connected component id matches the one\n             * we are looking for. connectedComponent.id is the old\n             * field we used to store the component id in so we will\n             * look for that field for the sake of backwards\n             * compatibility. connectedComponent.componentId is the\n             * new field we store the component id in.\n             */\n            if (componentId === connectedComponent.id ||\n                componentId === connectedComponent.componentId) {\n              connectedComponentParams = connectedComponent;\n            }\n          }\n        }\n      }\n    }\n    return connectedComponentParams;\n  }\n\n  /**\n   * Get the active nodes.\n   * @return An array of the active node objects.\n   */\n  getActiveNodes() {\n    return this.project.nodes;\n  }\n\n  /**\n   * Get the inactive nodes\n   * @returns the inactive nodes\n   */\n  getInactiveNodes() {\n    let inactiveNodes = [];\n    if (this.project != null) {\n      if (this.project.inactiveNodes == null) {\n        this.project.inactiveNodes = [];\n      }\n      inactiveNodes = this.project.inactiveNodes;\n    }\n    return inactiveNodes;\n  }\n\n  /**\n   * Remove the node from the active nodes\n   * @param nodeId the node to remove\n   * @returns the node that we have removed\n   */\n  removeNodeFromActiveNodes(nodeId) {\n    let node = null;\n    if (nodeId != null) {\n      const activeNodes = this.project.nodes;\n      if (activeNodes != null) {\n        for (let a = 0; a < activeNodes.length; a++) {\n          const activeNode = activeNodes[a];\n          if (activeNode != null) {\n            if (nodeId === activeNode.id) {\n              node = activeNode;\n\n              // remove the node from the array\n              activeNodes.splice(a, 1);\n\n              if (activeNode.type == 'group') {\n                this.removeChildNodesFromActiveNodes(activeNode);\n              }\n              break;\n            }\n          }\n        }\n      }\n    }\n    return node;\n  }\n\n  /**\n   * Move the child nodes of a group from the active nodes and put them into\n   * the inactive nodes.\n   * @param node The group node.\n   */\n  removeChildNodesFromActiveNodes(node) {\n    if (node != null) {\n      let childIds = node.ids;\n      for (let childId of childIds) {\n        this.removeNodeFromActiveNodes(childId);\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive nodes array\n   * @param nodeId the node to remove\n   * @returns the node that was removed\n   */\n  removeNodeFromInactiveNodes(nodeId) {\n    let node = null;\n    if (nodeId != null) {\n      let parentGroup = this.getParentGroup(nodeId);\n      if (parentGroup != null) {\n        // The node has a parent so we will remove it from the parent.\n        this.removeChildFromParent(nodeId);\n      }\n\n      let inactiveNodes = this.project.inactiveNodes;\n      if (inactiveNodes != null) {\n        for (let i = 0; i < inactiveNodes.length; i++) {\n          let inactiveNode = inactiveNodes[i];\n          if (inactiveNode != null) {\n            if (nodeId === inactiveNode.id) {\n              node = inactiveNode;\n\n              // remove the node from the array\n              inactiveNodes.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n      this.removeNodeFromInactiveStepNodes(nodeId);\n      this.removeNodeFromInactiveGroupNodes(nodeId);\n    }\n    return node;\n  }\n\n  /**\n   * Remove the child node from the parent group.\n   * @param nodeId The child node to remove from the parent.\n   */\n  removeChildFromParent(nodeId) {\n    let parentGroup = this.getParentGroup(nodeId);\n    if (parentGroup != null) {\n      // Remove the child from the parent\n      for (let i = 0; i < parentGroup.ids.length; i++) {\n        let childId = parentGroup.ids[i];\n        if (nodeId == childId) {\n          parentGroup.ids.splice(i, 1);\n          break;\n        }\n      }\n      if (nodeId == parentGroup.startId) {\n        /*\n         * The child we removed was the start id of the group so we\n         * will update the start id.\n         */\n        let startIdUpdated = false;\n        let transitions = this.getTransitionsByFromNodeId(nodeId);\n        if (transitions != null &&\n          transitions.length > 0 &&\n          transitions[0] != null &&\n          transitions[0].to != null) {\n          parentGroup.startId = transitions[0].to;\n          startIdUpdated = true;\n        }\n        if (!startIdUpdated && parentGroup.ids.length > 0) {\n          parentGroup.startId = parentGroup.ids[0];\n          startIdUpdated = true;\n        }\n        if (!startIdUpdated) {\n          parentGroup.startId = '';\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive step nodes array.\n   * @param nodeId The node id of the node we want to remove from the\n   * inactive step nodes array.\n   */\n  removeNodeFromInactiveStepNodes(nodeId) {\n    for (let i = 0; i < this.inactiveStepNodes.length; i++) {\n      let inactiveStepNode = this.inactiveStepNodes[i];\n      if (nodeId == inactiveStepNode.id) {\n        this.inactiveStepNodes.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive group nodes array.\n   * @param nodeId The node id of the group we want to remove from the\n   * inactive group nodes array.\n   */\n  removeNodeFromInactiveGroupNodes(nodeId) {\n    for (let i = 0; i < this.inactiveGroupNodes.length; i++) {\n      let inactiveGroupNode = this.inactiveGroupNodes[i];\n      if (nodeId == inactiveGroupNode.id) {\n        this.inactiveGroupNodes.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Load the inactive nodes\n   * @param nodes the inactive nodes\n   */\n  loadInactiveNodes(nodes) {\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null) {\n          const nodeId = node.id;\n\n          this.setIdToNode(nodeId, node);\n          this.setIdToElement(nodeId, node);\n          if (node.type == 'group') {\n            this.inactiveGroupNodes.push(node);\n          } else {\n            this.inactiveStepNodes.push(node);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the node is active\n   * @param nodeId the node to check\n   * @param componentId (optional) the component to check\n   * @returns whether the node or component is active\n   */\n  isActive(nodeId, componentId) {\n    if (nodeId != null) {\n      if (nodeId === 'inactiveNodes') {\n        // this occurs when the author puts a step into the inactive nodes\n        return false;\n      } else if (nodeId === 'inactiveGroups') {\n        // this occurs when the author puts a group into the inactive groups\n        return false;\n      } else if (this.isGroupNode(nodeId)) {\n        return this.isGroupActive(nodeId);\n      } else {\n        // the node is a step node\n\n        const activeNodes = this.project.nodes;\n        if (activeNodes != null) {\n          for (let activeNode of activeNodes) {\n            if (activeNode != null) {\n              const activeNodeId = activeNode.id;\n              if (nodeId == activeNodeId) {\n                // we have found the node id we are looking for\n\n                if (componentId != null) {\n                  // we need to find the node id and component id\n\n                  const activeComponents = activeNode.components;\n\n                  if (activeComponents != null) {\n                    for (let activeComponent of activeComponents) {\n                      if (activeComponent != null) {\n                        const activeComponentId = activeComponent.id;\n                        if (componentId == activeComponentId) {\n                          /*\n                           * we have found the component id we are\n                           * looking for so we are done\n                           */\n                          return true;\n                        }\n                      }\n                    }\n                  }\n                } else {\n                  //we only need to find the node id so we are done\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a group is active.\n   * @param nodeId the node id of the group\n   */\n  isGroupActive(nodeId) {\n    for (let activeNode of this.project.nodes) {\n      if (nodeId == activeNode.id) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Move the node to the active nodes array\n   */\n  moveToActive(node) {\n    if (node != null) {\n      if (!this.isActive(node.id)) {\n        // the node is inactive so we will move it to the active array\n\n        // remove the node from inactive nodes array\n        this.removeNodeFromInactiveNodes(node.id);\n\n        this.addNode(node);\n\n        if (this.isGroupNode(node.id)) {\n          /*\n           * This is a group node so we will also move all of its\n           * children to active.\n           */\n          let childIds = node.ids;\n          for (let childId of childIds) {\n            let childNode = this.removeNodeFromInactiveNodes(childId);\n            this.addNode(childNode);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Move the node to the inactive nodes array\n   * @param node the node to move\n   * @param nodeIdToInsertAfter place the node after this\n   */\n  moveToInactive(node, nodeIdToInsertAfter) {\n    if (node != null) {\n      if (this.isActive(node.id)) {\n        // the node is active so we will move it to the inactive array\n\n        this.removeNodeFromActiveNodes(node.id);\n\n        // add the node to the inactive array\n        this.addInactiveNode(node, nodeIdToInsertAfter);\n      }\n    }\n  }\n\n  /**\n   * Add the node to the inactive nodes array\n   * @param node the node to move\n   * @param nodeIdToInsertAfter place the node after this\n   */\n  addInactiveNode(node, nodeIdToInsertAfter) {\n    if (node != null) {\n      const inactiveNodes = this.project.inactiveNodes;\n\n      if (inactiveNodes != null) {\n        // clear the transitions from this node\n        if (node.transitionLogic != null) {\n          node.transitionLogic.transitions = [];\n        }\n\n        if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveNodes' || nodeIdToInsertAfter === 'inactiveSteps' || nodeIdToInsertAfter === 'inactiveGroups') {\n          // put the node at the beginning of the inactive steps\n          inactiveNodes.splice(0, 0, node);\n        } else {\n          // put the node after one of the inactive nodes\n\n          let added = false;\n          for (let i = 0; i < inactiveNodes.length; i++) {\n            const inactiveNode = inactiveNodes[i];\n            if (inactiveNode != null) {\n              if (nodeIdToInsertAfter === inactiveNode.id) {\n                // we have found the position to place the node\n                inactiveNodes.splice(i + 1, 0, node);\n                added = true;\n              }\n            }\n          }\n\n          if (!added) {\n            /*\n             * we haven't added the node yet so we will just add it\n             * to the end of the array\n             */\n            inactiveNodes.push(node);\n          }\n        }\n\n        if (node.type == 'group') {\n          this.inactiveGroupNodes.push(node.id);\n          this.addGroupChildNodesToInactive(node);\n        } else {\n          this.inactiveStepNodes.push(node.id);\n        }\n      }\n    }\n  }\n\n  /**\n   * Add a group's child nodes to the inactive nodes.\n   * @param node The group node.\n   */\n  addGroupChildNodesToInactive(node) {\n    if (node != null) {\n      let childIds = node.ids;\n      for (let childId of childIds) {\n        let childNode = this.getNodeById(childId);\n        this.project.inactiveNodes.push(childNode);\n        this.inactiveStepNodes.push(childNode);\n      }\n    }\n  }\n\n  /**\n   * Move an inactive node within the inactive nodes array\n   * @param node the node to move\n   * @param nodeIdToInsertAfter place the node after this\n   */\n  moveInactiveNode(node, nodeIdToInsertAfter) {\n    if (node != null) {\n      const inactiveNodes = this.project.inactiveNodes;\n      if (inactiveNodes != null) {\n        // remove the node from inactive nodes\n\n        for (let i = 0; i < inactiveNodes.length; i++) {\n          const inactiveNode = inactiveNodes[i];\n          if (inactiveNode != null) {\n            if (node.id === inactiveNode.id) {\n              // we have found the node we want to remove\n              inactiveNodes.splice(i, 1);\n            }\n          }\n        }\n\n        // add the node back into the inactive nodes\n\n        if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveSteps' || nodeIdToInsertAfter === 'inactiveNodes') {\n          // put the node at the beginning of the inactive nodes\n          inactiveNodes.splice(0, 0, node);\n        } else {\n          // put the node after one of the inactive nodes\n\n          let added = false;\n          for (let i = 0; i < inactiveNodes.length; i++) {\n            const inactiveNode = inactiveNodes[i];\n            if (inactiveNode != null) {\n              if (nodeIdToInsertAfter === inactiveNode.id) {\n                // we have found the position to place the node\n                inactiveNodes.splice(i + 1, 0, node);\n                added = true;\n              }\n            }\n          }\n\n          if (!added) {\n            /*\n             * we haven't added the node yet so we will just add it\n             * to the end of the array\n             */\n            inactiveNodes.push(node);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove transitions that go into the group\n   * @param nodeId the group id\n   */\n  removeTransitionsIntoGroup(nodeId) {\n    if (nodeId != null) {\n      const group = this.getNodeById(nodeId);\n      if (group != null) {\n        const childIds = group.ids;\n        if (childIds != null) {\n          for (let childId of childIds) {\n            if (childId != null) {\n              this.removeTransitionsThatPointToNodeIdFromOutsideGroup(childId);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the transitions that point to the node that does not have\n   * the same parent\n   * @param nodeId remove transitions to this node\n   */\n  removeTransitionsThatPointToNodeIdFromOutsideGroup(nodeId) {\n    if (nodeId != null) {\n      const parentGroupId = this.getParentGroupId(nodeId);\n      const nodesThatPointToTargetNode = this.getNodesByToNodeId(nodeId);\n\n      if (nodesThatPointToTargetNode != null) {\n        for (let nodeThatPointsToTargetNode of nodesThatPointToTargetNode) {\n          if (nodeThatPointsToTargetNode != null) {\n            const nodeThatPointsToTargetNodeParentGroupId =\n                this.getParentGroupId(nodeThatPointsToTargetNode.id);\n\n            if (parentGroupId != nodeThatPointsToTargetNodeParentGroupId) {\n              /*\n               * the parent groups are different so we will remove\n               * the transition\n               */\n              this.removeTransition(nodeThatPointsToTargetNode, nodeId);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove a transition\n   * @param node remove a transition in this node\n   * @param toNodeId remove the transition that goes to this node id\n   */\n  removeTransition(node, toNodeId) {\n    if (node != null && toNodeId != null) {\n      const transitionLogic = node.transitionLogic;\n      if (transitionLogic != null) {\n        const transitions = transitionLogic.transitions;\n        if (transitions != null) {\n          for (let t = 0; t < transitions.length; t++) {\n            const transition = transitions[t];\n            if (transition != null) {\n              if (toNodeId === transition.to) {\n                // we have found a transition that goes to the toNodeId\n\n                // remove the transition\n                transitions.splice(t, 1);\n                t--;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove transitions that go out of the group\n   * @param nodeId the group id\n   */\n  removeTransitionsOutOfGroup(nodeId) {\n    if (nodeId != null) {\n      const group = this.getNodeById(nodeId);\n      if (group != null) {\n        const childIds = group.ids;\n        if (childIds != null) {\n          for (let childId of childIds) {\n            if (childId != null) {\n              const transitions = this.getTransitionsByFromNodeId(childId);\n              if (transitions != null) {\n                for (let t = 0; t < transitions.length; t++) {\n                  const transition = transitions[t];\n                  if (transition != null) {\n                    const toNodeId = transition.to;\n                    if (toNodeId != null) {\n                      const toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n                      if (nodeId != toNodeIdParentGroupId) {\n                        /*\n                         * the parent group is different which means it is a\n                         * transition that goes out of the group\n                         */\n\n                        // remove the transition\n                        transitions.splice(t, 1);\n                        t--;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /*\n   * Update the step transitions that point into the group we are moving\n   * For example\n   * group1 has children node1 and node2 (node2 transitions to node3)\n   * group2 has children node3 and node4 (node4 transitions to node5)\n   * group3 has children node5 and node6\n   * if we move group2 after group3 we will need to change the\n   * transition from node2 to node3 and make node2 transition to node5\n   * the result will be\n   * group1 has children node1 and node2 (node2 transitions to node5)\n   * group3 has children node5 and node6\n   * group2 has children node3 and node4 (node4 transitions to node5)\n   * note: the (node4 transition to node5) will be removed later\n   * when is called removeTransitionsOutOfGroup\n   * note: when group2 is added in a later function call, we will add\n   * the node6 to node3 transition\n   * @param groupThatTransitionsToGroupWeAreMoving the group object\n   * that transitions to the group we are moving. we may need to update\n   * the transitions of this group's children.\n   * @param groupIdWeAreMoving the group id of the group we are moving\n   */\n  updateChildrenTransitionsIntoGroupWeAreMoving(\n      groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving) {\n    if (groupThatTransitionsToGroupWeAreMoving != null &&\n        groupIdWeAreMoving != null) {\n      const group = this.getNodeById(groupIdWeAreMoving);\n      if (group != null) {\n        // get all the nodes that have a transition to the node we are removing\n        const nodesByToNodeId = this.getNodesByToNodeId(groupIdWeAreMoving);\n\n        // get the transitions of the node we are removing\n        const nodeToRemoveTransitionLogic = group.transitionLogic;\n        let nodeToRemoveTransitions = [];\n\n        if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n          nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n        }\n\n        if (nodeToRemoveTransitions.length == 0) {\n          /*\n           * The group we are moving is the last group in the project\n           * and does not have any transitions. We will loop through\n           * all the nodes that transition into this group and remove\n           * those transitions.\n           */\n\n          // get child ids of the group that comes before the group we are moving\n          const childIds = groupThatTransitionsToGroupWeAreMoving.ids;\n\n          if (childIds != null) {\n            for (let childId of childIds) {\n              const transitionsFromChild = this.getTransitionsByFromNodeId(childId);\n              if (transitionsFromChild != null) {\n                for (let tfc = 0; tfc < transitionsFromChild.length; tfc++) {\n                  const transitionFromChild = transitionsFromChild[tfc];\n                  if (transitionFromChild != null) {\n                    const toNodeId = transitionFromChild.to;\n\n                    // get the parent group id of the toNodeId\n                    const toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n\n                    if (groupIdWeAreMoving === toNodeIdParentGroupId) {\n                      // the transition is to a child in the group we are moving\n\n                      // remove the transition\n                      transitionsFromChild.splice(tfc, 1);\n\n                      /*\n                       * move the counter back one because we have just removed an\n                       * element from the array\n                       */\n                      tfc--;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else if (nodeToRemoveTransitions.length > 0) {\n          // get the first group that comes after the group we are removing\n          const firstNodeToRemoveTransition = nodeToRemoveTransitions[0];\n          const firstNodeToRemoveTransitionToNodeId = firstNodeToRemoveTransition.to;\n\n          if (this.isGroupNode(firstNodeToRemoveTransitionToNodeId)) {\n            // get the group that comes after the group we are moving\n            const groupNode = this.getNodeById(firstNodeToRemoveTransitionToNodeId);\n\n            // get child ids of the group that comes before the group we are moving\n            const childIds = groupThatTransitionsToGroupWeAreMoving.ids;\n\n            if (childIds != null) {\n              for (let childId of childIds) {\n                const transitionsFromChild = this.getTransitionsByFromNodeId(childId);\n                if (transitionsFromChild != null) {\n                  for (let transitionFromChild of transitionsFromChild) {\n                    if (transitionFromChild != null) {\n                      const toNodeId = transitionFromChild.to;\n\n                      // get the parent group id of the toNodeId\n                      const toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n\n                      if (groupIdWeAreMoving === toNodeIdParentGroupId) {\n                        // the transition is to a child in the group we are moving\n\n                        if (groupNode.startId == null) {\n                          // change the transition to point to the after group\n                          transitionFromChild.to = firstNodeToRemoveTransitionToNodeId;\n                        } else {\n                          // change the transition to point to the start id of the after group\n                          transitionFromChild.to = groupNode.startId;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the node ids and component ids in a node\n   * @param nodeId get the node ids and component ids in this node\n   * @returns an array of objects. the objects contain a node id\n   * and component id.\n   */\n  getNodeIdsAndComponentIds(nodeId) {\n    const nodeIdAndComponentIds = [];\n    if (nodeId != null) {\n      const nodeContent = this.getNodeContentByNodeId(nodeId);\n      if (nodeContent != null) {\n        const components = nodeContent.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null) {\n              const componentId = component.id;\n              const nodeIdAndComponentId = {};\n              nodeIdAndComponentId.nodeId = nodeId;\n              nodeIdAndComponentId.componentId = componentId;\n              nodeIdAndComponentIds.push(nodeIdAndComponentId);\n            }\n          }\n        }\n      }\n    }\n    return nodeIdAndComponentIds;\n  }\n\n  /**\n   * Get the show previous work node ids and component ids in a node\n   * @param nodeId get the show previous work node ids and component ids in\n   * this node\n   * @returns an array of objects. the objects contain a node id\n   * and component id.\n   */\n  getShowPreviousWorkNodeIdsAndComponentIds(nodeId) {\n    const nodeIdAndComponentIds = [];\n    if (nodeId != null) {\n      const nodeContent = this.getNodeContentByNodeId(nodeId);\n      if (nodeContent != null) {\n        const components = nodeContent.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null) {\n              const showPreviousWorkNodeId = component.showPreviousWorkNodeId;\n              const showPreviousWorkComponentId =\n                  component.showPreviousWorkComponentId;\n              if (showPreviousWorkNodeId != null &&\n                  showPreviousWorkComponentId != null) {\n                const nodeIdAndComponentId = {};\n                nodeIdAndComponentId.nodeId = showPreviousWorkNodeId;\n                nodeIdAndComponentId.componentId = showPreviousWorkComponentId;\n                nodeIdAndComponentIds.push(nodeIdAndComponentId);\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodeIdAndComponentIds;\n  }\n\n  /**\n   * Check if we need to display the annotation to the student\n   * @param annotation the annotation\n   * @returns whether we need to display the annotation to the student\n   */\n  displayAnnotation(annotation) {\n    let result = true;\n    if (annotation != null) {\n      const nodeId = annotation.nodeId;\n      const componentId = annotation.componentId;\n      const component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n      if (component != null) {\n        const componentType = component.type;\n\n        // get the component service\n        const componentService = this.$injector.get(componentType + 'Service');\n\n        if (componentService != null && componentService.displayAnnotation != null) {\n          result = componentService.displayAnnotation(component, annotation);\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get the global annotation properties for the specified component and score, if exists.\n   * @param component the component content\n   * @param previousScore the previousScore we want the annotation properties for, can be null, which means we just want to look at\n   * the currentScore\n   * @param currentScore the currentScore we want the annotation properties for\n   * @returns the annotation properties for the given score\n   */\n  getGlobalAnnotationGroupByScore(component, previousScore, currentScore) {\n    let annotationGroup = null;\n    if (component.globalAnnotationSettings != null &&\n        component.globalAnnotationSettings.globalAnnotationGroups != null) {\n      let globalAnnotationGroups = component.globalAnnotationSettings.globalAnnotationGroups;\n      for (let globalAnnotationGroup of globalAnnotationGroups) {\n        if (globalAnnotationGroup.enableCriteria != null &&\n            globalAnnotationGroup.enableCriteria.scoreSequence != null) {\n          let scoreSequence = globalAnnotationGroup.enableCriteria.scoreSequence;\n          if (scoreSequence != null) {\n            /*\n             * get the expected previous score and current score\n             * that will satisfy the rule\n             */\n            let previousScoreMatch = scoreSequence[0];\n            let currentScoreMatch = scoreSequence[1];\n\n            if (previousScore == null) {\n              // just matching on the current score\n              if (previousScoreMatch == \"\" &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                // found a match\n                annotationGroup = globalAnnotationGroup;\n                break;\n              }\n            } else {\n              if (previousScore.toString().match(\"[\" + previousScoreMatch + \"]\") &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                /*\n                 * the previous score and current score match the\n                 * expected scores so we have found the rule we want\n                 */\n                annotationGroup = globalAnnotationGroup;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    return annotationGroup;\n  }\n\n  /**\n   * Get the notification for the given score, if exists.\n   * @param component the component content\n   * @param previousScore the previousScore we want notification for, can be null, which means we just want to look at\n   * the currentScore\n   * @param currentScore the currentScore we want notification for\n   * @returns the notification for the given score\n   */\n  getNotificationByScore(component, previousScore, currentScore) {\n    let notificationResult = null;\n    if (component.notificationSettings != null &&\n        component.notificationSettings.notifications != null) {\n      let notifications = component.notificationSettings.notifications;\n      for (let notification of notifications) {\n        if (notification.enableCriteria != null &&\n            notification.enableCriteria.scoreSequence != null) {\n          let scoreSequence = notification.enableCriteria.scoreSequence;\n          if (scoreSequence != null) {\n            /*\n             * get the expected previous score and current score\n             * that will satisfy the rule\n             */\n            let previousScoreMatch = scoreSequence[0];\n            let currentScoreMatch = scoreSequence[1];\n\n            if (previousScore == null) {\n              // just matching on the current score\n              if (previousScoreMatch == \"\" &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                notificationResult = notification;\n                break;\n              }\n            } else {\n              if (previousScore.toString().match(\"[\" + previousScoreMatch + \"]\") &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                /*\n                 * the previous score and current score match the\n                 * expected scores so we have found the rule we want\n                 */\n                notificationResult = notification;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    return notificationResult;\n  }\n\n  /**\n   * Returns a project template for new projects\n   */\n  getNewProjectTemplate() {\n    return {\n      \"nodes\": [\n        {\n          \"id\": \"group0\",\n          \"type\": \"group\",\n          \"title\": \"Master\",\n          \"startId\": \"group1\",\n          \"ids\": [\n            \"group1\"\n          ]\n        },\n        {\n          \"id\": \"group1\",\n          \"type\": \"group\",\n          \"title\": this.$translate('FIRST_ACTIVITY'),\n          \"startId\": \"\",\n          \"ids\": [\n          ],\n          \"icons\": {\n            \"default\": {\n              \"color\": \"#2196F3\",\n              \"type\": \"font\",\n              \"fontSet\": \"material-icons\",\n              \"fontName\": \"info\"\n            }\n          }\n        }\n      ],\n      \"constraints\": [],\n      \"startGroupId\": \"group0\",\n      \"startNodeId\": \"group0\",\n      \"navigationMode\": \"guided\",\n      \"layout\": {\n        \"template\": \"starmap|leftNav|rightNav\"\n      },\n      \"metadata\": {\n        \"title\": \"\"\n      },\n      \"notebook\": {\n        \"enabled\": false,\n        \"label\": this.$translate('NOTEBOOK'),\n        \"enableAddNew\": true,\n        \"itemTypes\": {\n          \"note\": {\n            \"type\": \"note\",\n            \"enabled\": true,\n            \"enableLink\": true,\n            \"enableAddNote\": true,\n            \"enableClipping\": true,\n            \"enableStudentUploads\": true,\n            \"requireTextOnEveryNote\": false,\n            \"label\": {\n              \"singular\": this.$translate('NOTE_LOWERCASE'),\n              \"plural\": this.$translate('NOTES_LOWERCASE'),\n              \"link\": this.$translate('NOTES'),\n              \"icon\": \"note\",\n              \"color\": \"#1565C0\"\n            }\n          },\n          \"question\": {\n            \"type\": \"question\",\n            \"enabled\": false,\n            \"enableLink\": true,\n            \"enableClipping\": true,\n            \"enableStudentUploads\": true,\n            \"label\": {\n              \"singular\": this.$translate('QUESTION_LOWER_CASE'),\n              \"plural\": this.$translate('QUESTIONS_LOWER_CASE'),\n              \"link\": this.$translate('QUESTIONS'),\n              \"icon\": \"live_help\",\n              \"color\": \"#F57C00\"\n            }\n          },\n          \"report\": {\n            \"enabled\": false,\n            \"label\": {\n              \"singular\": this.$translate('REPORT_LOWERCASE'),\n              \"plural\": this.$translate('REPORTS_LOWERCASE'),\n              \"link\": this.$translate('REPORT'),\n              \"icon\": \"assignment\",\n              \"color\": \"#AD1457\"\n            },\n            \"notes\": [\n              {\n                \"reportId\": \"finalReport\",\n                \"title\": this.$translate('FINAL_REPORT'),\n                \"description\": this.$translate('REPORT_DESCRIPTION'),\n                \"prompt\": this.$translate('REPORT_PROMPT'),\n                \"content\": this.$translate('REPORT_CONTENT')\n              }\n            ]\n          }\n        }\n      },\n      \"inactiveNodes\": []\n    };\n  }\n\n  /**\n   * Check if a node generates work by looking at all of its components\n   * @param nodeId the node id\n   * @return whether the node generates work\n   */\n  nodeHasWork(nodeId) {\n    if (nodeId != null) {\n      const nodeContent = this.getNodeContentByNodeId(nodeId);\n      if (nodeContent != null) {\n        const components = nodeContent.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null) {\n              const componentHasWork = this.componentHasWork(component);\n              if (componentHasWork) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a component generates work\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @return whether the component generates work\n   */\n  componentHasWorkByNodeIdAndComponentId(nodeId, componentId) {\n    if (nodeId != null) {\n      const nodeContent = this.getNodeContentByNodeId(nodeId);\n      if (nodeContent != null) {\n        const components = nodeContent.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null && componentId == component.id) {\n              const componentHasWork = this.componentHasWork(component);\n              if (componentHasWork) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a component generates work\n   * @param component check if this component generates work\n   * @return whether the component generates work\n   */\n  componentHasWork(component) {\n    if (component != null) {\n      const componentType = component.type;\n      const componentService = this.getComponentService(componentType);\n      if (componentService != null) {\n        return componentService.componentHasWork(component);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get a component service\n   * @param componentType the component type\n   * @return the component service\n   */\n  getComponentService(componentType) {\n    let componentService = null;\n    if (componentType != null) {\n      const componentServiceName = componentType + 'Service';\n\n      /*\n       * check if we have previously retrieved the component service.\n       * if have previously retrieved the component service it will\n       * be in the componentServices map\n       */\n      componentService = this.componentServices[componentServiceName];\n\n      if (componentService == null) {\n        /*\n         * we have not previously retrieved the component service so\n         * we will get it now\n         */\n        componentService = this.$injector.get(componentServiceName);\n\n        /*\n         * save the component service to the map so we can easily\n         * retrieve it later\n         */\n        this.componentServices[componentServiceName] = componentService;\n      }\n    }\n    return componentService;\n  }\n\n  /**\n   * Check if a node is inactive. At the moment only step nodes can be\n   * inactive.\n   * @param nodeId the node id of the step\n   */\n  isInactive(nodeId) {\n    if (nodeId != null && this.project.inactiveNodes != null) {\n      for (let inactiveNode of this.project.inactiveNodes) {\n        if (inactiveNode != null) {\n          if (nodeId === inactiveNode.id) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get an unused component id\n   * @param componentIdsToSkip (optional) An array of additional component ids\n   * to skip. This is used when we are creating multiple new components. There\n   * is avery small chance that we create duplicate component ids that aren't\n   * already in the project. We avoid this problem by using this parameter.\n   * Example\n   * We want to create two new components. We first generate a new component\n   * id for the first new component for example \"1234567890\". Then we generate\n   * a new component id for the second new component and pass in\n   * [\"1234567890\"] as componentIdsToSkip because the new \"1234567890\"\n   * component hasn't actually been added to the project yet.\n   * @return a component id that isn't already being used in the project\n   */\n  getUnusedComponentId(componentIdsToSkip) {\n    // we want to make an id with 10 characters\n    const idLength = 10;\n\n    let newComponentId = this.UtilService.generateKey(idLength);\n\n    // check if the component id is already used in the project\n    if (this.isComponentIdUsed(newComponentId)) {\n      /*\n       * the component id is already used in the project so we need to\n       * try generating another one\n       */\n      let alreadyUsed = true;\n\n      /*\n       * keep trying to generate a new component id until we have found\n       * one that isn't already being used\n       */\n      while(!alreadyUsed) {\n        // generate a new id\n        newComponentId = this.UtilService.generateKey(idLength);\n\n        // check if the id is already being used in the project\n        alreadyUsed = this.isComponentIdUsed(newComponentId);\n\n        if (componentIdsToSkip != null && componentIdsToSkip.indexOf(newComponentId) != -1) {\n          /*\n           * the new component is in the componentIdsToSkip so it has\n           * already been used\n           */\n          alreadyUsed = true;\n        }\n      }\n    }\n    return newComponentId;\n  }\n\n  /**\n   * Check if the component id is already being used in the project\n   * @param componentId check if this component id is already being used in\n   * the project\n   * @return whether the component id is already being used in the project\n   */\n  isComponentIdUsed(componentId) {\n    for (let node of this.project.nodes) {\n      if (node != null) {\n        const components = node.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null) {\n              if (componentId === component.id) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for (let node of this.project.inactiveNodes) {\n      if (node != null) {\n        const components = node.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null) {\n              if (componentId === component.id) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a node id is already being used in the project\n   * @param nodeId check if this node id is already being used in the project\n   * @return whether the node id is already being used in the project\n   */\n  isNodeIdUsed(nodeId) {\n    for (let node of this.project.nodes) {\n      if (node != null) {\n        if (nodeId === node.id) {\n          return true;\n        }\n      }\n    }\n\n    for (let node of this.project.inactiveNodes) {\n      if (node != null) {\n        if (nodeId === node.id) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Copy the nodes into the project\n   * @param selectedNodes the nodes to import\n   * @param fromProjectId copy the nodes from this project\n   * @param toProjectId copy the nodes into this project\n   * @param nodeIdToInsertInsideOrAfter If this is a group, we will make the\n   * new step the first step in the group. If this is a step, we will place\n   * the new step after it.\n   */\n  copyNodes(selectedNodes, fromProjectId, toProjectId, nodeIdToInsertInsideOrAfter) {\n    const importStepsURL = this.ConfigService.getConfigParam('importStepsURL');\n\n    const httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = importStepsURL;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    const params = {};\n    params.steps = angular.toJson(selectedNodes);\n    params.fromProjectId = fromProjectId;\n    params.toProjectId = toProjectId;\n    httpParams.data = $.param(params);\n\n    /*\n     * Make the request to import the steps. This will copy the asset files\n     * and change file names if necessary. If an asset file with the same\n     * name exists in both projects we will check if their content is the\n     * same. If the content is the same we don't need to copy the file. If\n     * the content is different, we need to make a copy of the file with a\n     * new name and change all the references in the steps to use the new\n     * name.\n     */\n    return this.$http(httpParams).then((result) => {\n      selectedNodes = result.data;\n\n      const inactiveNodes = this.getInactiveNodes();\n      const newNodes = [];\n      const newNodeIds = [];\n\n      for (let selectedNode of selectedNodes) {\n        if (selectedNode != null) {\n          // make a copy of the node so that we don't modify the source\n          const tempNode = this.UtilService.makeCopyOfJSONObject(selectedNode);\n\n          // check if the node id is already being used in the current project\n          if (this.isNodeIdUsed(tempNode.id)) {\n            // the node id is already being used in the current project\n\n            // get the next available node id\n            const nextAvailableNodeId = this.getNextAvailableNodeId(newNodeIds);\n\n            // change the node id of the node we are importing\n            tempNode.id = nextAvailableNodeId;\n          }\n\n          // get the components in the node\n          const tempComponents = tempNode.components;\n\n          if (tempComponents != null) {\n            for (let tempComponent of tempComponents) {\n              if (tempComponent != null) {\n                if (this.isComponentIdUsed(tempComponent.id)) {\n                  // we are already using the component id so we will need to change it\n\n                  const newComponentId = this.getUnusedComponentId();\n                  tempComponent.id = newComponentId;\n                }\n              }\n            }\n          }\n\n          // clear the constraints\n          tempNode.constraints = [];\n\n          // add the new node and new node id to our arrays\n          newNodes.push(tempNode);\n          newNodeIds.push(tempNode.id);\n        }\n      }\n\n      if (nodeIdToInsertInsideOrAfter == null) {\n        /*\n         * the place to put the new node has not been specified so we\n         * will place it in the inactive steps section\n         */\n\n        /*\n         * Insert the node after the last inactive node. If there\n         * are no inactive nodes it will just be placed in the\n         * inactive nodes section. In the latter case we do this by\n         * setting nodeIdToInsertInsideOrAfter to 'inactiveSteps'.\n         */\n        if (inactiveNodes != null && inactiveNodes.length > 0) {\n          nodeIdToInsertInsideOrAfter = inactiveNodes[inactiveNodes.length - 1];\n        } else {\n          nodeIdToInsertInsideOrAfter = 'inactiveSteps';\n        }\n      }\n\n      for (let newNode of newNodes) {\n        if (this.isGroupNode(nodeIdToInsertInsideOrAfter)) {\n          // we want to make the new step the first step in the given activity\n          this.createNodeInside(newNode, nodeIdToInsertInsideOrAfter);\n        } else {\n          // we want to place the new step after the given step\n          this.createNodeAfter(newNode, nodeIdToInsertInsideOrAfter);\n        }\n\n        /*\n         * Update the nodeIdToInsertInsideOrAfter so that when we are\n         * importing multiple steps, the steps get placed in the correct\n         * order.\n         *\n         * Example\n         * We are importing nodeA and nodeB and want to place them after\n         * nodeX. Therefore we want the order to be\n         *\n         * nodeX\n         * nodeA\n         * nodeB\n         *\n         * This means after we add nodeA, we must update\n         * nodeIdToInsertInsideOrAfter to be nodeA so that when we add\n         * nodeB, it will be placed after nodeA.\n         */\n        nodeIdToInsertInsideOrAfter = newNode.id;\n      }\n      return newNodes;\n    });\n  }\n\n  /**\n   * Get the next available constraint id for a node\n   * @param nodeId get the next available constraint id for this node\n   * e.g. node8Constraint2\n   * @return the next available constraint id for the node\n   */\n  getNextAvailableConstraintIdForNodeId(nodeId) {\n    let nextAvailableConstraintId = null;\n    if (nodeId != null) {\n      // an array to hold the constraint ids that are already being used\n      const usedConstraintIds = [];\n      const node = this.getNodeById(nodeId);\n\n      if (node != null) {\n        const constraints = node.constraints;\n        if (constraints != null) {\n          for (let constraint of constraints) {\n            if (constraint != null) {\n              const constraintId = constraint.id;\n\n              // add the constraint id to the array of used constraint ids\n              usedConstraintIds.push(constraintId);\n            }\n          }\n        }\n      }\n\n      let foundNextAvailableConstraintId = false;\n      let counter = 1;\n\n      while (!foundNextAvailableConstraintId) {\n        const potentialConstraintId = nodeId + 'Constraint' + counter;\n        // check if the constraint id has been used\n        if (usedConstraintIds.indexOf(potentialConstraintId) == -1) {\n          nextAvailableConstraintId = potentialConstraintId;\n          foundNextAvailableConstraintId = true;\n        } else {\n          counter++;\n        }\n      }\n    }\n    return nextAvailableConstraintId;\n  }\n\n  /**\n   * Set a field in the transition logic of a node\n   */\n  setTransitionLogicField(nodeId, field, value) {\n    if (nodeId != null && field != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        const transitionLogic = node.transitionLogic;\n        if (transitionLogic != null) {\n          transitionLogic[field] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Set the criteria params field\n   * @param criteria the criteria object\n   * @param field the field name\n   * @param value the value to set into the field\n   */\n  setCriteriaParamsField(criteria, field, value) {\n    if (criteria != null) {\n      if (criteria.params == null) {\n        criteria.params = {};\n      }\n      criteria.params[field] = value;\n    }\n  }\n\n  /**\n   * Get the criteria params field\n   * @param criteria the criteria object\n   * @param field the field name\n   */\n  getCriteriaParamsField(criteria, field) {\n    if (criteria != null) {\n      const params = criteria.params;\n      if (params != null) {\n        return params[field];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Set the transition to value of a node\n   * @param fromNodeId the from node\n   * @param toNodeId the to node\n   */\n  setTransition(fromNodeId, toNodeId) {\n    const node = this.getNodeById(fromNodeId);\n    if (node != null) {\n      const transitionLogic = node.transitionLogic;\n      if (transitionLogic != null) {\n        let transitions = transitionLogic.transitions;\n        if (transitions == null || transitions.length == 0) {\n          transitionLogic.transitions = [];\n          const transition = {};\n          transitionLogic.transitions.push(transition);\n          transitions = transitionLogic.transitions;\n        }\n\n        if (transitions != null && transitions.length > 0) {\n          // get the first transition. we will assume there is only one transition.\n          const transition = transitions[0];\n          if (transition != null) {\n            transition.to = toNodeId;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the node id that comes after a given node id\n   * @param nodeId get the node id that comes after this node id\n   * @param the node id that comes after the one that is passed in as a parameter\n   */\n  getNodeIdAfter(nodeId) {\n    let nodeIdAfter = null;\n\n    // get an array of ordered items. each item represents a node\n    const orderedItems = this.$filter('orderBy')(this.$filter('toArray')(this.idToOrder), 'order');\n\n    if (orderedItems != null) {\n      let foundNodeId = false;\n      for (let item of orderedItems) {\n        if (item != null) {\n          const tempNodeId = item.$key;\n\n          // check if we have found the node id that was passed in as a parameter\n          if (foundNodeId) {\n            /*\n             * we have previously found the node id that was passed in which means\n             * the current temp node id is the one that comes after it\n             */\n            nodeIdAfter = tempNodeId;\n            break;\n          } else {\n            if (nodeId == tempNodeId) {\n              // we have found the node id that was passed in as a parameter\n              foundNodeId = true;\n            }\n          }\n        }\n      }\n    }\n    return nodeIdAfter;\n  }\n\n  /**\n   * Get the node ids in the branch by looking for nodes that have branch\n   * path taken constraints with the given fromNodeId and toNodeId\n   * @param fromNodeId the from node id\n   * @param toNodeId the to node id\n   * @return an array of nodes that are in the branch path\n   */\n  getNodeIdsInBranch(fromNodeId, toNodeId) {\n    const nodeIdsInBranch = [];\n    const nodes = this.getNodes();\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null) {\n          if (this.hasBranchPathTakenConstraint(node, fromNodeId, toNodeId)) {\n            /*\n             * this node has the the branch path taken constraint we are\n             * looking for\n             */\n            nodeIdsInBranch.push(node.id);\n          }\n        }\n      }\n    }\n    this.orderNodeIds(nodeIdsInBranch);\n    return nodeIdsInBranch;\n  }\n\n  /**\n   * Order the node ids so that they show up in the same order as in the\n   * project.\n   * @param constraints An array of node ids.\n   * @return An array of ordered node ids.\n   */\n  orderNodeIds(nodeIds) {\n    let orderedNodeIds = this.getFlattenedProjectAsNodeIds();\n    return nodeIds.sort(this.nodeIdsComparatorGenerator(orderedNodeIds));\n  }\n\n  /**\n   * Create the node ids comparator function that is used for sorting an\n   * array of node ids.\n   * @param orderedNodeIds An array of node ids in the order in which they\n   * show up in the project.\n   * @return A comparator that orders node ids in the order in which they show\n   * up in the project.\n   */\n  nodeIdsComparatorGenerator(orderedNodeIds) {\n    return function(nodeIdA, nodeIdB) {\n      let nodeIdAIndex = orderedNodeIds.indexOf(nodeIdA);\n      let nodeIdBIndex = orderedNodeIds.indexOf(nodeIdB);\n      if (nodeIdAIndex < nodeIdBIndex) {\n        return -1;\n      } else if (nodeIdAIndex > nodeIdBIndex) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Check if a node has a branch path taken constraint\n   * @param node the node to check\n   * @param fromNodeId the from node id of the branch path taken\n   * @param toNodeId the to node id of the branch path taken\n   * @return whether the node has a branch path taken constraint with the\n   * given from node id and to node id\n   */\n  hasBranchPathTakenConstraint(node, fromNodeId, toNodeId) {\n    if (node != null) {\n      const constraints = node.constraints;\n      if (constraints != null) {\n        for (let constraint of constraints) {\n          if (constraint != null) {\n            const removalCriteria = constraint.removalCriteria;\n            if (removalCriteria != null) {\n              for (let removalCriterion of removalCriteria) {\n                if (removalCriterion != null) {\n                  const name = removalCriterion.name;\n                  if (name == 'branchPathTaken') {\n                    const params = removalCriterion.params;\n                    if (params != null) {\n                      if (fromNodeId == params.fromNodeId && toNodeId == params.toNodeId) {\n                        return true;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Add branch path taken constraints to the node\n   * @param targetNodeId the node to add the constraints to\n   * @param fromNodeId the from node id of the branch path taken constraint\n   * @param toNodeId the to node id of the branch path taken constraint\n   */\n  addBranchPathTakenConstraints(targetNodeId, fromNodeId, toNodeId) {\n    if (targetNodeId != null) {\n      const node = this.getNodeById(targetNodeId);\n\n      if (node != null) {\n        /*\n         * create the constraint that makes the node not visible until\n         * the given branch path is taken\n         */\n        const makeThisNodeNotVisibleConstraint = {};\n        makeThisNodeNotVisibleConstraint.id = this.getNextAvailableConstraintIdForNodeId(targetNodeId);\n        makeThisNodeNotVisibleConstraint.action = 'makeThisNodeNotVisible';\n        makeThisNodeNotVisibleConstraint.targetId = targetNodeId;\n        makeThisNodeNotVisibleConstraint.removalCriteria = [];\n        const notVisibleRemovalCriterion = {};\n        notVisibleRemovalCriterion.name = 'branchPathTaken';\n        notVisibleRemovalCriterion.params = {};\n        notVisibleRemovalCriterion.params.fromNodeId = fromNodeId;\n        notVisibleRemovalCriterion.params.toNodeId = toNodeId;\n        makeThisNodeNotVisibleConstraint.removalConditional = 'all';\n        makeThisNodeNotVisibleConstraint.removalCriteria.push(notVisibleRemovalCriterion);\n        node.constraints.push(makeThisNodeNotVisibleConstraint);\n\n        /*\n         * create the constraint that makes the node not visitable until\n         * the given branch path is taken\n         */\n        const makeThisNodeNotVisitableConstraint = {};\n        makeThisNodeNotVisitableConstraint.id = this.getNextAvailableConstraintIdForNodeId(targetNodeId);\n        makeThisNodeNotVisitableConstraint.action = 'makeThisNodeNotVisitable';\n        makeThisNodeNotVisitableConstraint.targetId = targetNodeId;\n        makeThisNodeNotVisitableConstraint.removalCriteria = [];\n        const notVisitableRemovalCriterion = {};\n        notVisitableRemovalCriterion.name = 'branchPathTaken';\n        notVisitableRemovalCriterion.params = {};\n        notVisitableRemovalCriterion.params.fromNodeId = fromNodeId;\n        notVisitableRemovalCriterion.params.toNodeId = toNodeId;\n        makeThisNodeNotVisitableConstraint.removalConditional = 'all';\n        makeThisNodeNotVisitableConstraint.removalCriteria.push(notVisitableRemovalCriterion);\n        node.constraints.push(makeThisNodeNotVisitableConstraint);\n      }\n    }\n  }\n\n  /**\n   * Remove the branch path taken constraints from a node\n   * @param nodeId remove the constraints from this node\n   */\n  removeBranchPathTakenNodeConstraints(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      const constraints = node.constraints;\n      if (constraints != null) {\n        for (let c = 0; c < constraints.length; c++) {\n          const constraint = constraints[c];\n          if (constraint != null) {\n            const removalCriteria = constraint.removalCriteria;\n\n            if (removalCriteria != null) {\n              for (let removalCriterion of removalCriteria) {\n                if (removalCriterion != null) {\n                  if (removalCriterion.name == 'branchPathTaken') {\n                    const params = removalCriterion.params;\n                    constraints.splice(c, 1);\n                    // move the counter back one because we just removed a constraint\n                    c--;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the branch path taken constraints from a node\n   * @param nodeId get the branch path taken constraints from this node\n   * @return an array of branch path taken constraints from the node\n   */\n  getBranchPathTakenConstraintsByNodeId(nodeId) {\n    const branchPathTakenConstraints = [];\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        const constraints = node.constraints;\n        if (constraints != null) {\n          for (let constraint of constraints) {\n            if (constraint != null) {\n              const removalCriteria = constraint.removalCriteria;\n              if (removalCriteria != null) {\n                for (let removalCriterion of removalCriteria) {\n                  if (removalCriterion != null) {\n                    if (removalCriterion.name == 'branchPathTaken') {\n                      /*\n                       * we have found a branch path taken constraint so\n                       * we will add the constraint to the array\n                       */\n                      branchPathTakenConstraints.push(constraint);\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return branchPathTakenConstraints;\n  }\n\n  /**\n   * Update the branch path taken constraint\n   * @param node update the branch path taken constraints in this node\n   * @param currentFromNodeId the current from node id\n   * @param currentToNodeId the current to node id\n   * @param newFromNodeId the new from node id\n   * @param newToNodeId the new to node id\n   */\n  updateBranchPathTakenConstraint(node, currentFromNodeId, currentToNodeId,\n      newFromNodeId, newToNodeId) {\n    if (node != null) {\n      const constraints = node.constraints;\n      if (constraints != null) {\n        for (let constraint of constraints) {\n          if (constraint != null) {\n            const removalCriteria = constraint.removalCriteria;\n            if (removalCriteria != null) {\n              for (let removalCriterion of removalCriteria) {\n                if (removalCriterion != null) {\n                  if (removalCriterion.name === 'branchPathTaken') {\n                    const params = removalCriterion.params;\n                    if (params != null) {\n                      if (params.fromNodeId === currentFromNodeId &&\n                        params.toNodeId === currentToNodeId) {\n                        /*\n                         * we have found a branchPathTaken removal criterion\n                         * with the fromNodeId and toNodeId that we are\n                         * looking for so we will now update the values\n                         */\n                        params.fromNodeId = newFromNodeId;\n                        params.toNodeId = newToNodeId;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the project level rubric\n   * @return the project level rubric\n   */\n  getProjectRubric() {\n    return this.project.rubric;\n  }\n\n  /**\n   * Set the project level rubric\n   */\n  setProjectRubric(html) {\n    this.project.rubric = html;\n  }\n\n  /**\n   * Check if a node is a branch point\n   * @param nodeId the node id\n   * @return whether the node is a branch point\n   */\n  isBranchPoint(nodeId) {\n    const transitions = this.getTransitionsByFromNodeId(nodeId);\n    if (transitions != null) {\n      if (transitions.length > 1) {\n        /*\n         * the node contains more than one transition which means it is\n         * a branch point\n         */\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a node is the first node in a branch path\n   * @param nodeId the node id\n   * @return whether the node is the first node in a branch path\n   */\n  isFirstNodeInBranchPath(nodeId) {\n    const nodes = this.getNodes();\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null &&\n            node.transitionLogic != null &&\n            node.transitionLogic.transitions != null) {\n          const transitions = node.transitionLogic.transitions;\n\n          if (transitions.length > 1) {\n            /*\n             * there is more than one transition from this node\n             * which means it is a branch point\n             */\n            for (let transition of transitions) {\n              if (transition != null) {\n                const transitionTo = transition.to;\n                if (transitionTo === nodeId) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the node is in any branch path\n   * @param nodeId the node id of the node\n   * @return whether the node is in any branch path\n   */\n  isNodeInAnyBranchPath(nodeId) {\n    let result = false;\n    if (this.nodeIdToIsInBranchPath[nodeId] == null) {\n      /*\n       * we have not calculated whether the node id is in a branch path\n       * before so we will now\n       */\n\n      const branches = this.getBranches();\n      result = this.isNodeIdInABranch(branches, nodeId);\n\n      // remember the result for this node id\n      this.nodeIdToIsInBranchPath[nodeId] = result;\n    } else {\n      /*\n       * we have calculated whether the node id is in a branch path\n       * before\n       */\n      result = this.nodeIdToIsInBranchPath[nodeId];\n    }\n    return result;\n  }\n\n  /**\n   * Check if a node is a branch start point\n   * @param nodeId look for a branch with this start node id\n   * @return whether the node is a branch start point\n   */\n  isBranchStartPoint(nodeId) {\n    /*\n     * Get all the branches. Each branch is represented as an object that\n     * contains the branchStartPoint, branchEndPoint, and branchPaths.\n     */\n    const branches = this.getBranches();\n\n    if (branches != null) {\n      for (let branch of branches) {\n        if (branch != null) {\n          if (branch.branchStartPoint == nodeId) {\n            /*\n             * we have found a branch with the given nodeId as the\n             * start point\n             */\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a node is a branch end point\n   * @param nodeId look for a branch with this end node id\n   * @return whether the node is a branch end point\n   */\n  isBranchMergePoint(nodeId) {\n    /*\n     * Get all the branches. Each branch is represented as an object that\n     * contains the branchStartPoint, branchEndPoint, and branchPaths.\n     */\n    const branches = this.getBranches();\n\n    if (branches != null) {\n      for (let branch of branches) {\n        if (branch != null) {\n          if (branch.branchEndPoint == nodeId) {\n            /*\n             * we have found a branch with the given nodeId as the\n             * end point\n             */\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get all the branches whose branch start point is the given node id\n   * @param nodeId the branch start point\n   * @return an array of branches that have the given branch start point\n   */\n  getBranchesByBranchStartPointNodeId(nodeId) {\n    const branches = [];\n    const allBranches = this.getBranches();\n\n    if (allBranches != null) {\n      for (let branch of allBranches) {\n        if (branch != null) {\n          if (nodeId == branch.branchStartPoint) {\n            /*\n             * the branch start point matches the node id we are\n             * looking for\n             */\n            branches.push(branch);\n          }\n        }\n      }\n    }\n    return branches;\n  }\n\n  /**\n   * Calculate the node numbers and set them into the nodeIdToNumber map\n   */\n  calculateNodeNumbers() {\n    this.nodeIdToNumber = {};\n    this.nodeIdToBranchPathLetter = {};\n    const startNodeId = this.getStartNodeId();\n\n    const currentActivityNumber = 0;\n    const currentStepNumber = 0;\n\n    // recursively calculate the node numbers by traversing the project tree\n    this.calculateNodeNumbersHelper(\n        startNodeId, currentActivityNumber, currentStepNumber);\n  }\n\n  /**\n   * Recursively calcualte the node numbers by traversing the project tree\n   * using transitions\n   * @param nodeId the current node id we are on\n   * @param currentActivityNumber the current activity number\n   * @param currentStepNumber the current step number\n   * @param branchLetterCode (optional) the character code for the branch\n   * letter e.g. 1=A, 2=B, etc.\n   */\n  calculateNodeNumbersHelper(nodeId, currentActivityNumber, currentStepNumber, branchLetterCode) {\n    if (nodeId != null) {\n      if (this.isApplicationNode(nodeId)) {\n        const node = this.getNodeById(nodeId);\n        if (node != null) {\n          const parentGroup = this.getParentGroup(nodeId);\n          if (parentGroup != null) {\n            if (this.nodeIdToNumber[parentGroup.id] == null) {\n              /*\n               * the parent group has not been assigned a number so\n               * we will assign a number now\n               */\n\n              currentActivityNumber = parseInt(currentActivityNumber) + 1;\n\n              /*\n               * set the current step number to 1 now that we have\n               * entered a new group\n               */\n              currentStepNumber = 1;\n\n              this.nodeIdToNumber[parentGroup.id] = \"\" + currentActivityNumber;\n            } else {\n              /*\n               * the parent group has previously been assigned a number so we\n               * will use it\n               */\n              currentActivityNumber = this.nodeIdToNumber[parentGroup.id];\n            }\n          }\n\n          if (this.isBranchMergePoint(nodeId)) {\n            /*\n             * the node is a merge point so we will not use a letter\n             * anymore now that we are no longer in a branch path\n             */\n            branchLetterCode = null;\n          }\n\n          if (this.isBranchStartPoint(nodeId)) {\n            const branchesByBranchStartPointNodeId =\n                this.getBranchesByBranchStartPointNodeId(nodeId);\n            const branchesObject = branchesByBranchStartPointNodeId[0];\n\n            /*\n             * this is used to obtain the max step number that has\n             * been used in the branch paths so that we know what\n             * step number to give the merge end point\n             */\n            let maxCurrentStepNumber = 0;\n\n            // set the step number for the branch start point\n            this.nodeIdToNumber[nodeId] = currentActivityNumber + '.' + currentStepNumber;\n\n            currentStepNumber++;\n            const branchPaths = branchesObject.branchPaths;\n\n            for (let bp = 0; bp < branchPaths.length; bp++) {\n              const branchPath = branchPaths[bp];\n              let branchCurrentStepNumber = currentStepNumber;\n\n              // get the letter code e.g. 1=A, 2=B, etc.\n              const branchLetterCode = bp;\n\n              for (let bpn = 0; bpn < branchPath.length; bpn++) {\n                if (bpn == 0) {\n                  /*\n                   * Recursively call calculateNodeNumbersHelper on the\n                   * first step in this branch path. This will recursively\n                   * calculate the numbers for all the nodes in this\n                   * branch path.\n                   */\n                  const branchPathNodeId = branchPath[bpn];\n                  this.calculateNodeNumbersHelper(branchPathNodeId, currentActivityNumber, branchCurrentStepNumber, branchLetterCode);\n                }\n\n                branchCurrentStepNumber++;\n\n                /*\n                 * update the max current step number if we have found\n                 * a larger number\n                 */\n                if (branchCurrentStepNumber > maxCurrentStepNumber) {\n                  maxCurrentStepNumber = branchCurrentStepNumber;\n                }\n              }\n            }\n\n            // get the step number we should use for the end point\n            currentStepNumber = maxCurrentStepNumber;\n\n            const branchEndPointNodeId = branchesObject.branchEndPoint;\n\n            /*\n             * calculate the node number for the branch end point and\n             * continue calculating node numbers for the nodes that\n             * come after it\n             */\n            this.calculateNodeNumbersHelper(branchEndPointNodeId, currentActivityNumber, currentStepNumber);\n          } else {\n            // the node is not a branch start point\n\n            /*\n             * check if we have already set the number for this node so\n             * that we don't need to unnecessarily re-calculate the\n             * node number\n             */\n            if (this.nodeIdToNumber[nodeId] == null) {\n              // we have not calculated the node number yet\n\n              let number = null;\n\n              if (branchLetterCode == null) {\n                // we do not need to add a branch letter\n\n                // get the node number e.g. 1.5\n                number = currentActivityNumber + '.' + currentStepNumber;\n              } else {\n                // we need to add a branch letter\n\n                // get the branch letter\n                const branchLetter = String.fromCharCode(65 + branchLetterCode);\n\n                // get the node number e.g. 1.5 A\n                number = currentActivityNumber + '.' + currentStepNumber + ' ' + branchLetter;\n\n                // remember the branch path letter for this node\n                this.nodeIdToBranchPathLetter[nodeId] = branchLetter;\n              }\n\n              // set the number for the node\n              this.nodeIdToNumber[nodeId] = number;\n            } else {\n              /*\n               * We have calculated the node number before so we\n               * will return. This will prevent infinite looping\n               * within the project.\n               */\n              return;\n            }\n\n            // increment the step number for the next node to use\n            currentStepNumber++;\n\n            let transitions = [];\n\n            if (node.transitionLogic != null && node.transitionLogic.transitions) {\n              transitions = node.transitionLogic.transitions;\n            }\n\n            if (transitions.length > 0) {\n              /*\n               * loop through all the transitions, there should only\n               * be one but we will loop through them just to be complete.\n               * if there was more than one transition, it would mean\n               * this node is a branch start point in which case we\n               * would have gone inside the other block of code where\n               * this.isBranchStartPoint() is true.\n               */\n              for (let transition of transitions) {\n                if (transition != null) {\n                  if (this.isBranchMergePoint(transition.to)) {\n\n                  } else {\n                    this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\n                  }\n                }\n              }\n            } else {\n              // if there are no transitions, check if the parent group has a transition\n\n              if (parentGroup != null &&\n                  parentGroup.transitionLogic != null &&\n                  parentGroup.transitionLogic.transitions != null &&\n                  parentGroup.transitionLogic.transitions.length > 0) {\n                for (let transition of parentGroup.transitionLogic.transitions) {\n                  if (transition != null) {\n                    this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else {\n        // the node is a group node\n\n        const node = this.getNodeById(nodeId);\n        if (node != null) {\n          // check if the group has previously been assigned a number\n          if (this.nodeIdToNumber[nodeId] == null) {\n            /*\n             * the group has not been assigned a number so\n             * we will assign a number now\n             */\n            if (nodeId == 'group0') {\n              // group 0 will always be given the activity number of 0\n              this.nodeIdToNumber[nodeId] = \"\" + 0;\n            } else {\n              // set the activity number\n              currentActivityNumber = parseInt(currentActivityNumber) + 1;\n\n              /*\n               * set the current step number to 1 now that we have\n               * entered a new group\n               */\n              currentStepNumber = 1;\n\n              // set the activity number\n              this.nodeIdToNumber[nodeId] = \"\" + currentActivityNumber;\n            }\n          } else {\n            /*\n             * We have calculated the node number before so we\n             * will return. This will prevent infinite looping\n             * within the project.\n             */\n            return;\n          }\n\n          if (node.startId != null && node.startId != '') {\n            /*\n             * calculate the node number for the first step in this\n             * activity and any steps after it\n             */\n            this.calculateNodeNumbersHelper(node.startId, currentActivityNumber, currentStepNumber, branchLetterCode);\n          } else {\n            /*\n             * this activity doesn't have a start step so we will\n             * look for a transition\n             */\n\n            if (node != null &&\n                node.transitionLogic != null &&\n                node.transitionLogic.transitions != null &&\n                node.transitionLogic.transitions.length > 0) {\n              for (let transition of node.transitionLogic.transitions) {\n                if (transition != null) {\n                  /*\n                   * calculate the node number for the next group\n                   * and all its children steps\n                   */\n                  this.calculateNodeNumbersHelper(\n                      transition.to, currentActivityNumber, currentStepNumber,\n                      branchLetterCode);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get script for this project\n   */\n  getProjectScript() {\n    return this.project.script;\n  }\n\n  /**\n   * Retrieve the script with the provided script filename\n   * @param scriptFilename\n   */\n  retrieveScript(scriptFilename) {\n    let assetDirectoryPath = this.ConfigService.getProjectAssetsDirectoryPath();\n    let scriptPath = assetDirectoryPath + \"/\" + scriptFilename;\n    return this.$http.get(scriptPath).then((result) => {\n      return result.data;\n    });\n  };\n\n  /**\n   * Registers an additionalProcessingFunction for the specified node and component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @param additionalProcessingFunction the function to register for the node and component.\n   */\n  addAdditionalProcessingFunction(nodeId, componentId, additionalProcessingFunction) {\n    let key = nodeId + \"_\" + componentId;\n    if (this.additionalProcessingFunctionsMap[key] == null) {\n      this.additionalProcessingFunctionsMap[key] = [];\n    }\n    this.additionalProcessingFunctionsMap[key].push(additionalProcessingFunction);\n  }\n\n  /**\n   * Returns true iff the specified node and component has any registered additionalProcessingFunctions\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns true/false\n   */\n  hasAdditionalProcessingFunctions(nodeId, componentId) {\n    return this.getAdditionalProcessingFunctions(nodeId, componentId) != null;\n  }\n\n  /**\n   * Returns an array of registered additionalProcessingFunctions for the specified node and component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns an array of additionalProcessingFunctions\n   */\n  getAdditionalProcessingFunctions(nodeId, componentId) {\n    let key = nodeId + \"_\" + componentId;\n    return this.additionalProcessingFunctionsMap[key];\n  }\n\n  /**\n   * Get the previous node\n   * @param nodeId get the node id that comes before this one\n   * @return the node id that comes before\n   */\n  getPreviousNodeId(nodeId) {\n    const flattenedNodeIds = this.getFlattenedProjectAsNodeIds();\n    if (flattenedNodeIds != null) {\n      const indexOfNodeId = flattenedNodeIds.indexOf(nodeId);\n      if (indexOfNodeId != -1) {\n        const indexOfPreviousNodeId = indexOfNodeId - 1;\n        return flattenedNodeIds[indexOfPreviousNodeId];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the next node\n   * @param nodeId get the node id that comes after this one\n   * @return the node id that comes after\n   */\n  getNextNodeId(nodeId) {\n    const flattenedNodeIds = this.getFlattenedProjectAsNodeIds();\n    if (flattenedNodeIds != null) {\n      const indexOfNodeId = flattenedNodeIds.indexOf(nodeId);\n      if (indexOfNodeId != -1) {\n        const indexOfNextNodeId = indexOfNodeId + 1;\n        return flattenedNodeIds[indexOfNextNodeId];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Set the project script filename\n   * @param script the script filename\n   */\n  setProjectScriptFilename(scriptFilename) {\n    this.project.script = scriptFilename;\n  }\n\n  /**\n   * Get the project script filename\n   */\n  getProjectScriptFilename() {\n    if (this.project != null && this.project.script != null) {\n      return this.project.script;\n    }\n    return null;\n  }\n\n  /**\n   * Get all the achievements object in the project. The achievements object\n   * contains the isEnabled field and an array of items.\n   * @return the achievement object\n   */\n  getAchievements() {\n    if (this.project != null) {\n      if (this.project.achievements == null) {\n        this.project.achievements = {\n          isEnabled: true,\n          items: []\n        };\n      }\n      return this.project.achievements;\n    }\n    return null;\n  }\n\n  /**\n   * Get the achievement items in the project\n   * @return the achievement items\n   */\n  getAchievementItems() {\n    const achievements = this.getAchievements();\n    if (achievements != null) {\n      if (achievements.items == null) {\n        achievements.items = [];\n      }\n      return achievements.items;\n    }\n    return null;\n  }\n\n  /**\n   * Get an achievement by the 10 character alphanumeric achievement id\n   * @param achievementId the 10 character alphanumeric achievement id\n   * @return the achievement with the given achievement id\n   */\n  getAchievementByAchievementId(achievementId) {\n    if (achievementId != null) {\n      const achievements = this.getAchievements();\n      if (achievements != null) {\n        const achievementItems = achievements.items;\n        if (achievementItems != null) {\n          for (let achievement of achievementItems) {\n            if (achievement != null && achievement.id == achievementId) {\n              return achievement;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Check if there are any rubrics in the project. There can potentially be\n   * a project rubric, node rubrics, and component rubrics.\n   * @return whether there are any rubrics in the project\n   */\n  hasRubrics() {\n    if (this.project != null) {\n      if (this.project.rubric != null && this.project.rubric != \"\") {\n        return true;\n      }\n\n      for (let node of this.project.nodes) {\n        if (node != null) {\n          if (node.rubric != null && node.rubric != \"\") {\n            return true;\n          }\n\n          if (node.components != null) {\n            for (let component of node.components) {\n              if (component != null) {\n                if (component.rubric != null && component.rubric != \"\") {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the branch letter in the node position string if the node is in a\n   * branch path\n   * @param nodeId the node id we want the branch letter for\n   * @return the branch letter in the node position if the node is in a branch\n   * path\n   */\n  getBranchLetter(nodeId) {\n    if (nodeId != null) {\n      // get the node position e.g. \"1.8\" or \"1.9 A\"\n      const nodePosition = this.getNodePositionById(nodeId);\n\n      if (nodePosition != null) {\n        // regex for extracting the branch letter\n        const branchLetterRegex = /.*([A-Z])/;\n\n        // run the regex on the node position string\n        const match = branchLetterRegex.exec(nodePosition);\n\n        if (match != null) {\n          /*\n           * the node position has a branch letter so we will get it\n           * from the matched group\n           */\n          return match[1];\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the total number of rubrics (step + components) for the given nodeId\n   * @param nodeId the node id\n   * @return Number of rubrics for the node\n   */\n  getNumberOfRubricsByNodeId(nodeId) {\n    let n = 0;\n    let nodeContent = this.getNodeContentByNodeId(nodeId);\n    if (nodeContent) {\n      let nodeRubric = nodeContent.rubric;\n      if (nodeRubric != null && nodeRubric != '') {\n        n++;\n      }\n\n      let components = nodeContent.components;\n      if (components && components.length) {\n        for (let component of components) {\n          if (component) {\n            const componentRubric = component.rubric;\n            if (componentRubric != null && componentRubric != '') {\n              n++;\n            }\n          }\n        }\n      }\n    }\n    return n;\n  }\n\n  /**\n   * Copy a component and insert it into the step\n   * @param nodeId we are copying a component in this node\n   * @param componentIds the components to copy\n   * @param insertAfterComponentId Which component to place the new components\n   * after. If this is null, we will put the new components at the beginning.\n   * @return an array of the new components\n   */\n  copyComponentAndInsert(nodeId, componentIds, insertAfterComponentId) {\n    const node = this.getNodeById(nodeId);\n    const newComponents = [];\n    const newComponentIds = [];\n    for (let componentId of componentIds) {\n      const newComponent =\n          this.copyComponent(nodeId, componentId, newComponentIds);\n      newComponents.push(newComponent);\n      newComponentIds.push(newComponent.id);\n    }\n\n    const components = node.components;\n    if (components != null) {\n      let insertPosition = 0;\n      if (insertAfterComponentId == null) {\n        // place the new components at the beginning\n        insertPosition = 0;\n      } else {\n        // place the new components after the specified component id\n        insertPosition = this.getComponentPositionByNodeIdAndComponentId(nodeId, insertAfterComponentId) + 1;\n      }\n\n      for (let newComponent of newComponents) {\n        components.splice(insertPosition, 0, newComponent);\n\n        /*\n         * increment the insert position for cases when we have multiple\n         * new components\n         */\n        insertPosition += 1;\n      }\n    }\n    return newComponents;\n  }\n\n  /**\n   * Copy a component\n   * @param nodeId the node id\n   * @param componentId the compnent id\n   * @param componentIdsToSkip component ids that we can't use for our new\n   * component\n   * @return a new component object\n   */\n  copyComponent(nodeId, componentId, componentIdsToSkip) {\n    const component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    const newComponent = this.UtilService.makeCopyOfJSONObject(component);\n    const newComponentId = this.getUnusedComponentId(componentIdsToSkip);\n    newComponent.id = newComponentId;\n    return newComponent;\n  }\n\n  /**\n   * Import components from a project. Also import asset files that are\n   * referenced in any of those components.\n   * @param components an array of component objects that we are importing\n   * @param importProjectId the id of the project we are importing from\n   * @param nodeId the node we are adding the components to\n   * @param insertAfterComponentId insert the components after this component\n   * id\n   * @return an array of the new components\n   */\n  importComponents(components, importProjectId, nodeId, insertAfterComponentId) {\n    let newComponents = [];\n    const newComponentIds = [];\n\n    /*\n     * loop through all the components and make sure their ids are not\n     * already used in the project\n     */\n    for (let component of components) {\n      if (component != null) {\n        const newComponent = this.UtilService.makeCopyOfJSONObject(component);\n        let newComponentId = newComponent.id;\n\n        if (this.isComponentIdUsed(newComponentId)) {\n          // component id is already used so we will find a new component id\n          newComponentId = this.getUnusedComponentId(newComponentIds);\n          newComponent.id = newComponentId;\n        }\n\n        newComponents.push(newComponent);\n        newComponentIds.push(newComponentId);\n      }\n    }\n\n    const importStepsURL = this.ConfigService.getConfigParam('importStepsURL');\n    const httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = importStepsURL;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    const toProjectId = this.ConfigService.getConfigParam('projectId');\n    const fromProjectId = importProjectId;\n\n    const params = {};\n    params.steps = angular.toJson(newComponents);\n    params.fromProjectId = fromProjectId;\n    params.toProjectId = toProjectId;\n    httpParams.data = $.param(params);\n\n    /*\n     * Make the request to import the components. This will copy the asset files\n     * and change file names if necessary. If an asset file with the same\n     * name exists in both projects we will check if their content is the\n     * same. If the content is the same we don't need to copy the file. If\n     * the content is different, we need to make a copy of the file with a\n     * new name and change all the references in the steps to use the new\n     * name.\n     */\n    return this.$http(httpParams).then((result) => {\n      newComponents = result.data;\n      const node = this.getNodeById(nodeId);\n      const currentComponents = node.components;\n      let insertPosition = 0;\n\n      if (insertAfterComponentId == null) {\n        // place the new components at the beginning\n        insertPosition = 0;\n      } else {\n        // place the new components after the specified component id\n        insertPosition = this.getComponentPositionByNodeIdAndComponentId(nodeId, insertAfterComponentId) + 1;\n      }\n\n      for (let newComponent of newComponents) {\n        // insert the new component\n        currentComponents.splice(insertPosition, 0, newComponent);\n\n        /*\n         * increment the insert position for cases when we have multiple\n         * new components\n         */\n        insertPosition += 1;\n      }\n      return newComponents;\n    });\n  }\n\n  /**\n   * Get the branch path letter\n   * @param nodeId get the branch path letter for this node if it is in a\n   * branch\n   * @return the branch path letter for the node if it is in a branch\n   */\n  getBranchPathLetter(nodeId) {\n    return this.nodeIdToBranchPathLetter[nodeId];\n  }\n\n  /**\n   * Set the node into the project by replacing the existing node with the\n   * given node id\n   * @param nodeId the node id of the node\n   * @param node the node object\n   */\n  setNode(nodeId, node) {\n    if (nodeId != null && node != null) {\n      for (let n = 0; n < this.project.nodes.length; n++) {\n        let tempNode = this.project.nodes[n];\n        if (tempNode != null && tempNode.id == nodeId) {\n          this.project.nodes[n] = node;\n        }\n      }\n\n      for (let i = 0; i < this.project.inactiveNodes.length; i++) {\n        let tempNode = this.project.inactiveNodes[i];\n        if (tempNode != null && tempNode.id == nodeId) {\n          this.project.inactiveNodes[i] = node;\n        }\n      }\n      this.idToNode[nodeId] = node;\n    }\n  }\n\n  /**\n   * Remember the result for whether the node is affected by the constraint\n   * @param nodeId the node id\n   * @param constraintId the constraint id\n   * @param whether the node is affected by the constraint\n   */\n  setIsNodeAffectedByConstraintResult(nodeId, constraintId, result) {\n    this.isNodeAffectedByConstraintResult[nodeId + '-' + constraintId] = result;\n  }\n\n  /**\n   * Check if we have calculated the result for whether the node is affected\n   * by the constraint\n   * @param nodeId the node id\n   * @param constraintId the constraint id\n   * @return Return the result if we have calculated the result before. If we\n   * have not calculated the result before, we will return null.\n   */\n  getIsNodeAffectedByConstraintResult(nodeId, constraintId) {\n    return this.isNodeAffectedByConstraintResult[nodeId + '-' + constraintId];\n  }\n\n  /**\n   * Get the id to node mappings.\n   * @return An object the keys as node ids and the values as nodes.\n   */\n  getIdToNode() {\n    return this.idToNode;\n  }\n}\n\nProjectService.$inject = [\n  '$filter',\n  '$http',\n  '$injector',\n  '$q',\n  '$rootScope',\n  'ConfigService',\n  'UtilService'\n];\n\nexport default ProjectService;\n"]}