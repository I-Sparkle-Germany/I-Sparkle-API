{"version":3,"sources":["projectService.es6"],"names":["ProjectService","$filter","$http","$injector","$q","$rootScope","ConfigService","UtilService","project","transitions","applicationNodes","inactiveStepNodes","inactiveGroupNodes","groupNodes","idToNode","idToElement","metadata","activeConstraints","rootNode","idToPosition","idToOrder","nodeCount","componentServices","nodeIdToNumber","nodeIdToIsInBranchPath","nodeIdToBranchPathLetter","achievements","isNodeAffectedByConstraintResult","flattenedProjectAsNodeIds","$translate","additionalProcessingFunctionsMap","filters","parseProject","clearBranchesCache","style","name","getProjectMetadata","title","projectTitle","nodes","nodeId","node","getNodeById","ids","id","getNodes","existingNodes","replaced","n","length","existingNode","splice","push","$broadcast","groupId","group","groupChildNodeIds","indexOf","type","nodeType","content","constraints","setIdToNode","setIdToElement","addNode","addGroupNode","addApplicationNode","addNodeToGroupNode","isPreview","getConfigParam","constraint","planningNodes","planningNode","clearProjectFields","loadNodes","loadPlanningNodes","inactiveNodes","loadInactiveNodes","constraintId","active","getRootNode","calculateNodeOrderOfProject","branches","getBranches","branchNodeIds","pos","setIdToPosition","isNodeIdInABranch","getPositionById","b","getBranchNodePositionById","calculateNodeNumbers","projectAchievements","calculateNodeOrder","isGroupNode","childId","child","startGroupId","stepNumber","importProjectIdToOrder","getNodeOrderOfProjectHelper","item","childIds","c","childStepNumber","i","path","getPathToNode","undefined","order","getIdByOrder","integerToAlpha","int","alphabet","branch","branchPaths","p","branchPath","nodeIndex","startPoint","branchStartPoint","startPointPos","branchPathPos","num","Object","entries","value","element","contentString","JSON","stringify","replaceAssetPaths","parse","contentBaseURL","replace","RegExp","matchedString","delimiter","matchedStringWithoutQuotes","substr","charAt","injectClickToSnipImageIntoContentString","imgMatcher","matchGroup1","newString","tempNode","position","getNodePositionById","nodeIcon","color","fontSet","fontName","imgSrc","imgAlt","icons","icon","$","extend","getGroupNodes","groupNode","isNodeDirectChildOfGroup","getInactiveGroupNodes","inactiveGroupNode","parentGroup","getParentGroup","val","depth","parent","getNodeDepth","groupIds","descendents","getDescendentsOfGroup","childDescendents","concat","startNodeId","allConstraints","isNodeAffectedByConstraint","getConstraintsOnNode","orderedNodeIds","getFlattenedProjectAsNodeIds","sort","constraintsComparatorGenerator","constraintA","constraintB","constraintAIndex","targetId","constraintBIndex","cachedResult","getCachedIsNodeAffectedByConstraintResult","result","action","isNodeIdAfter","targetNode","isNodeDescendentOfGroup","cacheIsNodeAffectedByConstraintResult","nodeId1","nodeId2","isApplicationNode","pathsFromNodeId1ToEnd","getAllPaths","pathToEnd","isNodeAfterGroup","getTransitionsByFromNodeId","transition","pathFromGroupToEnd","to","e","fromNodeId","transitionLogic","getTransitionLogicByFromNodeId","toNodeId","nodesByToNodeId","nodeHasTransitionToNodeId","getInactiveNodes","inactiveNode","nodeIds","getNodesByToNodeId","groupsThatPointToNodeId","groups","getGroups","projectURL","Date","getTime","get","then","projectJSON","data","setProject","projectId","configURL","window","configJSON","previewProjectURL","commitMessage","cleanupBeforeSave","getProjectId","saveProjectURL","authors","userInfo","getMyUserInfo","exists","index","author","httpParams","method","url","headers","param","projectJSONString","angular","toJson","commitHistory","activeNodes","getActiveNodes","activeNode","cleanupNode","checked","hasWork","hasAlert","hasNewAlert","isVisible","completionStatus","score","hasScore","maxScore","hasMaxScore","scorePct","show","components","component","cleanupComponent","wiseBaseURL","getWISEBaseURL","theme","themeSettings","recalculate","getStartNodeId","pathsSoFar","allPaths","consolidatePaths","pathSoFar","includeGroups","parentGroupId","addedCurrentNodeId","getParentGroupId","parentGroupTransitions","parentGroupTransition","allPathsFromToNode","tempPath","unshift","firstNodeId","firstParentGroupId","lastNodeId","pop","startId","paths","consolidatedPath","arePathsEmpty","currentPath","getNonEmptyPathIndex","getFirstNodeIdInPathAtIndex","areFirstNodeIdsInPathsTheSame","removeNodeIdFromPaths","pathsThatContainNodeId","getPathsThatContainNodeId","removeNodeIdFromPath","consumedPath","consumePathsUntilNodeId","consumedNodes","includes","subPath","slice","nodeIdInPath","x","tempNodeId","pathIndex","branchesCache","getMode","getBranchesCache","findBranches","setBranchesCache","previousNodeId","branchMetaObject","createBranchMetaObject","nextCommonNodeId","findNextCommonNodeId","branchEndPoint","extractPathsUpToNodeId","removeDuplicatePaths","trimPathsUpToNodeId","allPathsContainNodeId","extractedPaths","extractedPath","uniquePaths","isPathInUniquePaths","uniquePath","pathsEqual","path1","path2","path1NodeId","path2NodeId","branchPathsIn","componentId","getComponentsByNodeId","tempComponent","tempComponentId","nodeIdToInsert","nodeIdToInsertAfter","insertNodeAfterInGroup","inactiveGroup","nodeToInsert","nodeToInsertAfter","updateChildrenTransitionsInAndOutOfGroup","copyTransitions","copyParentTransitions","transitionObject","updateBranchPathTakenConstraints","parentTransitions","parentTransition","newTransition","getGroupStartId","previousNode","transitionsJSONString","transitionsCopy","fromJson","removeBranchPathTakenNodeConstraintsIfAny","branchPathTakenConstraints","getBranchPathTakenConstraintsByNodeId","branchPathTakenConstraint","newConstraint","getNextAvailableConstraintIdForNodeId","removalCriteria","makeCopyOfJSONObject","addConstraintToNode","currentFromNodeId","currentToNodeId","newFromNodeId","newToNodeId","removalCriterion","params","nodeIdToInsertInside","updateTransitionsToStartId","updateStepTransitionsToGroup","createTransitionFromNodeToInsertToOldStartNode","inheritParentTransitions","nextGroup","addToTransition","startNode","nodesThatTransitionToGroup","nodeThatTransitionsToGroup","updateToTransition","nodesThatTransitionToStartId","nodeThatTransitionToStartId","criteria","oldToNodeId","lastNodes","getGroupIds","largestGroupIdNumber","groupIdNumber","isNaN","parseInt","nextAvailableGroupId","inactiveGroupId","nodeIdsToSkip","getNodeIds","largestNodeIdNumber","nodeIdNumber","inactiveNodeIds","getInactiveNodeIds","inactiveNodeId","nodeIdToSkip","movedNodes","movingNodeIsActive","isActive","stationaryNodeIsActive","removeNodeIdFromTransitions","removeNodeIdFromGroups","insertNodeInsideOnlyUpdateTransitions","insertNodeInsideInGroups","insertNodeAfterInTransitions","insertNodeAfterInGroups","moveFromActiveToInactiveInsertInside","moveToInactive","moveToActive","moveFromInactiveToInactiveInsertInside","moveInactiveNodeToInactiveSection","nodeCopy","getNextAvailableNodeId","newComponentIds","newComponentId","getUnusedComponentId","setGroupStartIdToNextChildId","isProjectStartNodeIdOrContainsProjectStartNodeId","updateProjectStartNodeIdToNextLogicalNode","removeChildNodes","removeNodeIdFromNodes","recalculatePositionsInGroup","updateProjectStartNodeIdToNextLogicalNodeForRemovingGroup","updateProjectStartNodeIdToNextLogicalNodeForRemovingStep","setStartNodeId","nextNodeId","nextGroupStartId","isNodeInGroup","hasSetNewStartId","containsStartNodeId","projectStartNodeId","nodeToRemove","nodeToRemoveTransitionLogic","nodeToRemoveTransitions","parentIdOfNodeToRemove","parentGroupStartId","nodeToRemoveTransition","parentIdOfFromNode","t","tc","tempTransition","tempToNodeId","parentIdOfToNode","isFirstNodeInBranchPath","nodeIdsInBranch","getNodeIdsInBranch","nodeIdInBranch","nodeInBranch","transitionCopy","updateBranchPathTakenConstraint","isBranchPoint","getBranchesByBranchStartPointNodeId","branchPathNodeId","branchPathNode","insertIndex","groupIdWeAreMoving","groupThatTransitionsToGroupWeAreMoving","updateChildrenTransitionsIntoGroupWeAreMoving","removeTransitionsOutOfGroup","removeNodeIdFromGroup","shiftGroupStartNodeByOne","transitionsFromStartNode","componentType","insertAfterComponentId","service","createComponent","componentHasWork","showSaveButton","doesAnyComponentInNodeShowSubmitButton","addComponentToNode","showSubmitButton","added","componentIds","componentsToMove","a","firstPath","nodeMaxScore","getMaxScoreForNode","componentMaxScore","getComponentByNodeIdAndComponentId","firstLeafNodeId","done","tempApplicationNode","tempApplicationNodeId","getChildNodeIdsById","message","nodeTitle","getNodePositionAndTitleByNodeId","removalConditional","criteriaMessages","tempRemovalCriteria","criteriaMessage","getCriteriaMessage","actionMessage","getActionMessage","singleRemovalCriteria","scoresString","scores","join","choiceIds","choices","getChoiceTextByNodeIdAndComponentId","choiceText","requiredSubmitCount","fromNodeTitle","toNodeTitle","requiredNumberOfWords","requiredNumberOfNotes","requiredNumberOfFilledRows","getChoicesByNodeIdAndComponentId","choicesText","choice","text","fromGroupId","oldToGroupId","newToGroupId","fromGroup","oldToGroup","newToGroup","newToGroupStartId","oldToGroupIds","oldToGroupStartId","transitionsBefore","previousGroupNodes","getGroupNodesByToNodeId","transitionsAfter","extracted","previousGroupNode","updateTransitionsForExtractingGroup","transitionAfter","inserted","updateTransitionsForInsertingGroup","getStartGroupId","startGroup","firstGroupId","removeChildFromParent","removeNodeFromInactiveStepNodes","removeNodeFromInactiveGroupNodes","startIdUpdated","inactiveStepNode","target","isNodeActive","removeNodeFromInactiveNodes","childNode","transitionsFromChild","tfc","transitionFromChild","toNodeIdParentGroupId","firstNodeToRemoveTransition","firstNodeToRemoveTransitionToNodeId","nodeContent","getNodeContentByNodeId","componentService","getComponentService","componentServiceName","componentIdsToSkip","idLength","generateKey","isComponentIdUsed","alreadyUsed","nextAvailableConstraintId","usedConstraintIds","foundNextAvailableConstraintId","counter","potentialConstraintId","hasBranchPathTakenConstraint","orderNodeIds","nodeIdsComparatorGenerator","nodeIdA","nodeIdB","nodeIdAIndex","nodeIdBIndex","rubric","transitionTo","allBranches","currentActivityNumber","currentStepNumber","calculateNodeNumbersHelper","branchLetterCode","isBranchMergePoint","isBranchStartPoint","branchesByBranchStartPointNodeId","branchesObject","maxCurrentStepNumber","bp","branchCurrentStepNumber","bpn","branchEndPointNodeId","number","branchLetter","String","fromCharCode","script","flattenedNodeIds","indexOfNodeId","indexOfNextNodeId","isEnabled","items","getAchievements","achievementId","achievementItems","achievement","numRubrics","nodeRubric","componentRubric","numberOfRubrics","getNumberOfRubricsByNodeId","spaces","space","isSpaceExists","saveProject","getSpaces","s","getAdditionalProcessingFunctions","key","featuredProjectIconsURL","projectIcon","featuredProjectIconURL","setProjectIcon","customProjectIconURL","projectIconURL","$inject"],"mappings":"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","sourcesContent":["'use strict';\n\nclass ProjectService {\n  constructor($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService) {\n    this.$filter = $filter;\n    this.$http = $http;\n    this.$injector = $injector;\n    this.$q = $q;\n    this.$rootScope = $rootScope;\n    this.ConfigService = ConfigService;\n    this.UtilService = UtilService;\n    this.project = null;\n    this.transitions = [];\n    this.applicationNodes = [];\n    this.inactiveStepNodes = [];\n    this.inactiveGroupNodes = [];\n    this.groupNodes = [];\n    this.idToNode = {};\n    this.idToElement = {};\n    this.metadata = {};\n    this.activeConstraints = [];\n    this.rootNode = null;\n    this.idToPosition = {};\n    this.idToOrder = {};\n    this.nodeCount = 0;\n    this.componentServices = {};\n    this.nodeIdToNumber = {};\n    this.nodeIdToIsInBranchPath = {};\n    this.nodeIdToBranchPathLetter = {};\n    this.achievements = [];\n    this.isNodeAffectedByConstraintResult = {};\n    this.flattenedProjectAsNodeIds = null;\n\n    this.$translate = this.$filter('translate');\n\n    // map from nodeId_componentId to array of additionalProcessingFunctions\n    this.additionalProcessingFunctionsMap = {};\n\n    // filtering options for navigation displays\n    this.filters = [\n      {'name': 'all', 'label': 'All'}\n      //{'name': 'todo', 'label': 'Todo'},\n      //{'name': 'completed', 'label': 'Completed'}\n    ];\n  };\n\n  setProject(project) {\n    this.project = project;\n    this.parseProject();\n  };\n\n  /**\n   * Initialize the data structures used to hold project information\n   */\n  clearProjectFields() {\n    this.transitions = [];\n    this.applicationNodes = [];\n    this.inactiveStepNodes = [];\n    this.inactiveGroupNodes = [];\n    this.groupNodes = [];\n    this.idToNode = {};\n    this.idToElement = {};\n    this.metadata = {};\n    this.activeConstraints = [];\n    this.rootNode = null;\n    this.idToPosition = {};\n    this.idToOrder = {};\n    this.nodeCount = 0;\n    this.nodeIdToIsInBranchPath = {};\n    this.achievements = [];\n    this.clearBranchesCache();\n  };\n\n  getStyle() {\n    return this.project.style;\n  };\n\n  getFilters() {\n    return this.filters;\n  };\n\n  getProjectTitle() {\n    const name = this.getProjectMetadata().title;\n    return name ? name : 'A WISE Project (No name)';\n  };\n\n  setProjectTitle(projectTitle) {\n    const metadata = this.getProjectMetadata();\n    metadata.title = projectTitle;\n  }\n\n  getProjectMetadata() {\n    return this.metadata ? this.metadata : {};\n  };\n\n  getNodes() {\n    return this.project.nodes;\n  };\n\n  getChildNodeIdsById(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node.ids) {\n      return node.ids;\n    }\n    return [];\n  };\n\n  getGroupNodes() {\n    return this.groupNodes;\n  };\n\n  isNode(id) {\n    const nodes = this.getNodes();\n    for (let node of nodes) {\n      if (node.id === id) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  addNode(node) {\n    const existingNodes = this.project.nodes;\n    let replaced = false;\n    if (node != null && existingNodes != null) {\n      for (let n = 0; n < existingNodes.length; n++) {\n        const existingNode = existingNodes[n];\n        if (existingNode.id === node.id) {\n          existingNodes.splice(n, 1, node);\n          replaced = true;\n        }\n      }\n    }\n    if (!replaced) {\n      existingNodes.push(node);\n    }\n  };\n\n  addApplicationNode(node) {\n    const applicationNodes = this.applicationNodes;\n    if (node != null && applicationNodes != null) {\n      applicationNodes.push(node);\n    }\n  };\n\n  addGroupNode(node) {\n    const groupNodes = this.groupNodes;\n    if (node != null && groupNodes != null) {\n      groupNodes.push(node);\n    }\n    this.$rootScope.$broadcast('groupsChanged');\n  };\n\n  addNodeToGroupNode(groupId, nodeId) {\n    if (groupId != null && nodeId != null) {\n      const group = this.getNodeById(groupId);\n      if (group != null) {\n        const groupChildNodeIds = group.ids;\n        if (groupChildNodeIds != null) {\n          if (groupChildNodeIds.indexOf(nodeId) === -1) {\n            groupChildNodeIds.push(nodeId);\n          }\n        }\n      }\n    }\n  };\n\n  isGroupNode(id) {\n    const node = this.getNodeById(id);\n    return node != null && node.type == 'group';\n  };\n\n  isApplicationNode(id) {\n    const node = this.getNodeById(id);\n    return node != null && node.type !== 'group';\n  };\n\n  getGroups() {\n    return this.groupNodes;\n  };\n\n  getInactiveGroupNodes() {\n    return this.inactiveGroupNodes;\n  }\n\n  /**\n   * Get the inactive step nodes. This will include the inactive steps that\n   * are in an inactive group.\n   * @return An array of inactive step nodes.\n   */\n  getInactiveStepNodes() {\n    return this.inactiveStepNodes;\n  }\n\n  loadNodes(nodes) {\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null) {\n          const nodeId = node.id;\n          const nodeType = node.type;\n          const content = node.content;\n          const constraints = node.constraints;\n\n          if (content != null) {\n            //node.content = this.injectAssetPaths(content);\n          }\n\n          this.setIdToNode(nodeId, node);\n          this.setIdToElement(nodeId, node);\n          this.addNode(node);\n\n          if (nodeType === 'group') {\n            this.addGroupNode(node);\n          } else {\n            this.addApplicationNode(node);\n          }\n\n          const groupId = node.groupId;\n          if (groupId != null) {\n            this.addNodeToGroupNode(groupId, nodeId);\n          }\n\n          if (constraints != null) {\n            if (this.ConfigService.isPreview() == true && this.ConfigService.getConfigParam('constraints') === false) {\n              /*\n               * if we are in preview mode and constraints are set\n               * to false, we will not add the constraints\n               */\n            } else {\n              // all other cases we will add the constraints\n              for (let constraint of constraints) {\n                this.activeConstraints.push(constraint);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Load the planning template nodes\n   * @param planning template nodes\n   */\n  loadPlanningNodes(planningNodes) {\n    if (planningNodes != null) {\n      for (let planningNode of planningNodes) {\n        if (planningNode != null) {\n          const nodeId = planningNode.id;\n          this.setIdToNode(nodeId, planningNode);\n          this.setIdToElement(nodeId, planningNode);\n\n          // TODO: may need to add more function calls here to add the planning\n        }\n      }\n    }\n  }\n\n  /**\n   * Parse the project to detect the nodes, branches, node numbers, etc.\n   */\n  parseProject() {\n    const project = this.project;\n    if (project != null) {\n      this.clearProjectFields();\n\n      if (project.metadata) {\n        this.metadata = project.metadata;\n      }\n\n      const nodes = project.nodes;\n      this.loadNodes(nodes);\n\n      const planningNodes = project.planningNodes;\n      this.loadPlanningNodes(planningNodes);\n\n      const inactiveNodes = project.inactiveNodes;\n      this.loadInactiveNodes(inactiveNodes);\n\n      const constraints = project.constraints;\n\n      if (constraints != null) {\n        for (let constraint of constraints) {\n          if (constraint != null) {\n            const constraintId = constraint.id;\n            constraint.active = true;\n            this.setIdToElement(constraintId, constraint);\n          }\n        }\n      }\n\n      this.rootNode = this.getRootNode(nodes[0].id);\n      this.calculateNodeOrderOfProject();\n\n      let n = nodes.length;\n      const branches = this.getBranches();\n      const branchNodeIds = [];\n\n      // set node positions\n      let id, pos;\n\n      while (n--) {\n        id = nodes[n].id;\n        if (id === this.rootNode.id) {\n          this.setIdToPosition(id, '0');\n        } else if (this.isNodeIdInABranch(branches, id)) {\n          // node is in a branch, so process later\n          branchNodeIds.push(id);\n        } else {\n          pos = this.getPositionById(id);\n          this.setIdToPosition(id, pos);\n        }\n      }\n\n      // set branch node positions\n      let b = branchNodeIds.length;\n      while (b--) {\n        id = branchNodeIds[b];\n        pos = this.getBranchNodePositionById(id);\n        this.setIdToPosition(id, pos);\n      }\n\n      /*\n       * calculate the node numbers\n       * e.g. if the step is called\n       * 1.5 View the Potential Energy\n       * then the node number is 1.5\n       */\n      this.calculateNodeNumbers();\n\n      if (this.project.projectAchievements != null) {\n        this.achievements = this.project.projectAchievements;\n      }\n    }\n\n    this.$rootScope.$broadcast('projectChanged');\n  };\n\n  calculateNodeOrderOfProject() {\n    this.calculateNodeOrder(this.rootNode);\n  }\n\n  /**\n   * Recursively calculates the node order.\n   * @param node\n   */\n  calculateNodeOrder(node) {\n    this.idToOrder[node.id] = {'order': this.nodeCount};\n    this.nodeCount++;\n    if (this.isGroupNode(node.id)) {\n      for (let childId of node.ids) {\n        const child = this.getNodeById(childId);\n        this.calculateNodeOrder(child);\n      }\n    }\n  };\n\n  /**\n   * Get the node order mappings of the project\n   * @param project the project JSOn\n   * @return an object containing the idToOrder mapping and also the array\n   * of nodes\n   */\n  getNodeOrderOfProject(project) {\n    const rootNode = this.getNodeById(project.startGroupId, project);\n    const idToOrder = {\n      nodeCount: 0\n    };\n    const stepNumber = '';\n    const nodes = [];\n    const importProjectIdToOrder = this.getNodeOrderOfProjectHelper(project, rootNode, idToOrder, stepNumber, nodes);\n    delete importProjectIdToOrder.nodeCount;\n    return {\n      idToOrder: importProjectIdToOrder,\n      nodes: nodes\n    };\n  }\n\n  /**\n   * Recursively traverse the project to calculate the node order and step numbers\n   * @param project the project JSON\n   * @param node the current node we are on\n   * @param idToOrder the mapping of node id to item\n   * @param stepNumber the current step number\n   * @param nodes the array of nodes\n   */\n  getNodeOrderOfProjectHelper(project, node, idToOrder, stepNumber, nodes) {\n    /*\n     * Create the item that we will add to the idToOrder mapping.\n     * The 'order' field determines how the project nodes are displayed\n     * when we flatten the project for displaying.\n     */\n    const item = {\n      'order': idToOrder.nodeCount,\n      'node': node,\n      'stepNumber': stepNumber\n    };\n\n    idToOrder[node.id] = item;\n    idToOrder.nodeCount++;\n    nodes.push(item);\n\n    if (node.type == 'group') {\n      const childIds = node.ids;\n      for (let c = 0; c < childIds.length; c++) {\n        const childId = childIds[c];\n        const child = this.getNodeById(childId, project);\n        let childStepNumber = stepNumber;\n\n        if (childStepNumber != '') {\n          // add the . separator for the step number e.g. 1.\n          childStepNumber += '.';\n        }\n\n        childStepNumber += (c + 1);\n        this.getNodeOrderOfProjectHelper(project, child, idToOrder, childStepNumber, nodes);\n      }\n    }\n    return idToOrder;\n  }\n\n  /**\n   * Returns the position in the project for the node with the given id. Returns null if no node with id exists.\n   * @param id a node id\n   * @return string position of the given node id in the project\n   */\n  getPositionById(id) {\n    for (let i = 0; i < this.rootNode.ids.length; i++) {\n      const node = this.getNodeById(this.rootNode.ids[i]);\n      const path = this.getPathToNode(node, i + 1, id);\n      if (path != undefined && path != null) {\n        return path;\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Returns the order of the given node id in the project. Returns null if no node with id exists.\n   * @param id String node id\n   * @return Number order of the given node id in the project\n   */\n  getOrderById(id) {\n    if (this.idToOrder[id]) {\n      return this.idToOrder[id].order;\n    }\n    return null;\n  };\n\n  /**\n   * Returns the id of the node with the given order in the project. Returns null if no order with node exists.\n   * @param order Number\n   * @return Number node id of the given order in the project\n   */\n  getIdByOrder(order) {\n    let nodeId = null;\n    for (let id in this.idToOrder) {\n      if (this.idToOrder[id].order === order) {\n        if (this.isGroupNode(id) && order > 1) {\n          nodeId = this.getIdByOrder(order-1);\n        } else {\n          nodeId = id;\n        }\n        break;\n      }\n    }\n    return nodeId;\n  };\n\n  /**\n   * Returns the position in the project for the branch node with the given id. Returns null if no node with id exists or node is not a branch node.\n   * @param id a node id\n   * @return string position of the given node id in the project\n   */\n  getBranchNodePositionById(id) {\n    const branches = this.getBranches();\n    let b = branches.length;\n\n    // TODO: should we localize this? should we support more than 26?\n    const integerToAlpha = function(int) {\n      const alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n      if (int > -1 && int < 26) {\n        return alphabet[int];\n      } else {\n        return int;\n      }\n    };\n\n    while (b--) {\n      const branch = branches[b];\n      const branchPaths = branch.branchPaths;\n      for (let p = 0; p < branchPaths.length; p++) {\n        const branchPath = branchPaths[p];\n        const nodeIndex = branchPath.indexOf(id);\n        if (nodeIndex > -1) {\n          const startPoint = branch.branchStartPoint;\n          const startPointPos = this.idToPosition[startPoint];\n          const branchPathPos = startPointPos + ' ' + integerToAlpha(p);\n          return branchPathPos + (nodeIndex+1);\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Recursively searches for the given node id from the point of the given node down and returns the path number (position)\n   * @param node a node to start searching down\n   * @param path the position of the given node\n   * @param id the node id to search for\n   * @return string path of the given node id in the project\n   */\n  getPathToNode(node, path, id) {\n    if (node.id === id) {\n      return path + '';\n    } else if (node.type === 'group') {\n      let num = 0;\n      const branches = this.getBranches();\n      for (let nodeId of node.ids) {\n        if (this.isNodeIdInABranch(branches, nodeId)) {\n          this.getBranchNodePositionById(nodeId);\n        } else {\n          ++num;\n          const pos = this.getPathToNode(this.getNodeById(nodeId), (path) + '.' + (num), id);\n          if (pos) {\n            return pos;\n          }\n        }\n      }\n    }\n  };\n\n  setIdToPosition(id, pos) {\n    if (id != null) {\n      this.idToPosition[id] = pos;\n    }\n  };\n\n  getNodePositionById(id) {\n    if (id != null) {\n      return this.nodeIdToNumber[id];\n    }\n    return null;\n  };\n\n  getNodeIdByOrder(order) {\n    for (let [nodeId, value] of Object.entries(this.idToOrder)) {\n      if (value.order === order) {\n        return nodeId;\n      }\n    }\n    return null;\n  };\n\n  getNodeOrderById(id) {\n    return this.idToOrder[id] ? this.idToOrder[id].order : null;\n  };\n\n  setIdToNode(id, element) {\n    this.idToNode[id] = element;\n  };\n\n  setIdToElement(id, element) {\n    this.idToElement[id] = element;\n  };\n\n  /**\n   * Replace relative asset paths with absolute paths\n   * e.g.\n   * assets/myimage.jpg\n   * will be replaced with\n   * http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg\n   * @param content a string or JSON object\n   * @return the same type of object that was passed in as the content\n   * but with relative asset paths replaced with absolute paths\n   */\n  injectAssetPaths(content) {\n    if (content != null) {\n      if (typeof content === 'object') {\n        let contentString = JSON.stringify(content);\n        if (contentString != null) {\n          // replace the relative asset paths with the absolute paths\n          contentString = this.replaceAssetPaths(contentString);\n          content = JSON.parse(contentString);\n        }\n      } else if (typeof content === 'string') {\n        // replace the relative asset paths with the absolute paths\n        content = this.replaceAssetPaths(content);\n      }\n    }\n    return content;\n  };\n\n  /**\n   * Replace the relative asset paths with absolute paths\n   * @param contentString the content string\n   * @return the content string with relative asset paths replaced\n   * with absolute asset paths\n   */\n  replaceAssetPaths(contentString) {\n    if (contentString != null) {\n      // get the content base url e.g. http://wise.berkeley.edu/curriculum/123456/\n      const contentBaseURL = this.ConfigService.getConfigParam('projectBaseURL');\n\n      // only look for string that starts with ' or \" and ends in png, jpg, jpeg, pdf, etc.\n      // the string we're looking for can't start with '/ and \"/.\n      // note that this also works for \\\"abc.png and \\'abc.png, where the quotes are escaped\n      contentString = contentString.replace(\n        new RegExp('(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")[^:][^\\/]?[^\\/]?[a-zA-Z0-9@%&;\\\\._\\\\/\\\\s\\\\-\\']*[\\.](png|jpe?g|pdf|gif|mov|mp4|mp3|wav|swf|css|txt|json|xlsx?|doc|html.*?|js).*?(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")', 'gi'),\n        (matchedString) => {\n          // once found, we prepend the contentBaseURL + \"assets/\" to the string within the quotes and keep everything else the same.\n          let delimiter = '';\n          let matchedStringWithoutQuotes = '';\n\n          if (matchedString.length > 2 && matchedString.substr(0,1) == '\\\\') {\n            // the string has escaped quotes for example \\\"hello.png\\\"\n\n            // get everything between the escaped quotes\n            matchedStringWithoutQuotes = matchedString.substr(2, matchedString.length - 4);\n\n            // get the delimiter which will be \\' or \\\"\n            delimiter = matchedString.substr(0,2);\n          } else {\n            // the string does not have escaped quotes for example \"hello.png\"\n\n            // get everything between the quotes\n            matchedStringWithoutQuotes = matchedString.substr(1, matchedString.length - 2);\n\n            // get the delimiter which will be ' or \"\n            delimiter = matchedString.substr(0,1);\n          }\n\n          if (matchedStringWithoutQuotes != null && matchedStringWithoutQuotes.length > 0 && matchedStringWithoutQuotes.charAt(0) == \"/\") {\n            /*\n             * the matched string starts with a \"/\" which means it's\n             * an absolute path and does not require path prepending\n             * so we will just return the original unmodified string\n             */\n            return delimiter + matchedStringWithoutQuotes + delimiter;\n          } else {\n            //const matchedStringWithoutFirstAndLastQuote = matchedString.substr(1, matchedString.length - 2);  // everything but the beginning and end quote (' or \")\n            // make a new string with the contentBaseURL + assets/ prepended to the path\n            return delimiter + contentBaseURL + \"assets/\" + matchedStringWithoutQuotes + delimiter;\n          }\n        }\n      );\n    }\n    return contentString;\n  };\n\n  /**\n   * Inject the ng-click attribute that will call the snipImage function\n   * @param content the content\n   * @returns the modified content\n   */\n  injectClickToSnipImage(content) {\n    if (content != null) {\n      if (typeof content === 'object') {\n        let contentString = JSON.stringify(content);\n        if (contentString != null) {\n          // replace the relative asset paths with the absolute paths\n          contentString = this.injectClickToSnipImageIntoContentString(contentString);\n\n          content = JSON.parse(contentString);\n        }\n      } else if (typeof content === 'string') {\n        // replace the relative asset paths with the absolute paths\n        content = this.injectClickToSnipImageIntoContentString(content);\n      }\n    }\n    return content;\n  }\n\n  /**\n   * Inject the ng-click attribute that will call the snipImage function\n   * @param contentString the content in string format\n   * @returns the modified content string\n   */\n  injectClickToSnipImageIntoContentString(contentString) {\n    if (contentString != null) {\n      // regex to match image elements\n      const imgMatcher = new RegExp('<img.*?src=\\\\\\\\?[\\'\"](.*?)\\\\\\\\?[\\'\"].*?>', 'gi');\n\n      // replace all instances that match\n      contentString = contentString.replace(imgMatcher,\n        (matchedString, matchGroup1) => {\n          /*\n           * insert the ng-click attribute\n           * Before: <img src=\"abc.png\"/>\n           * After: <img ng-click=\"vleController.snipImage($event)\" src=\"abc.png\" />\n           */\n          const newString = matchedString.replace('img', 'img ng-click=\\\\\\\"$emit(\\'snipImage\\', $event)\\\\\\\"');\n          return newString;\n        }\n      );\n    }\n    return contentString;\n  }\n\n  /**\n   * Returns the node specified by the nodeId\n   * @param nodeId get the node with this node id\n   * @param (optional) the project to retrieve the node from. this is used in\n   * the case when we want the node from another project such as when we are\n   * importing a step from another project\n   * Return null if nodeId param is null or the specified node does not exist in the project.\n   */\n  getNodeById(nodeId, project) {\n    if (project == null) {\n      if (this.idToNode[nodeId]) {\n        return this.idToNode[nodeId];\n      }\n    } else {\n      for (let tempNode of project.nodes) {\n        if (tempNode != null && tempNode.id == nodeId) {\n          return tempNode;\n        }\n      }\n\n      for (let tempNode of project.inactiveNodes) {\n        if (tempNode != null && tempNode.id == nodeId) {\n          return tempNode;\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Returns the title of the node with the nodeId\n   * Return null if nodeId param is null or the specified node does not exist in the project.\n   */\n  getNodeTitleByNodeId(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      return node.title;\n    }\n    return null;\n  };\n\n  /**\n   * Get the node position and title\n   * @param nodeId the node id\n   * @returns the node position and title, e.g. \"1.1 Introduction\"\n   */\n  getNodePositionAndTitleByNodeId(nodeId) {\n    const node = this.getNodeById(nodeId);\n    if (node != null) {\n      const position = this.getNodePositionById(nodeId);\n      if (position != null) {\n        return position + ': ' + node.title;\n      } else {\n        return node.title;\n      }\n    }\n    return null;\n  };\n\n  getNodeIconByNodeId(nodeId) {\n    const node = this.getNodeById(nodeId);\n    let nodeIcon = null;\n    if (node != null) {\n      // set defaults (TODO: get from configService?)\n      nodeIcon = {\n        color: 'rgba(0,0,0,0.54)',\n        type: 'font',\n        fontSet: 'material-icons',\n        fontName: (node.type === 'group') ? 'explore' : 'school',\n        imgSrc: '',\n        imgAlt: 'node icon'\n      };\n\n      // TODO: check for different statuses\n      const icons = node.icons;\n      if (!!icons && !!icons.default) {\n        const icon = icons.default;\n        nodeIcon = $.extend(true, nodeIcon, icon);\n      }\n\n      // check for empty image source\n      if (!nodeIcon.imgSrc) {\n        // revert to font icon\n        nodeIcon.type = 'font';\n      }\n    }\n    return nodeIcon;\n  };\n\n  getParentGroup(nodeId) {\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        // Check if the node is a child of an active group.\n        const groupNodes = this.getGroupNodes();\n        for (let groupNode of groupNodes) {\n          if (this.isNodeDirectChildOfGroup(node, groupNode)) {\n            return groupNode;\n          }\n        }\n\n        // Check if the node is a child of an inactive group.\n        const inactiveGroupNodes = this.getInactiveGroupNodes();\n        for (let inactiveGroupNode of inactiveGroupNodes) {\n          if (this.isNodeDirectChildOfGroup(node, inactiveGroupNode)) {\n            return inactiveGroupNode;\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Get the parent group id\n   * @param nodeId the parent group id\n   * @returns the parent group id\n   */\n  getParentGroupId(nodeId) {\n    if (nodeId != null) {\n      const parentGroup = this.getParentGroup(nodeId);\n      if (parentGroup != null) {\n        return parentGroup.id;\n      }\n    }\n    return null;\n  }\n\n  getNodeDepth(nodeId, val) {\n    if (nodeId != null) {\n      let depth = (typeof val === \"number\") ? val : 0;\n      const parent = this.getParentGroup(nodeId);\n      if (parent) {\n        depth = this.getNodeDepth(parent.id, depth + 1);\n      }\n      return depth;\n    }\n    return null;\n  };\n\n  getRootNode(nodeId) {\n    const parentGroup = this.getParentGroup(nodeId);\n    if (parentGroup == null) {\n      return this.getNodeById(nodeId);\n    } else {\n      return this.getRootNode(parentGroup.id);\n    }\n    return null;\n  };\n\n  isNodeDirectChildOfGroup(node, group) {\n    if (node != null && group != null) {\n      const nodeId = node.id;\n      const groupIds = group.ids;\n      if (groupIds != null && groupIds.indexOf(nodeId) != -1) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  isNodeDescendentOfGroup(node, group) {\n    if (node != null && group != null) {\n      const descendents = this.getDescendentsOfGroup(group);\n      const nodeId = node.id;\n      if (descendents.indexOf(nodeId) != -1) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  getDescendentsOfGroup(group) {\n    let descendents = [];\n    if (group != null) {\n      const childIds = group.ids;\n      if (childIds != null) {\n        descendents = childIds;\n        for (let childId of childIds) {\n          const node = this.getNodeById(childId);\n          if (node != null) {\n            const childDescendents = this.getDescendentsOfGroup(node);\n            descendents = descendents.concat(childDescendents);\n          }\n        }\n      }\n    }\n    return descendents;\n  };\n\n  getStartNodeId() {\n    return this.project.startNodeId;\n  };\n\n  setStartNodeId(nodeId) {\n    this.project.startNodeId = nodeId;\n  }\n\n  getStartGroupId() {\n    return this.project.startGroupId;\n  }\n\n  isStartNodeId(nodeId) {\n    return this.project.startNodeId === nodeId;\n  }\n\n  getConstraintsForNode(node) {\n    const constraints = [];\n    const allConstraints = this.activeConstraints;\n    for (let constraint of allConstraints) {\n      if (this.isNodeAffectedByConstraint(node, constraint)) {\n        constraints.push(constraint);\n      }\n    }\n    return constraints;\n  };\n\n  /**\n   * Get the constraints on the node.\n   * @param nodeId The node id of the node.\n   * @return An array of constraint objects.\n   */\n  getConstraintsOnNode(nodeId) {\n    let node = this.getNodeById(nodeId);\n    return node.constraints;\n  }\n\n  /**\n   * @param node A node object.\n   * @param constraint A constraint object.\n   */\n  addConstraintToNode(node, constraint) {\n    if (node.constraints == null) {\n      node.constraints = [];\n    }\n    node.constraints.push(constraint);\n  }\n\n  /**\n   * Check if a node has constraints.\n   * @param nodeId The node id of the node.\n   * @return true iff the node has constraints authored on it.\n   */\n  nodeHasConstraint(nodeId) {\n    let constraints = this.getConstraintsOnNode(nodeId);\n    return constraints.length > 0;\n  }\n\n  /**\n   * Order the constraints so that they show up in the same order as in the\n   * project.\n   * @param constraints An array of constraint objects.\n   * @return An array of ordered constraints.\n   */\n  orderConstraints(constraints) {\n    let orderedNodeIds = this.getFlattenedProjectAsNodeIds();\n    return constraints.sort(this.constraintsComparatorGenerator(orderedNodeIds));\n  }\n\n  /**\n   * Create the constraints comparator function that is used for sorting an\n   * array of constraint objects.\n   * @param orderedNodeIds An array of node ids in the order in which they\n   * show up in the project.\n   * @return A comparator that orders constraint objects in the order in which\n   * the target ids show up in the project.\n   */\n  constraintsComparatorGenerator(orderedNodeIds) {\n    return function(constraintA, constraintB) {\n      let constraintAIndex = orderedNodeIds.indexOf(constraintA.targetId);\n      let constraintBIndex = orderedNodeIds.indexOf(constraintB.targetId);\n      if (constraintAIndex < constraintBIndex) {\n        return -1;\n      } else if (constraintAIndex > constraintBIndex) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Check if a node is affected by the constraint\n   * @param node check if the node is affected\n   * @param constraint the constraint that might affect the node\n   * @returns whether the node is affected by the constraint\n   */\n  isNodeAffectedByConstraint(node, constraint) {\n    const cachedResult =\n        this.getCachedIsNodeAffectedByConstraintResult(node.id, constraint.id);\n    if (cachedResult != null) {\n      return cachedResult;\n    } else {\n      let result = false;\n      const nodeId = node.id;\n      const targetId = constraint.targetId;\n      const action = constraint.action;\n\n      if (action === 'makeAllNodesAfterThisNotVisible') {\n        if (this.isNodeIdAfter(targetId, node.id)) {\n          result = true;\n        }\n      } else if (action === 'makeAllNodesAfterThisNotVisitable') {\n        if (this.isNodeIdAfter(targetId, node.id)) {\n          result = true;\n        }\n      } else {\n        const targetNode = this.getNodeById(targetId);\n        if (targetNode != null) {\n          const nodeType = targetNode.type;\n          if (nodeType === 'node' && nodeId === targetId) {\n            result = true;\n          } else if (nodeType === 'group' &&\n              (nodeId === targetId || this.isNodeDescendentOfGroup(node, targetNode))) {\n            result = true;\n          }\n        }\n      }\n\n      this.cacheIsNodeAffectedByConstraintResult(node.id, constraint.id, result);\n      return result;\n    }\n  };\n\n  /**\n   * Check if a node id comes after another node id in the project.\n   * @param nodeId1 The node id of a step or group.\n   * @param nodeId2 The node id of a step or group.\n   * @returns {boolean} True iff nodeId2 comes after nodeId1.\n   */\n  isNodeIdAfter(nodeId1, nodeId2) {\n    if (this.isApplicationNode(nodeId1)) {\n      if (nodeId1 == nodeId2) {\n        return false;\n      } else {\n        const pathsFromNodeId1ToEnd = this.getAllPaths([], nodeId1, true);\n        for (let pathToEnd of pathsFromNodeId1ToEnd) {\n          if (pathToEnd.indexOf(nodeId2) != -1) {\n            return true;\n          }\n        }\n      }\n    } else {\n      return this.isNodeAfterGroup(nodeId1, nodeId2);\n    }\n    return false;\n  }\n\n  /**\n   * @param groupId\n   * @param nodeId The node id of a step or group.\n   * @returns {boolean} True iff nodeId comes after groupId.\n   */\n  isNodeAfterGroup(groupId, nodeId) {\n    const transitions = this.getTransitionsByFromNodeId(groupId);\n    try {\n      for (let transition of transitions) {\n        const pathFromGroupToEnd = this.getAllPaths([], transition.to, true);\n        for (let pathToEnd of pathFromGroupToEnd) {\n          if (pathToEnd.indexOf(nodeId) != -1) {\n            return true;\n          }\n        }\n      }\n    } catch(e) {\n\n    }\n    return false;\n  }\n\n  /**\n   * Get the transition logic for a node\n   * @param fromNodeId the from node id\n   * @returns the transition logic object\n   */\n  getTransitionLogicByFromNodeId(fromNodeId) {\n    const node = this.getNodeById(fromNodeId);\n    if (node.transitionLogic == null) {\n      node.transitionLogic = {\n        transitions: []\n      }\n    }\n    return node.transitionLogic;\n  };\n\n  /**\n   * Get the transitions for a node\n   * @param fromNodeId the node to get transitions from\n   * @returns {Array} an array of transitions\n   */\n  getTransitionsByFromNodeId(fromNodeId) {\n    const transitionLogic = this.getTransitionLogicByFromNodeId(fromNodeId);\n    return transitionLogic.transitions;\n  }\n\n  /**\n   * Get nodes that have a transition to the given node id\n   * @param toNodeId the node id\n   * @returns an array of node objects that transition to the\n   * given node id\n   */\n  getNodesByToNodeId(toNodeId) {\n    const nodesByToNodeId = [];\n    if (toNodeId != null) {\n      const nodes = this.project.nodes;\n      for (let node of nodes) {\n        if (this.nodeHasTransitionToNodeId(node, toNodeId)) {\n          nodesByToNodeId.push(node);\n        }\n      }\n      const inactiveNodes = this.getInactiveNodes();\n      for (let inactiveNode of inactiveNodes) {\n        if (this.nodeHasTransitionToNodeId(inactiveNode, toNodeId)) {\n          nodesByToNodeId.push(inactiveNode);\n        }\n      }\n    }\n    return nodesByToNodeId;\n  };\n\n  /**\n   * Check if a node has a transition to the given nodeId.\n   * @param node The node to check.\n   * @param toNodeId We are looking for a transition to this node id.\n   * @returns Whether the node has a transition to the given nodeId.\n   */\n  nodeHasTransitionToNodeId(node, toNodeId) {\n    const transitions = this.getTransitionsByFromNodeId(node.id);\n    if (transitions != null) {\n      for (let transition of transitions) {\n        if (toNodeId === transition.to) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get node ids of all the nodes that have a to transition to the given node id\n   * @param toNodeId\n   * @returns all the node ids that have a transition to the given node id\n   */\n  getNodesWithTransitionToNodeId(toNodeId) {\n    const nodeIds = [];\n    const nodes = this.getNodesByToNodeId(toNodeId);\n    for (let node of nodes) {\n      nodeIds.push(node.id);\n    }\n    return nodeIds;\n  }\n\n  /**\n   * Get the group nodes that point to a given node id\n   * @param toNodeId\n   */\n  getGroupNodesByToNodeId(toNodeId) {\n    const groupsThatPointToNodeId = [];\n    if (toNodeId != null) {\n      const groups = this.getGroups();\n      for (let group of groups) {\n        if (this.nodeHasTransitionToNodeId(group, toNodeId)) {\n          groupsThatPointToNodeId.push(group);\n        }\n      }\n    }\n    return groupsThatPointToNodeId;\n  }\n\n  /**\n   * Retrieves the project JSON from Config.projectURL and returns it.\n   * If Config.projectURL is undefined, returns null.\n   */\n  retrieveProject() {\n    let projectURL = this.ConfigService.getConfigParam('projectURL');\n    if (projectURL == null) {\n      return null;\n    } else {\n      /*\n       * add a unique GET parameter value so that it always retrieves the\n       * latest version of the project file from the server and never\n       * retrieves the project from cache.\n       */\n      projectURL += '?noCache=' + (new Date()).getTime();\n    }\n\n    return this.$http.get(projectURL).then((result) => {\n      const projectJSON = result.data;\n      this.setProject(projectJSON);\n      return projectJSON;\n    });\n  };\n\n  /**\n   * Retrieve the project JSON\n   * @param projectId retrieve the project JSON with this id\n   * @return a promise to return the project JSON\n   */\n  retrieveProjectById(projectId) {\n    if (projectId != null) {\n      const configURL = window.configURL + '/' + projectId;\n      return this.$http.get(configURL).then((result) => {\n        const configJSON = result.data;\n        if (configJSON != null) {\n          const projectURL = configJSON.projectURL;\n          const previewProjectURL = configJSON.previewProjectURL;\n          if (projectURL != null) {\n            return this.$http.get(projectURL).then((result) => {\n              const projectJSON = result.data;\n              projectJSON.previewProjectURL = previewProjectURL;\n              return projectJSON;\n            });\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Saves the project to Config.saveProjectURL and returns commit history promise.\n   * if Config.saveProjectURL or Config.projectId are undefined, does not save and returns null\n   */\n  saveProject(commitMessage = \"\") {\n    this.$rootScope.$broadcast('savingProject');\n    this.cleanupBeforeSave();\n\n    const projectId = this.ConfigService.getProjectId();\n    const saveProjectURL = this.ConfigService.getConfigParam('saveProjectURL');\n    if (projectId == null || saveProjectURL == null) {\n      return null;\n    }\n\n    const authors = this.project.metadata.authors ? this.project.metadata.authors : [];\n    const userInfo = this.ConfigService.getMyUserInfo();\n    let exists = false;\n    for (let [index, author] of authors.entries()) {\n      if (author.id === userInfo.id) {\n        author = userInfo;\n        exists = true;\n        break;\n      }\n    }\n    if (!exists) {\n      authors.push(userInfo);\n    }\n    this.project.metadata.authors = authors;\n\n    const httpParams = {\n      method: 'POST',\n      url: saveProjectURL,\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n      data: $.param({\n        projectId: projectId,\n        commitMessage: commitMessage,\n        projectJSONString: angular.toJson(this.project, false)\n      })\n    };\n\n    return this.$http(httpParams).then((result) => {\n      const commitHistory = result.data;\n      this.$rootScope.$broadcast('projectSaved');\n      return commitHistory;\n    });\n  };\n\n  /**\n   * Perform any necessary cleanup before we save the project.\n   * For example we need to remove the checked field in the inactive node\n   * objects.\n   */\n  cleanupBeforeSave() {\n    let activeNodes = this.getActiveNodes();\n    for (let activeNode of activeNodes) {\n      this.cleanupNode(activeNode);\n    }\n\n    let inactiveNodes = this.getInactiveNodes();\n    for (let inactiveNode of inactiveNodes) {\n      this.cleanupNode(inactiveNode);\n    }\n  }\n\n  /**\n   * Remove any fields that are used temporarily for display purposes like when\n   * the project is loaded in the authoring tool and grading tool\n   * @param node The node object.\n   */\n  cleanupNode(node) {\n    delete node.checked;\n    delete node.hasWork;\n    delete node.hasAlert;\n    delete node.hasNewAlert;\n    delete node.isVisible;\n    delete node.completionStatus;\n    delete node.score;\n    delete node.hasScore;\n    delete node.maxScore;\n    delete node.hasMaxScore;\n    delete node.scorePct;\n    delete node.order;\n    delete node.show;\n\n    let components = node.components;\n    // activity nodes do not have components but step nodes do have components\n    if (components != null) {\n      for (let component of components) {\n        this.cleanupComponent(component);\n      }\n    }\n  }\n\n  /**\n   * Remove any fields that are used temporarily for display purposes like when\n   * the project is loaded in the authoring tool and grading tool\n   * @param component The component object.\n   */\n  cleanupComponent(component) {\n    delete component.checked;\n    delete component.hasWork;\n  }\n\n  /**\n   * Returns the theme path for the current project\n   */\n  getThemePath() {\n    const wiseBaseURL = this.ConfigService.getWISEBaseURL();\n    const project = this.project;\n    if (project && project.theme) {\n      // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n      return wiseBaseURL + '/wise5/themes/' + project.theme;\n    } else {\n      // TODO: get default theme name from ConfigService\n      return wiseBaseURL + '/wise5/themes/default';\n    }\n  };\n\n  /**\n   * Returns the theme settings for the current project\n   */\n  getThemeSettings() {\n    let themeSettings = {};\n    let project = this.project;\n    if (project && project.themeSettings) {\n      if (project.theme) {\n        // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n        themeSettings = project.themeSettings[project.theme];\n      } else {\n        // TODO: get default theme name from ConfigService\n        themeSettings = project.themeSettings[\"default\"];\n      }\n    }\n    return themeSettings ? themeSettings : {};\n  };\n\n  /**\n   * Flatten the project to obtain a list of node ids\n   * @param recalculate Whether to force recalculating the flattened node ids.\n   * @return An array of the flattened node ids in the project.\n   */\n  getFlattenedProjectAsNodeIds(recalculate) {\n    if (!recalculate && this.flattenedProjectAsNodeIds != null) {\n      // use the previously calculated flattened node ids\n      return this.flattenedProjectAsNodeIds;\n    }\n\n    const startNodeId = this.getStartNodeId();\n\n    /*\n     * an array to keep track of the node ids in the path that\n     * we are currently on as we traverse the nodes in the project\n     * depth first\n     */\n    const pathsSoFar = [];\n\n    // get all the possible paths through the project\n    const allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n    // consolidate all the paths to create a single list of node ids\n    const nodeIds = this.consolidatePaths(allPaths);\n\n    /*\n     * Remember the flattened node ids so that we don't have to calculate\n     * it again.\n     */\n    this.flattenedProjectAsNodeIds = nodeIds;\n\n    return nodeIds;\n  };\n\n  /**\n   * Get all the possible paths through the project. This function\n   * recursively calls itself to traverse the project depth first.\n   * @param pathSoFar the node ids in the path so far. the node ids\n   * in this array are referenced to make sure we don't loop back\n   * on the path.\n   * @param nodeId the node id we want to get the paths from\n   * @param includeGroups whether to include the group node ids in the paths\n   * @return an array of paths. each path is an array of node ids.\n   */\n  getAllPaths(pathSoFar, nodeId, includeGroups) {\n    const allPaths = [];\n    if (nodeId != null) {\n      if (this.isApplicationNode(nodeId)) {\n        const path = [];\n        const transitions = this.getTransitionsByFromNodeId(nodeId);\n        if (transitions != null) {\n          if (includeGroups) {\n            const parentGroup = this.getParentGroup(nodeId);\n            if (parentGroup != null) {\n              const parentGroupId = parentGroup.id;\n              if (parentGroupId != null && pathSoFar.indexOf(parentGroupId) == -1) {\n                pathSoFar.push(parentGroup.id);\n              }\n            }\n          }\n\n          /*\n           * add the node id to the path so far so we can later check\n           * which nodes are already in the path to prevent looping\n           * back in the path\n           */\n          pathSoFar.push(nodeId);\n\n          if (transitions.length === 0) {\n            /*\n             * there are no transitions from the node id so we will\n             * look for a transition in the parent group\n             */\n\n            let addedCurrentNodeId = false;\n            const parentGroupId = this.getParentGroupId(nodeId);\n            const parentGroupTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n\n            if (parentGroupTransitions != null) {\n              for (let parentGroupTransition of parentGroupTransitions) {\n                if (parentGroupTransition != null) {\n                  const toNodeId = parentGroupTransition.to;\n                  if (pathSoFar.indexOf(toNodeId) == -1) {\n                    /*\n                     * recursively get the paths by getting all\n                     * the paths for the to node\n                     */\n                    const allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                    for (let tempPath of allPathsFromToNode) {\n                      tempPath.unshift(nodeId);\n                      allPaths.push(tempPath);\n                      addedCurrentNodeId = true;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (!addedCurrentNodeId) {\n              /*\n               * if the parent group doesn't have any transitions we will\n               * need to add the current node id to the path\n               */\n              path.push(nodeId);\n              allPaths.push(path);\n            }\n          } else {\n            // there are transitions from this node id\n\n            for (let transition of transitions) {\n              if (transition != null) {\n                const toNodeId = transition.to;\n                if (toNodeId != null && pathSoFar.indexOf(toNodeId) == -1) {\n                  // we have not found the to node in the path yet so we can traverse it\n\n                  /*\n                   * recursively get the paths by getting all\n                   * the paths from the to node\n                   */\n                  const allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                  if (allPathsFromToNode != null) {\n                    for (let tempPath of allPathsFromToNode) {\n                      if (includeGroups) {\n                        // we need to add the group id to the path\n\n                        if (tempPath.length > 0) {\n                          const firstNodeId = tempPath[0];\n                          const firstParentGroupId = this.getParentGroupId(firstNodeId);\n                          const parentGroupId = this.getParentGroupId(nodeId);\n                          if (parentGroupId != firstParentGroupId) {\n                            /*\n                             * the parent ids are different which means this is a boundary\n                             * between two groups. for example if the project looked like\n                             * group1>node1>node2>group2>node3>node4\n                             * and the current node was node2 then the first node in the\n                             * path would be node3 which means we would need to place\n                             * group2 on the path before node3\n                             */\n                            tempPath.unshift(firstParentGroupId);\n                          }\n                        }\n                      }\n\n                      tempPath.unshift(nodeId);\n                      allPaths.push(tempPath);\n                    }\n                  }\n                } else {\n                  /*\n                   * the node is already in the path so far which means\n                   * the transition is looping back to a previous node.\n                   * we do not want to take this transition because\n                   * it will lead to an infinite loop. we will just\n                   * add the current node id to the path and not take\n                   * the transition which essentially ends the path.\n                   */\n                  path.push(nodeId);\n                  allPaths.push(path);\n                }\n              }\n            }\n          }\n\n          if (pathSoFar.length > 0) {\n            const lastNodeId = pathSoFar[pathSoFar.length - 1];\n            if (this.isGroupNode(lastNodeId)) {\n              /*\n               * the last node id is a group id so we will remove it\n               * since we are moving back up the path as we traverse\n               * the nodes depth first\n               */\n              pathSoFar.pop();\n            }\n          }\n\n          /*\n           * remove the latest node id (this will be a step node id)\n           * since we are moving back up the path as we traverse the\n           * nodes depth first\n           */\n          pathSoFar.pop();\n\n          if (includeGroups) {\n            if (pathSoFar.length == 1) {\n              /*\n               * we are including groups and we have traversed\n               * back up to the start node id for the project.\n               * the only node id left in pathSoFar is now the\n               * parent group of the start node id. we will\n               * now add this parent group of the start node id\n               * to all of the paths\n               */\n\n              for (let path of allPaths) {\n                if (path != null) {\n                  /*\n                   * prepend the parent group of the start node id\n                   * to the path\n                   */\n                  path.unshift(pathSoFar[0]);\n                }\n              }\n\n              /*\n               * remove the parent group of the start node id from\n               * pathSoFar which leaves us with an empty pathSoFar\n               * which means we are completely done with\n               * calculating all the paths\n               */\n              pathSoFar.pop();\n            }\n          }\n        }\n      } else if (this.isGroupNode(nodeId)) {\n\n        /*\n         * add the node id to the path so far so we can later check\n         * which nodes are already in the path to prevent looping\n         * back in the path\n         */\n        pathSoFar.push(nodeId);\n\n        const groupNode = this.getNodeById(nodeId);\n        if (groupNode != null) {\n          const startId = groupNode.startId;\n          if (startId == null || startId == \"\") {\n            // there is no start id so we will take the transition from the group\n            // TODO? there is no start id so we will loop through all the child nodes\n\n            const transitions = this.getTransitionsByFromNodeId(groupNode.id);\n            if (transitions != null && transitions.length > 0) {\n              for (let transition of transitions) {\n                if (transition != null) {\n                  const toNodeId = transition.to;\n\n                  const allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                  if (allPathsFromToNode != null) {\n                    for (let tempPath of allPathsFromToNode) {\n                      tempPath.unshift(nodeId);\n                      allPaths.push(tempPath);\n                    }\n                  }\n                }\n              }\n            } else {\n              /*\n               * this activity does not have any transitions so\n               * we have reached the end of this path\n               */\n\n              const tempPath = [];\n              tempPath.unshift(nodeId);\n              allPaths.push(tempPath);\n            }\n          } else {\n            // there is a start id so we will traverse it\n\n            const allPathsFromToNode = this.getAllPaths(pathSoFar, startId, includeGroups);\n\n            if (allPathsFromToNode != null) {\n              for (let tempPath of allPathsFromToNode) {\n                tempPath.unshift(nodeId);\n                allPaths.push(tempPath);\n              }\n            }\n          }\n        }\n\n        /*\n         * remove the latest node id since we are moving back\n         * up the path as we traverse the nodes depth first\n         */\n        pathSoFar.pop();\n      }\n    }\n    return allPaths;\n  };\n\n  /**\n   * Consolidate all the paths into a linear list of node ids\n   * @param paths an array of paths. each path is an array of node ids.\n   * @return an array of node ids that have been properly ordered\n   */\n  consolidatePaths(paths) {\n    let consolidatedPath = [];\n\n    if (paths != null) {\n      /*\n       * continue until all the paths are empty. as we consolidate\n       * node ids, we will remove them from the paths. once all the\n       * paths are empty we will be done consolidating the paths.\n       */\n      while(!this.arePathsEmpty(paths)) {\n        // start with the first path\n        const currentPath = this.getNonEmptyPathIndex(paths);\n\n        // get the first node id in the current path\n        const nodeId = this.getFirstNodeIdInPathAtIndex(paths, currentPath);\n        if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n          // the first node ids in all the paths are the same\n\n          // remove the node id from all the paths\n          this.removeNodeIdFromPaths(nodeId, paths);\n\n          // add the node id to our consolidated path\n          consolidatedPath.push(nodeId);\n        } else {\n          // not all the top node ids are the same which means we have branched\n\n          // get all the paths that contain the node id\n          const pathsThatContainNodeId = this.getPathsThatContainNodeId(nodeId, paths);\n\n          if (pathsThatContainNodeId != null) {\n            if (pathsThatContainNodeId.length === 1) {\n              // only the current path we are on has the node id\n\n              // remove the node id from the path\n              this.removeNodeIdFromPath(nodeId, paths, currentPath);\n\n              // add the node id to our consolidated path\n              consolidatedPath.push(nodeId);\n            } else {\n              // there are multiple paths that have this node id\n\n              // consume all the node ids up to the given node id\n              const consumedPath = this.consumePathsUntilNodeId(paths, nodeId);\n\n              // remove the node id from the paths\n              this.removeNodeIdFromPaths(nodeId, paths);\n\n              // add the node id to the end of the consumed path\n              consumedPath.push(nodeId);\n\n              // add the consumed path to our consolidated path\n              consolidatedPath = consolidatedPath.concat(consumedPath);\n            }\n          }\n        }\n      }\n    }\n    return consolidatedPath;\n  };\n\n  /**\n   * Consume the node ids in the paths until we get to the given node id\n   * @param paths the paths to consume\n   * @param nodeId the node id to stop consuming at\n   * @return an array of node ids that we have consumed\n   */\n  consumePathsUntilNodeId(paths, nodeId) {\n    let consumedNodes = [];\n    for (let path of paths) {\n      if (path.includes(nodeId)) {\n        let subPath = path.slice(0, path.indexOf(nodeId));\n        for (let nodeIdInPath of subPath) {\n          if (!consumedNodes.includes(nodeIdInPath)) {\n            consumedNodes.push(nodeIdInPath);\n          }\n        }\n      }\n    }\n    return consumedNodes;\n  }\n\n  /**\n   * Get the path at the given index and get the first node id in\n   * the path\n   * @param paths an array of paths. each path is an array of node ids\n   * @param index the index of the path we want\n   * @return the first node in the given path\n   */\n  getFirstNodeIdInPathAtIndex(paths, index) {\n    let nodeId = null;\n    if (paths != null && index != null) {\n      const path = paths[index];\n      if (path != null && path.length > 0) {\n        nodeId = path[0];\n      }\n    }\n    return nodeId;\n  };\n\n  /**\n   * Remove the node ifrom the paths\n   * @param nodeId the node id to remove\n   * @param paths an array of paths. each path is an array of node ids\n   */\n  removeNodeIdFromPaths(nodeId, paths) {\n    if (nodeId != null && paths != null) {\n      for (let path of paths) {\n        for (let x = 0; x < path.length; x++) {\n          const tempNodeId = path[x];\n\n          /*\n           * check if the node id matches the one we are looking\n           * for\n           */\n          if (nodeId === tempNodeId) {\n            /*\n             * we have found the node id we are looking for so\n             * we will remove it from the path\n             */\n            path.splice(x, 1);\n\n            /*\n             * move the counter back since we just removed a\n             * node id. we will continue searching this path\n             * for the node id in case the path contains it\n             * multiple times.\n             */\n            x--;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Remove the node id from the path\n   * @param nodeId the node id to remove\n   * @param paths an array of paths. each path is an array of node ids\n   * @param pathIndex the path to remove from\n   */\n  removeNodeIdFromPath(nodeId, paths, pathIndex) {\n    if (nodeId != null && paths != null && pathIndex != null) {\n      const path = paths[pathIndex];\n      if (path != null) {\n        for (let x = 0; x < path.length; x++) {\n          const tempNodeId = path[x];\n\n          /*\n           * check if the node id matches the one we are looking\n           * for\n           */\n          if (nodeId === tempNodeId) {\n            /*\n             * we have found the node id we are looking for so\n             * we will remove it from the path\n             */\n            path.splice(x, 1);\n\n            /*\n             * move the counter back since we just removed a\n             * node id. we will continue searching this path\n             * for the node id in case the path contains it\n             * multiple times.\n             */\n            x--;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Check if the first node ids in the paths are the same\n   * @param paths an array of paths. each path is an array of node ids\n   * @return whether all the paths have the same first node id\n   */\n  areFirstNodeIdsInPathsTheSame(paths) {\n    let result = true;\n    let nodeId = null;\n    if (paths != null) {\n      for (let path of paths) {\n        const tempNodeId = path[0];\n        if (nodeId == null) {\n          /*\n           * this is the first path we have looked at so we will\n           * remember the node id\n           */\n          nodeId = tempNodeId;\n        } else if (nodeId != tempNodeId) {\n          /*\n           * the node id does not match the first node id from a\n           * previous path so the paths do not all have the same\n           * first node id\n           */\n          result = false;\n          break;\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Check if all the paths are empty\n   * @param paths an array of paths. each path is an array of node ids\n   * @return whether all the paths are empty\n   */\n  arePathsEmpty(paths) {\n    if (paths != null) {\n      for (let path of paths) {\n        if (path != null) {\n          if (path.length !== 0) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  };\n\n  /**\n   * Get the paths that contain the node id\n   * @param nodeId the node id we are looking for\n   * @param paths an array of paths. each path is an array of node ids\n   * @return an array of paths that contain the given node id\n   */\n  getPathsThatContainNodeId(nodeId, paths) {\n    const pathsThatContainNodeId = [];\n    if (nodeId != null && paths != null) {\n      for (let path of paths) {\n        // check if the path contains the node id\n        if (path.indexOf(nodeId) != -1) {\n          /*\n           * add the path to the array of paths that contain\n           * the node id\n           */\n          pathsThatContainNodeId.push(path);\n        }\n      }\n    }\n    return pathsThatContainNodeId;\n  };\n\n  /**\n   * Get a non empty path index. It will loop through the paths and\n   * return the index of the first non empty path.\n   * @param paths an array of paths. each path is an array of node ids\n   * @return the index of the path that is not empty\n   */\n  getNonEmptyPathIndex(paths) {\n    if (paths != null) {\n      for (let p = 0; p < paths.length; p++) {\n        const path = paths[p];\n        if (path.length !== 0) {\n          return p;\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Remember the branches.\n   * @param branches An array of arrays of node ids.\n   */\n  setBranchesCache(branches) {\n    this.branchesCache = branches;\n  }\n\n  /**\n   * Get the branches that were previously calculated.\n   * @returns An array of arrays of node ids.\n   */\n  getBranchesCache() {\n    return this.branchesCache;\n  }\n\n  clearBranchesCache() {\n    this.branchesCache = null;\n  }\n\n  getBranches() {\n    /*\n     * Do not use the branches cache in the authoring tool because the branches\n     * may change when the author changes the project. In all other modes the\n     * branches can't change so we can use the cache.\n     */\n    if (this.ConfigService.getMode() != 'author') {\n      let branchesCache = this.getBranchesCache();\n      if (branchesCache != null) {\n        return branchesCache;\n      }\n    }\n\n    const startNodeId = this.getStartNodeId();\n\n    /*\n     * an array to keep track of the node ids in the path that\n     * we are currently on as we traverse the nodes in the project\n     * depth first\n     */\n    const pathsSoFar = [];\n\n    const allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n    const branches = this.findBranches(allPaths);\n    if (this.ConfigService.getMode() != 'author') {\n      this.setBranchesCache(branches);\n    }\n    return branches;\n  };\n\n  /**\n   * Find the branches in the project\n   * @param paths all the possible paths through the project\n   * @return an array of branch objects. each branch object contains\n   * the branch start point, the branch paths, and the branch\n   * end point\n   */\n  findBranches(paths) {\n    let branches = [];\n    let previousNodeId = null;\n\n    /*\n     * continue until all the paths are empty. we will remove\n     * node ids from the paths as we traverse the paths to find\n     * the branches\n     */\n    while (!this.arePathsEmpty(paths)) {\n      const nodeId = this.getFirstNodeIdInPathAtIndex(paths, 0);\n\n      if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n        // the first node ids in all the paths are the same\n\n        this.removeNodeIdFromPaths(nodeId, paths);\n        previousNodeId = nodeId;\n      } else {\n        // not all the top node ids are the same which means we have branched\n\n        const branchMetaObject = this.createBranchMetaObject(previousNodeId);\n        branchMetaObject.branchStartPoint = previousNodeId;\n\n        const nextCommonNodeId = this.findNextCommonNodeId(paths);\n        branchMetaObject.branchEndPoint = nextCommonNodeId;\n\n        let branchPaths = this.extractPathsUpToNodeId(paths, nextCommonNodeId);\n        branchPaths = this.removeDuplicatePaths(branchPaths);\n        branchMetaObject.branchPaths = branchPaths;\n        branches.push(branchMetaObject);\n\n        // trim the paths so that they start at the branch end point\n        this.trimPathsUpToNodeId(paths, nextCommonNodeId);\n\n        // remember this node id for the next iteration of the loop\n        previousNodeId = nextCommonNodeId;\n      }\n    }\n    return branches;\n  };\n\n  /**\n   * Create a branch meta object that will contain the branch start\n   * point, branch paths, and branch end point\n   * @return an object that contains a branch start point, branch paths,\n   * and a branch end point\n   */\n  createBranchMetaObject() {\n    const branchMetaObject = {};\n    branchMetaObject.branchStartPoint = null;\n    branchMetaObject.branchPaths = [];\n    branchMetaObject.branchEndPoint = null;\n    return branchMetaObject;\n  };\n\n  /**\n   * Find the next common node id in all the paths\n   * @param paths the paths to find the common node id in\n   * @return a node id that is in all the paths or null\n   * if there is no node id that is in all the paths\n   */\n  findNextCommonNodeId(paths) {\n    let nextCommonNodeId = null;\n    if (paths != null) {\n      if (paths.length > 0) {\n        const path = paths[0];\n        for (let tempNodeId of path) {\n          if (this.allPathsContainNodeId(paths, tempNodeId)) {\n            /*\n             * the node id is in all the paths so we have found\n             * what we were looking for\n             */\n            nextCommonNodeId = tempNodeId;\n            break;\n          }\n        }\n      }\n    }\n    return nextCommonNodeId;\n  };\n\n  /**\n   * Check if all the paths contain the node id\n   * @param paths an array of paths. each path contains an array of node ids\n   * @param nodeId the node id that we will check is in all the paths\n   * @return whether the node id is in all the paths\n   */\n  allPathsContainNodeId(paths, nodeId) {\n    let result = false;\n    if (paths != null) {\n      for (let path of paths) {\n        const index = path.indexOf(nodeId);\n        if (index == -1) {\n          result = false;\n          break;\n        } else {\n          result = true;\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Trim the paths up to the given node id so that the paths will contain\n   * the given node id and all the node ids after it. This function will\n   * modify the paths.\n   * @param paths the paths to trim\n   * @param nodeId the node id to trim up to\n   */\n  trimPathsUpToNodeId(paths, nodeId) {\n    if (paths != null) {\n      for (let path of paths) {\n        if (path != null) {\n          let index = path.indexOf(nodeId);\n\n          if (index == -1) {\n            /*\n             * the node id is not in the path so we will\n             * trim the path to the end which will make\n             * the path empty\n             */\n            index = path.length;\n          }\n\n          /*\n           * trim the path up to the node id index. this will\n           * modify the path array.\n           */\n          path.splice(0, index);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Extract the paths up to a given node id. This will be used to\n   * obtain branch paths.\n   * @param paths the paths to extract from\n   * @param nodeId the node id to extract up to\n   * @return paths that go up to but do not include the node id\n   */\n  extractPathsUpToNodeId(paths, nodeId) {\n    const extractedPaths = [];\n    if (paths != null) {\n      for (let path of paths) {\n        if (path != null) {\n          let index = path.indexOf(nodeId);\n          if (index == -1) {\n            /*\n             * the node id is not in the path so we will\n             * extract up to the end of the path\n             */\n            index = path.length;\n          }\n\n          /*\n           * get the path up to the node id index. this does\n           * not modify the path array.\n           */\n          const extractedPath = path.slice(0, index);\n          extractedPaths.push(extractedPath);\n        }\n      }\n    }\n    return extractedPaths;\n  };\n\n  /**\n   * Removes duplicate paths\n   * @param paths an array of paths. each path contains an array of node ids\n   * @return an array of unique paths\n   */\n  removeDuplicatePaths(paths) {\n    const uniquePaths = [];\n    if (paths != null) {\n      for (let path of paths) {\n        let isPathInUniquePaths = false;\n        for (let uniquePath of uniquePaths) {\n          if (this.pathsEqual(path, uniquePath)) {\n            isPathInUniquePaths = true;\n          }\n        }\n\n        if (!isPathInUniquePaths) {\n          // the path is not equal to any paths in the unique\n          // paths array so we will add it to the unique paths array\n          uniquePaths.push(path);\n        }\n      }\n    }\n    return uniquePaths;\n  };\n\n  /**\n   * Check if two paths are equal\n   * @param path1 an array of node ids\n   * @param path2 an array of node ids\n   * @return whether the two paths contain the same node ids\n   * in the same order\n   */\n  pathsEqual(path1, path2) {\n    let result = false;\n    if (path1 != null && path2 != null) {\n      if (path1.length === path2.length) {\n        result = true;\n\n        for (let x = 0; x < path1.length; x++) {\n          const path1NodeId = path1[x];\n          const path2NodeId = path2[x];\n          if (path1NodeId !== path2NodeId) {\n            result = false;\n            break;\n          }\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Check if a node id is in any branch\n   * @param branches an array of branch objects\n   * @param nodeId the node id to check\n   * @return whether the node id is in any branch\n   */\n  isNodeIdInABranch(branches, nodeId) {\n    if (branches != null && nodeId != null) {\n      for (let branch of branches) {\n        if (branch != null) {\n          const branchPaths = branch.branchPaths;\n          if (branchPaths != null) {\n            for (let branchPath of branchPaths) {\n              if (branchPath != null) {\n                const index = branchPath.indexOf(nodeId);\n                if (index != -1) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Get the branch paths that a node id is in\n   * @param branches an array of branch objects\n   * @param nodeId the node id to check\n   * @return an array of the branch paths that the node id is in\n   */\n  getBranchPathsByNodeId(branches, nodeId) {\n    const branchPathsIn = [];\n    if (branches != null && nodeId != null) {\n      for (let branch of branches) {\n        if (branch != null) {\n          const branchPaths = branch.branchPaths;\n          if (branchPaths != null) {\n            for (let branchPath of branchPaths) {\n              if (branchPath != null) {\n                const index = branchPath.indexOf(nodeId);\n                if (index != -1) {\n                  /*\n                   * the node is in this branch path so we will\n                   * add the branch path to our array\n                   */\n                  branchPathsIn.push(branchPath);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return branchPathsIn;\n  }\n\n  /**\n   * Get the component by node id and component id\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns the component or null if the nodeId or componentId are null or does not exist in the project.\n   */\n  getComponentByNodeIdAndComponentId(nodeId, componentId) {\n    if (nodeId != null && componentId != null) {\n      const components = this.getComponentsByNodeId(nodeId);\n      for (let tempComponent of components) {\n        if (tempComponent != null) {\n          const tempComponentId = tempComponent.id;\n          if (componentId === tempComponentId) {\n            return tempComponent;\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Returns the position of the component in the node by node id and\n   * component id, 0-indexed.\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns the component's position or -1 if nodeId or componentId are null\n   * or doesn't exist in the project.\n   */\n  getComponentPositionByNodeIdAndComponentId(nodeId, componentId) {\n    if (nodeId != null && componentId != null) {\n      const components = this.getComponentsByNodeId(nodeId);\n      for (let c = 0; c < components.length; c++) {\n        const tempComponent = components[c];\n        if (tempComponent != null) {\n          const tempComponentId = tempComponent.id;\n          if (componentId === tempComponentId) {\n            return c;\n          }\n        }\n      }\n    }\n    return -1;\n  };\n\n  /**\n   * Get the components in a node\n   * @param nodeId the node id\n   * @returns an array of components or empty array if nodeId is null or\n   * doesn't exist in the project.\n   * if the node exists but doesn't have any components, returns an empty array.\n   */\n  getComponentsByNodeId(nodeId) {\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        if (node.components != null) {\n          return node.components;\n        }\n      }\n    }\n    return [];\n  };\n\n\n  // TODO: how is this different from straight-up calling getNodeById?\n  getNodeContentByNodeId(nodeId) {\n    if (nodeId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        return node;\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Insert the node after the given node id in the group's\n   * array of children ids\n   * @param nodeIdToInsert the node id we want to insert\n   * @param nodeIdToInsertAfter the node id we want to insert after\n   */\n  insertNodeAfterInGroups(nodeIdToInsert, nodeIdToInsertAfter) {\n    const groupNodes = this.getGroupNodes();\n    if (groupNodes != null) {\n      for (let group of groupNodes) {\n        if (group != null) {\n          this.insertNodeAfterInGroup(group, nodeIdToInsert, nodeIdToInsertAfter);\n        }\n      }\n    }\n    const inactiveGroupNodes = this.getInactiveGroupNodes();\n    if (inactiveGroupNodes != null) {\n      for (let inactiveGroup of inactiveGroupNodes) {\n        if (inactiveGroup != null) {\n          this.insertNodeAfterInGroup(inactiveGroup, nodeIdToInsert, nodeIdToInsertAfter);\n        }\n      }\n    }\n  }\n\n  /**\n   * Insert a node id in a group after another specific node id.\n   * @param group A group object.\n   * @param nodeIdToInsert The node id to insert.\n   * @param nodeIdToInsertAfter The node id to insert after.\n   * @returns {boolean} Whether we inserted the node id.\n   */\n  insertNodeAfterInGroup(group, nodeIdToInsert, nodeIdToInsertAfter) {\n    const ids = group.ids;\n    if (ids != null) {\n      for (let i = 0; i < ids.length; i++) {\n        const id = ids[i];\n        if (nodeIdToInsertAfter === id) {\n          ids.splice(i + 1, 0, nodeIdToInsert);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Update the transitions to handle inserting a node after another node.\n   * The two nodes must either both be steps or both be activities.\n   * @param nodeToInsert the node to insert\n   * @param nodeIdToInsertAfter the node id to insert after\n   */\n  insertNodeAfterInTransitions(nodeToInsert, nodeIdToInsertAfter) {\n    const nodeToInsertAfter = this.getNodeById(nodeIdToInsertAfter);\n    if (nodeToInsert.type != nodeToInsertAfter.type) {\n      throw 'Error: insertNodeAfterInTransitions() nodes are not the same type';\n    }\n    if (nodeToInsertAfter.transitionLogic == null) {\n      nodeToInsertAfter.transitionLogic = {\n        transitions: []\n      };\n    }\n    if (nodeToInsert.transitionLogic == null) {\n      nodeToInsert.transitionLogic = {\n        transitions: []\n      };\n    }\n    if (this.isGroupNode(nodeToInsert.id)) {\n      this.updateChildrenTransitionsInAndOutOfGroup(nodeToInsert, nodeIdToInsertAfter);\n    }\n    this.copyTransitions(nodeToInsertAfter, nodeToInsert);\n    if (nodeToInsert.transitionLogic.transitions.length == 0) {\n      this.copyParentTransitions(nodeIdToInsertAfter, nodeToInsert);\n    }\n    const transitionObject = {\n      to: nodeToInsert.id\n    };\n    nodeToInsertAfter.transitionLogic.transitions = [transitionObject];\n    this.updateBranchPathTakenConstraints(nodeToInsert, nodeIdToInsertAfter);\n  }\n\n  /*\n   * Copy the transitions from nodeId's parent and add to node's transitions.\n   * @param nodeId Copy the transition of this nodeId's parent.\n   * @param node The node to add transitions to.\n   */\n  copyParentTransitions(nodeId, node) {\n    const parentGroupId = this.getParentGroupId(nodeId);\n    if (parentGroupId != 'group0') {\n      const parentTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n      for (let parentTransition of parentTransitions) {\n        const newTransition = {};\n        const toNodeId = parentTransition.to;\n        if (this.isGroupNode(toNodeId)) {\n          const startId = this.getGroupStartId(toNodeId);\n          if (startId == null || startId == '') {\n            newTransition.to = toNodeId;\n          } else {\n            newTransition.to = startId;\n          }\n        }\n        node.transitionLogic.transitions.push(newTransition);\n      }\n    }\n  }\n\n  copyTransitions(previousNode, node) {\n    const transitionsJSONString = angular.toJson(previousNode.transitionLogic.transitions);\n    const transitionsCopy = angular.fromJson(transitionsJSONString);\n    node.transitionLogic.transitions = transitionsCopy;\n  }\n\n  /**\n   * If the previous node was in a branch path, we will also put the\n   * inserted node into the branch path.\n   * @param node The node that is in the branch path.\n   * @param nodeId The node we are adding to the branch path.\n   */\n  updateBranchPathTakenConstraints(node, nodeId) {\n    this.removeBranchPathTakenNodeConstraintsIfAny(node.id);\n    const branchPathTakenConstraints = this.getBranchPathTakenConstraintsByNodeId(nodeId);\n    for (let branchPathTakenConstraint of branchPathTakenConstraints) {\n      const newConstraint = {\n        id: this.getNextAvailableConstraintIdForNodeId(node.id),\n        action: branchPathTakenConstraint.action,\n        targetId: node.id,\n        removalCriteria: this.UtilService.makeCopyOfJSONObject(branchPathTakenConstraint.removalCriteria)\n      };\n      this.addConstraintToNode(newConstraint);\n    }\n  }\n\n  /**\n   * Update a node's branchPathTaken constraint's fromNodeId and toNodeId\n   * @param node update the branch path taken constraints in this node\n   * @param currentFromNodeId the current from node id\n   * @param currentToNodeId the current to node id\n   * @param newFromNodeId the new from node id\n   * @param newToNodeId the new to node id\n   */\n  updateBranchPathTakenConstraint(node, currentFromNodeId, currentToNodeId,\n      newFromNodeId, newToNodeId) {\n    for (let constraint of node.constraints) {\n      for (let removalCriterion of constraint.removalCriteria) {\n        if (removalCriterion.name === 'branchPathTaken') {\n          const params = removalCriterion.params;\n          if (params.fromNodeId === currentFromNodeId &&\n            params.toNodeId === currentToNodeId) {\n            params.fromNodeId = newFromNodeId;\n            params.toNodeId = newToNodeId;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Insert a node into a group\n   * @param nodeIdToInsert the node id to insert\n   * @param nodeIdToInsertInside the node id of the group we will insert into\n   */\n  insertNodeInsideInGroups(nodeIdToInsert, nodeIdToInsertInside) {\n    const group = this.getNodeById(nodeIdToInsertInside);\n    if (group != null) {\n      const ids = group.ids;\n      if (ids != null) {\n        ids.splice(0, 0, nodeIdToInsert);\n        group.startId = nodeIdToInsert;\n      }\n    }\n  }\n\n  /**\n   * Update the transitions to handle inserting a node as the first step in a group.\n   * @param nodeIdToInsert node id that we will insert\n   * @param nodeIdToInsertInside the node id of the group we are inserting into\n   */\n  insertNodeInsideOnlyUpdateTransitions(nodeIdToInsert, nodeIdToInsertInside) {\n    if (!this.isGroupNode(nodeIdToInsertInside)) {\n      throw 'Error: insertNodeInsideOnlyUpdateTransitions() second parameter must be a group';\n    }\n\n    const nodeToInsert = this.getNodeById(nodeIdToInsert);\n    nodeToInsert.transitionLogic.transitions = [];\n    this.removeBranchPathTakenNodeConstraintsIfAny(nodeIdToInsert);\n\n    if (this.isGroupNode(nodeIdToInsert)) {\n      this.updateChildrenTransitionsInAndOutOfGroup(nodeToInsert);\n    }\n\n    /*\n     * the node will become the first node in the group. this means we need to update any nodes\n     * that point to the old start id and make them point to the node we are inserting.\n     */\n    const group = this.getNodeById(nodeIdToInsertInside);\n    const startId = group.startId;\n    this.updateTransitionsToStartId(startId, nodeIdToInsert);\n    this.updateStepTransitionsToGroup(nodeIdToInsertInside, nodeIdToInsert);\n    this.createTransitionFromNodeToInsertToOldStartNode(startId, nodeToInsert);\n    const transitions = this.getTransitionsByFromNodeId(nodeIdToInsert);\n    if (transitions.length == 0) {\n      this.inheritParentTransitions(nodeIdToInsertInside, nodeToInsert);\n    }\n  }\n\n  /**\n   * Copy the transitions from the parent to the node we are inserting.\n   * @param nodeIdToInsertInside\n   * @param nodeToInsert\n   */\n  inheritParentTransitions(nodeIdToInsertInside, nodeToInsert) {\n    const parentTransitions = this.getTransitionsByFromNodeId(nodeIdToInsertInside);\n    for (let parentTransition of parentTransitions) {\n      const toNodeId = parentTransition.to;\n      if (this.isGroupNode(toNodeId)) {\n        const nextGroup = this.getNodeById(toNodeId);\n        const startId = nextGroup.startId;\n        if (startId == null || startId == '') {\n          this.addToTransition(nodeToInsert, toNodeId);\n        } else {\n          this.addToTransition(nodeToInsert, startId);\n        }\n      } else {\n        this.addToTransition(nodeToInsert, toNodeId);\n      }\n    }\n  }\n\n  /*\n   * Create a transition from the node we are inserting to the node that\n   * was the start node.\n   * @param startId\n   * @param nodeToInsert\n   */\n  createTransitionFromNodeToInsertToOldStartNode(startId, nodeToInsert) {\n    const startNode = this.getNodeById(startId);\n    if (startNode != null) {\n      const transitions = this.getTransitionsByFromNodeId(nodeToInsert.id);\n      const transitionObject = {\n        to: startId\n      };\n      transitions.push(transitionObject);\n    }\n  }\n\n  /*\n   * Update all the transitions that point to the group and change\n   * them to point to the new start id\n   */\n  updateStepTransitionsToGroup(nodeIdToInsertInside, nodeIdToInsert) {\n    const nodesThatTransitionToGroup = this.getNodesByToNodeId(nodeIdToInsertInside);\n    for (let nodeThatTransitionsToGroup of nodesThatTransitionToGroup) {\n      if (!this.isGroupNode(nodeThatTransitionsToGroup.id)) {\n        this.updateToTransition(nodeThatTransitionsToGroup, nodeIdToInsertInside, nodeIdToInsert);\n      }\n    }\n  }\n\n  updateTransitionsToStartId(startId, nodeIdToInsert) {\n    const nodesThatTransitionToStartId = this.getNodesByToNodeId(startId);\n    for (let nodeThatTransitionToStartId of nodesThatTransitionToStartId) {\n      this.updateToTransition(nodeThatTransitionToStartId, startId, nodeIdToInsert);\n    }\n  }\n\n  /**\n   * Add a transition to a node\n   * @param node the node we are adding a transition to\n   * @param toNodeId the node id we going to transition to\n   * @param criteria (optional) a criteria object specifying\n   * what needs to be satisfied in order to use this transition\n   */\n  addToTransition(node, toNodeId, criteria) {\n    if (node != null) {\n      if (node.transitionLogic == null) {\n        node.transitionLogic = {};\n      }\n      if (node.transitionLogic.transitions == null) {\n        node.transitionLogic.transitions = [];\n      }\n      const transition = {};\n      transition.to = toNodeId;\n      if (criteria != null) {\n        transition.criteria = criteria;\n      }\n      node.transitionLogic.transitions.push(transition);\n    }\n  }\n\n  /**\n   * Update the to value of aa transition\n   * @param node the node to update\n   * @param oldToNodeId the previous to node id\n   * @param newToNodeId the new to node id\n   */\n  updateToTransition(node, oldToNodeId, newToNodeId) {\n    if (node != null) {\n      if (node.transitionLogic == null) {\n        node.transitionLogic = {};\n      }\n\n      if (node.transitionLogic.transitions == null) {\n        node.transitionLogic.transitions = [];\n      }\n\n      const transitions = node.transitionLogic.transitions;\n      for (let transition of transitions) {\n        if (transition != null) {\n          const toNodeId = transition.to;\n          if (oldToNodeId === toNodeId) {\n            transition.to = newToNodeId;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param group The group object.\n   * @returns {Array} The nodes in the group that do not have transitions.\n   */\n  getChildNodesWithoutTransitions(group) {\n    const lastNodes = [];\n    for (let childId of group.ids) {\n      const child = this.getNodeById(childId);\n      const transitionLogic = child.transitionLogic;\n      const transitions = transitionLogic.transitions;\n      if (transitions.length == 0) {\n        lastNodes.push(child);\n      }\n    }\n    return lastNodes;\n  }\n\n  /**\n   * Get the next available group id\n   * @returns the next available group id\n   */\n  getNextAvailableGroupId() {\n    const groupIds = this.getGroupIds();\n    let largestGroupIdNumber = null;\n    for (let groupId of groupIds) {\n      // get the number from the group id e.g. the number of 'group2' would be 2\n      let groupIdNumber = groupId.replace('group', '');\n\n      // make sure the number is an actual number\n      if (!isNaN(groupIdNumber)) {\n        groupIdNumber = parseInt(groupIdNumber);\n\n        // update the largest group id number if necessary\n        if (largestGroupIdNumber == null) {\n          largestGroupIdNumber = groupIdNumber;\n        } else if (groupIdNumber > largestGroupIdNumber) {\n          largestGroupIdNumber = groupIdNumber;\n        }\n      }\n    }\n\n    const nextAvailableGroupId = 'group' + (largestGroupIdNumber + 1);\n    return nextAvailableGroupId;\n  }\n\n  /**\n   * Get all the group ids\n   * @returns an array with all the group ids\n   */\n  getGroupIds() {\n    const groupIds = [];\n    const groupNodes = this.groupNodes;\n    for (let group of groupNodes) {\n      if (group != null) {\n        const groupId = group.id;\n        if (groupId != null) {\n          groupIds.push(groupId);\n        }\n      }\n    }\n\n    const inactiveGroupNodes = this.getInactiveGroupNodes();\n    for (let inactiveGroup of inactiveGroupNodes) {\n      if (inactiveGroup != null) {\n        const inactiveGroupId = inactiveGroup.id;\n        if (inactiveGroupId != null) {\n          groupIds.push(inactiveGroupId);\n        }\n      }\n    }\n    return groupIds;\n  }\n\n  /**\n   * Get the next available node id\n   * @param nodeIdsToSkip (optional) An array of additional node ids to not\n   * use. This parameter is used in cases where we are creating multiple new\n   * nodes at once.\n   * Example\n   * We ask for two new node ids by calling getNextAvailableNodeId() twice.\n   * The first time it returns \"node10\".\n   * If we ask the second time without actually creating and adding node10,\n   * it will return \"node10\" again. If we provide \"node10\" in the\n   * nodeIdsToSkip, then getNextAvailableNodeId() will properly return to us\n   * \"node11\".\n   * @returns the next available node id\n   */\n  getNextAvailableNodeId(nodeIdsToSkip) {\n    const nodeIds = this.getNodeIds();\n    let largestNodeIdNumber = null;\n\n    for (let nodeId of nodeIds) {\n      // get the number from the node id e.g. the number of 'node2' would be 2\n      let nodeIdNumber = nodeId.replace('node', '');\n\n      // make sure the number is an actual number\n      if (!isNaN(nodeIdNumber)) {\n        nodeIdNumber = parseInt(nodeIdNumber);\n\n        // update the largest node id number if necessary\n        if (largestNodeIdNumber == null) {\n          largestNodeIdNumber = nodeIdNumber;\n        } else if (nodeIdNumber > largestNodeIdNumber) {\n          largestNodeIdNumber = nodeIdNumber;\n        }\n      }\n    }\n\n    const inactiveNodeIds = this.getInactiveNodeIds();\n    for (let inactiveNodeId of inactiveNodeIds) {\n      // get the number from the node id e.g. the number of 'node2' would be 2\n      let nodeIdNumber = inactiveNodeId.replace('node', '');\n\n      if (!isNaN(nodeIdNumber)) {\n        nodeIdNumber = parseInt(nodeIdNumber);\n\n        // update the largest node id number if necessary\n        if (largestNodeIdNumber == null) {\n          largestNodeIdNumber = nodeIdNumber;\n        } else if (nodeIdNumber > largestNodeIdNumber) {\n          largestNodeIdNumber = nodeIdNumber;\n        }\n      }\n    }\n\n    if (nodeIdsToSkip != null) {\n      for (let nodeIdToSkip of nodeIdsToSkip) {\n        // get the number from the node id e.g. the number of 'node2' would be 2\n        let nodeIdNumber = nodeIdToSkip.replace('node', '');\n\n        if (!isNaN(nodeIdNumber)) {\n          nodeIdNumber = parseInt(nodeIdNumber);\n\n          // update the largest node id number if necessary\n          if (largestNodeIdNumber == null) {\n            largestNodeIdNumber = nodeIdNumber;\n          } else if (nodeIdNumber > largestNodeIdNumber) {\n            largestNodeIdNumber = nodeIdNumber;\n          }\n        }\n      }\n    }\n    return 'node' + (largestNodeIdNumber + 1);\n  }\n\n  /**\n   * Get all the node ids from steps (not groups)\n   * @returns an array with all the node ids\n   */\n  getNodeIds() {\n    const nodeIds = [];\n    for (let node of this.applicationNodes) {\n      const nodeId = node.id;\n      if (nodeId != null) {\n        nodeIds.push(nodeId);\n      }\n    }\n    return nodeIds;\n  }\n\n  /**\n   * Get all the node ids from inactive steps\n   * @returns an array with all the inactive node ids\n   */\n  getInactiveNodeIds() {\n    const nodeIds = [];\n    const inactiveNodes = this.project.inactiveNodes;\n    if (inactiveNodes != null) {\n      for (let inactiveNode of inactiveNodes) {\n        if (inactiveNode != null) {\n          const nodeId = inactiveNode.id;\n          if (nodeId != null) {\n            nodeIds.push(nodeId);\n          }\n        }\n      }\n    }\n    return nodeIds;\n  }\n\n  /**\n   * Move nodes inside a group node\n   * @param nodeIds the node ids to move\n   * @param nodeId the node id of the group we are moving the nodes inside\n   */\n  moveNodesInside(nodeIds, nodeId) {\n    const movedNodes = [];\n\n    for (let n = 0; n < nodeIds.length; n++) {\n      const tempNodeId = nodeIds[n];\n      const tempNode = this.getNodeById(tempNodeId);\n      movedNodes.push(tempNode);\n\n      const movingNodeIsActive = this.isActive(tempNodeId);\n      const stationaryNodeIsActive = this.isActive(nodeId);\n\n      if (movingNodeIsActive && stationaryNodeIsActive) {\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n\n        if (n == 0) {\n          /*\n           * this is the first node we are moving so we will insert it\n           * into the beginning of the group\n           */\n          this.insertNodeInsideOnlyUpdateTransitions(tempNodeId, nodeId);\n          this.insertNodeInsideInGroups(tempNodeId, nodeId);\n        } else {\n          /*\n           * this is not the first node we are moving so we will insert\n           * it after the node we previously inserted\n           */\n          this.insertNodeAfterInTransitions(tempNode, nodeId);\n          this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        }\n      } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n\n        if (n == 0) {\n          /*\n           * this is the first node we are moving so we will insert it\n           * into the beginning of the group\n           */\n          this.moveFromActiveToInactiveInsertInside(tempNode, nodeId);\n        } else {\n          /*\n           * this is not the first node we are moving so we will insert\n           * it after the node we previously inserted\n           */\n          this.moveToInactive(tempNode, nodeId);\n        }\n      } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n        this.moveToActive(tempNode);\n\n        if (n == 0) {\n          /*\n           * this is the first node we are moving so we will insert it\n           * into the beginning of the group\n           */\n          this.insertNodeInsideOnlyUpdateTransitions(tempNodeId, nodeId);\n          this.insertNodeInsideInGroups(tempNodeId, nodeId);\n        } else {\n          /*\n           * this is not the first node we are moving so we will insert\n           * it after the node we previously inserted\n           */\n          this.insertNodeAfterInTransitions(tempNode, nodeId);\n          this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        }\n      } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n\n        if (n == 0) {\n          /*\n           * this is the first node we are moving so we will insert it\n           * into the beginning of the group\n           */\n          this.moveFromInactiveToInactiveInsertInside(tempNode, nodeId);\n        } else {\n          /*\n           * this is not the first node we are moving so we will insert\n           * it after the node we previously inserted\n           */\n          this.moveInactiveNodeToInactiveSection(tempNode, nodeId);\n        }\n      }\n\n      /*\n       * remember the node id so we can put the next node (if any)\n       * after this one\n       */\n      nodeId = tempNode.id;\n    }\n    return movedNodes;\n  }\n\n  /**\n   * Move nodes after a certain node id\n   * @param nodeIds the node ids to move\n   * @param nodeId the node id we will put the moved nodes after\n   */\n  moveNodesAfter(nodeIds, nodeId) {\n    const movedNodes = [];\n\n    for (let tempNodeId of nodeIds) {\n      const node = this.getNodeById(tempNodeId);\n      movedNodes.push(node);\n\n      const movingNodeIsActive = this.isActive(tempNodeId);\n      const stationaryNodeIsActive = this.isActive(nodeId);\n\n      if (movingNodeIsActive && stationaryNodeIsActive) {\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n        this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        this.insertNodeAfterInTransitions(node, nodeId);\n      } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n        this.moveToInactive(node, nodeId);\n      } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n        this.moveToActive(node);\n        this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        this.insertNodeAfterInTransitions(node, nodeId);\n      } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n        this.removeNodeIdFromTransitions(tempNodeId);\n        this.removeNodeIdFromGroups(tempNodeId);\n        this.moveInactiveNodeToInactiveSection(node, nodeId);\n      }\n\n      // remember the node id so we can put the next node (if any) after this one\n      nodeId = node.id;\n    }\n    return movedNodes;\n  }\n\n  /**\n   * Copy the node with the specified nodeId\n   * @param nodeId the node id to copy\n   * @return copied node\n   */\n  copyNode(nodeId) {\n    const node = this.getNodeById(nodeId);\n    const nodeCopy = this.UtilService.makeCopyOfJSONObject(node);\n    nodeCopy.id = this.getNextAvailableNodeId();\n    nodeCopy.transitionLogic = {};  // clear transition logic\n    nodeCopy.constraints = [];  // clear constraints\n\n    const newComponentIds = [];\n    for (let component of nodeCopy.components) {\n      const newComponentId = this.getUnusedComponentId(newComponentIds);\n      newComponentIds.push(newComponentId);\n      component.id = newComponentId;\n    }\n    return nodeCopy;\n  }\n\n  /**\n   * Delete a node from the project and update transitions.\n   *\n   * If we are deleting the project start node id, we will need\n   * to change it to the next logical node id that will be used\n   * as the project start.\n   *\n   * @param nodeId the node id to delete from the project. It can be a step\n   * or an activity.\n   */\n  deleteNode(nodeId) {\n    const parentGroup = this.getParentGroup(nodeId);\n    if (parentGroup.startId === nodeId) {\n      this.setGroupStartIdToNextChildId(parentGroup)\n    }\n\n    if (this.isProjectStartNodeIdOrContainsProjectStartNodeId(nodeId)) {\n      this.updateProjectStartNodeIdToNextLogicalNode(nodeId);\n    }\n\n    if (this.isGroupNode(nodeId)) {\n      this.removeChildNodes(nodeId);\n    }\n\n    this.removeNodeIdFromTransitions(nodeId);\n    this.removeNodeIdFromGroups(nodeId);\n    this.removeNodeIdFromNodes(nodeId);\n    this.recalculatePositionsInGroup(parentGroup.id);\n  }\n\n  updateProjectStartNodeIdToNextLogicalNode(nodeId) {\n    if (this.isGroupNode(nodeId)) {\n      this.updateProjectStartNodeIdToNextLogicalNodeForRemovingGroup(nodeId);\n    } else {\n      this.updateProjectStartNodeIdToNextLogicalNodeForRemovingStep(nodeId);\n    }\n  }\n\n  /**\n   * Set the startNodeId of the specified group to the first node of the next group.\n   * If the next group doesn't have any nodes, startNodeId should point\n   * to the next group.\n   */\n  updateProjectStartNodeIdToNextLogicalNodeForRemovingGroup(nodeId) {\n    const transitions = this.getTransitionsByFromNodeId(nodeId);\n    if (transitions.length == 0) {\n      this.setStartNodeId('group0');\n    } else {\n      let nextNodeId = transitions[0].to;\n      if (this.isGroupNode(nextNodeId)) {\n        const nextGroupStartId = this.getGroupStartId(nextNodeId);\n        if (nextGroupStartId == null) {\n          this.setStartNodeId(nextNodeId);\n        } else {\n          this.setStartNodeId(nextGroupStartId);\n        }\n      } else {\n        this.setStartNodeId(nextNodeId);\n      }\n    }\n  }\n\n  /**\n   * Set the startNodeId to the next node in the transitions.\n   * If there are no transitions, set it to the parent group of the node.\n   */\n  updateProjectStartNodeIdToNextLogicalNodeForRemovingStep(nodeId) {\n    const transitions = this.getTransitionsByFromNodeId(nodeId);\n    const parentGroupId = this.getParentGroupId(nodeId);\n    if (transitions.length == 0) {\n      this.setStartNodeId(parentGroupId);\n    } else {\n      let nextNodeId = transitions[0].to;\n      if (this.isNodeInGroup(nextNodeId, parentGroupId)) {\n        this.setStartNodeId(nextNodeId);\n      } else {\n        this.setStartNodeId(this.getParentGroupId(nodeId));\n      }\n    }\n  }\n\n  setGroupStartIdToNextChildId(group) {\n    let hasSetNewStartId = false;\n    const transitions = this.getTransitionsByFromNodeId(group.startId);\n    if (transitions.length > 0) {\n      const transition = transitions[0];\n      const toNodeId = transition.to;\n      if (this.isNodeInGroup(toNodeId, group.id)) {\n        group.startId = toNodeId;\n        hasSetNewStartId = true;\n      }\n    }\n\n    if (!hasSetNewStartId) {\n      group.startId = '';\n    }\n  }\n\n  removeChildNodes(groupId) {\n    const group = this.getNodeById(groupId);\n    for (let i = 0; i < group.ids.length; i++) {\n      const childId = group.ids[i];\n      this.removeNodeIdFromTransitions(childId);\n      this.removeNodeIdFromGroups(childId);\n      this.removeNodeIdFromNodes(childId);\n      i--; // so it won't skip the next element\n    }\n  }\n\n  isProjectStartNodeIdOrContainsProjectStartNodeId(nodeId) {\n    return this.getStartNodeId() === nodeId ||\n      (this.isGroupNode(nodeId) && this.containsStartNodeId(nodeId));\n  }\n\n  containsStartNodeId(groupId) {\n    const group = this.getNodeById(groupId);\n    const projectStartNodeId = this.getStartNodeId();\n    for (let childId of group.ids) {\n      if (childId === projectStartNodeId) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Update the transitions to handle removing a node\n   * @param nodeId the node id to remove\n   */\n  removeNodeIdFromTransitions(nodeId) {\n    const nodeToRemove = this.getNodeById(nodeId);\n    const nodesByToNodeId = this.getNodesByToNodeId(nodeId);\n\n    const nodeToRemoveTransitionLogic = nodeToRemove.transitionLogic;\n    let nodeToRemoveTransitions = [];\n\n    if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n      nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n    }\n\n    const parentIdOfNodeToRemove = this.getParentGroupId(nodeId);\n    const parentGroup = this.getNodeById(parentIdOfNodeToRemove);\n\n    // update the start id if we are removing the start node of a group\n    if (parentGroup != null) {\n      const parentGroupStartId = parentGroup.startId;\n      if (parentGroupStartId != null) {\n        if (parentGroupStartId === nodeId) {\n          // the node we are removing is the start node\n\n          if (nodeToRemoveTransitions != null && nodeToRemoveTransitions.length > 0) {\n            for (let nodeToRemoveTransition of nodeToRemoveTransitions) {\n              if (nodeToRemoveTransition != null) {\n                const toNodeId = nodeToRemoveTransition.to;\n                if (toNodeId != null) {\n                  /*\n                   * we need to check that the to node id is in the\n                   * same group. some transitions point to a node id\n                   * in the next group which we would not want to use\n                   * for the start id.\n                   */\n                  if (this.getParentGroupId(toNodeId) == parentIdOfNodeToRemove) {\n                    // set the new start id\n                    parentGroup.startId = toNodeId;\n                  }\n                }\n              }\n            }\n          } else {\n            // there are no transitions so we will have an empty start id\n            parentGroup.startId = '';\n          }\n        }\n      }\n    }\n\n    for (let n = 0; n < nodesByToNodeId.length; n++) {\n      const node = nodesByToNodeId[n];\n      if (node != null) {\n        const parentIdOfFromNode = this.getParentGroupId(node.id);\n        const transitionLogic = node.transitionLogic;\n\n        if (transitionLogic != null) {\n          const transitions = transitionLogic.transitions;\n          for (let t = 0; t < transitions.length; t++) {\n            const transition = transitions[t];\n            if (nodeId === transition.to) {\n              // we have found the transition to the node we are removing\n\n              // copy the transitions from the node we are removing\n              let transitionsCopy = angular.toJson(nodeToRemoveTransitions);\n              transitionsCopy = angular.fromJson(transitionsCopy);\n\n              /*\n               * if the parent from group is different than the parent removing group\n               * remove transitions that are to a node in a different group than\n               * the parent removing group\n               */\n\n              if (parentIdOfFromNode != parentIdOfNodeToRemove) {\n                for (let tc = 0; tc < transitionsCopy.length; tc++) {\n                  const tempTransition = transitionsCopy[tc];\n                  if (tempTransition != null) {\n                    const tempToNodeId = tempTransition.to;\n                    if (tempToNodeId != null) {\n                      const parentIdOfToNode = this.getParentGroupId(tempToNodeId);\n                      if (parentIdOfNodeToRemove != parentIdOfToNode) {\n                        // remove the transition\n                        transitionsCopy.splice(tc, 1);\n                        tc--;\n                      }\n                    }\n                  }\n                }\n              }\n\n              if (this.isFirstNodeInBranchPath(nodeId)) {\n                /*\n                 * Get the node ids that have a branchPathTaken\n                 * constraint from the before node and to the node\n                 * we are removing. If there are any, we need to\n                 * update the branchPathTaken constraint with the\n                 * next nodeId that comes after the node we are\n                 * removing.\n                 */\n                const nodeIdsInBranch = this.getNodeIdsInBranch(node.id, nodeId);\n\n                if (nodeIdsInBranch != null) {\n                  for (let nodeIdInBranch of nodeIdsInBranch) {\n                    const nodeInBranch = this.getNodeById(nodeIdInBranch);\n                    for (let transitionCopy of transitionsCopy) {\n                      if (transitionCopy != null) {\n                        const currentFromNodeId = node.id;\n                        const currentToNodeId = nodeId;\n                        const newFromNodeId = node.id;\n                        const newToNodeId = transitionCopy.to;\n\n                        /*\n                         * change the branch path taken constraint by changing\n                         * the toNodeId\n                         */\n                        this.updateBranchPathTakenConstraint(nodeInBranch, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId);\n                      }\n                    }\n                  }\n                }\n              } else if (this.isBranchPoint(nodeId)) {\n                /*\n                 * get all the branches that have the node we\n                 * are removing as the start point\n                 */\n                const branches = this.getBranchesByBranchStartPointNodeId(nodeId);\n\n                for (let branch of branches) {\n                  if (branch != null) {\n                    /*\n                     * get the branch paths. these paths do not\n                     * contain the start point or merge point.\n                     */\n                    const branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n                      for (let branchPath of branchPaths) {\n                        if (branchPath != null) {\n                          const currentFromNodeId = nodeId;\n                          const currentToNodeId = branchPath[0];\n                          const newFromNodeId = node.id;\n                          const newToNodeId = branchPath[0];\n                          for (let branchPathNodeId of branchPath) {\n                            const branchPathNode = this.getNodeById(branchPathNodeId);\n                            this.updateBranchPathTakenConstraint(branchPathNode, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n\n              // remove the transition to the node we are removing\n              transitions.splice(t, 1);\n\n              if (transitionsCopy != null) {\n                let insertIndex = t;\n\n                /*\n                 * loop through all the transitions from the node we are removing\n                 * and insert them into the transitions of the from node\n                 * e.g.\n                 * the node that comes before the node we are removing has these transitions\n                 * \"transitions\": [\n                 *     {\n                 *         \"to\": \"node4\"\n                 *     },\n                 *     {\n                 *         \"to\": \"node6\"\n                 *     }\n                 * ]\n                 *\n                 * we are removing node4. node4 has a transition to node5.\n                 *\n                 * the node that comes before the node we are removing now has these transitions\n                 * \"transitions\": [\n                 *     {\n                 *         \"to\": \"node5\"\n                 *     },\n                 *     {\n                 *         \"to\": \"node6\"\n                 *     }\n                 * ]\n                 */\n                for (let transitionCopy of transitionsCopy) {\n                  // insert a transition from the node we are removing\n                  transitions.splice(insertIndex, 0, transitionCopy);\n                  insertIndex++;\n                }\n              }\n\n              // check if the node we are moving is a group\n              if (this.isGroupNode(nodeId)) {\n                /*\n                 * we are moving a group so we need to update transitions that\n                 * go into the group\n                 */\n                const groupIdWeAreMoving = nodeId;\n                const groupThatTransitionsToGroupWeAreMoving = node;\n                this.updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving);\n              }\n            }\n          }\n\n          if (this.isBranchPoint(nodeId)) {\n            /*\n             * the node we are deleting is a branch point so we to\n             * copy the transition logic to the node that comes\n             * before it\n             */\n            node.transitionLogic = this.UtilService.makeCopyOfJSONObject(nodeToRemoveTransitionLogic);\n\n            /*\n             * set the transitions for the node that comes before\n             * the one we are removing\n             */\n            node.transitionLogic.transitions = transitions;\n          }\n        }\n      }\n    }\n\n    if (nodeToRemoveTransitionLogic != null) {\n      nodeToRemoveTransitionLogic.transitions = [];\n    }\n\n    if (this.isGroupNode(nodeId)) {\n      this.removeTransitionsOutOfGroup(nodeId);\n    }\n  };\n\n  /**\n   * Remove the node id from all groups\n   * @param nodeId the node id to remove\n   */\n  removeNodeIdFromGroups(nodeId) {\n    for (let group of this.getGroupNodes()) {\n      this.removeNodeIdFromGroup(group, nodeId);\n    }\n    for (let inactiveGroup of this.getInactiveGroupNodes()) {\n      this.removeNodeIdFromGroup(inactiveGroup, nodeId);\n    }\n  }\n\n  /**\n   * Remove a node from a group.\n   * If the node is a start node of the group, update the group's start node to\n   * the next node in the group after removing.\n   * @param group The group to remove from.\n   * @param nodeId The node id to remove.\n   */\n  removeNodeIdFromGroup(group, nodeId) {\n    const ids = group.ids;\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      if (id === nodeId) {\n        ids.splice(i, 1);\n        if (id === group.startId) {\n          this.shiftGroupStartNodeByOne(group);\n        }\n      }\n    }\n  }\n\n  // TODO handle the case when the start node of the group is a branch point\n  shiftGroupStartNodeByOne(group) {\n    const transitionsFromStartNode =\n        this.getTransitionsByFromNodeId(group.startId);\n    if (transitionsFromStartNode.length > 0) {\n      group.startId = transitionsFromStartNode[0].to;\n    } else {\n      group.startId = '';\n    }\n  }\n\n  /**\n   * Remove the node from the array of nodes\n   * @param nodeId the node id to remove\n   */\n  removeNodeIdFromNodes(nodeId) {\n    const nodes = this.project.nodes;\n    for (let n = 0; n < nodes.length; n++) {\n      const node = nodes[n];\n      if (node != null) {\n        if (nodeId === node.id) {\n          nodes.splice(n, 1);\n        }\n      }\n    }\n\n    const inactiveNodes = this.project.inactiveNodes;\n    if (inactiveNodes != null) {\n      for (let i = 0; i < inactiveNodes.length; i++) {\n        const inactiveNode = inactiveNodes[i];\n        if (inactiveNode != null) {\n          if (nodeId === inactiveNode.id) {\n            inactiveNodes.splice(i, 1);\n          }\n        }\n      }\n    }\n\n    this.idToNode[nodeId] = null;\n  }\n\n  /**\n   * Remove the node from the inactive nodes array\n   * @param nodeId the node to remove from the inactive nodes array\n   */\n  removeNodeIdFromInactiveNodes(nodeId) {\n    const inactiveNodes = this.project.inactiveNodes;\n    if (inactiveNodes != null) {\n      for (let i = 0; i < inactiveNodes.length; i++) {\n        const inactiveNode = inactiveNodes[i];\n        if (inactiveNode != null) {\n          const inactiveNodeId = inactiveNode.id;\n          if (inactiveNodeId === nodeId) {\n            inactiveNodes.splice(i, 1);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a new component\n   * @param nodeId the node id to create the component in\n   * @param componentType the component type\n   * @param insertAfterComponentId Insert the new compnent after the given\n   * component id. If this argument is null, we will place the new component\n   * in the first position.\n   */\n  createComponent(nodeId, componentType, insertAfterComponentId) {\n    let component = null;\n    if (nodeId != null && componentType != null) {\n      const node = this.getNodeById(nodeId);\n      const service = this.$injector.get(componentType + 'Service');\n      if (node != null && service != null) {\n        component = service.createComponent();\n\n        if (service.componentHasWork()) {\n          /*\n           * the component has student work so we will need to\n           * determine if we need to show the save button on the\n           * component or the step\n           */\n\n          if (node.showSaveButton == true) {\n            /*\n             * the step is showing a save button so we will not show\n             * the save button on this new component\n             */\n          } else {\n            if (this.doesAnyComponentInNodeShowSubmitButton(node.id)) {\n              /*\n               * at least one of the other components in the step are\n               * showing a submit button so we will also show the save\n               * button on this new component\n               */\n              component.showSaveButton = true;\n            } else {\n              /*\n               * none of the other components are showing a submit button\n               * so we will show the save button on the step\n               */\n              node.showSaveButton = true;\n            }\n          }\n        }\n        this.addComponentToNode(node, component, insertAfterComponentId);\n      }\n    }\n    return component;\n  }\n\n  /**\n   * Returns true iff any component in the step generates work\n   * @param nodeId the node id\n   * @return whether any components in the step generates work\n   */\n  doesAnyComponentHaveWork(nodeId) {\n    const node = this.getNodeById(nodeId);\n    for (let component of node.components) {\n      const service = this.$injector.get(component.type + 'Service');\n      if (service != null && service.componentHasWork()) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if any of the components in the node are showing their submit button.\n   * @param nodeId {string} The node id to check.\n   * @return {boolean} Whether any of the components in the node show their submit button.\n   */\n  doesAnyComponentInNodeShowSubmitButton(nodeId) {\n    const node = this.getNodeById(nodeId);\n    for (let component of node.components) {\n      if (component.showSubmitButton == true) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Add the component to the node\n   * @param node the node\n   * @param component the component\n   * @param insertAfterComponentId Insert the component after this given\n   * component id. If this argument is null, we will place the new component\n   * in the first position.\n   */\n  addComponentToNode(node, component, insertAfterComponentId) {\n    if (node != null && component != null) {\n      if (insertAfterComponentId == null) {\n        /*\n         * insertAfterComponentId is null so we will place the new\n         * component in the first position\n         */\n        node.components.splice(0, 0, component);\n      } else {\n        // place the new component after the insertAfterComponentId\n\n        // boolean flag for whether we have added the component yet\n        let added = false;\n\n        const components = node.components;\n        for (let c = 0; c < components.length; c++) {\n          const tempComponent = components[c];\n          if (tempComponent != null && tempComponent.id != null &&\n              tempComponent.id == insertAfterComponentId) {\n            /*\n             * we have found the component we want to add the new\n             * one after\n             */\n\n            components.splice(c + 1, 0, component);\n            added = true;\n            break;\n          }\n        }\n\n        if (!added) {\n          /*\n           * the component has not been added yet so we will just add\n           * it at the end\n           */\n          node.components.push(component);\n        }\n      }\n    }\n  }\n\n  /**\n   * Move the component(s) within the node\n   * @param nodeId we are moving component(s) in this node\n   * @param componentIds the component(s) we are moving\n   * @param insertAfterComponentId Insert the component(s) after this given\n   * component id. If this argument is null, we will place the new\n   * component(s) in the first position.\n   */\n  moveComponent(nodeId, componentIds, insertAfterComponentId) {\n    const node = this.getNodeById(nodeId);\n    const components = node.components;\n    const componentsToMove = [];\n\n    // remove the component(s)\n    for (let a = components.length - 1; a >= 0; a--) {\n      const tempComponent = components[a];\n      if (tempComponent != null) {\n        if (componentIds.indexOf(tempComponent.id) != -1) {\n          // we have found a component we want to move\n\n          // add the component to our array of components we are moving\n          componentsToMove.splice(0, 0, tempComponent);\n\n          // remove the component from the components array in the node\n          components.splice(a, 1);\n        }\n      }\n    }\n\n    // insert the component(s)\n    if (insertAfterComponentId == null) {\n      // insert the components at the beginning of the components list\n\n      for (let c = 0; c < componentsToMove.length; c++) {\n        // insert a component\n        components.splice(c, 0, componentsToMove[c]);\n      }\n    } else {\n      // insert the component(s) after the given insertAfterComponentId\n\n      for (let b = 0; b < components.length; b++) {\n        const tempComponent = components[b];\n        if (tempComponent != null && tempComponent.id == insertAfterComponentId) {\n          // we have found the component we want to add after\n\n          for (let c = 0; c < componentsToMove.length; c++) {\n            // insert a component\n            components.splice(b + 1 + c, 0, componentsToMove[c]);\n          }\n          break;\n        }\n      }\n    }\n    return componentsToMove;\n  }\n\n  /**\n   * Delete the component\n   * @param nodeId the node id\n   * @param componentId the component id\n   */\n  deleteComponent(nodeId, componentId) {\n    // TODO refactor and move to authoringToolProjectService\n    if (nodeId != null && componentId != null) {\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        const components = node.components;\n        if (components != null) {\n          for (let c = 0; c < components.length; c++) {\n            const component = components[c];\n            if (component.id === componentId) {\n              components.splice(c, 1);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * TODO: Deprecated, should be removed; replaced by getMaxScoreForWorkgroupId in StudentStatusService\n   * Get the max score for the project. If the project contains branches, we\n   * will only calculate the max score for a single path from the first node\n   * to the last node in the project.\n   * @returns the max score for the project or null if none of the components in the project\n   * has max scores.\n   */\n  getMaxScore() {\n    let maxScore = null;\n    const startNodeId = this.getStartNodeId();\n\n    // get all the paths in the project\n    const allPaths = this.getAllPaths([], startNodeId);\n\n    if (allPaths != null && allPaths.length > 0) {\n      const firstPath = allPaths[0];\n      for (let nodeId of firstPath) {\n        const nodeMaxScore = this.getMaxScoreForNode(nodeId);\n        if (nodeMaxScore != null) {\n          if (maxScore == null) {\n            maxScore = nodeMaxScore;\n          } else {\n            maxScore += nodeMaxScore;\n          }\n        }\n      }\n    }\n    return maxScore;\n  }\n\n  /**\n   * Get the max score for the node\n   * @param nodeId the node id which can be a step or an activity\n   * @returns the max score for the node which can be null or a number\n   * if null, author/teacher has not set a max score for the node\n   */\n  getMaxScoreForNode(nodeId) {\n    let maxScore = null;\n    if (!this.isGroupNode(nodeId)) {\n      const node = this.getNodeById(nodeId);\n      for (let component of node.components) {\n        const componentMaxScore = component.maxScore;\n        if (typeof componentMaxScore == 'number') {\n          if (maxScore == null) {\n            maxScore = componentMaxScore;\n          } else {\n            maxScore += componentMaxScore;\n          }\n        }\n      }\n    }\n    return maxScore;\n  }\n\n  /**\n   * Get the max score for a component\n   * @param nodeId get the max score from a component in this node\n   * @param componentId get the max score from this component\n   */\n  getMaxScoreForComponent(nodeId, componentId) {\n    const component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    if (component != null) {\n      return component.maxScore;\n    }\n    return null;\n  }\n\n  /**\n   * Set the max score for a component\n   * @param nodeId set the max score from a component in this node\n   * @param componentId set the max score from this component\n   * @param maxScore set it to this maxScore\n   */\n  setMaxScoreForComponent(nodeId, componentId, maxScore) {\n    if (nodeId != null && componentId != null && maxScore != null && typeof maxScore === 'number') {\n      let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n      if (component != null) {\n        component.maxScore = maxScore;\n      }\n    }\n  }\n\n  /**\n   * Determine if a node id is a direct child of a group\n   * @param nodeId the node id\n   * @param groupId the group id\n   */\n  isNodeInGroup(nodeId, groupId) {\n    const group = this.getNodeById(groupId);\n    return group.ids.indexOf(nodeId) != -1;\n  }\n\n  /**\n   * Get the first leaf node by traversing all the start ids\n   * until a leaf node id is found\n   */\n  getFirstLeafNodeId() {\n    let firstLeafNodeId = null;\n    const startGroupId = this.project.startGroupId;\n    let node = this.getNodeById(startGroupId);\n    let done = false;\n\n    // loop until we have found a leaf node id or something went wrong\n    while (!done) {\n      if (node == null) {\n        done = true;\n      } else if (this.isGroupNode(node.id)) {\n        firstLeafNodeId = node.id;\n        node = this.getNodeById(node.startId);\n      } else if (this.isApplicationNode(node.id)) {\n        firstLeafNodeId = node.id;\n        done = true;\n      } else {\n        done = true;\n      }\n    }\n    return firstLeafNodeId;\n  }\n\n  /**\n   * Replace a node. This is used when we want to revert a node back to a\n   * previous version in the authoring tool.\n   * @param nodeId the node id\n   * @param node the node object\n   */\n  replaceNode(nodeId, node) {\n    if (nodeId != null && node != null) {\n      this.setIdToNode(nodeId, node);\n      this.setIdToElement(nodeId, node);\n      const nodes = this.getNodes();\n      if (nodes != null) {\n        for (let n = 0; n < nodes.length; n++) {\n          const tempNode = nodes[n];\n          if (tempNode != null) {\n            const tempNodeId = tempNode.id;\n            if (nodeId === tempNodeId) {\n              nodes.splice(n, 1, node);\n              break;\n            }\n          }\n        }\n      }\n\n      const applicationNodes = this.applicationNodes;\n      if (applicationNodes != null) {\n        for (let a = 0; a < applicationNodes.length; a++) {\n          const tempApplicationNode = applicationNodes[a];\n          if (tempApplicationNode != null) {\n            const tempApplicationNodeId = tempApplicationNode.id;\n            if (nodeId === tempApplicationNodeId) {\n              applicationNodes.splice(a, 1, node);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Recalculate the positions of the children in the group.\n   * The positions are the numbers usually seen before the title\n   * e.g. if the step is seen as 1.3: Gather Evidence, then 1.3\n   * is the position\n   * @param groupId recalculate all the children of this group\n   */\n  recalculatePositionsInGroup(groupId) {\n    if (groupId != null) {\n      let childIds = this.getChildNodeIdsById(groupId);\n      for (let childId of childIds) {\n        let pos = this.getPositionById(childId);\n        this.setIdToPosition(childId, pos);\n      }\n    }\n  }\n\n  /**\n   * Get the message that describes how to disable the constraint\n   * @param nodeId the node the student is trying to go to\n   * @param constraint the constraint that is preventing the student\n   * from going to the node\n   * @returns the message to display to the student that describes how\n   * to disable the constraint\n   */\n  getConstraintMessage(nodeId, constraint) {\n    let message = '';\n\n    if (nodeId != null && constraint != null) {\n      // get the node title the student is trying to go to\n      const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n\n      const removalConditional = constraint.removalConditional;\n      const removalCriteria = constraint.removalCriteria;\n\n      if (removalCriteria != null) {\n        let criteriaMessages = '';\n        for (let tempRemovalCriteria of removalCriteria) {\n          if (tempRemovalCriteria != null) {\n            // get the message that describes the criteria that needs to be satisfied\n            const criteriaMessage = this.getCriteriaMessage(tempRemovalCriteria);\n\n            if (criteriaMessage != null && criteriaMessage != '') {\n              // separate criteria messages with a line break\n              if (criteriaMessages != '') {\n                criteriaMessages += '<br/>';\n              }\n              criteriaMessages += criteriaMessage;\n            }\n          }\n        }\n        message += criteriaMessages;\n      }\n    }\n    return message;\n  }\n\n  /**\n   * Get the human readable description of the constraint.\n   * @param constraint The constraint object.\n   * @returns A human readable text string that describes the constraint.\n   * example\n   * 'All steps after this one will not be visitable until the student completes \"3.7 Revise Your Bowls Explanation\"'\n   */\n  getConstraintDescription(constraint) {\n    let message = '';\n    let action = constraint.action;\n    let actionMessage = this.getActionMessage(action);\n    for (let singleRemovalCriteria of constraint.removalCriteria) {\n      if (message != '') {\n        // this constraint has multiple removal criteria\n        if (constraint.removalConditional == 'any') {\n          message += ' or ';\n        } else if (constraint.removalConditional == 'all') {\n          message += ' and ';\n        }\n      }\n      message += this.getCriteriaMessage(singleRemovalCriteria);\n    }\n    message = actionMessage + message;\n    return message;\n  }\n\n  /**\n   * Get the constraint action as human readable text.\n   * @param action A constraint action.\n   * @return A human readable text string that describes the action\n   * example\n   * 'All steps after this one will not be visitable until '\n   */\n  getActionMessage(action) {\n    if (action == 'makeAllNodesAfterThisNotVisitable') {\n      return this.$translate('allStepsAfterThisOneWillNotBeVisitableUntil');\n    } else if (action == 'makeAllNodesAfterThisNotVisible') {\n      return this.$translate('allStepsAfterThisOneWillNotBeVisibleUntil');\n    } else if (action == 'makeAllOtherNodesNotVisitable') {\n      return this.$translate('allOtherStepsWillNotBeVisitableUntil');\n    } else if (action == 'makeAllOtherNodesNotVisible') {\n      return this.$translate('allOtherStepsWillNotBeVisibleUntil');\n    } else if (action == 'makeThisNodeNotVisitable') {\n      return this.$translate('thisStepWillNotBeVisitableUntil');\n    } else if (action == 'makeThisNodeNotVisible') {\n      return this.$translate('thisStepWillNotBeVisibleUntil');\n    }\n  }\n\n  /**\n   * Get the message that describes how to satisfy the criteria\n   * TODO: check if the criteria is satisfied\n   * @param criteria the criteria object that needs to be satisfied\n   * @returns the message to display to the student that describes how to\n   * satisfy the criteria\n   */\n  getCriteriaMessage(criteria) {\n    let message = '';\n\n    if (criteria != null) {\n      const name = criteria.name;\n      const params = criteria.params;\n\n      if (name === 'isCompleted') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('completeNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'isVisited') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('visitNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'isCorrect') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('correctlyAnswerNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'score') {\n        const nodeId = params.nodeId;\n        let nodeTitle = '';\n        let scoresString = '';\n\n        if (nodeId != null) {\n          nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n        }\n\n        const scores = params.scores;\n        if (scores != null) {\n          // get the required score\n          scoresString = scores.join(', ');\n        }\n\n        // generate the message\n        message += this.$translate('obtainAScoreOfXOnNodeTitle', { score: scoresString, nodeTitle: nodeTitle });\n      } else if (name === 'choiceChosen') {\n        const nodeId = params.nodeId;\n        const componentId = params.componentId;\n        const choiceIds = params.choiceIds;\n        let nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n        let choices = this.getChoiceTextByNodeIdAndComponentId(nodeId, componentId, choiceIds);\n        let choiceText = choices.join(', ');\n        message += this.$translate('chooseChoiceOnNodeTitle', { choiceText: choiceText, nodeTitle: nodeTitle });\n      } else if (name === 'usedXSubmits') {\n        const nodeId = params.nodeId;\n        let nodeTitle = '';\n\n        const requiredSubmitCount = params.requiredSubmitCount;\n\n        if (nodeId != null) {\n          nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n        }\n\n        if (requiredSubmitCount == 1) {\n          message += this.$translate('submitXTimeOnNodeTitle', { requiredSubmitCount: requiredSubmitCount, nodeTitle: nodeTitle });\n        } else {\n          message += this.$translate('submitXTimesOnNodeTitle', { requiredSubmitCount: requiredSubmitCount, nodeTitle: nodeTitle });\n        }\n      } else if (name === 'branchPathTaken') {\n        const fromNodeId = params.fromNodeId;\n        const fromNodeTitle = this.getNodePositionAndTitleByNodeId(fromNodeId);\n        const toNodeId = params.toNodeId;\n        const toNodeTitle = this.getNodePositionAndTitleByNodeId(toNodeId);\n        message += this.$translate('branchPathTakenFromTo', { fromNodeTitle: fromNodeTitle, toNodeTitle: toNodeTitle });\n      } else if (name === 'isPlanningActivityCompleted') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('completeNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'wroteXNumberOfWords') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const requiredNumberOfWords = params.requiredNumberOfWords;\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('writeXNumberOfWordsOnNodeTitle',\n              { requiredNumberOfWords: requiredNumberOfWords, nodeTitle: nodeTitle });\n        }\n      } else if (name === 'isVisible') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('nodeTitleIsVisible', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'isVisitable') {\n        const nodeId = params.nodeId;\n        if (nodeId != null) {\n          const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('nodeTitleIsVisitable', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'addXNumberOfNotesOnThisStep') {\n        const nodeId = params.nodeId;\n        const requiredNumberOfNotes = params.requiredNumberOfNotes;\n        const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n        if (requiredNumberOfNotes == 1) {\n          message += this.$translate('addXNumberOfNotesOnThisStepSingular',\n            { requiredNumberOfNotes: requiredNumberOfNotes, nodeTitle: nodeTitle });\n        } else {\n          message += this.$translate('addXNumberOfNotesOnThisStepPlural',\n            { requiredNumberOfNotes: requiredNumberOfNotes, nodeTitle: nodeTitle });\n        }\n      } else if (name === 'fillXNumberOfRows') {\n        const requiredNumberOfFilledRows = params.requiredNumberOfFilledRows;\n        const nodeId = params.nodeId;\n        const nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n        if (requiredNumberOfFilledRows == 1) {\n          message += this.$translate('youMustFillInXRow',\n            { requiredNumberOfFilledRows: requiredNumberOfFilledRows, nodeTitle: nodeTitle });\n        } else {\n          message += this.$translate('youMustFillInXRows',\n            { requiredNumberOfFilledRows: requiredNumberOfFilledRows, nodeTitle: nodeTitle });\n        }\n      }\n    }\n    return message;\n  }\n\n  /**\n   * Get the choices of a Multiple Choice component.\n   * @param nodeId The node id.\n   * @param componentId The component id.\n   * @return The choices from the component.\n   */\n  getChoicesByNodeIdAndComponentId(nodeId, componentId) {\n    let choices = [];\n    let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    if (component != null && component.choices != null) {\n      choices = component.choices;\n    }\n    return choices;\n  }\n\n  /**\n   * Get the choice text for the given choice ids of a multiple choice component.\n   * @param nodeId The node id of the component.\n   * @param componentId The component id of the component.\n   * @param choiceIds An array of choice ids.\n   * @return An array of choice text strings.\n   */\n  getChoiceTextByNodeIdAndComponentId(nodeId, componentId, choiceIds) {\n    let choices = this.getChoicesByNodeIdAndComponentId(nodeId, componentId);\n    let choicesText = [];\n    for (let choice of choices) {\n      if (choiceIds.indexOf(choice.id) != -1) {\n        choicesText.push(choice.text);\n      }\n    }\n    return choicesText;\n  }\n\n  /**\n   * Get the start id of a group\n   * @param nodeId get the start id of this group\n   * @returns the start id of the group\n   */\n  getGroupStartId(nodeId) {\n    const node = this.getNodeById(nodeId);\n    return node.startId;\n  }\n\n  /**\n   * Get the start id of the node's parent group\n   * @param nodeId we will get the parent of this node and then look\n   * for the start id of the parent\n   * @returns the start id of the parent\n   */\n  getParentGroupStartId(nodeId) {\n    if (nodeId != null) {\n      const parentGroup = this.getParentGroup(nodeId);\n      if (parentGroup != null) {\n        return parentGroup.startId;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Update the transitions so that the fromGroup points to the newToGroup\n   *\n   * Before\n   * fromGroup -> oldToGroup -> newToGroup\n   *\n   * After\n   * fromGroup -> newToGroup\n   * oldToGroup becomes dangling and has no transitions to or from it\n   */\n  updateTransitionsForExtractingGroup(fromGroupId, oldToGroupId, newToGroupId) {\n    /*\n     * make the transitions\n     * fromGroup -> newToGroup\n     */\n    if (fromGroupId != null && oldToGroupId != null) {\n      const fromGroup = this.getNodeById(fromGroupId);\n      const oldToGroup = this.getNodeById(oldToGroupId);\n      let newToGroup = null;\n      let newToGroupStartId = null;\n\n      if (newToGroupId != null) {\n        newToGroup = this.getNodeById(newToGroupId);\n      }\n\n      if (newToGroup != null) {\n        newToGroupStartId = newToGroup.startId;\n      }\n\n      if (fromGroup != null && oldToGroup != null) {\n        const childIds = fromGroup.ids;\n\n        // update the children of the from group to point to the new to group\n        if (childIds != null) {\n          for (let childId of childIds) {\n            const child = this.getNodeById(childId);\n            const transitions = this.getTransitionsByFromNodeId(childId);\n\n            if (transitions != null) {\n              for (let t = 0; t < transitions.length; t++) {\n                const transition = transitions[t];\n                if (transition != null) {\n                  const toNodeId = transition.to;\n                  if (toNodeId === oldToGroupId) {\n                    // the transition is to the group\n                    if (newToGroupId == null && newToGroupStartId == null) {\n                      // there is no new to group so we will remove the transition\n                      transitions.splice(t, 1);\n                      t--;\n                    } else {\n                      // make the transition point to the new to group\n                      transition.to = newToGroupId;\n                    }\n                  } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                    // the transition is to a node in the group\n                    if (newToGroupId == null && newToGroupStartId == null) {\n                      // there is no new to group so we will remove the transition\n                      transitions.splice(t, 1);\n                      t--;\n                    } else if (newToGroupStartId == null || newToGroupStartId == '') {\n                      // make the transition point to the new to group\n                      transition.to = newToGroupId;\n                    } else {\n                      // make the transition point to the new group start id\n                      transition.to = newToGroupStartId;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /*\n     * remove the transitions from the oldToGroup\n     */\n    if (oldToGroupId != null && newToGroupId != null) {\n      const oldToGroup = this.getNodeById(oldToGroupId);\n      if (oldToGroup != null) {\n        const childIds = oldToGroup.ids;\n\n        // remove the transitions from the old to group that point to the new to group\n        if (childIds != null) {\n          for (let childId of childIds) {\n            const child = this.getNodeById(childId);\n            const transitions = this.getTransitionsByFromNodeId(childId);\n            if (transitions != null) {\n              for (let t = 0; t < transitions.length; t++) {\n                const transition = transitions[t];\n                if (transition != null) {\n                  const toNodeId = transition.to;\n                  if (toNodeId === newToGroupId) {\n                    // the transition is to the group so we will remove it\n                    transitions.splice(t, 1);\n                    t--;\n                  } else if (this.isNodeInGroup(toNodeId, newToGroupId)) {\n                    // the transition is to a node in the group so we will remove it\n                    transitions.splice(t, 1);\n                    t--;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Update the transitions so that the fromGroup points to the newToGroup\n   *\n   * Before\n   * fromGroup -> oldToGroup\n   * newToGroup is dangling and has no transitions to or from it\n   *\n   * After\n   * fromGroup -> newToGroup -> oldToGroup\n   */\n  updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId) {\n    let fromGroup = null;\n    let newToGroup = null;\n    if (fromGroupId != null) {\n      fromGroup = this.getNodeById(fromGroupId);\n    }\n\n    if (newToGroupId != null) {\n      newToGroup = this.getNodeById(newToGroupId);\n    }\n\n    /*\n     * make the transitions that point to the old group now point\n     * to the new group\n     * fromGroup -> newToGroup\n     */\n    if (fromGroup != null && newToGroup != null) {\n      const childIds = fromGroup.ids;\n      const newToGroupStartId = newToGroup.startId;\n      if (childIds != null) {\n        for (let childId of childIds) {\n          const child = this.getNodeById(childId);\n\n          // get the transitions from the child\n          const transitions = this.getTransitionsByFromNodeId(childId);\n\n          if (transitions == null || transitions.length == 0) {\n            /*\n             * the child does not have any transitions so we will make it\n             * point to the new group\n             */\n            if (newToGroupStartId == null || newToGroupStartId == '') {\n              this.addToTransition(child, newToGroupId);\n            } else {\n              this.addToTransition(child, newToGroupStartId)\n            }\n          } else if (transitions != null) {\n            for (let transition of transitions) {\n              if (transition != null) {\n                const toNodeId = transition.to;\n                if (oldToGroupIds != null) {\n                  for (let oldToGroupId of oldToGroupIds) {\n                    if (toNodeId === oldToGroupId) {\n                      /*\n                       * the transition is to the group so we will update the transition\n                       * to the new group\n                       */\n                      transition.to = newToGroupId;\n                    } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                      /*\n                       * the transition is to a node in the old group so we will update\n                       * the transition to point to the new group\n                       */\n                      if (newToGroupStartId == null || newToGroupStartId == '') {\n                        transition.to = newToGroupId;\n                      } else {\n                        transition.to = newToGroupStartId;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /*\n     * make the steps that do not have a transition now point to the old\n     * group\n     * newToGroup -> oldToGroup\n     */\n    if (newToGroup != null) {\n      const childIds = newToGroup.ids;\n      if (childIds != null) {\n        for (let childId of childIds) {\n          const child = this.getNodeById(childId);\n          const transitions = this.getTransitionsByFromNodeId(childId);\n\n          if (transitions == null || transitions.length == 0) {\n            if (oldToGroupIds != null) {\n              for (let oldToGroupId of oldToGroupIds) {\n                const oldToGroup = this.getNodeById(oldToGroupId);\n                if (oldToGroup != null) {\n                  const oldToGroupStartId = oldToGroup.startId;\n                  const transition = {};\n                  let toNodeId = '';\n                  if (oldToGroupStartId == null) {\n                    // there is no start node id so we will just point to the group\n                    toNodeId = oldToGroup;\n                  } else {\n                    // there is a start node id so we will point to it\n                    toNodeId = oldToGroupStartId;\n                  }\n\n                  // create the transition from the child to the old group\n                  this.addToTransition(child, toNodeId);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Update the child transitions because we are moving a group. We will\n   * update the transitions into and out of the group in the location\n   * we are extracting the group from and also in the location we are\n   * inserting the group into.\n   * @param node the group we are moving\n   * @param nodeId we will put the group after this node id\n   */\n  updateChildrenTransitionsInAndOutOfGroup(node, nodeId = null) {\n    let transitionsBefore = null;\n\n    // get the group nodes that point to the group we are moving\n    const previousGroupNodes = this.getGroupNodesByToNodeId(node.id);\n\n    // get all the transitions from the group we are moving\n    const transitionsAfter = this.getTransitionsByFromNodeId(node.id);\n\n    let extracted = false;\n\n    /*\n     * extract the group we are moving by updating the transitions of the\n     * from group and the new to group. also remove the transitions from the\n     * group we are moving.\n     */\n\n    for (let previousGroupNode of previousGroupNodes) {\n      if (transitionsAfter == null || transitionsAfter.length == 0) {\n        // the group we are moving does not have any transitions\n\n        /*\n         * remove the transitions to the group we are moving and make\n         * new transitions from the from group to the new to group\n         */\n        this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, null);\n        extracted = true;\n      } else {\n        // the group we are moving has transitions\n\n        // make the previous group point to the new to group\n        for (let transitionAfter of transitionsAfter) {\n          if (transitionAfter != null) {\n            const toNodeId = transitionAfter.to;\n\n            /*\n             * remove the transitions to the group we are moving and make\n             * new transitions from the from group to the new to group\n             */\n            this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, toNodeId);\n            extracted = true;\n          }\n        }\n      }\n    }\n\n    if (!extracted) {\n      /*\n       * we have not removed the transitions yet because the group\n       * we are moving does not have any groups before it\n       */\n\n      if (transitionsAfter != null) {\n        // remove the transitions from the group we are moving\n        for (let transitionAfter of transitionsAfter) {\n          if (transitionAfter != null) {\n            const toNodeId = transitionAfter.to;\n\n            // remove the transitions to the group we are moving\n            this.updateTransitionsForExtractingGroup(null, node.id, toNodeId);\n            extracted = true;\n          }\n        }\n      }\n    }\n\n    let inserted = false;\n\n    /*\n     * create the transitions from the from group to the group we are moving\n     * and the transitions from the group we are moving to the old to group\n     */\n    if (nodeId != null) {\n      // get the transitions from the previous group to the next group\n      const transitionsAfter = this.getTransitionsByFromNodeId(nodeId);\n\n      for (let transitionAfter of transitionsAfter) {\n        if (transitionAfter != null) {\n          const toNodeId = transitionAfter.to;\n\n          /*\n           * create the transitions that traverse from the from group\n           * to the group we are moving. also create the transitions\n           * that traverse from the group we are moving to the old\n           * to group.\n           */\n          this.updateTransitionsForInsertingGroup(nodeId, [toNodeId], node.id);\n          inserted = true;\n        }\n      }\n    }\n\n    if (!inserted) {\n      /*\n       * we have not inserted the transitions yet because there were no\n       * previous group transitions\n       */\n\n      if (nodeId == null) {\n        /*\n         * the previous node id is null which means there was no previous\n         * group. this means the group we are inserting will become the\n         * first group. this happens when the group we are moving\n         * is moved inside the root (group0).\n         */\n\n        const startGroupId = this.getStartGroupId();\n\n        if (startGroupId != null) {\n          // get the start group for the whole project (group0)\n          const startGroup = this.getNodeById(startGroupId);\n\n          if (startGroup != null) {\n            const firstGroupId = startGroup.startId;\n\n            /*\n             * create the transitions that traverse from the group\n             * we are moving to the previous first activity.\n             */\n            this.updateTransitionsForInsertingGroup(nodeId, [firstGroupId], node.id);\n          }\n        }\n      } else {\n        /*\n         * we have not inserted the group yet because the from group doesn't\n         * have a group after it\n         */\n\n        /*\n         * create the transitions that traverse from the from group\n         * to the group we are moving.\n         */\n        this.updateTransitionsForInsertingGroup(nodeId, null, node.id);\n      }\n    }\n  }\n\n  getActiveNodes() {\n    return this.project.nodes;\n  }\n\n  getInactiveNodes() {\n    let inactiveNodes = [];\n    if (this.project != null) {\n      if (this.project.inactiveNodes == null) {\n        this.project.inactiveNodes = [];\n      }\n      inactiveNodes = this.project.inactiveNodes;\n    }\n    return inactiveNodes;\n  }\n\n  /**\n   * Remove the node from the inactive nodes array\n   * @param nodeId the node to remove\n   * @returns the node that was removed\n   */\n  removeNodeFromInactiveNodes(nodeId) {\n    let node = null;\n    if (nodeId != null) {\n      let parentGroup = this.getParentGroup(nodeId);\n      if (parentGroup != null) {\n        this.removeChildFromParent(nodeId);\n      }\n\n      let inactiveNodes = this.project.inactiveNodes;\n      if (inactiveNodes != null) {\n        for (let i = 0; i < inactiveNodes.length; i++) {\n          let inactiveNode = inactiveNodes[i];\n          if (inactiveNode != null) {\n            if (nodeId === inactiveNode.id) {\n              node = inactiveNode;\n              inactiveNodes.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n      this.removeNodeFromInactiveStepNodes(nodeId);\n      this.removeNodeFromInactiveGroupNodes(nodeId);\n    }\n    return node;\n  }\n\n  /**\n   * Remove the child node from the parent group.\n   * @param nodeId The child node to remove from the parent.\n   */\n  removeChildFromParent(nodeId) {\n    let parentGroup = this.getParentGroup(nodeId);\n    if (parentGroup != null) {\n      // Remove the child from the parent\n      for (let i = 0; i < parentGroup.ids.length; i++) {\n        let childId = parentGroup.ids[i];\n        if (nodeId == childId) {\n          parentGroup.ids.splice(i, 1);\n          break;\n        }\n      }\n      if (nodeId == parentGroup.startId) {\n        /*\n         * The child we removed was the start id of the group so we\n         * will update the start id.\n         */\n        let startIdUpdated = false;\n        let transitions = this.getTransitionsByFromNodeId(nodeId);\n        if (transitions != null &&\n          transitions.length > 0 &&\n          transitions[0] != null &&\n          transitions[0].to != null) {\n          parentGroup.startId = transitions[0].to;\n          startIdUpdated = true;\n        }\n        if (!startIdUpdated && parentGroup.ids.length > 0) {\n          parentGroup.startId = parentGroup.ids[0];\n          startIdUpdated = true;\n        }\n        if (!startIdUpdated) {\n          parentGroup.startId = '';\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive step nodes array.\n   * @param nodeId The node id of the node we want to remove from the\n   * inactive step nodes array.\n   */\n  removeNodeFromInactiveStepNodes(nodeId) {\n    for (let i = 0; i < this.inactiveStepNodes.length; i++) {\n      let inactiveStepNode = this.inactiveStepNodes[i];\n      if (nodeId == inactiveStepNode.id) {\n        this.inactiveStepNodes.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive group nodes array.\n   * @param nodeId The node id of the group we want to remove from the\n   * inactive group nodes array.\n   */\n  removeNodeFromInactiveGroupNodes(nodeId) {\n    for (let i = 0; i < this.inactiveGroupNodes.length; i++) {\n      let inactiveGroupNode = this.inactiveGroupNodes[i];\n      if (nodeId == inactiveGroupNode.id) {\n        this.inactiveGroupNodes.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Load the inactive nodes\n   * @param nodes the inactive nodes\n   */\n  loadInactiveNodes(nodes) {\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null) {\n          const nodeId = node.id;\n          this.setIdToNode(nodeId, node);\n          this.setIdToElement(nodeId, node);\n          if (node.type == 'group') {\n            this.inactiveGroupNodes.push(node);\n          } else {\n            this.inactiveStepNodes.push(node);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the target is active\n   * @param target the node id or inactiveNodes/inactiveGroups to check\n   * @returns whether the target is active\n   */\n  isActive(target) {\n    if (target === 'inactiveNodes' || target === 'inactiveGroups') {\n      return false;\n    } else {\n      return this.isNodeActive(target);\n    }\n  }\n\n  /**\n   * Check if a node is active.\n   * @param nodeId the id of the node\n   */\n  isNodeActive(nodeId) {\n    for (let activeNode of this.project.nodes) {\n      if (activeNode.id == nodeId) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Move the node to the active nodes array. If the node is a group node,\n   * also move all of its children to active.\n   */\n  moveToActive(node) {\n    if (!this.isActive(node.id)) {\n      this.removeNodeFromInactiveNodes(node.id);\n      this.addNode(node);\n      if (this.isGroupNode(node.id)) {\n        for (let childId of node.ids) {\n          const childNode = this.removeNodeFromInactiveNodes(childId);\n          this.addNode(childNode);\n        }\n      }\n    }\n  }\n\n  /**\n   * Add a group's child nodes to the inactive nodes.\n   * @param node The group node.\n   */\n  addGroupChildNodesToInactive(node) {\n    for (let childId of node.ids) {\n      const childNode = this.getNodeById(childId);\n      this.project.inactiveNodes.push(childNode);\n      this.inactiveStepNodes.push(childNode);\n    }\n  }\n\n  /**\n   * Remove transition from nodes in the specified group that go out of the group\n   * @param nodeId the group id\n   */\n  removeTransitionsOutOfGroup(groupId) {\n    const group = this.getNodeById(groupId);\n    for (let childId of group.ids) {\n      const transitions = this.getTransitionsByFromNodeId(childId);\n      for (let t = 0; t < transitions.length; t++) {\n        const transition = transitions[t];\n        const parentGroupId = this.getParentGroupId(transition.to);\n        if (parentGroupId != groupId) {\n          // this is a transition that goes out of the specified group\n          transitions.splice(t, 1);\n          t--; // so it won't skip the next element\n        }\n      }\n    }\n  }\n\n  /*\n   * Update the step transitions that point into the group we are moving\n   * For example\n   * group1 has children node1 and node2 (node2 transitions to node3)\n   * group2 has children node3 and node4 (node4 transitions to node5)\n   * group3 has children node5 and node6\n   * if we move group2 after group3 we will need to change the\n   * transition from node2 to node3 and make node2 transition to node5\n   * the result will be\n   * group1 has children node1 and node2 (node2 transitions to node5)\n   * group3 has children node5 and node6\n   * group2 has children node3 and node4 (node4 transitions to node5)\n   * note: the (node4 transition to node5) will be removed later\n   * when is called removeTransitionsOutOfGroup\n   * note: when group2 is added in a later function call, we will add\n   * the node6 to node3 transition\n   * @param groupThatTransitionsToGroupWeAreMoving the group object\n   * that transitions to the group we are moving. we may need to update\n   * the transitions of this group's children.\n   * @param groupIdWeAreMoving the group id of the group we are moving\n   */\n  updateChildrenTransitionsIntoGroupWeAreMoving(\n      groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving) {\n    if (groupThatTransitionsToGroupWeAreMoving != null &&\n        groupIdWeAreMoving != null) {\n      const group = this.getNodeById(groupIdWeAreMoving);\n      if (group != null) {\n        // get all the nodes that have a transition to the node we are removing\n        const nodesByToNodeId = this.getNodesByToNodeId(groupIdWeAreMoving);\n\n        // get the transitions of the node we are removing\n        const nodeToRemoveTransitionLogic = group.transitionLogic;\n        let nodeToRemoveTransitions = [];\n\n        if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n          nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n        }\n\n        if (nodeToRemoveTransitions.length == 0) {\n          /*\n           * The group we are moving is the last group in the project\n           * and does not have any transitions. We will loop through\n           * all the nodes that transition into this group and remove\n           * those transitions.\n           */\n\n          // get child ids of the group that comes before the group we are moving\n          const childIds = groupThatTransitionsToGroupWeAreMoving.ids;\n\n          if (childIds != null) {\n            for (let childId of childIds) {\n              const transitionsFromChild = this.getTransitionsByFromNodeId(childId);\n              if (transitionsFromChild != null) {\n                for (let tfc = 0; tfc < transitionsFromChild.length; tfc++) {\n                  const transitionFromChild = transitionsFromChild[tfc];\n                  if (transitionFromChild != null) {\n                    const toNodeId = transitionFromChild.to;\n                    const toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n\n                    if (groupIdWeAreMoving === toNodeIdParentGroupId) {\n                      // the transition is to a child in the group we are moving\n                      transitionsFromChild.splice(tfc, 1);\n\n                      /*\n                       * move the counter back one because we have just removed an\n                       * element from the array\n                       */\n                      tfc--;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else if (nodeToRemoveTransitions.length > 0) {\n          // get the first group that comes after the group we are removing\n          const firstNodeToRemoveTransition = nodeToRemoveTransitions[0];\n          const firstNodeToRemoveTransitionToNodeId = firstNodeToRemoveTransition.to;\n\n          if (this.isGroupNode(firstNodeToRemoveTransitionToNodeId)) {\n            // get the group that comes after the group we are moving\n            const groupNode = this.getNodeById(firstNodeToRemoveTransitionToNodeId);\n\n            // get child ids of the group that comes before the group we are moving\n            const childIds = groupThatTransitionsToGroupWeAreMoving.ids;\n\n            if (childIds != null) {\n              for (let childId of childIds) {\n                const transitionsFromChild = this.getTransitionsByFromNodeId(childId);\n                if (transitionsFromChild != null) {\n                  for (let transitionFromChild of transitionsFromChild) {\n                    if (transitionFromChild != null) {\n                      const toNodeId = transitionFromChild.to;\n\n                      // get the parent group id of the toNodeId\n                      const toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n\n                      if (groupIdWeAreMoving === toNodeIdParentGroupId) {\n                        // the transition is to a child in the group we are moving\n\n                        if (groupNode.startId == null) {\n                          // change the transition to point to the after group\n                          transitionFromChild.to = firstNodeToRemoveTransitionToNodeId;\n                        } else {\n                          // change the transition to point to the start id of the after group\n                          transitionFromChild.to = groupNode.startId;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if a node generates work by looking at all of its components\n   * @param nodeId the node id\n   * @return whether the node generates work\n   */\n  nodeHasWork(nodeId) {\n    if (nodeId != null) {\n      const nodeContent = this.getNodeContentByNodeId(nodeId);\n      if (nodeContent != null) {\n        const components = nodeContent.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null) {\n              const componentHasWork = this.componentHasWork(component);\n              if (componentHasWork) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a component generates work\n   * @param component check if this component generates work\n   * @return whether the component generates work\n   */\n  componentHasWork(component) {\n    if (component != null) {\n      const componentType = component.type;\n      const componentService = this.getComponentService(componentType);\n      if (componentService != null) {\n        return componentService.componentHasWork(component);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get a component service\n   * @param componentType the component type\n   * @return the component service\n   */\n  getComponentService(componentType) {\n    let componentService = null;\n    if (componentType != null) {\n      const componentServiceName = componentType + 'Service';\n\n      /*\n       * check if we have previously retrieved the component service.\n       * if have previously retrieved the component service it will\n       * be in the componentServices map\n       */\n      componentService = this.componentServices[componentServiceName];\n\n      if (componentService == null) {\n        /*\n         * we have not previously retrieved the component service so\n         * we will get it now\n         */\n        componentService = this.$injector.get(componentServiceName);\n\n        /*\n         * save the component service to the map so we can easily\n         * retrieve it later\n         */\n        this.componentServices[componentServiceName] = componentService;\n      }\n    }\n    return componentService;\n  }\n\n  /**\n   * Get an unused component id\n   * @param componentIdsToSkip (optional) An array of additional component ids\n   * to skip. This is used when we are creating multiple new components. There\n   * is avery small chance that we create duplicate component ids that aren't\n   * already in the project. We avoid this problem by using this parameter.\n   * Example\n   * We want to create two new components. We first generate a new component\n   * id for the first new component for example \"1234567890\". Then we generate\n   * a new component id for the second new component and pass in\n   * [\"1234567890\"] as componentIdsToSkip because the new \"1234567890\"\n   * component hasn't actually been added to the project yet.\n   * @return a component id that isn't already being used in the project\n   */\n  getUnusedComponentId(componentIdsToSkip) {\n    // we want to make an id with 10 characters\n    const idLength = 10;\n\n    let newComponentId = this.UtilService.generateKey(idLength);\n\n    // check if the component id is already used in the project\n    if (this.isComponentIdUsed(newComponentId)) {\n      /*\n       * the component id is already used in the project so we need to\n       * try generating another one\n       */\n      let alreadyUsed = true;\n\n      /*\n       * keep trying to generate a new component id until we have found\n       * one that isn't already being used\n       */\n      while(!alreadyUsed) {\n        newComponentId = this.UtilService.generateKey(idLength);\n\n        // check if the id is already being used in the project\n        alreadyUsed = this.isComponentIdUsed(newComponentId);\n\n        if (componentIdsToSkip != null && componentIdsToSkip.indexOf(newComponentId) != -1) {\n          /*\n           * the new component is in the componentIdsToSkip so it has\n           * already been used\n           */\n          alreadyUsed = true;\n        }\n      }\n    }\n    return newComponentId;\n  }\n\n  /**\n   * Check if the component id is already being used in the project\n   * @param componentId check if this component id is already being used in\n   * the project\n   * @return whether the component id is already being used in the project\n   */\n  isComponentIdUsed(componentId) {\n    for (let node of this.project.nodes) {\n      if (node != null) {\n        const components = node.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null) {\n              if (componentId === component.id) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    for (let node of this.project.inactiveNodes) {\n      if (node != null) {\n        const components = node.components;\n        if (components != null) {\n          for (let component of components) {\n            if (component != null) {\n              if (componentId === component.id) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get the next available constraint id for a node\n   * @param nodeId get the next available constraint id for this node\n   * e.g. node8Constraint2\n   * @return the next available constraint id for the node\n   */\n  getNextAvailableConstraintIdForNodeId(nodeId) {\n    let nextAvailableConstraintId = null;\n    if (nodeId != null) {\n      const usedConstraintIds = [];\n      const node = this.getNodeById(nodeId);\n      if (node != null) {\n        const constraints = node.constraints;\n        if (constraints != null) {\n          for (let constraint of constraints) {\n            if (constraint != null) {\n              const constraintId = constraint.id;\n              usedConstraintIds.push(constraintId);\n            }\n          }\n        }\n      }\n\n      let foundNextAvailableConstraintId = false;\n      let counter = 1;\n\n      while (!foundNextAvailableConstraintId) {\n        const potentialConstraintId = nodeId + 'Constraint' + counter;\n        if (usedConstraintIds.indexOf(potentialConstraintId) == -1) {\n          nextAvailableConstraintId = potentialConstraintId;\n          foundNextAvailableConstraintId = true;\n        } else {\n          counter++;\n        }\n      }\n    }\n    return nextAvailableConstraintId;\n  }\n\n  /**\n   * Get the node ids in the branch by looking for nodes that have branch\n   * path taken constraints with the given fromNodeId and toNodeId\n   * @param fromNodeId the from node id\n   * @param toNodeId the to node id\n   * @return an array of nodes that are in the branch path\n   */\n  getNodeIdsInBranch(fromNodeId, toNodeId) {\n    const nodeIdsInBranch = [];\n    const nodes = this.getNodes();\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null) {\n          if (this.hasBranchPathTakenConstraint(node, fromNodeId, toNodeId)) {\n            nodeIdsInBranch.push(node.id);\n          }\n        }\n      }\n    }\n    this.orderNodeIds(nodeIdsInBranch);\n    return nodeIdsInBranch;\n  }\n\n  /**\n   * Order the node ids so that they show up in the same order as in the\n   * project.\n   * @param constraints An array of node ids.\n   * @return An array of ordered node ids.\n   */\n  orderNodeIds(nodeIds) {\n    let orderedNodeIds = this.getFlattenedProjectAsNodeIds();\n    return nodeIds.sort(this.nodeIdsComparatorGenerator(orderedNodeIds));\n  }\n\n  /**\n   * Create the node ids comparator function that is used for sorting an\n   * array of node ids.\n   * @param orderedNodeIds An array of node ids in the order in which they\n   * show up in the project.\n   * @return A comparator that orders node ids in the order in which they show\n   * up in the project.\n   */\n  nodeIdsComparatorGenerator(orderedNodeIds) {\n    return function(nodeIdA, nodeIdB) {\n      let nodeIdAIndex = orderedNodeIds.indexOf(nodeIdA);\n      let nodeIdBIndex = orderedNodeIds.indexOf(nodeIdB);\n      if (nodeIdAIndex < nodeIdBIndex) {\n        return -1;\n      } else if (nodeIdAIndex > nodeIdBIndex) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Check if a node has a branch path taken constraint\n   * @param node the node to check\n   * @param fromNodeId the from node id of the branch path taken\n   * @param toNodeId the to node id of the branch path taken\n   * @return whether the node has a branch path taken constraint with the\n   * given from node id and to node id\n   */\n  hasBranchPathTakenConstraint(node, fromNodeId, toNodeId) {\n    const constraints = node.constraints;\n    if (constraints != null) {\n      for (let constraint of constraints) {\n        for (let removalCriterion of constraint.removalCriteria) {\n          if (removalCriterion.name == 'branchPathTaken') {\n            const params = removalCriterion.params;\n            if (params.fromNodeId == fromNodeId &&\n                params.toNodeId == toNodeId) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Remove all branch path taken constraints from a node.\n   * @param nodeId Remove the constraints from this node.\n   */\n  removeBranchPathTakenNodeConstraintsIfAny(nodeId) {\n    const node = this.getNodeById(nodeId);\n    const constraints = node.constraints;\n    if (constraints != null) {\n      for (let c = 0; c < constraints.length; c++) {\n        const constraint = constraints[c];\n        const removalCriteria = constraint.removalCriteria;\n        for (let removalCriterion of removalCriteria) {\n          if (removalCriterion.name == 'branchPathTaken') {\n            constraints.splice(c, 1);\n            c--; // update the counter so we don't skip over the next element\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param nodeId Get the branch path taken constraints from this node.\n   * @return {Array} An array of branch path taken constraints from the node.\n   */\n  getBranchPathTakenConstraintsByNodeId(nodeId) {\n    const branchPathTakenConstraints = [];\n    const node = this.getNodeById(nodeId);\n    const constraints = node.constraints;\n    if (constraints != null) {\n      for (let constraint of constraints) {\n        for (let removalCriterion of constraint.removalCriteria) {\n          if (removalCriterion.name == 'branchPathTaken') {\n            branchPathTakenConstraints.push(constraint);\n            break;\n          }\n        }\n      }\n    }\n    return branchPathTakenConstraints;\n  }\n\n  /**\n   * Get the project level rubric\n   * @return the project level rubric\n   */\n  getProjectRubric() {\n    return this.project.rubric;\n  }\n\n  /**\n   * Check if a node is a branch point. A branch point is a node with more\n   * than one transition.\n   * @param nodeId the node id\n   * @return whether the node is a branch point\n   */\n  isBranchPoint(nodeId) {\n    const transitions = this.getTransitionsByFromNodeId(nodeId);\n    return transitions != null && transitions.length > 1;\n  }\n\n  /**\n   * Check if a node is the first node in a branch path\n   * @param nodeId the node id\n   * @return whether the node is the first node in a branch path\n   */\n  isFirstNodeInBranchPath(nodeId) {\n    const nodes = this.getNodes();\n    if (nodes != null) {\n      for (let node of nodes) {\n        if (node != null &&\n            node.transitionLogic != null &&\n            node.transitionLogic.transitions != null) {\n          const transitions = node.transitionLogic.transitions;\n\n          if (transitions.length > 1) {\n            /*\n             * there is more than one transition from this node\n             * which means it is a branch point\n             */\n            for (let transition of transitions) {\n              if (transition != null) {\n                const transitionTo = transition.to;\n                if (transitionTo === nodeId) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the node is in any branch path\n   * @param nodeId the node id of the node\n   * @return whether the node is in any branch path\n   */\n  isNodeInAnyBranchPath(nodeId) {\n    let result = false;\n    if (this.nodeIdToIsInBranchPath[nodeId] == null) {\n      /*\n       * we have not calculated whether the node id is in a branch path\n       * before so we will now\n       */\n\n      const branches = this.getBranches();\n      result = this.isNodeIdInABranch(branches, nodeId);\n\n      // remember the result for this node id\n      this.nodeIdToIsInBranchPath[nodeId] = result;\n    } else {\n      /*\n       * we have calculated whether the node id is in a branch path\n       * before\n       */\n      result = this.nodeIdToIsInBranchPath[nodeId];\n    }\n    return result;\n  }\n\n  /**\n   * Check if a node is a branch start point\n   * @param nodeId look for a branch with this start node id\n   * @return whether the node is a branch start point\n   */\n  isBranchStartPoint(nodeId) {\n    const branches = this.getBranches();\n    if (branches != null) {\n      for (let branch of branches) {\n        if (branch.branchStartPoint == nodeId) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if a node is a branch end point\n   * @param nodeId look for a branch with this end node id\n   * @return whether the node is a branch end point\n   */\n  isBranchMergePoint(nodeId) {\n    const branches = this.getBranches();\n    if (branches != null) {\n      for (let branch of branches) {\n        if (branch.branchEndPoint == nodeId) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get all the branches whose branch start point is the given node id\n   * @param nodeId the branch start point\n   * @return an array of branches that have the given branch start point\n   */\n  getBranchesByBranchStartPointNodeId(nodeId) {\n    const branches = [];\n    const allBranches = this.getBranches();\n\n    if (allBranches != null) {\n      for (let branch of allBranches) {\n        if (branch != null) {\n          if (nodeId == branch.branchStartPoint) {\n            /*\n             * the branch start point matches the node id we are\n             * looking for\n             */\n            branches.push(branch);\n          }\n        }\n      }\n    }\n    return branches;\n  }\n\n  /**\n   * Calculate the node numbers and set them into the nodeIdToNumber map\n   */\n  calculateNodeNumbers() {\n    this.nodeIdToNumber = {};\n    this.nodeIdToBranchPathLetter = {};\n    const startNodeId = this.getStartNodeId();\n    const currentActivityNumber = 0;\n    const currentStepNumber = 0;\n    this.calculateNodeNumbersHelper(\n        startNodeId, currentActivityNumber, currentStepNumber);\n  }\n\n  /**\n   * Recursively calcualte the node numbers by traversing the project tree\n   * using transitions\n   * @param nodeId the current node id we are on\n   * @param currentActivityNumber the current activity number\n   * @param currentStepNumber the current step number\n   * @param branchLetterCode (optional) the character code for the branch\n   * letter e.g. 1=A, 2=B, etc.\n   */\n  calculateNodeNumbersHelper(nodeId, currentActivityNumber, currentStepNumber, branchLetterCode) {\n    if (nodeId != null) {\n      if (this.isApplicationNode(nodeId)) {\n        const node = this.getNodeById(nodeId);\n        if (node != null) {\n          const parentGroup = this.getParentGroup(nodeId);\n          if (parentGroup != null) {\n            if (this.nodeIdToNumber[parentGroup.id] == null) {\n              /*\n               * the parent group has not been assigned a number so\n               * we will assign a number now\n               */\n\n              currentActivityNumber = parseInt(currentActivityNumber) + 1;\n\n              /*\n               * set the current step number to 1 now that we have\n               * entered a new group\n               */\n              currentStepNumber = 1;\n\n              this.nodeIdToNumber[parentGroup.id] = \"\" + currentActivityNumber;\n            } else {\n              /*\n               * the parent group has previously been assigned a number so we\n               * will use it\n               */\n              currentActivityNumber = this.nodeIdToNumber[parentGroup.id];\n            }\n          }\n\n          if (this.isBranchMergePoint(nodeId)) {\n            /*\n             * the node is a merge point so we will not use a letter\n             * anymore now that we are no longer in a branch path\n             */\n            branchLetterCode = null;\n          }\n\n          if (this.isBranchStartPoint(nodeId)) {\n            const branchesByBranchStartPointNodeId =\n                this.getBranchesByBranchStartPointNodeId(nodeId);\n            const branchesObject = branchesByBranchStartPointNodeId[0];\n\n            /*\n             * been used in the branch paths so that we know what\n             * step number to give the merge end point\n             * this is used to obtain the max step number that has\n             */\n            let maxCurrentStepNumber = 0;\n\n            // set the step number for the branch start point\n            this.nodeIdToNumber[nodeId] = currentActivityNumber + '.' + currentStepNumber;\n\n            currentStepNumber++;\n            const branchPaths = branchesObject.branchPaths;\n\n            for (let bp = 0; bp < branchPaths.length; bp++) {\n              const branchPath = branchPaths[bp];\n              let branchCurrentStepNumber = currentStepNumber;\n\n              // get the letter code e.g. 1=A, 2=B, etc.\n              const branchLetterCode = bp;\n\n              for (let bpn = 0; bpn < branchPath.length; bpn++) {\n                if (bpn == 0) {\n                  /*\n                   * Recursively call calculateNodeNumbersHelper on the\n                   * first step in this branch path. This will recursively\n                   * calculate the numbers for all the nodes in this\n                   * branch path.\n                   */\n                  const branchPathNodeId = branchPath[bpn];\n                  this.calculateNodeNumbersHelper(branchPathNodeId, currentActivityNumber, branchCurrentStepNumber, branchLetterCode);\n                }\n\n                branchCurrentStepNumber++;\n\n                /*\n                 * update the max current step number if we have found\n                 * a larger number\n                 */\n                if (branchCurrentStepNumber > maxCurrentStepNumber) {\n                  maxCurrentStepNumber = branchCurrentStepNumber;\n                }\n              }\n            }\n\n            // get the step number we should use for the end point\n            currentStepNumber = maxCurrentStepNumber;\n\n            const branchEndPointNodeId = branchesObject.branchEndPoint;\n\n            /*\n             * calculate the node number for the branch end point and\n             * continue calculating node numbers for the nodes that\n             * come after it\n             */\n            this.calculateNodeNumbersHelper(branchEndPointNodeId, currentActivityNumber, currentStepNumber);\n          } else {\n            // the node is not a branch start point\n\n            /*\n             * check if we have already set the number for this node so\n             * that we don't need to unnecessarily re-calculate the\n             * node number\n             */\n            if (this.nodeIdToNumber[nodeId] == null) {\n              // we have not calculated the node number yet\n\n              let number = null;\n\n              if (branchLetterCode == null) {\n                // we do not need to add a branch letter\n\n                // get the node number e.g. 1.5\n                number = currentActivityNumber + '.' + currentStepNumber;\n              } else {\n                // we need to add a branch letter\n\n                // get the branch letter\n                const branchLetter = String.fromCharCode(65 + branchLetterCode);\n\n                // get the node number e.g. 1.5 A\n                number = currentActivityNumber + '.' + currentStepNumber + ' ' + branchLetter;\n\n                // remember the branch path letter for this node\n                this.nodeIdToBranchPathLetter[nodeId] = branchLetter;\n              }\n\n              // set the number for the node\n              this.nodeIdToNumber[nodeId] = number;\n            } else {\n              /*\n               * We have calculated the node number before so we\n               * will return. This will prevent infinite looping\n               * within the project.\n               */\n              return;\n            }\n\n            // increment the step number for the next node to use\n            currentStepNumber++;\n\n            let transitions = [];\n\n            if (node.transitionLogic != null && node.transitionLogic.transitions) {\n              transitions = node.transitionLogic.transitions;\n            }\n\n            if (transitions.length > 0) {\n              /*\n               * loop through all the transitions, there should only\n               * be one but we will loop through them just to be complete.\n               * if there was more than one transition, it would mean\n               * this node is a branch start point in which case we\n               * would have gone inside the other block of code where\n               * this.isBranchStartPoint() is true.\n               */\n              for (let transition of transitions) {\n                if (transition != null) {\n                  if (this.isBranchMergePoint(transition.to)) {\n\n                  } else {\n                    this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\n                  }\n                }\n              }\n            } else {\n              // if there are no transitions, check if the parent group has a transition\n\n              if (parentGroup != null &&\n                  parentGroup.transitionLogic != null &&\n                  parentGroup.transitionLogic.transitions != null &&\n                  parentGroup.transitionLogic.transitions.length > 0) {\n                for (let transition of parentGroup.transitionLogic.transitions) {\n                  if (transition != null) {\n                    this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else {\n        // the node is a group node\n\n        const node = this.getNodeById(nodeId);\n        if (node != null) {\n          // check if the group has previously been assigned a number\n          if (this.nodeIdToNumber[nodeId] == null) {\n            /*\n             * the group has not been assigned a number so\n             * we will assign a number now\n             */\n            if (nodeId == 'group0') {\n              // group 0 will always be given the activity number of 0\n              this.nodeIdToNumber[nodeId] = \"\" + 0;\n            } else {\n              // set the activity number\n              currentActivityNumber = parseInt(currentActivityNumber) + 1;\n\n              /*\n               * set the current step number to 1 now that we have\n               * entered a new group\n               */\n              currentStepNumber = 1;\n\n              // set the activity number\n              this.nodeIdToNumber[nodeId] = \"\" + currentActivityNumber;\n            }\n          } else {\n            /*\n             * We have calculated the node number before so we\n             * will return. This will prevent infinite looping\n             * within the project.\n             */\n            return;\n          }\n\n          if (node.startId != null && node.startId != '') {\n            /*\n             * calculate the node number for the first step in this\n             * activity and any steps after it\n             */\n            this.calculateNodeNumbersHelper(node.startId, currentActivityNumber, currentStepNumber, branchLetterCode);\n          } else {\n            /*\n             * this activity doesn't have a start step so we will\n             * look for a transition\n             */\n\n            if (node != null &&\n                node.transitionLogic != null &&\n                node.transitionLogic.transitions != null &&\n                node.transitionLogic.transitions.length > 0) {\n              for (let transition of node.transitionLogic.transitions) {\n                if (transition != null) {\n                  /*\n                   * calculate the node number for the next group\n                   * and all its children steps\n                   */\n                  this.calculateNodeNumbersHelper(\n                      transition.to, currentActivityNumber, currentStepNumber,\n                      branchLetterCode);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  getProjectScript() {\n    return this.project.script;\n  }\n\n  /**\n   * Get the next node after the specified node\n   * @param nodeId get the node id that comes after this one\n   * @return the node id that comes after\n   */\n  getNextNodeId(nodeId) {\n    const flattenedNodeIds = this.getFlattenedProjectAsNodeIds();\n    if (flattenedNodeIds != null) {\n      const indexOfNodeId = flattenedNodeIds.indexOf(nodeId);\n      if (indexOfNodeId != -1) {\n        const indexOfNextNodeId = indexOfNodeId + 1;\n        return flattenedNodeIds[indexOfNextNodeId];\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get all the projectAchievements object in the project. The projectAchievements object\n   * contains the isEnabled field and an array of items.\n   * @return the achievement object\n   */\n  getAchievements() {\n    if (this.project.achievements == null) {\n      this.project.achievements = {\n        isEnabled: false,\n        items: []\n      };\n    }\n    return this.project.achievements;\n  }\n\n  /**\n   * Get the achievement items in the project\n   * @return the achievement items\n   */\n  getAchievementItems() {\n    const achievements = this.getAchievements();\n    if (achievements.items == null) {\n      achievements.items = [];\n    }\n    return achievements.items;\n  }\n\n  /**\n   * Get an achievement by the 10 character alphanumeric achievement id\n   * @param achievementId the 10 character alphanumeric achievement id\n   * @return the achievement with the given achievement id\n   */\n  getAchievementByAchievementId(achievementId) {\n    if (achievementId != null) {\n      const achievements = this.getAchievements();\n      if (achievements != null) {\n        const achievementItems = achievements.items;\n        if (achievementItems != null) {\n          for (let achievement of achievementItems) {\n            if (achievement != null && achievement.id == achievementId) {\n              return achievement;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Get the total number of rubrics (step + components) for the given nodeId\n   * @param nodeId the node id\n   * @return Number of rubrics for the node\n   */\n  getNumberOfRubricsByNodeId(nodeId) {\n    let numRubrics = 0;\n    let nodeContent = this.getNodeContentByNodeId(nodeId);\n    if (nodeContent) {\n      let nodeRubric = nodeContent.rubric;\n      if (nodeRubric != null && nodeRubric != '') {\n        numRubrics++;\n      }\n\n      let components = nodeContent.components;\n      if (components && components.length) {\n        for (let component of components) {\n          if (component) {\n            const componentRubric = component.rubric;\n            if (componentRubric != null && componentRubric != '') {\n              numRubrics++;\n            }\n          }\n        }\n      }\n    }\n    return numRubrics;\n  }\n\n  /**\n   * Remember the result for whether the node is affected by the constraint\n   * @param nodeId the node id\n   * @param constraintId the constraint id\n   * @param whether the node is affected by the constraint\n   */\n  cacheIsNodeAffectedByConstraintResult(nodeId, constraintId, result) {\n    this.isNodeAffectedByConstraintResult[nodeId + '-' + constraintId] = result;\n  }\n\n  /**\n   * Check if we have calculated the result for whether the node is affected\n   * by the constraint\n   * @param nodeId the node id\n   * @param constraintId the constraint id\n   * @return Return the result if we have calculated the result before. If we\n   * have not calculated the result before, we will return null\n   */\n  getCachedIsNodeAffectedByConstraintResult(nodeId, constraintId) {\n    return this.isNodeAffectedByConstraintResult[nodeId + '-' + constraintId];\n  }\n\n  /**\n   * Get the id to node mappings.\n   * @return An object the keys as node ids and the values as nodes.\n   */\n  getIdToNode() {\n    return this.idToNode;\n  }\n\n  /**\n   * Check if a node has rubrics.\n   * @param nodeId The node id of the node.\n   * @return Whether the node has rubrics authored on it.\n   */\n  nodeHasRubric(nodeId) {\n    let numberOfRubrics = this.getNumberOfRubricsByNodeId(nodeId);\n    if (numberOfRubrics > 0) {\n      return true;\n    }\n    return false;\n  }\n\n  getSpaces() {\n    if (this.project.spaces != null) {\n      return this.project.spaces;\n    } else {\n      return [];\n    }\n  }\n\n  addSpace(space) {\n    if (this.project.spaces == null) {\n      this.project.spaces = [];\n    }\n    if (!this.isSpaceExists(space.id)) {\n      this.project.spaces.push(space);\n      this.saveProject();\n    }\n  }\n\n  isSpaceExists(id) {\n    const spaces = this.getSpaces();\n    for (let space of spaces) {\n      if (space.id === id) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  removeSpace(id) {\n    let spaces = this.getSpaces();\n    for (let s = 0; s < spaces.length; s++) {\n      if (spaces[s].id == id) {\n        spaces.splice(s, 1);\n        this.saveProject();\n        return;\n      }\n    }\n  }\n\n  /**\n   * Returns true iff the specified node and component has any registered additionalProcessingFunctions\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns true/false\n   */\n  hasAdditionalProcessingFunctions(nodeId, componentId) {\n    return this.getAdditionalProcessingFunctions(nodeId, componentId) != null;\n  }\n\n  /**\n   * Returns an array of registered additionalProcessingFunctions for the specified node and component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns an array of additionalProcessingFunctions\n   */\n  getAdditionalProcessingFunctions(nodeId, componentId) {\n    let key = nodeId + \"_\" + componentId;\n    return this.additionalProcessingFunctionsMap[key];\n  }\n\n  getFeaturedProjectIcons() {\n    const featuredProjectIconsURL = this.ConfigService.getConfigParam('featuredProjectIcons');\n    return this.$http.get(featuredProjectIconsURL).then((result) => {\n      return result.data;\n    });\n  }\n\n  setFeaturedProjectIcon(projectIcon) {\n    const featuredProjectIconURL = this.ConfigService.getConfigParam('featuredProjectIcon');\n    return this.setProjectIcon(projectIcon, featuredProjectIconURL);\n  }\n\n  setCustomProjectIcon(projectIcon) {\n    const customProjectIconURL = this.ConfigService.getConfigParam('customProjectIcon');\n    return this.setProjectIcon(projectIcon, customProjectIconURL);\n  }\n\n  setProjectIcon(projectIcon, projectIconURL) {\n    let projectId = this.ConfigService.getProjectId();\n    const httpParams = {\n      method: 'POST',\n      url: projectIconURL,\n      headers: {'Content-Type': 'application/x-www-form-urlencoded'},\n      data: $.param({\n        projectId: projectId,\n        projectIcon: projectIcon\n      })\n    };\n    return this.$http(httpParams).then((result) => {\n      return result.data;\n    });\n  }\n}\n\nProjectService.$inject = [\n  '$filter',\n  '$http',\n  '$injector',\n  '$q',\n  '$rootScope',\n  'ConfigService',\n  'UtilService'\n];\n\nexport default ProjectService;\n"],"file":"projectService.js"}