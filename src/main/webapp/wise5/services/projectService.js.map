{"version":3,"sources":["projectService.es6"],"names":[],"mappings":"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","file":"projectService.js","sourcesContent":["class ProjectService {\n    constructor($http, $rootScope, ConfigService) {\n        this.$http = $http;\n        this.$rootScope = $rootScope;\n        this.ConfigService = ConfigService;\n        this.project = null;\n        this.transitions = [];\n        this.applicationNodes = [];\n        this.groupNodes = [];\n        this.idToNode = {};\n        this.idToElement = {};\n        this.idToTransition = {};\n        this.metadata = {};\n        this.idToContent = {};\n        this.activeConstraints = [];\n        this.rootNode = null;\n        this.idToPosition = {};\n        this.idToOrder = {};\n        this.nodeCount = 0;\n\n        // filtering options for navigation displays\n        this.filters = [\n            {'name': 'all', 'label': 'All'},\n            //{'name': 'todo', 'label': 'Todo'},\n            //{'name': 'completed', 'label': 'Completed'},\n            {'name': 'bookmark', 'label': 'Bookmarks'} // TODO: Add when bookmarks are active\n        ];\n    }\n\n    getProject() {\n        return this.project;\n    };\n\n    setProject(project) {\n        this.project = project;\n        if (project.metadata) {\n            this.metadata = project.metadata;\n        }\n        this.parseProject();\n    };\n\n    getStyle() {\n        var style = '';\n        var project = this.project;\n        if (project != null) {\n            style = project.style;\n        }\n        return style;\n    };\n\n    getFilters(){\n        return this.filters;\n    };\n\n    getName() {\n        var name = this.getProjectMetadata().title;\n        name = name ? name : 'A WISE Project (No name)';\n        return name;\n    };\n\n    getProjectMetadata() {\n        return this.metadata;\n    };\n\n    getNodes() {\n        var nodes = null;\n        var project = this.project;\n\n        if (project != null) {\n            nodes = project.nodes;\n        }\n\n        return nodes;\n    };\n\n    getChildNodeIdsById(nodeId) {\n        var childIds = [];\n        var node = this.getNodeById(nodeId);\n\n        if (node.ids) {\n            childIds = node.ids;\n        }\n\n        return childIds;\n    };\n\n    getApplicationNodes() {\n        return this.applicationNodes;\n    };\n\n    getGroupNodes() {\n        return this.groupNodes;\n    };\n\n    getIdToNode() {\n        return this.idToNode;\n    };\n\n    isNode(id) {\n        var result = false;\n        var nodes = this.getNodes();\n\n        if (nodes != null) {\n            for (var n = 0; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeId = node.id;\n\n                    if (nodeId === id) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    // adds or update transition if exists\n    addTransition(transition) {\n\n        var existingTransitions = this.getTransitions();\n        var replaced = false;\n        for (var t = 0; t < existingTransitions.length; t++) {\n            var existingTransition = existingTransitions[t];\n            if (existingTransition.id === transition.id) {\n                existingTransitions.splice(t, 1, transition);\n                replaced = true;\n            }\n        }\n        if (!replaced) {\n            existingTransitions.push(transition);\n        }\n    };\n\n    addNode(node) {\n        var existingNodes = this.project.nodes;\n\n        var replaced = false;\n        if (node != null && existingNodes != null) {\n            for (var n = 0; n < existingNodes.length; n++) {\n                var existingNode = existingNodes[n];\n                var existingNodeId = existingNode.id;\n                if (existingNodeId === node.id) {\n                    existingNodes.splice(n, 1, node);\n                    replaced = true;\n                }\n            }\n        }\n        if (!replaced) {\n            existingNodes.push(node);\n        }\n    };\n\n    addApplicationNode(node) {\n\n        var applicationNodes = this.applicationNodes;\n\n        if (node != null && applicationNodes != null) {\n            applicationNodes.push(node);\n        }\n    };\n\n    addGroupNode(node) {\n\n        var groupNodes = this.groupNodes;\n\n        if (node != null && groupNodes != null) {\n            groupNodes.push(node);\n        }\n\n        this.$rootScope.$broadcast('groupsChanged');\n    };\n\n    addNodeToGroupNode(groupId, nodeId) {\n        if (groupId != null && nodeId != null) {\n            var group = this.getNodeById(groupId);\n            if (group != null) {\n                var groupChildNodeIds = group.ids;\n                if (groupChildNodeIds != null) {\n                    if (groupChildNodeIds.indexOf(nodeId) === -1) {\n                        groupChildNodeIds.push(nodeId);\n                    }\n                }\n            }\n        }\n    };\n\n    isGroupNode(id) {\n        var result = false;\n\n        var groupNode = this.getNodeById(id);\n\n        if (groupNode != null) {\n            var type = groupNode.type;\n\n            if (type === 'group') {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    isApplicationNode(id) {\n        var result = false;\n\n        var applicationNode = this.getNodeById(id);\n\n        if (applicationNode != null) {\n            var type = applicationNode.type;\n\n            if (type !== 'group') {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    getGroups() {\n        return this.groupNodes;\n    };\n\n    loadNodes(nodes) {\n        if (nodes != null) {\n            for (var n = 0 ; n < nodes.length; n++) {\n                var node = nodes[n];\n\n                if (node != null) {\n                    var nodeId = node.id;\n                    var nodeType = node.type;\n                    var content = node.content;\n                    var constraints = node.constraints;\n\n                    if (content != null) {\n                        //node.content = this.injectAssetPaths(content);\n                    }\n\n                    this.setIdToNode(nodeId, node);\n                    this.setIdToElement(nodeId, node);\n\n                    this.addNode(node);\n\n                    if (nodeType === 'group') {\n                        this.addGroupNode(node);\n                    } else {\n                        this.addApplicationNode(node);\n                    }\n\n                    var groupId = node.groupId;\n\n                    if (groupId != null) {\n                        this.addNodeToGroupNode(groupId, nodeId);\n                    }\n\n                    if (constraints != null) {\n                        for (var c = 0; c < constraints.length; c++) {\n                            var constraint = constraints[c];\n\n                            this.activeConstraints.push(constraint);\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    loadTransitions(transitions) {\n        if (transitions != null) {\n            for (var t = 0; t < transitions.length; t++) {\n                var transition = transitions[t];\n\n                if (transition != null) {\n                    var transitionId = transition.id;\n\n                    this.setIdToElement(transitionId, transition);\n                    this.setIdToTransition(transitionId, transition);\n\n                    this.addTransition(transition);\n                }\n            }\n        }\n    };\n\n    parseProject() {\n        var project = this.project;\n        if (project != null) {\n            var nodes = project.nodes;\n            this.loadNodes(nodes);\n\n            var transitions = project.transitions;\n            this.loadTransitions(transitions);\n\n            var constraints = project.constraints;\n\n            if (constraints != null) {\n                for (var c = 0; c < constraints.length; c++) {\n                    var constraint = constraints[c];\n\n                    if (constraint != null) {\n                        var constraintId = constraint.id;\n                        constraint.active = true;\n\n                        this.setIdToElement(constraintId, constraint);\n                    }\n                }\n            }\n\n            // set root node\n            this.rootNode = this.getRootNode(nodes[0].id);\n\n            // set project order\n            this.setNodeOrder(this.rootNode, this.nodeCount);\n            this.nodeCount = 0;\n\n            var n = nodes.length;\n            var branches = this.getBranches();\n            var branchNodeIds = [];\n\n            // set node positions\n            var id, pos;\n\n            while (n--) {\n                id = nodes[n].id;\n                if(id === this.rootNode.id) {\n                    this.setIdToPosition(id, '0');\n                } else if (this.isNodeIdInABranch(branches, id)) {\n                    // node is in a branch, so process later\n                    branchNodeIds.push(id);\n                } else {\n                    pos = this.getPositionById(id);\n                    this.setIdToPosition(id, pos);\n                }\n            }\n\n            // set branch node positions\n            var b = branchNodeIds.length;\n            while (b--) {\n                id = branchNodeIds[b];\n                pos = this.getBranchNodePositionById(id);\n                this.setIdToPosition(id, pos);\n            }\n        }\n    };\n\n    setNodeOrder(node) {\n        this.idToOrder[node.id] = {'order': this.nodeCount};\n        this.nodeCount++;\n        if (this.isGroupNode(node.id)){\n            var childIds = node.ids;\n            for(var i=0; i<childIds.length; i++){\n                var child = this.getNodeById(childIds[i]);\n                this.setNodeOrder(child);\n            }\n        }\n    };\n\n    /**\n     * Returns the position in the project for the node with the given id. Returns null if no node with id exists.\n     * @param id a node id\n     * @return string position of the given node id in the project\n     */\n    getPositionById(id) {\n        for (var i=0;i<this.rootNode.ids.length;i++) {\n            var node = this.getNodeById(this.rootNode.ids[i]);\n            var path = this.getPathToNode(node, i+1, id);\n            if (path!=undefined && path!=null) {\n                return path;\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Returns the order of the given node id in the project. Returns null if no node with id exists.\n     * @param id String node id\n     * @return Number order of the given node id in the project\n     */\n    getOrderById(id) {\n        if(this.idToOrder[id]) {\n            return this.idToOrder[id].order;\n        }\n\n        return null;\n    };\n    /**\n     * Returns the id of the node with the given order in the project. Returns null if no order with node exists.\n     * @param order Number\n     * @return Number node id of the given order in the project\n     */\n    getIdByOrder(order) {\n        var nodeId = null;\n\n        for (var id in this.idToOrder) {\n            if (this.idToOrder[id].order === order) {\n                if (this.isGroupNode(id) && order > 1) {\n                    nodeId = this.getIdByOrder(order-1);\n                } else {\n                    nodeId = id;\n                }\n                break;\n            }\n        }\n\n        return nodeId;\n    };\n\n    /**\n     * Returns the position in the project for the branch node with the given id. Returns null if no node with id exists or node is not a branch node.\n     * @param id a node id\n     * @return string position of the given node id in the project\n     */\n    getBranchNodePositionById(id) {\n        var branches = this.getBranches();\n        var b = branches.length;\n\n        // TODO: should we localize this? should we support more than 26?\n        var integerToAlpha = function(int) {\n            var alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n            if(int > -1 && int < 26){\n                return alphabet[int];\n            } else {\n                return int;\n            }\n        };\n\n\n        while (b--) {\n            var branch = branches[b];\n            var branchPaths = branch.branchPaths;\n            for (var p=0; p<branchPaths.length; p++) {\n                var branchPath = branchPaths[p];\n                var nodeIndex = branchPath.indexOf(id);\n                if (nodeIndex > -1) {\n                    var startPoint = branch.branchStartPoint;\n                    var startPointPos = this.idToPosition[startPoint];\n                    var branchPathPos = startPointPos + ' ' + integerToAlpha(p);\n                    return branchPathPos + (nodeIndex+1);\n                }\n            }\n        }\n\n        return null;\n    };\n\n    /**\n     * Recursively searches for the given node id from the point of the given node down and returns the path number (position)\n     * @param node a node to start searching down\n     * @param path the position of the given node\n     * @param id the node id to search for\n     * @return string path of the given node id in the project\n     */\n    getPathToNode(node, path, id) {\n        if (node.id===id) {\n            return path + '';\n        } else if (node.type==='group'){\n            var num = 0;\n            var branches = this.getBranches();\n            for (var i=0;i<node.ids.length;i++) {\n                var nodeId = node.ids[i];\n                if (this.isNodeIdInABranch(branches, nodeId)) {\n                    this.getBranchNodePositionById(nodeId);\n                } else {\n                    ++num;\n                    var pos = this.getPathToNode(this.getNodeById(nodeId), (path) + '.' + (num), id);\n                    if (pos) {\n                        return pos;\n                    }\n                }\n            }\n        }\n    };\n\n    setIdToPosition(id, pos) {\n        if (id != null) {\n            this.idToPosition[id] = pos;\n        }\n    };\n\n    getNodePositionById(id) {\n        if (id != null) {\n            return this.idToPosition[id];\n        }\n    };\n\n    setIdToNode(id, element) {\n        if (id != null) {\n            this.idToNode[id] = element;\n        }\n    };\n\n    setIdToElement(id, element) {\n        if (id != null) {\n            this.idToElement[id] = element;\n        }\n    };\n\n    /**\n     * Replace relative asset paths with absolute paths\n     * e.g.\n     * assets/myimage.jpg\n     * will be replaced with\n     * http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg\n     * @param content a string or JSON object\n     * @return the same type of object that was passed in as the content\n     * but with relative asset paths replaced with absolute paths\n     */\n    injectAssetPaths(content) {\n\n        if (content != null) {\n\n            if (typeof content === 'object') {\n\n                var contentString = JSON.stringify(content);\n\n                if (contentString != null) {\n\n                    // replace the relative asset paths with the absolute paths\n                    contentString = this.replaceAssetPaths(contentString);\n\n                    content = JSON.parse(contentString);\n                }\n            } else if (typeof content === 'string') {\n\n                // replace the relative asset paths with the absolute paths\n                content = this.replaceAssetPaths(content);\n            }\n        }\n\n        return content;\n    };\n\n    /**\n     * Replace the relative asset paths with absolute paths\n     * @param contentString the content string\n     * @return the content string with relative asset paths replaced\n     * with absolute asset paths\n     */\n    replaceAssetPaths(contentString) {\n\n        if (contentString != null) {\n\n            // get the content base url e.g. http://wise.berkeley.edu/curriculum/123456/\n            var contentBaseURL = this.ConfigService.getConfigParam('projectBaseURL');\n\n            // only look for string that starts with ' or \" and ends in png, jpg, jpeg, pdf, etc.\n            // the string we're looking for can't start with '/ and \"/.\n            // note that this also works for \\\"abc.png and \\'abc.png, where the quotes are escaped\n            var startTime = new Date().getTime();\n            contentString = contentString.replace(\n                new RegExp('(\\'|\\\")[^\\/][^\\/][a-zA-Z0-9@\\\\._\\\\/\\\\s\\\\-]*(png|jpe?g|pdf|gif|mp4|mp3|wav|swf|css|txt|json|xlsx?|doc)', 'gi'),\n                function myFunction(matchedString) {\n                    // once found, we prepend the contentBaseURL + \"assets/\" to the string within the quotes and keep everything else the same.\n                    var firstQuote = matchedString.substr(0,1);  // this could be ' or \"\n                    var matchedStringWithoutFirstQuote = matchedString.substr(1);\n                    return  firstQuote + contentBaseURL + \"assets/\" + matchedStringWithoutFirstQuote;\n                }\n            );\n            var endTime = new Date().getTime();\n        }\n\n        return contentString;\n    };\n\n    getElementById(id) {\n        var element = null;\n\n        if (id != null) {\n            element = this.idToElement[id];\n        }\n\n        return element;\n    };\n\n    getNodeById(id) {\n        var element = null;\n\n        if (id != null) {\n            element = this.idToNode[id];\n        }\n\n        return element;\n    };\n\n    setIdToTransition(id, transition) {\n        if (id != null) {\n            this.idToTransition[id] = transition;\n        }\n    };\n\n    getTransitionById(id) {\n        var element = null;\n\n        if (id != null) {\n            element = this.idToTransition[id];\n        }\n\n        return element;\n    };\n\n    getConstraintById(id) {\n        var element = null;\n\n        if (id != null) {\n            element = this.idToElement[id];\n        }\n\n        return element;\n    };\n\n    getParentGroup(nodeId) {\n        var result = null;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                var groupNodes = this.getGroupNodes();\n\n                for (var g = 0; g < groupNodes.length; g++) {\n                    var groupNode = groupNodes[g];\n\n                    if (this.isNodeDirectChildOfGroup(node, groupNode)) {\n                        result = groupNode;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    getNodeDepth(nodeId, val) {\n        var result = null;\n\n        if(nodeId != null){\n            var depth = (typeof val === \"number\") ? val : 0;\n            var parent = this.getParentGroup(nodeId);\n            if(parent){\n                depth = this.getNodeDepth(parent.id, depth+1);\n            }\n            result = depth;\n        }\n\n        return result;\n    };\n\n    getRootNode(nodeId) {\n        var result = null;\n\n        var parentGroup = this.getParentGroup(nodeId);\n\n        if (parentGroup == null) {\n            result = this.getNodeById(nodeId);\n        } else {\n            result = this.getRootNode(parentGroup.id);\n        }\n\n        return result;\n    };\n\n    isNodeDirectChildOfGroup(node, group) {\n        var result = false;\n\n        if (node != null && group != null) {\n            var nodeId = node.id;\n            var groupIds = group.ids;\n\n            if (groupIds != null && groupIds.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    isNodeDescendentOfGroup(node, group) {\n        var result = false;\n\n        if (node != null && group != null) {\n            var descendents = this.getDescendentsOfGroup(group);\n            var nodeId = node.id;\n\n            if (descendents.indexOf(nodeId) != -1) {\n                result = true;\n            }\n        }\n\n        return result;\n    };\n\n    getDescendentsOfGroup(group) {\n        var descendents = [];\n\n        if (group != null) {\n            var childIds = group.ids;\n\n            if (childIds != null) {\n                descendents = childIds;\n\n                for (var c = 0; c < childIds.length; c++) {\n                    var childId = childIds[c];\n\n                    var node = this.getNodeById(childId);\n\n                    if (node != null) {\n                        var childDescendents = this.getDescendentsOfGroup(node);\n\n                        descendents = descendents.concat(childDescendents);\n                    }\n                }\n            }\n        }\n\n        return descendents;\n    };\n\n    isStartNode(node) {\n        var result = false;\n\n        if (node != null) {\n            var nodeId = node.id;\n\n            var projectStartId = this.getStartNodeId();\n\n            if (nodeId === projectStartId) {\n                result = true;\n            }\n\n            var groups = this.getGroups();\n\n            for (var g = 0; g < groups.length; g++) {\n                var group = groups[g];\n\n                if (group != null) {\n                    var groupStartId = group.startId;\n\n                    if (nodeId === groupStartId) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    getStartNodeId() {\n        var startNodeId = null;\n        var project = this.getProject();\n        if (project != null) {\n            startNodeId = project.startNodeId;\n        }\n        return startNodeId;\n    };\n\n    getConstraints() {\n        var constraints = this.activeConstraints;\n\n        return constraints;\n    };\n\n    getConstraintsForNode(node) {\n        var constraints = [];\n\n        var allConstraints = this.getConstraints();\n\n        for (var c = 0; c < allConstraints.length; c++) {\n            var constraint = allConstraints[c];\n\n            if (this.isNodeAffectedByConstraint(node, constraint)) {\n                constraints.push(constraint);\n            }\n        }\n\n        return constraints;\n    };\n\n    isNodeAffectedByConstraint(node, constraint) {\n        var result = false;\n\n        if (node != null && constraint != null) {\n            var nodeId = node.id;\n            var targetId = constraint.targetId;\n\n            var targetNode = this.getNodeById(targetId);\n\n            if (targetNode != null) {\n                var nodeType = targetNode.type;\n\n                if (nodeType === 'node') {\n                    // the target is an application\n\n                    if (nodeId === targetId) {\n                        result = true;\n                    }\n                } else if (nodeType === 'group') {\n                    // the target is a group\n\n                    if (this.isNodeDescendentOfGroup(node, targetNode)) {\n                        result = true;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    getNavigationMode() {\n        var navigationMode = null;\n        var project = this.getProject();\n        if (project != null) {\n            navigationMode = project.navigationMode;\n        }\n        return navigationMode;\n    };\n\n    getNavigationApplications() {\n        var navigationApplications = null;\n        var project = this.getProject();\n        if (project != null) {\n            navigationApplications = project.navigationApplications;\n        }\n        return navigationApplications;\n    };\n\n    getTransitions() {\n        var transitions = null;\n        var project = this.getProject();\n        if (project != null) {\n            transitions = project.transitions;\n        }\n        return transitions;\n    };\n\n    getTransitionsByGroupId(groupId) {\n        var transitionsInGroup = [];\n\n        if (groupId != null) {\n            var group = this.getNodeById(groupId);\n\n            if (group != null) {\n                var childIds = group.ids;\n\n                if (childIds != null) {\n                    var allTransitions = this.getTransitions();\n\n                    // loop through all the transitions\n\n                    for (var t = 0; t < allTransitions.length; t++) {\n                        var tempTransition = allTransitions[t];\n\n                        if (tempTransition != null) {\n                            var from = tempTransition.from;\n                            var to = tempTransition.to;\n\n                            if (childIds.indexOf(from) != -1 || childIds.indexOf(to) != -1) {\n                                transitionsInGroup.push(tempTransition);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        var project = this.getProject();\n        if (project != null) {\n\n\n            transitions = project.transitions;\n        }\n        return transitionsInGroup;\n    };\n\n    getTransitionsByFromNodeId0(fromNodeId) {\n        var transitionsResults = [];\n        if (fromNodeId != null) {\n            var transitions = this.getTransitions();\n\n            if (transitions != null) {\n                for (var i = 0; i < transitions.length; i++) {\n                    var transition = transitions[i];\n                    if (transition.from === fromNodeId && !transition.disabled) {\n                        transitionsResults.push(transition);\n                    }\n                }\n            }\n        }\n\n        return transitionsResults;\n    };\n\n    /**\n     * Get the transition logic for a node\n     * @param fromNodeId the from node id\n     * @returns the transition logic object\n     */\n    getTransitionLogicByFromNodeId(fromNodeId) {\n        var transitionLogic = null;\n\n        if (fromNodeId != null) {\n\n            // get the node\n            var node = this.getNodeById(fromNodeId);\n\n            if (node != null) {\n                // get the transition logic\n                transitionLogic = node.transitionLogic;\n            }\n        }\n\n        return transitionLogic;\n    };\n\n    getTransitionsByToNodeId(toNodeId) {\n        var transitionsResults = [];\n        if (toNodeId != null) {\n            var transitions = this.getTransitions();\n\n            if (transitions != null) {\n                for (var i = 0; i < transitions.length; i++) {\n                    var transition = transitions[i];\n                    if (transition.to === toNodeId) {\n                        transitionsResults.push(transition);\n                    }\n                }\n            }\n        }\n\n        return transitionsResults;\n    };\n\n    getTransitionsByFromAndToNodeId(fromNodeId, toNodeId) {\n        var transitionsResults = [];\n\n        if (fromNodeId != null && toNodeId != null) {\n            var node = this.getNodeById(fromNodeId);\n\n            if (node != null) {\n                var transitionLogic = node.transitionLogic;\n\n                if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    if (transitions != null) {\n\n                        for (var t = 0; t < transitions.length; t++) {\n                            var transition = transitions[t];\n\n                            if (transition != null) {\n                                var to = transition.to;\n\n                                if (toNodeId === to) {\n                                    transitionsResults.push(transition);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return transitionsResults;\n    };\n\n    getLayoutLogic() {\n        var layoutLogic = null;\n        var project = this.getProject();\n        if (project != null) {\n            layoutLogic = project.layoutLogic;\n        }\n        return layoutLogic;\n    };\n\n    retrieveProject() {\n        var projectFileUrl = this.ConfigService.getConfigParam('projectURL');\n\n        return this.$http.get(projectFileUrl).then(angular.bind(this, function(result) {\n            var projectJSON = result.data;\n            this.setProject(projectJSON);\n            return projectJSON;\n        }));\n    };\n\n    saveProject(projectJSON, commitMessage) {\n\n        if (projectJSON == null) {\n            // get the project from this service\n            projectJSON = angular.toJson(this.project, 4);\n        }\n\n        var httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = this.ConfigService.getConfigParam('saveProjectURL');\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n        var params = {};\n        params.projectId = this.ConfigService.getProjectId();\n        params.commitMessage = commitMessage;\n        params.projectJSONString = projectJSON;\n        httpParams.data = $.param(params);\n\n        return this.$http(httpParams).then(angular.bind(this, function(result) {\n            var commitHistory = result.data;\n            return commitHistory;\n        }));\n    };\n\n    commitChanges(commitMessage) {\n        var commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\n\n        return this.$http({\n            url: commitProjectURL,\n            method: 'POST',\n            params: {commitMessage: commitMessage}\n        }).then(angular.bind(this, function(result) {\n            var commitResult = result.data;\n            return commitResult;\n        }));\n    };\n\n    getCommitHistory() {\n        var commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\n\n        return this.$http({\n            url: commitProjectURL,\n            method: 'GET'\n        }).then(angular.bind(this, function(result) {\n            return result.data;\n        }));\n    };\n\n    getThemePath() {\n        var project = this.getProject();\n        if (project && project.theme) { // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n            return 'wise5/vle/themes/' + project.theme;\n        } else {\n            return \"wise5/vle/themes/default\"; // TODO: get default theme name from ConfigService\n        }\n    };\n\n    getNodeTypeByNode(node) {\n        var nodeType = null;\n\n        if (node != null) {\n            nodeType = node.type;\n        }\n\n        return nodeType;\n    };\n\n    getApplicationTypeByNode(node) {\n        var applicationType = null;\n\n        if (node != null) {\n            applicationType = node.applicationType;\n        }\n\n        return applicationType;\n    };\n\n    getNodeSrcByNodeId(nodeId) {\n        var nodeSrc = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n            nodeSrc = node.src;\n        }\n\n        if(nodeSrc != null) {\n            var projectBaseURL = this.ConfigService.getConfigParam('projectBaseURL');\n            nodeSrc = projectBaseURL + nodeSrc;\n        }\n\n        return nodeSrc;\n    };\n\n    getNodeTitleByNodeId(nodeId) {\n        var title = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n            title = node.title;\n        }\n\n        return title;\n    };\n\n    /**\n     * Get the node position and title\n     * @param nodeId the node id\n     * @returns the node position and title\n     */\n    getNodePositionAndTitleByNodeId(nodeId) {\n        var title = null;\n\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n\n            var position = this.getNodePositionById(nodeId);\n\n            if (position != null) {\n                title = position + ' ' + node.title;\n            } else {\n                title = node.title;\n            }\n        }\n\n        return title;\n    };\n\n    getNodeIconByNodeId(nodeId) {\n        var node = this.getNodeById(nodeId);\n        var nodeIcon = null;\n\n        if (node != null) {\n            var nodeType = this.getNodeTypeByNode(node);\n\n            // set defaults (TODO: get from configService?)\n            var defaultName = (nodeType === 'group') ? 'explore' : 'school';\n            nodeIcon = {\n                color: 'rgba(0,0,0,0.54)',\n                type: 'font',\n                fontSet: 'material-icons',\n                fontName: defaultName,\n                imgSrc: '',\n                imgAlt: 'node icon'\n            };\n\n            // TODO: check for different statuses\n            var icons = node.icons;\n            if (!!icons && !!icons.default){\n                var icon = icons.default;\n                nodeIcon = $.extend(true, nodeIcon, icon);\n            }\n\n            // check for empty image source\n            if(!nodeIcon.imgSrc){\n                // revert to font icon\n                nodeIcon.type = 'font';\n            }\n        }\n\n        return nodeIcon;\n    };\n\n    getStudentIsOnGroupNodeClass() {\n        var studentIsOnGroupNodeClass = null;\n        var project = this.getProject();\n\n        if (project != null) {\n            var layout = project.layout\n\n            if (layout != null) {\n                studentIsOnGroupNodeClass = layout.studentIsOnGroupNode;\n            }\n        }\n\n        return studentIsOnGroupNodeClass;\n    };\n\n    getStudentIsOnApplicationNodeClass() {\n        var studentIsOnApplicationNodeClass = null;\n        var project = this.getProject();\n\n        if (project != null) {\n            var layout = project.layout\n\n            if (layout != null) {\n                studentIsOnApplicationNodeClass = layout.studentIsOnApplicationNode;\n            }\n        }\n\n        return studentIsOnApplicationNodeClass;\n    };\n\n    getStartGroupId() {\n        var startGroupId = null;\n        var project = this.getProject();\n        if (project != null) {\n            startGroupId = project.startGroupId;\n        }\n        return startGroupId;\n    };\n\n    /**\n     * Flatten the project to obtain a list of node ids\n     */\n    getFlattenedProjectAsNodeIds() {\n        var nodeIds = [];\n\n        // get the start node id\n        var startNodeId = this.getStartNodeId();\n\n        /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n        var pathsSoFar = [];\n\n        // get all the possible paths through the project\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n        // consolidate all the paths to create a single list of node ids\n        nodeIds = this.consolidatePaths(allPaths);\n        //nodeIds = this.consolidatePaths(allPaths.reverse());\n\n        return nodeIds;\n    };\n\n    /**\n     * Get all the possible paths through the project. This function\n     * recursively calls itself to traverse the project depth first.\n     * @param pathSoFar the node ids in the path so far. the node ids\n     * in this array are referenced to make sure we don't loop back\n     * on the path.\n     * @param nodeId the node id we are want to get the paths from\n     * @return an array of paths. each path is an array of node ids.\n     */\n    getAllPaths(pathSoFar, nodeId) {\n        var allPaths = [];\n\n        if (nodeId != null) {\n            if (this.isApplicationNode(nodeId)) {\n                // the node is an application node\n\n                // get the transition logic from the node id\n                var transitionLogic = this.getTransitionLogicByFromNodeId(nodeId);\n\n                if (transitionLogic != null) {\n\n                    // get all the transitions from this node\n                    var transitions = transitionLogic.transitions;\n\n                    var path = [];\n\n                    if (transitions != null) {\n\n                        // add the node id to the path so far\n                        pathSoFar.push(nodeId);\n\n                        if (transitions.length === 0) {\n                            /*\n                             * there are no transitions from the node id so this path\n                             * only contains this node id\n                             */\n\n                            // add the node id to the path\n                            path.push(nodeId);\n\n                            // add the path to the all paths array\n                            allPaths.push(path);\n                        } else {\n                            // loop through all the transitions from this node id\n                            for (var t = 0; t < transitions.length; t++) {\n                                var transitionResult = [];\n\n                                // get a transition\n                                var transition = transitions[t];\n\n                                if (transition != null) {\n                                    // get the to node id\n                                    var toNodeId = transition.to;\n\n                                    if (pathSoFar.indexOf(toNodeId) == -1) {\n                                        /*\n                                         * recursively get the paths by getting all\n                                         * the paths for the to node\n                                         */\n                                        var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId);\n\n                                        if (allPathsFromToNode != null) {\n                                            // loop through all the paths for the to node\n                                            for (var a = 0; a<allPathsFromToNode.length; a++) {\n\n                                                // get a path\n                                                var tempPath = allPathsFromToNode[a];\n\n                                                // prepend the current node id to the path\n                                                tempPath.unshift(nodeId);\n\n                                                // add the path to our collection of paths\n                                                allPaths.push(tempPath);\n                                            }\n                                        }\n                                    } else {\n                                        /*\n                                         * the node is already in the path so far which means\n                                         * the transition is looping back to a previous node.\n                                         * we do not want to take this transition because\n                                         * it will lead to an infinite loop. we will just\n                                         * add the current node id to the path and not take\n                                         * the transition which essentially ends the path.\n                                         */\n                                        // add the node id to the path\n                                        path.push(nodeId);\n\n                                        // add the path to the all paths array\n                                        allPaths.push(path);\n                                    }\n                                }\n                            }\n                        }\n\n                        /*\n                         * remove the latest node id since we are moving back\n                         * up the path as we traverse the nodes depth first\n                         */\n                        pathSoFar.pop();\n                    }\n                }\n            } else if (this.isGroupNode(nodeId)) {\n                // the node is a group node\n            }\n        }\n\n        return allPaths;\n    };\n\n    /**\n     * Consolidate all the paths into a linear list of node ids\n     * @param paths an array of paths. each path is an array of node ids.\n     * @return an array of node ids that have been properly ordered\n     */\n    consolidatePaths(paths) {\n        var consolidatedPath = [];\n\n        if (paths != null) {\n\n            /*\n             * continue until all the paths are empty. as we consolidate\n             * node ids, we will remove them from the paths. once all the\n             * paths are empty we will be done consolidating the paths.\n             */\n            while(!this.arePathsEmpty(paths)) {\n\n                // start with the first path\n                var currentPath = this.getNonEmptyPathIndex(paths);\n\n                // get the first node id in the current path\n                var nodeId = this.getFirstNodeIdInPathAtIndex(paths, currentPath);\n\n                if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n                    // the first node ids in all the paths are the same\n\n                    // remove the node id from all the paths\n                    this.removeNodeIdFromPaths(nodeId, paths);\n\n                    // add the node id to our consolidated path\n                    consolidatedPath.push(nodeId);\n                } else {\n                    // not all the top node ids are the same which means we have branched\n\n                    // get all the paths that contain the node id\n                    var pathsThatContainNodeId = this.getPathsThatContainNodeId(nodeId, paths);\n\n                    if (pathsThatContainNodeId != null) {\n                        if(pathsThatContainNodeId.length === 1) {\n                            // only the current path we are on has the node id\n\n                            // remove the node id from the path\n                            this.removeNodeIdFromPath(nodeId, paths, currentPath);\n\n                            // add the node id to our consolidated path\n                            consolidatedPath.push(nodeId);\n                        } else {\n                            // there are multiple paths that have this node id\n\n                            // consume all the node ids up to the given node id\n                            var consumedPath = this.consumePathsUntilNodeId(paths, nodeId);\n\n                            // remove the node id from the paths\n                            this.removeNodeIdFromPaths(nodeId, paths);\n\n                            // add the node id to the end of the consumed path\n                            consumedPath.push(nodeId);\n\n                            // add the consumed path to our consolidated path\n                            consolidatedPath = consolidatedPath.concat(consumedPath);\n                        }\n                    }\n                }\n\n            }\n        }\n\n        return consolidatedPath;\n    };\n\n    /**\n     * Consume the node ids in the paths until we get to the given node id\n     * @param paths the paths to consume\n     * @param nodeId the node id to stop consuming at\n     * @return an array of node ids that we have consumed\n     */\n    consumePathsUntilNodeId(paths, nodeId) {\n        var consumedNodeIds = [];\n\n        if (paths != null && nodeId != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // check if the path contains the node id to stop consuming at\n                if (path != null && path.indexOf(nodeId) != -1) {\n                    /*\n                     * the path does contain the node id to stop consuming at\n                     * so we will consume the node ids in this path until\n                     * we get to the given node id to stop consuming at\n                     */\n\n                    // loop through the node ids in the path\n                    for (var x = 0; x < path.length; x++) {\n\n                        // get a node id\n                        var tempNodeId = path[x];\n\n                        if (nodeId === tempNodeId) {\n                            /*\n                             * the node id is the same as the one we need to\n                             * stop consuming at so we will stop looking\n                             * at this path\n                             */\n                            break;\n                        } else {\n                            /*\n                             * the node id is not the one that we need to stop consuming at\n                             * so we will consume it\n                             */\n\n                            // get all the paths that contain the node id\n                            var pathsThatContainNodeId = this.getPathsThatContainNodeId(tempNodeId, paths);\n\n                            if (pathsThatContainNodeId.length === 1) {\n                                // there is only one path with this node id\n\n                                // remove the node id from the path\n                                this.removeNodeIdFromPath(tempNodeId, paths, p);\n\n                                // move the counter back one since we have just removed a node id\n                                x--;\n\n                                // add the node id to the consumed node ids array\n                                consumedNodeIds.push(tempNodeId);\n                            } else {\n                                // there are multiple paths with this node id\n\n                                // tempNodeId must come before nodeId\n\n                                var pathsToConsume = [];\n\n                                // loop through all the paths that contain the node id\n                                for (var g = 0; g < pathsThatContainNodeId.length; g++) {\n\n                                    // get a path that contains the node id\n                                    var pathThatContainsNodeId = pathsThatContainNodeId[g];\n\n                                    // get the index of the node id we want to remove\n                                    var tempNodeIdIndex = pathThatContainsNodeId.indexOf(tempNodeId);\n\n                                    // get the index of the node id we want to stop consuming at\n                                    var nodeIdIndex = pathThatContainsNodeId.indexOf(nodeId);\n\n                                    /*\n                                     * check if the node id we want to remove comes before\n                                     * the node id we want to stop consuming at. we need to\n                                     * do this to prevent an infinite loop. an example of\n                                     * when this can happen is if there are two paths\n                                     *\n                                     * path1 = 1, 2, 3, 4, 5\n                                     * path2 = 1, 2, 4, 3, 5\n                                     *\n                                     * as we consume path1 we will need to consume 3. in order to\n                                     * consume 3, we must consume consume up to 3 in path2.\n                                     * in order to consume up to 3 in path2 we must consume 4.\n                                     * in order to consume 4, we must consume everything before\n                                     * 4 in path1. everything before 4 in path1 is 1, 2, 3.\n                                     * this means we need to consume 3 which brings us back up\n                                     * to the top of this paragraph creating an infinite loop.\n                                     *\n                                     * this check below will prevent infinite loops by only\n                                     * adding paths that have the tempNodeId come before the\n                                     * nodeId to stop consuming at.\n                                     */\n                                    if (tempNodeIdIndex < nodeIdIndex) {\n                                        pathsToConsume.push(pathThatContainsNodeId);\n                                    }\n                                }\n\n                                /*\n                                 * take the paths that contain the given node id and consume\n                                 * the paths until the given node id\n                                 */\n                                var tempConsumedNodeIds = this.consumePathsUntilNodeId(pathsToConsume, tempNodeId);\n\n                                // remove the node id from the paths that contain it\n                                this.removeNodeIdFromPaths(tempNodeId, pathsThatContainNodeId);\n\n                                // add the temp consumed node ids to our consumed node ids array\n                                consumedNodeIds = consumedNodeIds.concat(tempConsumedNodeIds);\n\n                                // move the counter back one since we have just removed a node id\n                                x--;\n\n                                // add the node id to the consumed node ids array\n                                consumedNodeIds.push(tempNodeId);\n                            }\n                        }\n                    }\n                }\n            }\n\n        }\n\n        return consumedNodeIds;\n    };\n\n    /**\n     * Get the path at the given index and get the first node id in\n     * the path\n     * @param paths an array of paths. each path is an array of node ids\n     * @param index the index of the path we want\n     * @return the first node in the given path\n     */\n    getFirstNodeIdInPathAtIndex(paths, index) {\n        var nodeId = null;\n\n        if (paths != null && index != null) {\n            // get the path at the given index\n            var path = paths[index];\n\n            if (path != null && path.length > 0) {\n                // get the first node id in the path\n                nodeId = path[0];\n            }\n        }\n\n        return nodeId;\n    };\n\n    /**\n     * Remove the node ifrom the paths\n     * @param nodeId the node id to remove\n     * @param paths an array of paths. each path is an array of node ids\n     */\n    removeNodeIdFromPaths(nodeId, paths) {\n\n        if (nodeId != null && paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // loop through all the node ids in the path\n                for (var x = 0; x < path.length; x++) {\n                    // get a node id\n                    var tempNodeId = path[x];\n\n                    /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n                    if (nodeId === tempNodeId) {\n                        /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n                        path.splice(x, 1);\n\n                        /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n                        x--;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Remove the node id from the path\n     * @param nodeId the node id to remove\n     * @param paths an array of paths. each path is an array of node ids\n     * @param pathIndex the path to remove from\n     */\n    removeNodeIdFromPath(nodeId, paths, pathIndex) {\n\n        if (nodeId != null && paths != null && pathIndex != null) {\n\n            // get the path at the given index\n            var path = paths[pathIndex];\n\n            if (path != null) {\n\n                // loop through all the node ids in the path\n                for (var x = 0; x < path.length; x++) {\n                    // get a ndoe id\n                    var tempNodeId = path[x];\n\n                    /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n                    if (nodeId === tempNodeId) {\n                        /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n                        path.splice(x, 1);\n\n                        /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n                        x--;\n                    }\n                }\n            }\n        }\n    };\n\n    /**\n     * Check if the first node ids in the paths are the same\n     * @param paths an array of paths. each path is an array of node ids\n     * @return whether all the paths have the same first node id\n     */\n    areFirstNodeIdsInPathsTheSame(paths) {\n        var result = true;\n\n        var nodeId = null;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // get the first node id in the path\n                var tempNodeId = path[0];\n\n                if (nodeId == null) {\n                    /*\n                     * this is the first path we have looked at so we will\n                     * remember the node id\n                     */\n                    nodeId = tempNodeId;\n                } else if (nodeId != tempNodeId) {\n                    /*\n                     * the node id does not match the first node id from a\n                     * previous path so the paths do not all have the same\n                     * first node id\n                     */\n                    result = false;\n                    break;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if all the paths are empty\n     * @param paths an array of paths. each path is an array of node ids\n     * @return whether all the paths are empty\n     */\n    arePathsEmpty(paths) {\n        var result = true;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n\n                    // get the length of the path\n                    if (path.length !== 0) {\n                        // the path is not empty\n                        result = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Get the paths that contain the node id\n     * @param nodeId the node id we are looking for\n     * @param paths an array of paths. each path is an array of node ids\n     * @return an array of paths that contain the given node id\n     */\n    getPathsThatContainNodeId(nodeId, paths) {\n        var pathsThatContainNodeId = [];\n\n        if (nodeId != null && paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                // check if the path contains the node id\n                if (path.indexOf(nodeId) != -1) {\n                    /*\n                     * add the path to the array of paths that contain\n                     * the node id\n                     */\n                    pathsThatContainNodeId.push(path);\n                }\n            }\n        }\n\n        return pathsThatContainNodeId;\n    };\n\n    /**\n     * Get a non empty path index. It will loop through the paths and\n     * return the index of the first non empty path.\n     * @param paths an array of paths. each path is an array of node ids\n     * @return the index of the path that is not empty\n     */\n    getNonEmptyPathIndex(paths) {\n        var index = null;\n\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                // check the length of the path\n                if (path.length !== 0) {\n                    // the path is not empty so we will return this index\n                    index = p;\n                    break;\n                }\n            }\n        }\n\n        return index;\n    };\n\n    /**\n     * Get the branches in the project\n     */\n    getBranches() {\n\n        // get the start node id\n        var startNodeId = this.getStartNodeId();\n\n        /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n        var pathsSoFar = [];\n\n        // get all the paths in the project\n        var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n        // find the branches in the project from the paths\n        var branches = this.findBranches(allPaths);\n\n        return branches;\n    };\n\n    /**\n     * Find the branches in the project\n     * @param paths all the possible paths through the project\n     * @return an array of branch objects. each branch object contains\n     * the branch start point, the branch paths, and the branch\n     * end point\n     */\n    findBranches(paths) {\n        var branches = [];\n\n        var previousNodeId = null;\n\n        /*\n         * continue until all the paths are empty. we will remove\n         * node ids from the paths as we traverse the paths to find\n         * the branches\n         */\n        while(!this.arePathsEmpty(paths)) {\n\n            // get the first node id in the first path\n            var nodeId = this.getFirstNodeIdInPathAtIndex(paths, 0);\n\n            if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n                // the first node ids in all the paths are the same\n\n                // remove the node id from all the paths\n                this.removeNodeIdFromPaths(nodeId, paths);\n\n                // remember this node id for the next iteration of the loop\n                previousNodeId = nodeId;\n            } else {\n                // not all the top node ids are the same which means we have branched\n\n                // create a branch object\n                var branchMetaObject = this.createBranchMetaObject(previousNodeId);\n                branchMetaObject.branchStartPoint = previousNodeId;\n\n                // find the branch end point\n                var nextCommonNodeId = this.findNextCommonNodeId(paths);\n                branchMetaObject.branchEndPoint = nextCommonNodeId;\n\n                // get the branch paths\n                var branchPaths = this.extractPathsUpToNodeId(paths, nextCommonNodeId);\n                branchPaths = this.removeDuplicatePaths(branchPaths);\n                branchMetaObject.branchPaths = branchPaths;\n\n                // add the branch object to our array\n                branches.push(branchMetaObject);\n\n                // trim the paths so that they start at the branch end point\n                this.trimPathsUpToNodeId(paths, nextCommonNodeId);\n\n                // remember this node id for the next iteration of the loop\n                previousNodeId = nextCommonNodeId;\n            }\n        }\n\n        return branches;\n    };\n\n    /**\n     * Create a branch meta object that will contain the branch start\n     * point, branch paths, and branch end point\n     * @return an object that contains a branch start point, branch paths,\n     * and a branch end point\n     */\n    createBranchMetaObject() {\n        var branchMetaObject = {};\n\n        branchMetaObject.branchStartPoint = null;\n        branchMetaObject.branchPaths = [];\n        branchMetaObject.branchEndPoint = null;\n\n        return branchMetaObject;\n    };\n\n    /**\n     * Find the next common node id in all the paths\n     * @param paths the paths to find the common node id in\n     * @return a node id that is in all the paths or null\n     * if there is no node id that is in all the paths\n     */\n    findNextCommonNodeId(paths) {\n        var nextCommonNodeId = null;\n        var subPaths = [];\n\n        if (paths != null) {\n            if (paths.length > 0) {\n                // get the first path\n                var path = paths[0];\n\n                // loop through all the node ids in the first path\n                for (var x = 0; x < path.length; x++) {\n                    // get a node id\n                    var tempNodeId = path[x];\n\n                    // check if the node id is in all the paths\n                    if (this.allPathsContainNodeId(paths, tempNodeId)) {\n                        /*\n                         * the node id is in all the paths so we have found\n                         * what we were looking for\n                         */\n                        nextCommonNodeId = tempNodeId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return nextCommonNodeId;\n    };\n\n    /**\n     * Check if all the paths contain the node id\n     * @param paths an array of paths. each path contains an array of node ids\n     * @param nodeId the node id that we will check is in all the paths\n     * @return whether the node id is in all the paths\n     */\n    allPathsContainNodeId(paths, nodeId) {\n        var result = false;\n\n        if (paths != null) {\n\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                // get the index of the node id in the path\n                var index = path.indexOf(nodeId);\n\n                if (index == -1) {\n                    // the node id is not in the path\n                    result = false;\n                    break;\n                } else {\n                    // the node id is in the path\n                    result = true;\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Trim the paths up to the given node id so that the paths will contain\n     * the given node id and all the node ids after it. This function will\n     * modify the paths.\n     * @param paths the paths to trim\n     * @param nodeId the node id to trim up to\n     */\n    trimPathsUpToNodeId(paths, nodeId) {\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n                    // get the index of the node id in the path\n                    var index = path.indexOf(nodeId);\n\n                    if (index == -1) {\n                        /*\n                         * the node id is not in the path so we will\n                         * trim the path to the end which will make\n                         * the path empty\n                         */\n                        index = path.length;\n                    }\n\n                    /*\n                     * trim the path up to the node id index. this will\n                     * modify the path array.\n                     */\n                    path.splice(0, index);\n                }\n            }\n        }\n    };\n\n\n    /**\n     * Extract the paths up to a given node id. This will be used to\n     * obtain branch paths.\n     * @param paths the paths to extract from\n     * @param nodeId the node id to extract up to\n     * @return paths that go up to but do not include the node id\n     */\n    extractPathsUpToNodeId(paths, nodeId) {\n        var extractedPaths = [];\n\n        if (paths != null) {\n            // loop through the paths\n            for (var p = 0; p < paths.length; p++) {\n\n                // get a path\n                var path = paths[p];\n\n                if (path != null) {\n\n                    // get the index of the node id in the path\n                    var index = path.indexOf(nodeId);\n\n                    if (index == -1) {\n                        /*\n                         * the node id is not in the path so we will\n                         * extract up to the end of the path\n                         */\n                        index = path.length;\n                    }\n\n                    /*\n                     * get the path up to the node id index. this does\n                     * not modify the path array.\n                     */\n                    var extractedPath = path.slice(0, index);\n\n                    // add the\n                    extractedPaths.push(extractedPath);\n                }\n            }\n        }\n\n        return extractedPaths;\n    };\n\n    /**\n     * Removes duplicate paths\n     * @param paths an array of paths. each path contains an array of node ids\n     * @return an array of unique paths\n     */\n    removeDuplicatePaths(paths) {\n        var uniquePaths = [];\n\n        if (paths != null) {\n            // loop through all the paths\n            for (var p = 0; p < paths.length; p++) {\n                // get a path\n                var path = paths[p];\n\n                var isPathInUniquePaths = false;\n\n                // loop through all the unique paths so far\n                for (var u = 0; u < uniquePaths.length; u++) {\n                    // get a unique path\n                    var uniquePath = uniquePaths[u];\n\n                    // check if the paths are equal\n                    if (this.pathsEqual(path, uniquePath)) {\n                        // the paths are equal\n                        isPathInUniquePaths = true;\n                    }\n                }\n\n                if (!isPathInUniquePaths) {\n                    /*\n                     * the path is not equal to any paths in the unique\n                     * paths array so we will add it to the unique paths\n                     * array\n                     */\n                    uniquePaths.push(path);\n                }\n            }\n        }\n\n        return uniquePaths;\n    };\n\n    /**\n     * Check if two paths are equal\n     * @param path1 an array of node ids\n     * @param path2 an array of node ids\n     * @return whether the two paths contain the same node ids\n     * in the same order\n     */\n    pathsEqual(path1, path2) {\n        var result = false;\n\n        if (path1 != null && path2 != null) {\n\n            // check if the paths are the same length\n            if (path1.length === path2.length) {\n                result = true;\n\n                // loop through each element of the first path\n                for (var x = 0; x < path1.length; x++) {\n                    // get the node id from the first path\n                    var path1NodeId = path1[x];\n\n                    // get the node id from the second path\n                    var path2NodeId = path2[x];\n\n                    // check if the node ids are the same\n                    if (path1NodeId !== path2NodeId) {\n                        /*\n                         * the node ids are not the same to the paths\n                         * are not equal\n                         */\n                        result = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return result;\n    };\n\n    /**\n     * Check if a node id is in any branch\n     * @param branches an array of branch objects\n     * @param nodeId the node id to check\n     * @return whether the node id is in any branch\n     */\n    isNodeIdInABranch(branches, nodeId) {\n\n        if (branches != null && nodeId != null) {\n\n            // loop through all the branch objects\n            for (var b = 0; b < branches.length; b++) {\n\n                // get a branch object\n                var branch = branches[b];\n\n                if (branch != null) {\n\n                    // get the branch paths for this branch object\n                    var branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n\n                        // loop through all the branch paths\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\n\n                            // get a branch path\n                            var branchPath = branchPaths[bp];\n\n                            if (branchPath != null) {\n\n                                // check if the node id is in the branch path\n                                var index = branchPath.indexOf(nodeId);\n\n                                if (index != -1) {\n                                    // the node id is in this branch path\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * Get the branch paths that a node id is in\n     * @param branches an array of branch objects\n     * @param nodeId the node id to check\n     * @return an array of the branch paths that the node id is in\n     */\n    getBranchPathsByNodeId(branches, nodeId) {\n        var branchPathsIn = [];\n\n        if (branches != null && nodeId != null) {\n\n            // loop throught all the branches\n            for (var b = 0; b < branches.length; b++) {\n\n                // get a branch\n                var branch = branches[b];\n\n                if (branch != null) {\n\n                    // get the branch paths\n                    var branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n\n                        // loop through all the branch paths\n                        for (var bp = 0; bp < branchPaths.length; bp++) {\n\n                            // get a branch path\n                            var branchPath = branchPaths[bp];\n\n                            if (branchPath != null) {\n\n                                // get the index of the node id in the branch path\n                                var index = branchPath.indexOf(nodeId);\n\n                                if (index != -1) {\n                                    /*\n                                     * the node is in this branch path so we will\n                                     * add the branch path to our array\n                                     */\n                                    branchPathsIn.push(branchPath);\n\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return branchPathsIn;\n    }\n\n    /**\n     * Get the component by node id and component id\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @returns the component\n     */\n    getComponentByNodeIdAndComponentId(nodeId, componentId) {\n        var component = null;\n\n        if (nodeId != null && componentId != null) {\n\n            var components = this.getComponentsByNodeId(nodeId);\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n                        var tempComponentId = tempComponent.id;\n\n                        if (componentId === tempComponentId) {\n                            // we have found the component we want\n                            component = tempComponent;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return component;\n    };\n\n    /**\n     * Returns the position of the component in the node by node id and component id, 0-indexed.\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @returns the component's position\n     */\n    getComponentPositionByNodeIdAndComponentId(nodeId, componentId) {\n        var componentPosition = -1;\n\n        if (nodeId != null && componentId != null) {\n\n            var components = this.getComponentsByNodeId(nodeId);\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n                        var tempComponentId = tempComponent.id;\n\n                        if (componentId === tempComponentId) {\n                            // we have found the component we want\n                            componentPosition = c;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return componentPosition;\n    };\n\n    /**\n     * Get the components in a node\n     * @param nodeId the node id\n     * @returns an array of components\n     */\n    getComponentsByNodeId(nodeId) {\n        var components = [];\n\n        if (nodeId != null) {\n\n            // get the node\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n\n                // get the node content\n                var content = node.content;\n\n                if (content != null) {\n                    var tempComponents = content.components;\n\n                    if (tempComponents != null) {\n                        // we have obtained the components\n                        components = tempComponents;\n                    }\n                }\n            }\n        }\n\n        return components;\n    };\n\n    getNodeContentByNodeId(nodeId) {\n        var nodeContent = null;\n\n        if (nodeId != null) {\n            var node = this.getNodeById(nodeId);\n\n            if (node != null) {\n                nodeContent = node.content;\n            }\n        }\n\n        return nodeContent;\n    };\n\n    /**\n     * Replace a component\n     * @param nodeId the node id\n     * @param componentId the component id\n     * @param component the new component\n     */\n    replaceComponent(nodeId, componentId, component) {\n\n        if (nodeId != null && componentId != null && component != null) {\n\n            // get all the components for the node\n            var components = this.getComponentsByNodeId(nodeId);\n\n            if (components != null) {\n\n                // loop through all the components\n                for (var c = 0; c < components.length; c++) {\n                    var tempComponent = components[c];\n\n                    if (tempComponent != null) {\n\n                        if (tempComponent.id === componentId) {\n                            // the component id matches the one we want so we will replace it\n                            components[c] = component;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n}\n\nProjectService.$inject = ['$http', '$rootScope', 'ConfigService'];\n\nexport default ProjectService;\n\n"]}