{"version":3,"sources":["projectService.es6"],"names":["ProjectService","$filter","$http","$injector","$q","$rootScope","ConfigService","UtilService","project","transitions","applicationNodes","inactiveStepNodes","inactiveGroupNodes","groupNodes","idToNode","idToElement","metadata","activeConstraints","rootNode","idToPosition","idToOrder","nodeCount","componentServices","nodeIdToNumber","nodeIdToIsInBranchPath","nodeIdToBranchPathLetter","achievements","isNodeAffectedByConstraintResult","flattenedProjectAsNodeIds","$translate","additionalProcessingFunctionsMap","filters","parseProject","style","name","getProjectMetadata","title","projectTitle","nodes","planningNodes","nodeId","childIds","node","getNodeById","ids","id","result","getNodes","n","length","transition","existingTransitions","getTransitions","replaced","t","existingTransition","splice","push","existingNodes","existingNode","existingNodeId","$broadcast","groupId","group","groupChildNodeIds","indexOf","groupNode","type","applicationNode","nodeType","content","constraints","setIdToNode","setIdToElement","addNode","addGroupNode","addApplicationNode","addNodeToGroupNode","isPreview","getConfigParam","c","constraint","p","planningNode","clearProjectFields","loadNodes","loadPlanningNodes","inactiveNodes","loadInactiveNodes","constraintId","active","getRootNode","setNodeOrder","branches","getBranches","branchNodeIds","pos","setIdToPosition","isNodeIdInABranch","getPositionById","b","getBranchNodePositionById","calculateNodeNumbers","isGroupNode","i","child","getMode","planningIds","availablePlanningNodes","a","startGroupId","stepNumber","importProjectIdToOrder","getNodeOrderOfProjectHelper","item","childId","childStepNumber","path","getPathToNode","undefined","order","getIdByOrder","integerToAlpha","int","alphabet","branch","branchPaths","branchPath","nodeIndex","startPoint","branchStartPoint","startPointPos","branchPathPos","num","position","Object","entries","value","element","contentString","JSON","stringify","replaceAssetPaths","parse","contentBaseURL","replace","RegExp","matchedString","delimiter","matchedStringWithoutQuotes","substr","charAt","injectClickToSnipImageIntoContentString","imgMatcher","matchGroup1","newString","tempNode","getNodePositionById","nodeIcon","defaultName","color","fontSet","fontName","imgSrc","imgAlt","icons","default","icon","$","extend","getGroupNodes","g","isNodeDirectChildOfGroup","getInactiveGroupNodes","ig","inactiveGroupNode","parentGroupId","parentGroup","getParentGroup","val","depth","parent","getNodeDepth","groupIds","descendents","getDescendentsOfGroup","childDescendents","concat","projectStartId","getStartNodeId","groups","getGroups","groupStartId","startId","startNodeId","allConstraints","isNodeAffectedByConstraint","orderedNodeIds","getFlattenedProjectAsNodeIds","sort","constraintsComparatorGenerator","constraintA","constraintB","constraintAIndex","targetId","constraintBIndex","rememberedResult","getIsNodeAffectedByConstraintResult","action","isNodeIdAfter","targetNode","isNodeDescendentOfGroup","setIsNodeAffectedByConstraintResult","nodeIdBefore","nodeIdAfter","isApplicationNode","pathsToEnd","getAllPaths","pathToEnd","index","parentGroupIndex","getTransitionsByFromNodeId","toNodeId","to","navigationMode","componentId","component","getComponentByNodeIdAndComponentId","componentType","componentService","get","getPossibleTransitionCriteria","fromNodeId","transitionLogic","getTransitionLogicByFromNodeId","nodesByToNodeId","nodeIds","getNodesByToNodeId","groupsThatPointToNodeId","hasTransitionTo","transitionsResults","projectURL","Date","getTime","then","projectJSON","data","setProject","projectId","configURL","window","configJSON","previewProjectURL","commitMessage","cleanupBeforeSave","getProjectId","saveProjectURL","projectJSONString","angular","toJson","httpParams","method","url","headers","params","param","commitHistory","notifyProjectBeginURL","otherAuthors","resolve","reject","notifyProjectEndURL","activeNodes","getActiveNodes","activeNode","checked","getInactiveNodes","inactiveNode","copyProjectURL","registerNewProjectURL","e","Error","commitProjectURL","wiseBaseURL","getWISEBaseURL","theme","themeSettings","recalculate","pathsSoFar","allPaths","consolidatePaths","pathSoFar","includeGroups","addedCurrentNodeId","getParentGroupId","parentGroupTransitions","parentGroupTransition","allPathsFromToNode","tempPath","unshift","transitionResult","firstNodeId","firstParentGroupId","lastNodeId","pop","ap","paths","consolidatedPath","arePathsEmpty","currentPath","getNonEmptyPathIndex","getFirstNodeIdInPathAtIndex","areFirstNodeIdsInPathsTheSame","removeNodeIdFromPaths","pathsThatContainNodeId","getPathsThatContainNodeId","removeNodeIdFromPath","consumedPath","consumePathsUntilNodeId","consumedNodeIds","x","tempNodeId","pathsToConsume","pathThatContainsNodeId","tempNodeIdIndex","nodeIdIndex","tempConsumedNodeIds","pathIndex","findBranches","previousNodeId","branchMetaObject","createBranchMetaObject","nextCommonNodeId","findNextCommonNodeId","branchEndPoint","extractPathsUpToNodeId","removeDuplicatePaths","trimPathsUpToNodeId","subPaths","allPathsContainNodeId","extractedPaths","extractedPath","slice","uniquePaths","isPathInUniquePaths","u","uniquePath","pathsEqual","path1","path2","path1NodeId","path2NodeId","bp","branchPathsIn","components","getComponentsByNodeId","tempComponent","tempComponentId","componentPosition","nodeContent","newGroupId","getNextAvailableGroupId","newGroup","newNodeId","getNextAvailableNodeId","newNode","showSaveButton","showSubmitButton","addInactiveNode","insertNodeInsideInTransitions","insertNodeInsideInGroups","isInactive","insertNodeAfterInGroups","insertNodeAfterInTransitions","oldToGroupIds","transitionsFromGroup","transitionFromGroup","fromGroupId","newToGroupId","updateTransitionsForInsertingGroup","nodeIdToInsert","nodeIdToInsertAfter","previousNode","updateChildrenTransitionsForMovingGroup","previousNodeTransitionLogic","transitionsJSONString","transitionsCopy","fromJson","parentTransitions","parentTransition","newTransition","getGroupStartId","transitionObject","removeBranchPathTakenNodeConstraints","branchPathTakenConstraints","getBranchPathTakenConstraintsByNodeId","branchPathTakenConstraint","newConstraint","getNextAvailableConstraintIdForNodeId","removalCriteria","makeCopyOfJSONObject","nodeIdToInsertInside","nodeToInsert","previousNodes","previousGroups","getGroupNodesByToNodeId","previousGroup","lastNodesInGroup","getLastNodesInGroup","addToTransition","updateToTransition","nodesThatTransitionToGroup","nodeThatTransitionsToGroup","startNode","nextGroup","criteria","oldToNodeId","newToNodeId","lastNodes","getGroupIds","largestGroupIdNumber","groupIdNumber","isNaN","parseInt","nextAvailableGroupId","inactiveGroup","inactiveGroupId","nodeIdsToSkip","getNodeIds","largestNodeIdNumber","nodeIdNumber","inactiveNodeIds","getInactiveNodeIds","inactiveNodeId","s","nodeIdToSkip","nextAvailableNodeId","movedNodes","movingNodeIsActive","isActive","stationaryNodeIsActive","removeNodeIdFromTransitions","removeNodeIdFromGroups","moveToInactive","moveToActive","moveInactiveNode","newNodes","nodeIdToCopy","copyNode","createNodeInside","createNodeAfter","nodeCopy","newComponentIds","newComponentId","getUnusedComponentId","removingProjectStartNodeId","removeNodeIdFromNodes","hasSetNewStartId","isNodeInGroup","setStartNodeId","nextNodeId","nextGroupNode","nextGroupStartId","transitionToNodeId","recalculatePositionsInGroup","nodeToRemove","nodeToRemoveTransitionLogic","nodeToRemoveTransitions","parentIdOfNodeToRemove","parentGroupStartId","nodeToRemoveTransition","parentIdOfFromNode","tc","tempTransition","tempToNodeId","parentIdOfToNode","isFirstNodeInBranchPath","nodeIdsInBranch","getNodeIdsInBranch","nib","nodeIdInBranch","nodeInBranch","transitionCopy","currentFromNodeId","currentToNodeId","newFromNodeId","updateBranchPathTakenConstraint","isBranchPoint","getBranchesByBranchStartPointNodeId","bpn","branchPathNodeId","branchPathNode","insertIndex","groupIdWeAreMoving","groupThatTransitionsToGroupWeAreMoving","updateChildrenTransitionsIntoGroupWeAreMoving","removeTransitionsOutOfGroup","insertAfterComponentId","service","createComponent","componentHasWork","doesAnyComponentShowSubmitButton","addComponentToNode","componentUsesSaveButton","added","componentIds","componentsToMove","maxScore","firstPath","nodeMaxScore","getMaxScoreForNode","componentMaxScore","firstLeafNodeId","done","tempApplicationNode","tempApplicationNodeId","planning","planningNodeTemplateId","availablePlanningNodeIds","availablePlanningNodesSoFar","availablePlanningNode","availablePlanningNodeActual","max","nextAvailablePlanningNodeId","planningNodeInstance","planningNodeInstanceNodeId","nodeIdToMove","moveNodesInside","moveNodesAfter","getChildNodeIdsById","message","nodeTitle","getNodePositionAndTitleByNodeId","removalConditional","criteriaMessages","tempRemovalCriteria","criteriaMessage","getCriteriaMessage","scoresString","scores","join","score","requiredSubmitCount","oldToGroupId","fromGroup","oldToGroup","newToGroup","newToGroupStartId","ot","oldToGroupStartId","transitionsBefore","previousGroupNodes","transitionsAfter","extracted","previousGroupNode","updateTransitionsForExtractingGroup","transitionAfter","inserted","getStartGroupId","startGroup","firstGroupId","connectedComponentId","connectedComponents","connectedComponent","componentContent","connectedComponentParams","removeChildNodesFromActiveNodes","removeNodeFromActiveNodes","removeChildFromParent","removeNodeFromInactiveStepNodes","removeNodeFromInactiveGroupNodes","startIdUpdated","inactiveStepNode","isGroupActive","activeNodeId","activeComponents","activeComponent","activeComponentId","removeNodeFromInactiveNodes","childNode","addGroupChildNodesToInactive","removeTransitionsThatPointToNodeIdFromOutsideGroup","nodesThatPointToTargetNode","nodeThatPointsToTargetNode","nodeThatPointsToTargetNodeParentGroupId","removeTransition","toNodeIdParentGroupId","transitionsFromChild","tfc","transitionFromChild","firstNodeToRemoveTransition","firstNodeToRemoveTransitionToNodeId","nodeIdAndComponentIds","getNodeContentByNodeId","nodeIdAndComponentId","showPreviousWorkNodeId","showPreviousWorkComponentId","annotation","displayAnnotation","previousScore","currentScore","annotationGroup","globalAnnotationSettings","globalAnnotationGroups","globalAnnotationGroup","enableCriteria","scoreSequence","previousScoreMatch","currentScoreMatch","toString","match","notificationResult","notificationSettings","notifications","notification","getComponentService","componentServiceName","componentIdsToSkip","idLength","generateKey","isComponentIdUsed","alreadyUsed","isUsed","selectedNodes","fromProjectId","toProjectId","nodeIdToInsertInsideOrAfter","importStepsURL","steps","newNodeIds","selectedNode","isNodeIdUsed","tempComponents","nn","nextAvailableConstraintId","usedConstraintIds","foundNextAvailableConstraintId","counter","potentialConstraintId","field","orderedItems","foundNodeId","$key","hasBranchPathTakenConstraint","orderNodeIds","nodeIdsComparatorGenerator","nodeIdA","nodeIdB","nodeIdAIndex","nodeIdBIndex","r","removalCriterion","targetNodeId","makeThisNodeNotVisibleConstraint","notVisibleRemovalCriterion","makeThisNodeNotVisitableConstraint","notVisitableRemovalCriterion","rc","rubric","html","transitionTo","allBranches","currentActivityNumber","currentStepNumber","calculateNodeNumbersHelper","branchLetterCode","isBranchMergePoint","isBranchStartPoint","branchesByBranchStartPointNodeId","branchesObject","maxCurrentStepNumber","branchCurrentStepNumber","branchEndPointNodeId","number","branchLetter","String","fromCharCode","pg","script","scriptFilename","assetDirectoryPath","getProjectAssetsDirectoryPath","scriptPath","additionalProcessingFunction","key","getAdditionalProcessingFunctions","flattenedNodeIds","indexOfNodeId","indexOfPreviousNodeId","indexOfNextNodeId","isEnabled","items","achievementItems","getAchievements","achievementId","achievement","nodePosition","branchLetterRegex","exec","nodeRubric","componentRubric","newComponents","newComponent","copyComponent","insertPosition","getComponentPositionByNodeIdAndComponentId","importProjectId","currentComponents","$inject"],"mappings":"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","file":"projectService.js","sourcesContent":["'use strict';\n\nclass ProjectService {\n\n  constructor($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService) {\n    this.$filter = $filter;\n    this.$http = $http;\n    this.$injector = $injector;\n    this.$q = $q;\n    this.$rootScope = $rootScope;\n    this.ConfigService = ConfigService;\n    this.UtilService = UtilService;\n    this.project = null;\n    this.transitions = [];\n    this.applicationNodes = [];\n    this.inactiveStepNodes = [];\n    this.inactiveGroupNodes = [];\n    this.groupNodes = [];\n    this.idToNode = {};\n    this.idToElement = {};\n    this.metadata = {};\n    this.activeConstraints = [];\n    this.rootNode = null;\n    this.idToPosition = {};\n    this.idToOrder = {};\n    this.nodeCount = 0;\n    this.componentServices = {};\n    this.nodeIdToNumber = {};\n    this.nodeIdToIsInBranchPath = {};\n    this.nodeIdToBranchPathLetter = {};\n    this.achievements = [];\n    this.isNodeAffectedByConstraintResult = {};\n    this.flattenedProjectAsNodeIds = null;\n\n    this.$translate = this.$filter('translate');\n\n    // map from nodeId_componentId to array of additionalProcessingFunctions\n    this.additionalProcessingFunctionsMap = {};\n\n    // filtering options for navigation displays\n    this.filters = [\n      {'name': 'all', 'label': 'All'}\n      //{'name': 'todo', 'label': 'Todo'},\n      //{'name': 'completed', 'label': 'Completed'}\n    ];\n  };\n\n  setProject(project) {\n    this.project = project;\n    this.parseProject();\n  };\n\n  /**\n   * Initialize the data structures used to hold project information\n   */\n  clearProjectFields() {\n    this.transitions = [];\n    this.applicationNodes = [];\n    this.inactiveStepNodes = [];\n    this.inactiveGroupNodes = [];\n    this.groupNodes = [];\n    this.idToNode = {};\n    this.idToElement = {};\n    this.metadata = {};\n    this.activeConstraints = [];\n    this.rootNode = null;\n    this.idToPosition = {};\n    this.idToOrder = {};\n    this.nodeCount = 0;\n    this.nodeIdToIsInBranchPath = {};\n    this.achievements = [];\n  };\n\n  getStyle() {\n    var style = '';\n    var project = this.project;\n    if (project != null) {\n      style = project.style;\n    }\n    return style;\n  };\n\n  getFilters() {\n    return this.filters;\n  };\n\n  /**\n   * Returns the name/title of the current project\n   */\n  getProjectTitle() {\n    var name = this.getProjectMetadata().title;\n    return name ? name : 'A WISE Project (No name)';\n  };\n\n  /**\n   * Set the project title\n   */\n  setProjectTitle(projectTitle) {\n    var metadata = this.getProjectMetadata();\n\n    if (metadata != null) {\n      metadata.title = projectTitle;\n    }\n  }\n\n  getProjectMetadata() {\n    return this.metadata ? this.metadata : {};\n  };\n\n  getNodes() {\n    var nodes = null;\n    var project = this.project;\n\n    if (project != null) {\n      nodes = project.nodes;\n    }\n\n    return nodes;\n  };\n\n  getPlanningNodes() {\n    var planningNodes = null;\n    var project = this.project;\n\n    if (project != null) {\n      planningNodes = project.planningNodes;\n    }\n\n    return planningNodes;\n  };\n\n  getChildNodeIdsById(nodeId) {\n    var childIds = [];\n    var node = this.getNodeById(nodeId);\n\n    if (node.ids) {\n      childIds = node.ids;\n    }\n\n    return childIds;\n  };\n\n  getGroupNodes() {\n    return this.groupNodes;\n  };\n\n  isNode(id) {\n    var result = false;\n    var nodes = this.getNodes();\n\n    if (nodes != null) {\n      for (var n = 0; n < nodes.length; n++) {\n        var node = nodes[n];\n\n        if (node != null) {\n          var nodeId = node.id;\n\n          if (nodeId === id) {\n            result = true;\n            break;\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n\n  // adds or update transition if exists\n  addTransition(transition) {\n\n    var existingTransitions = this.getTransitions();\n    var replaced = false;\n    for (var t = 0; t < existingTransitions.length; t++) {\n      var existingTransition = existingTransitions[t];\n      if (existingTransition.id === transition.id) {\n        existingTransitions.splice(t, 1, transition);\n        replaced = true;\n      }\n    }\n    if (!replaced) {\n      existingTransitions.push(transition);\n    }\n  };\n\n  addNode(node) {\n    var existingNodes = this.project.nodes;\n\n    var replaced = false;\n    if (node != null && existingNodes != null) {\n      for (var n = 0; n < existingNodes.length; n++) {\n        var existingNode = existingNodes[n];\n        var existingNodeId = existingNode.id;\n        if (existingNodeId === node.id) {\n          existingNodes.splice(n, 1, node);\n          replaced = true;\n        }\n      }\n    }\n    if (!replaced) {\n      existingNodes.push(node);\n    }\n  };\n\n  addApplicationNode(node) {\n\n    var applicationNodes = this.applicationNodes;\n\n    if (node != null && applicationNodes != null) {\n      applicationNodes.push(node);\n    }\n  };\n\n  addGroupNode(node) {\n\n    var groupNodes = this.groupNodes;\n\n    if (node != null && groupNodes != null) {\n      groupNodes.push(node);\n    }\n\n    this.$rootScope.$broadcast('groupsChanged');\n  };\n\n  addNodeToGroupNode(groupId, nodeId) {\n    if (groupId != null && nodeId != null) {\n      var group = this.getNodeById(groupId);\n      if (group != null) {\n        var groupChildNodeIds = group.ids;\n        if (groupChildNodeIds != null) {\n          if (groupChildNodeIds.indexOf(nodeId) === -1) {\n            groupChildNodeIds.push(nodeId);\n          }\n        }\n      }\n    }\n  };\n\n  isGroupNode(id) {\n    var result = false;\n\n    var groupNode = this.getNodeById(id);\n\n    if (groupNode != null) {\n      var type = groupNode.type;\n\n      if (type === 'group') {\n        result = true;\n      }\n    }\n\n    return result;\n  };\n\n  isApplicationNode(id) {\n    var result = false;\n\n    var applicationNode = this.getNodeById(id);\n\n    if (applicationNode != null) {\n      var type = applicationNode.type;\n\n      if (type !== 'group') {\n        result = true;\n      }\n    }\n\n    return result;\n  };\n\n  getGroups() {\n    return this.groupNodes;\n  };\n\n  /**\n   * Get the inactive group nodes.\n   * @return An array of inactive group nodes.\n   */\n  getInactiveGroupNodes() {\n    return this.inactiveGroupNodes;\n  }\n\n  /**\n   * Get the inactive step nodes. This will include the inactive steps that\n   * are in an inactive group.\n   * @return An array of inactive step nodes.\n   */\n  getInactiveStepNodes() {\n    return this.inactiveStepNodes;\n  }\n\n  loadNodes(nodes) {\n    if (nodes != null) {\n      for (var n = 0 ; n < nodes.length; n++) {\n        var node = nodes[n];\n\n        if (node != null) {\n          var nodeId = node.id;\n          var nodeType = node.type;\n          var content = node.content;\n          var constraints = node.constraints;\n\n          if (content != null) {\n            //node.content = this.injectAssetPaths(content);\n          }\n\n          this.setIdToNode(nodeId, node);\n          this.setIdToElement(nodeId, node);\n\n          this.addNode(node);\n\n          if (nodeType === 'group') {\n            this.addGroupNode(node);\n          } else {\n            this.addApplicationNode(node);\n          }\n\n          var groupId = node.groupId;\n\n          if (groupId != null) {\n            this.addNodeToGroupNode(groupId, nodeId);\n          }\n\n          if (constraints != null) {\n\n            if (this.ConfigService.isPreview() == true && this.ConfigService.getConfigParam('constraints') === false) {\n              /*\n                             * if we are in preview mode and constraints are set\n                             * to false, we will not add the constraints\n                             */\n            } else {\n              // all other cases we will add the constraints\n\n              for (var c = 0; c < constraints.length; c++) {\n                var constraint = constraints[c];\n\n                this.activeConstraints.push(constraint);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Load the planning template nodes\n   * @param planning template nodes\n   */\n  loadPlanningNodes(planningNodes) {\n    if (planningNodes != null) {\n\n      // loop through all the planning template nodes\n      for (var p = 0; p < planningNodes.length; p++) {\n        var planningNode = planningNodes[p];\n\n        if (planningNode != null) {\n          var nodeId = planningNode.id;\n\n          this.setIdToNode(nodeId, planningNode);\n          this.setIdToElement(nodeId, planningNode);\n\n          // TODO: may need to add more function calls here to add the planning\n        }\n      }\n    }\n  }\n\n  /**\n   * Parse the project to detect the nodes, branches, node numbers, etc.\n   */\n  parseProject() {\n    var project = this.project;\n    if (project != null) {\n\n      // clear and initialize our project data structures\n      this.clearProjectFields();\n\n      if (project.metadata) {\n        this.metadata = project.metadata;\n      }\n\n      var nodes = project.nodes;\n      this.loadNodes(nodes);\n\n      // load the planning node templates\n      var planningNodes = project.planningNodes;\n      this.loadPlanningNodes(planningNodes);\n\n      // load the inactive nodes\n      var inactiveNodes = project.inactiveNodes;\n      this.loadInactiveNodes(inactiveNodes);\n\n      var constraints = project.constraints;\n\n      if (constraints != null) {\n        for (var c = 0; c < constraints.length; c++) {\n          var constraint = constraints[c];\n\n          if (constraint != null) {\n            var constraintId = constraint.id;\n            constraint.active = true;\n\n            this.setIdToElement(constraintId, constraint);\n          }\n        }\n      }\n\n      // set root node\n      this.rootNode = this.getRootNode(nodes[0].id);\n\n      // set project order\n      this.setNodeOrder(this.rootNode, this.nodeCount);\n      //this.nodeCount = 0;\n\n      var n = nodes.length;\n      var branches = this.getBranches();\n      var branchNodeIds = [];\n\n      // set node positions\n      var id, pos;\n\n      while (n--) {\n        id = nodes[n].id;\n        if (id === this.rootNode.id) {\n          this.setIdToPosition(id, '0');\n        } else if (this.isNodeIdInABranch(branches, id)) {\n          // node is in a branch, so process later\n          branchNodeIds.push(id);\n        } else {\n          pos = this.getPositionById(id);\n          this.setIdToPosition(id, pos);\n        }\n      }\n\n      // set branch node positions\n      var b = branchNodeIds.length;\n      while (b--) {\n        id = branchNodeIds[b];\n        pos = this.getBranchNodePositionById(id);\n        this.setIdToPosition(id, pos);\n      }\n\n      /*\n             * calculate the node numbers\n             * e.g. if the step is called\n             * 1.5 View the Potential Energy\n             * then the node number is 1.5\n             */\n      this.calculateNodeNumbers();\n\n      if (this.project.achievements != null) {\n        // get the project achievements\n        this.achievements = this.project.achievements;\n      }\n    }\n\n    this.$rootScope.$broadcast('projectChanged');\n  };\n\n  setNodeOrder(node) {\n    this.idToOrder[node.id] = {'order': this.nodeCount};\n    this.nodeCount++;\n    if (this.isGroupNode(node.id)) {\n      let childIds = node.ids;\n      for (let i = 0; i < childIds.length; i++) {\n        let child = this.getNodeById(childIds[i]);\n        this.setNodeOrder(child);\n      }\n\n      if (this.ConfigService.getMode() === 'classroomMonitor') {\n        // we're viewing the classroom monitor, so include planning nodes in the project structure\n        let planningIds = node.availablePlanningNodes;\n        if (planningIds) {\n          for (let a = 0; a < planningIds.length; a++) {\n            let child = this.getNodeById(planningIds[a].nodeId);\n            this.setNodeOrder(child);\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Get the node order mappings of the project\n   * @param project the project JSOn\n   * @return an object containing the idToOrder mapping and also the array\n   * of nodes\n   */\n  getNodeOrderOfProject(project) {\n\n    var idToOrder = {};\n\n    // initialize the node count used for counting the nodes\n    idToOrder.nodeCount = 0;\n\n    // get the start group id\n    var startGroupId = project.startGroupId;\n\n    // get the root node\n    var rootNode = this.getNodeById(startGroupId, project);\n\n    // initialize the step number\n    var stepNumber = '';\n\n    // initialize the nodes\n    var nodes = [];\n\n    // recursively traverse the project to calculate the node counts and step numbers\n    var importProjectIdToOrder = this.getNodeOrderOfProjectHelper(project, rootNode, idToOrder, stepNumber, nodes);\n\n    // remove the node count from the mapping since we don't need it anymore\n    delete importProjectIdToOrder.nodeCount;\n\n    // create the object we will return\n    var result = {};\n    result.idToOrder = importProjectIdToOrder;\n    result.nodes = nodes;\n\n    return result;\n  }\n\n  /**\n   * Recursively traverse the project to calculate the node order and step numbers\n   * @param project the project JSON\n   * @param node the current node we are on\n   * @param idToOrder the mapping of node id to item\n   * @param stepNumber the current step number\n   * @param nodes the array of nodes\n   */\n  getNodeOrderOfProjectHelper(project, node, idToOrder, stepNumber, nodes) {\n\n    /*\n         * Create the item that we will add to the idToOrder mapping.\n         * The 'order' field determines how the project nodes are displayed\n         * when we flatten the project for displaying.\n         */\n    var item = {\n      'order': idToOrder.nodeCount,\n      'node': node,\n      'stepNumber': stepNumber\n    };\n\n    // set the mapping of node id to item\n    idToOrder[node.id] = item;\n\n    // increment the node count\n    idToOrder.nodeCount++;\n\n    // add the item to the nodes array\n    nodes.push(item);\n\n    if (node.type == 'group') {\n      // the node is group so we also need to loop through its children\n\n      // get the child node ids\n      var childIds = node.ids;\n\n      // loop through all the children\n      for (var c = 0; c < childIds.length; c++) {\n        var childId = childIds[c];\n\n        // get a child node\n        var child = this.getNodeById(childId, project);\n\n        // get the current step number e.g. 1\n        var childStepNumber = stepNumber;\n\n        if (childStepNumber != '') {\n          // add the . separator for the step number e.g. 1.\n          childStepNumber += '.';\n        }\n\n        // update the step number e.g. 1.1\n        childStepNumber += (c + 1);\n\n        // recursively traverse the child\n        this.getNodeOrderOfProjectHelper(project, child, idToOrder, childStepNumber, nodes);\n      }\n    }\n\n    return idToOrder;\n  }\n\n  /**\n   * Returns the position in the project for the node with the given id. Returns null if no node with id exists.\n   * @param id a node id\n   * @return string position of the given node id in the project\n   */\n  getPositionById(id) {\n    for (var i = 0; i < this.rootNode.ids.length; i++) {\n      var node = this.getNodeById(this.rootNode.ids[i]);\n      var path = this.getPathToNode(node, i+1, id);\n      if (path != undefined && path != null) {\n        return path;\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Returns the order of the given node id in the project. Returns null if no node with id exists.\n   * @param id String node id\n   * @return Number order of the given node id in the project\n   */\n  getOrderById(id) {\n    if (this.idToOrder[id]) {\n      return this.idToOrder[id].order;\n    }\n\n    return null;\n  };\n  /**\n   * Returns the id of the node with the given order in the project. Returns null if no order with node exists.\n   * @param order Number\n   * @return Number node id of the given order in the project\n   */\n  getIdByOrder(order) {\n    var nodeId = null;\n\n    for (var id in this.idToOrder) {\n      if (this.idToOrder[id].order === order) {\n        if (this.isGroupNode(id) && order > 1) {\n          nodeId = this.getIdByOrder(order-1);\n        } else {\n          nodeId = id;\n        }\n        break;\n      }\n    }\n\n    return nodeId;\n  };\n\n  /**\n   * Returns the position in the project for the branch node with the given id. Returns null if no node with id exists or node is not a branch node.\n   * @param id a node id\n   * @return string position of the given node id in the project\n   */\n  getBranchNodePositionById(id) {\n    var branches = this.getBranches();\n    var b = branches.length;\n\n    // TODO: should we localize this? should we support more than 26?\n    var integerToAlpha = function(int) {\n      var alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'];\n      if (int > -1 && int < 26) {\n        return alphabet[int];\n      } else {\n        return int;\n      }\n    };\n\n    while (b--) {\n      var branch = branches[b];\n      var branchPaths = branch.branchPaths;\n      for (var p = 0; p < branchPaths.length; p++) {\n        var branchPath = branchPaths[p];\n        var nodeIndex = branchPath.indexOf(id);\n        if (nodeIndex > -1) {\n          var startPoint = branch.branchStartPoint;\n          var startPointPos = this.idToPosition[startPoint];\n          var branchPathPos = startPointPos + ' ' + integerToAlpha(p);\n          return branchPathPos + (nodeIndex+1);\n        }\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Recursively searches for the given node id from the point of the given node down and returns the path number (position)\n   * @param node a node to start searching down\n   * @param path the position of the given node\n   * @param id the node id to search for\n   * @return string path of the given node id in the project\n   */\n  getPathToNode(node, path, id) {\n    if (node.id === id) {\n      return path + '';\n    } else if (node.type === 'group') {\n      var num = 0;\n      var branches = this.getBranches();\n      for (var i = 0; i < node.ids.length; i++) {\n        var nodeId = node.ids[i];\n        if (this.isNodeIdInABranch(branches, nodeId)) {\n          this.getBranchNodePositionById(nodeId);\n        } else {\n          ++num;\n          var pos = this.getPathToNode(this.getNodeById(nodeId), (path) + '.' + (num), id);\n          if (pos) {\n            return pos;\n          }\n        }\n      }\n    }\n  };\n\n  setIdToPosition(id, pos) {\n    if (id != null) {\n      this.idToPosition[id] = pos;\n    }\n  };\n\n  getNodePositionById(id) {\n    let position = null;\n\n    if (id != null) {\n      //position = this.idToPosition[id] ? this.idToPosition[id] : null;\n      position = this.nodeIdToNumber[id];\n    }\n\n    return position;\n  };\n\n  getNodeIdByOrder(order) {\n    let id = null;\n\n    if (order != null) {\n      for (let [nodeId, value] of Object.entries(this.idToOrder)) {\n        if (value.order === order) {\n          id = nodeId;\n          break;\n        }\n      }\n    }\n\n    return id;\n  }\n\n  getNodeOrderById(id) {\n    let order = null;\n\n    if (id != null) {\n      order = this.idToOrder[id] ? this.idToOrder[id].order : null;\n    }\n\n    return order;\n  };\n\n  setIdToNode(id, element) {\n    if (id != null) {\n      this.idToNode[id] = element;\n    }\n  };\n\n  setIdToElement(id, element) {\n    if (id != null) {\n      this.idToElement[id] = element;\n    }\n  };\n\n  /**\n   * Replace relative asset paths with absolute paths\n   * e.g.\n   * assets/myimage.jpg\n   * will be replaced with\n   * http://wise.berkeley.edu/curriculum/123456/assets/myimage.jpg\n   * @param content a string or JSON object\n   * @return the same type of object that was passed in as the content\n   * but with relative asset paths replaced with absolute paths\n   */\n  injectAssetPaths(content) {\n\n    if (content != null) {\n\n      if (typeof content === 'object') {\n\n        var contentString = JSON.stringify(content);\n\n        if (contentString != null) {\n\n          // replace the relative asset paths with the absolute paths\n          contentString = this.replaceAssetPaths(contentString);\n\n          content = JSON.parse(contentString);\n        }\n      } else if (typeof content === 'string') {\n\n        // replace the relative asset paths with the absolute paths\n        content = this.replaceAssetPaths(content);\n      }\n    }\n\n    return content;\n  };\n\n  /**\n   * Replace the relative asset paths with absolute paths\n   * @param contentString the content string\n   * @return the content string with relative asset paths replaced\n   * with absolute asset paths\n   */\n  replaceAssetPaths(contentString) {\n\n    if (contentString != null) {\n\n      // get the content base url e.g. http://wise.berkeley.edu/curriculum/123456/\n      var contentBaseURL = this.ConfigService.getConfigParam('projectBaseURL');\n\n      // only look for string that starts with ' or \" and ends in png, jpg, jpeg, pdf, etc.\n      // the string we're looking for can't start with '/ and \"/.\n      // note that this also works for \\\"abc.png and \\'abc.png, where the quotes are escaped\n      contentString = contentString.replace(\n        new RegExp('(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")[^:][^\\/]?[^\\/]?[a-zA-Z0-9@\\\\._\\\\/\\\\s\\\\-]*[\\.](png|jpe?g|pdf|gif|mov|mp4|mp3|wav|swf|css|txt|json|xlsx?|doc|html.*?|js).*?(\\'|\\\"|\\\\\\\\\\'|\\\\\\\\\\\")', 'gi'),\n        (matchedString) => {\n          // once found, we prepend the contentBaseURL + \"assets/\" to the string within the quotes and keep everything else the same.\n          var delimiter = '';\n          var matchedStringWithoutQuotes = '';\n\n          if (matchedString.length > 2 && matchedString.substr(0,1) == '\\\\') {\n            // the string has escaped quotes for example \\\"hello.png\\\"\n\n            // get everything between the escaped quotes\n            matchedStringWithoutQuotes = matchedString.substr(2, matchedString.length - 4);\n\n            // get the delimiter which will be \\' or \\\"\n            delimiter = matchedString.substr(0,2);\n          } else {\n            // the string does not have escaped quotes for example \"hello.png\"\n\n            // get everything between the quotes\n            matchedStringWithoutQuotes = matchedString.substr(1, matchedString.length - 2);\n\n            // get the delimiter which will be ' or \"\n            delimiter = matchedString.substr(0,1);\n          }\n\n          if (matchedStringWithoutQuotes != null && matchedStringWithoutQuotes.length > 0 && matchedStringWithoutQuotes.charAt(0) == \"/\") {\n            /*\n                         * the matched string starts with a \"/\" which means it's\n                         * an absolute path and does not require path prepending\n                         * so we will just return the original unmodified string\n                         */\n            return delimiter + matchedStringWithoutQuotes + delimiter;\n          } else {\n            //var matchedStringWithoutFirstAndLastQuote = matchedString.substr(1, matchedString.length - 2);  // everything but the beginning and end quote (' or \")\n            // make a new string with the contentBaseURL + assets/ prepended to the path\n            return delimiter + contentBaseURL + \"assets/\" + matchedStringWithoutQuotes + delimiter;\n          }\n        }\n      );\n    }\n\n    return contentString;\n  };\n\n  /**\n   * Inject the ng-click attribute that will call the snipImage function\n   * @param content the content\n   * @returns the modified content\n   */\n  injectClickToSnipImage(content) {\n    if (content != null) {\n\n      if (typeof content === 'object') {\n\n        var contentString = JSON.stringify(content);\n\n        if (contentString != null) {\n\n          // replace the relative asset paths with the absolute paths\n          contentString = this.injectClickToSnipImageIntoContentString(contentString);\n\n          content = JSON.parse(contentString);\n        }\n      } else if (typeof content === 'string') {\n\n        // replace the relative asset paths with the absolute paths\n        content = this.injectClickToSnipImageIntoContentString(content);\n      }\n    }\n\n    return content;\n  }\n\n  /**\n   * Inject the ng-click attribute that will call the snipImage function\n   * @param contentString the content in string format\n   * @returns the modified content string\n   */\n  injectClickToSnipImageIntoContentString(contentString) {\n\n    if (contentString != null) {\n\n      // regex to match image elements\n      var imgMatcher = new RegExp('<img.*?src=\\\\\\\\?[\\'\"](.*?)\\\\\\\\?[\\'\"].*?>', 'gi');\n\n      // replace all instances that match\n      contentString = contentString.replace(imgMatcher,\n        (matchedString, matchGroup1) => {\n\n          /*\n                     * insert the ng-click attribute\n                     * Before: <img src=\"abc.png\"/>\n                     * After: <img ng-click=\"vleController.snipImage($event)\" src=\"abc.png\" />\n                     */\n          var newString = matchedString.replace('img', 'img ng-click=\\\\\\\"$emit(\\'snipImage\\', $event)\\\\\\\"');\n\n          return newString;\n        }\n      );\n    }\n\n    return contentString;\n  }\n\n  /**\n   * Returns the node specified by the nodeId\n   * @param nodeId get the node with this node id\n   * @param (optional) the project to retrieve the node from. this is used in\n   * the case when we want the node from another project such as when we are\n   * importing a step from another project\n   * Return null if nodeId param is null or the specified node does not exist in the project.\n   */\n  getNodeById(nodeId, project) {\n    var element = null;\n\n    if (project == null) {\n      // the project argument is null so we will get it from the current project\n      if (nodeId != null && this.idToNode[nodeId]) {\n        element = this.idToNode[nodeId];\n      }\n    } else {\n      /*\n             * the project argument is not null so we will get the node from\n             * project that was passed in\n             */\n\n      // loop through all the active nodes in the project\n      for (var n = 0; n < project.nodes.length; n++) {\n        var tempNode = project.nodes[n];\n\n        if (tempNode != null && tempNode.id == nodeId) {\n          // we have found the node we are looking for\n          return tempNode;\n        }\n      }\n\n      // loop through all the inactive nodes in the project\n      for (var n = 0; n < project.inactiveNodes.length; n++) {\n        var tempNode = project.inactiveNodes[n];\n\n        if (tempNode != null && tempNode.id == nodeId) {\n          // we have found the node we are looking for\n          return tempNode;\n        }\n      }\n    }\n\n    return element;\n  };\n\n  /**\n   * Returns the title of the node with the nodeId\n   * Return null if nodeId param is null or the specified node does not exist in the project.\n   */\n  getNodeTitleByNodeId(nodeId) {\n    var title = null;\n\n    var node = this.getNodeById(nodeId);\n\n    if (node != null) {\n      title = node.title;\n    }\n\n    return title;\n  };\n\n  /**\n   * Get the node position and title\n   * @param nodeId the node id\n   * @returns the node position and title, e.g. \"1.1 Introduction\"\n   */\n  getNodePositionAndTitleByNodeId(nodeId) {\n    var title = null;\n\n    var node = this.getNodeById(nodeId);\n\n    if (node != null) {\n\n      var position = this.getNodePositionById(nodeId);\n\n      if (position != null) {\n        title = position + ': ' + node.title;\n      } else {\n        title = node.title;\n      }\n    }\n\n    return title;\n  };\n\n  getNodeIconByNodeId(nodeId) {\n    var node = this.getNodeById(nodeId);\n    var nodeIcon = null;\n\n    if (node != null) {\n      var nodeType = node.type;\n\n      // set defaults (TODO: get from configService?)\n      var defaultName = (nodeType === 'group') ? 'explore' : 'school';\n      nodeIcon = {\n        color: 'rgba(0,0,0,0.54)',\n        type: 'font',\n        fontSet: 'material-icons',\n        fontName: defaultName,\n        imgSrc: '',\n        imgAlt: 'node icon'\n      };\n\n      // TODO: check for different statuses\n      var icons = node.icons;\n      if (!!icons && !!icons.default) {\n        var icon = icons.default;\n        nodeIcon = $.extend(true, nodeIcon, icon);\n      }\n\n      // check for empty image source\n      if (!nodeIcon.imgSrc) {\n        // revert to font icon\n        nodeIcon.type = 'font';\n      }\n    }\n\n    return nodeIcon;\n  };\n\n  getParentGroup(nodeId) {\n    var result = null;\n\n    if (nodeId != null) {\n      var node = this.getNodeById(nodeId);\n\n      if (node != null) {\n        // Check if the node is a child of an active group.\n        var groupNodes = this.getGroupNodes();\n        for (var g = 0; g < groupNodes.length; g++) {\n          var groupNode = groupNodes[g];\n          if (this.isNodeDirectChildOfGroup(node, groupNode)) {\n            return groupNode;\n          }\n        }\n\n        // Check if the node is a child of an inactive group.\n        var inactiveGroupNodes = this.getInactiveGroupNodes();\n        for (var ig = 0; ig < inactiveGroupNodes.length; ig++) {\n          var inactiveGroupNode = inactiveGroupNodes[ig];\n          if (this.isNodeDirectChildOfGroup(node, inactiveGroupNode)) {\n            return inactiveGroupNode;\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n  /**\n   * Get the parent group id\n   * @param nodeId the parent group id\n   * @returns the parent group id\n   */\n  getParentGroupId(nodeId) {\n\n    var parentGroupId = null;\n\n    if (nodeId != null) {\n      var parentGroup = this.getParentGroup(nodeId);\n\n      if (parentGroup != null) {\n        parentGroupId = parentGroup.id;\n      }\n    }\n\n    return parentGroupId;\n  }\n\n  getNodeDepth(nodeId, val) {\n    var result = null;\n\n    if (nodeId != null) {\n      var depth = (typeof val === \"number\") ? val : 0;\n      var parent = this.getParentGroup(nodeId);\n      if (parent) {\n        depth = this.getNodeDepth(parent.id, depth + 1);\n      }\n      result = depth;\n    }\n\n    return result;\n  };\n\n  getRootNode(nodeId) {\n    var result = null;\n\n    var parentGroup = this.getParentGroup(nodeId);\n\n    if (parentGroup == null) {\n      result = this.getNodeById(nodeId);\n    } else {\n      result = this.getRootNode(parentGroup.id);\n    }\n\n    return result;\n  };\n\n  isNodeDirectChildOfGroup(node, group) {\n    var result = false;\n\n    if (node != null && group != null) {\n      var nodeId = node.id;\n      var groupIds = group.ids;\n\n      if (groupIds != null && groupIds.indexOf(nodeId) != -1) {\n        result = true;\n      }\n    }\n\n    return result;\n  };\n\n  isNodeDescendentOfGroup(node, group) {\n    var result = false;\n\n    if (node != null && group != null) {\n      var descendents = this.getDescendentsOfGroup(group);\n      var nodeId = node.id;\n\n      if (descendents.indexOf(nodeId) != -1) {\n        result = true;\n      }\n    }\n\n    return result;\n  };\n\n  getDescendentsOfGroup(group) {\n    var descendents = [];\n\n    if (group != null) {\n      var childIds = group.ids;\n\n      if (childIds != null) {\n        descendents = childIds;\n\n        for (var c = 0; c < childIds.length; c++) {\n          var childId = childIds[c];\n\n          var node = this.getNodeById(childId);\n\n          if (node != null) {\n            var childDescendents = this.getDescendentsOfGroup(node);\n\n            descendents = descendents.concat(childDescendents);\n          }\n        }\n      }\n    }\n\n    return descendents;\n  };\n\n  isStartNode(node) {\n    var result = false;\n\n    if (node != null) {\n      var nodeId = node.id;\n\n      var projectStartId = this.getStartNodeId();\n\n      if (nodeId === projectStartId) {\n        result = true;\n      }\n\n      var groups = this.getGroups();\n\n      for (var g = 0; g < groups.length; g++) {\n        var group = groups[g];\n\n        if (group != null) {\n          var groupStartId = group.startId;\n\n          if (nodeId === groupStartId) {\n            result = true;\n            break;\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Returns the Project's start node id, or null if it's not defined in the project\n   */\n  getStartNodeId() {\n    var startNodeId = null;\n    var project = this.project;\n    if (project != null) {\n      startNodeId = project.startNodeId;\n    }\n    return startNodeId;\n  };\n\n  /**\n   * Set the start node id\n   * @param nodeId the new start node id\n   */\n  setStartNodeId(nodeId) {\n\n    if (nodeId != null) {\n      var project = this.project;\n      if (project != null) {\n        project.startNodeId = nodeId;\n      }\n    }\n  }\n\n  /**\n   * Get the start group id\n   * @return the start group id\n   */\n  getStartGroupId() {\n    var startGroupId = null;\n\n    var project = this.project;\n    if (project != null) {\n      startGroupId = project.startGroupId;\n    }\n\n    return startGroupId;\n  }\n\n  /**\n   * Check if the given node id is the start node id\n   * @return whether the node id is the start node id\n   */\n  isStartNodeId(nodeId) {\n\n    var result = false;\n\n    var project = this.project;\n\n    if (project != null) {\n      var startNodeId = project.startNodeId;\n\n      if (nodeId === startNodeId) {\n        result = true;\n      }\n    }\n\n    return result;\n  }\n\n  getConstraintsForNode(node) {\n    var constraints = [];\n\n    var allConstraints = this.activeConstraints;\n\n    for (var c = 0; c < allConstraints.length; c++) {\n      var constraint = allConstraints[c];\n\n      if (this.isNodeAffectedByConstraint(node, constraint)) {\n        constraints.push(constraint);\n      }\n    }\n\n    return constraints;\n  };\n\n  /**\n   * Order the constraints so that they show up in the same order as in the\n   * project.\n   * @param constraints An array of constraint objects.\n   * @return An array of ordered constraints.\n   */\n  orderConstraints(constraints) {\n    let orderedNodeIds = this.getFlattenedProjectAsNodeIds();\n    return constraints.sort(this.constraintsComparatorGenerator(orderedNodeIds));\n  }\n\n  /**\n   * Create the constraints comparator function that is used for sorting an\n   * array of constraint objects.\n   * @param orderedNodeIds An array of node ids in the order in which they\n   * show up in the project.\n   * @return A comparator that orders constraint objects in the order in which\n   * the target ids show up in the project.\n   */\n  constraintsComparatorGenerator(orderedNodeIds) {\n    return function(constraintA, constraintB) {\n      let constraintAIndex = orderedNodeIds.indexOf(constraintA.targetId);\n      let constraintBIndex = orderedNodeIds.indexOf(constraintB.targetId);\n      if (constraintAIndex < constraintBIndex) {\n        return -1;\n      } else if (constraintAIndex > constraintBIndex) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Check if a node is affected by the constraint\n   * @param node check if the node is affected\n   * @param constraint the constraint that might affect the node\n   * @returns whether the node is affected by the constraint\n   */\n  isNodeAffectedByConstraint(node, constraint) {\n    var result = false;\n\n    if (node != null && constraint != null) {\n\n      // check if we have previously calculated the result before\n      var rememberedResult = this.getIsNodeAffectedByConstraintResult(node.id, constraint.id, result);\n\n      if (rememberedResult != null) {\n        // we have calculated the result before\n\n        // use the remembered result\n        result = rememberedResult;\n      } else {\n        // we have not calculated the result before\n\n        var nodeId = node.id;\n        var targetId = constraint.targetId;\n        var action = constraint.action;\n\n        if (action === 'makeAllNodesAfterThisNotVisible') {\n          if (this.isNodeIdAfter(targetId, node.id)) {\n            result = true;\n          }\n        } else if (action === 'makeAllNodesAfterThisNotVisitable') {\n          if (this.isNodeIdAfter(targetId, node.id)) {\n            result = true;\n          }\n        } else {\n          var targetNode = this.getNodeById(targetId);\n\n          if (targetNode != null) {\n            var nodeType = targetNode.type;\n\n            if (nodeType === 'node') {\n              // the target is an application\n\n              if (nodeId === targetId) {\n                result = true;\n              }\n            } else if (nodeType === 'group') {\n              // the target is a group\n\n              if (nodeId === targetId) {\n                result = true;\n              }\n\n              if (this.isNodeDescendentOfGroup(node, targetNode)) {\n                result = true;\n              }\n            }\n          }\n        }\n\n        // remember the result so we can look it up in the future\n        this.setIsNodeAffectedByConstraintResult(node.id, constraint.id, result);\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Check if a node id comes after another node id in the project\n   * @param nodeIdBefore the node id before\n   * @param nodeIdAfter the node id after\n   */\n  isNodeIdAfter(nodeIdBefore, nodeIdAfter) {\n    var result = false;\n\n    if (nodeIdBefore != null && nodeIdAfter != null) {\n\n      if (this.isApplicationNode(nodeIdBefore)) {\n        // the node id before is a step\n\n        // get all the paths from the beforeNodeId to the end of the project\n        var pathsToEnd = this.getAllPaths([], nodeIdBefore, true);\n\n        if (pathsToEnd != null) {\n\n          // loop through all the paths\n          for (var p = 0; p < pathsToEnd.length; p++) {\n\n            var pathToEnd = pathsToEnd[p];\n\n            if (pathToEnd != null) {\n\n              /*\n                             * remove the first node id and its parent id because\n                             * we will check the remaining node ids in the array\n                             * for the nodeIdAfter\n                             */\n\n              // get the index of the node id before\n              var index = pathToEnd.indexOf(nodeIdBefore);\n\n              if (index != -1) {\n                // remove the node id before\n                pathToEnd.splice(index, 1);\n              }\n\n              // get the parent group of the node id before\n              var parentGroup = this.getParentGroup(nodeIdBefore);\n\n              if (parentGroup != null) {\n                // remove the parent group of the node id before\n                var parentGroupId = parentGroup.id;\n                var parentGroupIndex = pathToEnd.indexOf(parentGroupId);\n                if (parentGroupIndex != -1) {\n                  pathToEnd.splice(parentGroupIndex, 1);\n                }\n              }\n\n              if (pathToEnd.indexOf(nodeIdAfter) != -1) {\n                // we have found the nodeIdAfter in the path to the end of the project\n                result = true;\n              }\n            }\n          }\n        }\n      } else {\n        // the node id before is an activity\n\n        // get the group\n        var group = this.getNodeById(nodeIdBefore);\n\n        if (group != null) {\n\n          // get the transitions from the group\n          var transitions = this.getTransitionsByFromNodeId(nodeIdBefore);\n\n          if (transitions != null) {\n\n            // loop through all the transitions\n            for (var t = 0; t < transitions.length; t++) {\n              var transition = transitions[t];\n\n              if (transition != null) {\n                var toNodeId = transition.to;\n\n                // get the paths between to toNodeId and the end of the project\n                var pathsToEnd = this.getAllPaths([], toNodeId, true);\n\n                // loop through all the paths\n                for (var p = 0; p < pathsToEnd.length; p++) {\n\n                  // get a path\n                  var pathToEnd = pathsToEnd[p];\n\n                  if (pathToEnd != null) {\n                    if (pathToEnd.indexOf(nodeIdAfter) != -1) {\n                      // we have found the nodeIdAfter in the path to the end of the project\n                      result = true;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  getNavigationMode() {\n    var navigationMode = null;\n    var project = this.project;\n    if (project != null) {\n      navigationMode = project.navigationMode;\n    }\n    return navigationMode;\n  };\n\n  getTransitions() {\n    var transitions = null;\n    var project = this.project;\n    if (project != null) {\n      transitions = project.transitions;\n    }\n    return transitions;\n  };\n\n  /**\n   * Returns all possible transition criteria for the specified node and component.\n   */\n  getPossibleTransitionCriteria(nodeId, componentId) {\n    let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    if (component != null) {\n      let componentType = component.type;\n      let componentService = this.$injector.get(componentType + 'Service');\n      if (componentService.getPossibleTransitionCriteria) {\n        return componentService.getPossibleTransitionCriteria(nodeId, componentId, component);\n      } else {\n        return [];\n      }\n    } else {\n      return [];\n    }\n  };\n\n  /**\n   * Get the transition logic for a node\n   * @param fromNodeId the from node id\n   * @returns the transition logic object\n   */\n  getTransitionLogicByFromNodeId(fromNodeId) {\n    var transitionLogic = null;\n\n    if (fromNodeId != null) {\n\n      // get the node\n      var node = this.getNodeById(fromNodeId);\n\n      if (node != null) {\n        // get the transition logic\n        transitionLogic = node.transitionLogic;\n      }\n    }\n\n    return transitionLogic;\n  };\n\n  /**\n   * Get the transitions for a node\n   * @param fromNodeId the node to get transitions from\n   * @returns an array of transitions\n   */\n  getTransitionsByFromNodeId(fromNodeId) {\n\n    var transitions = null;\n\n    if (fromNodeId != null) {\n      // get the transition logic\n      var transitionLogic = this.getTransitionLogicByFromNodeId(fromNodeId);\n\n      if (transitionLogic != null) {\n        // get the transitions\n        transitions = transitionLogic.transitions;\n      }\n    }\n\n    return transitions;\n  }\n\n  /**\n   * Get nodes that have a transition to the given node id\n   * @param toNodeId the node id\n   * @returns an array of node objects that transition to the\n   * given node id\n   */\n  getNodesByToNodeId(toNodeId) {\n    var nodesByToNodeId = [];\n\n    if (toNodeId != null) {\n\n      // get all the nodes\n      var nodes = this.project.nodes;\n\n      // loop through all the nodes\n      for (var n = 0; n < nodes.length; n++) {\n        var node = nodes[n];\n\n        var transitionLogic = node.transitionLogic;\n\n        if (transitionLogic != null) {\n          var transitions = transitionLogic.transitions;\n\n          if (transitions != null) {\n\n            // loop through all the transitions for the node\n            for (var t = 0; t < transitions.length; t++) {\n              var transition = transitions[t];\n\n              if (transition != null) {\n                if (toNodeId === transition.to) {\n                  // this node has a transition to the node id\n                  nodesByToNodeId.push(node);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return nodesByToNodeId;\n  };\n\n  /**\n   * Get node ids of all the nodes that have a to transition to the given node id\n   * @param toNodeId\n   * @returns all the node ids that have a transition to the given node id\n   */\n  getNodeIdsByToNodeId(toNodeId) {\n    var nodeIds = [];\n\n    // get all the nodes that transition to the toNodeId\n    var nodes = this.getNodesByToNodeId(toNodeId);\n\n    if (nodes != null) {\n\n      // loop through all the nodes to get the node ids\n      for (var n = 0; n < nodes.length; n++) {\n        var node = nodes[n];\n\n        if (node != null) {\n          nodeIds.push(node.id);\n        }\n      }\n    }\n\n    return nodeIds;\n  }\n\n  /**\n   * Get the group nodes that point to a given node id\n   * @param toNodeId\n   */\n  getGroupNodesByToNodeId(toNodeId) {\n    var groupsThatPointToNodeId = [];\n\n    if (toNodeId != null) {\n      var groups = this.getGroups();\n\n      for (var g = 0; g < groups.length; g++) {\n        var group = groups[g];\n\n        if (group != null) {\n          if (this.hasTransitionTo(group, toNodeId)) {\n            groupsThatPointToNodeId.push(group);\n          }\n        }\n      }\n    }\n\n    return groupsThatPointToNodeId;\n  }\n\n  /**\n   * Check if a node has a transition to a node id\n   * @param node check if this node has a transition to the node id\n   * @param toNodeId we will look for a transition to this node id\n   * @returns whether the node has a transition to the node id\n   */\n  hasTransitionTo(node, toNodeId) {\n    var result = false;\n\n    if (node != null && toNodeId != null) {\n      var transitionLogic = node.transitionLogic;\n\n      if (transitionLogic != null) {\n        var transitions = transitionLogic.transitions;\n\n        if (transitions != null) {\n          for (var t = 0; t < transitions.length; t++) {\n            var transition = transitions[t];\n\n            if (toNodeId === transition.to) {\n              result = true;\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the transitions that traverse from the fromNodeId and to the toNodeId\n   * @param fromNodeId the from node id\n   * @param toNodeId the to node id\n   * @returns an array of transitions that traverse from the fromNodeId and\n   * to the toNodeId\n   */\n  getTransitionsByFromAndToNodeId(fromNodeId, toNodeId) {\n    var transitionsResults = [];\n\n    if (fromNodeId != null && toNodeId != null) {\n      var node = this.getNodeById(fromNodeId);\n\n      if (node != null) {\n        var transitionLogic = node.transitionLogic;\n\n        if (transitionLogic != null) {\n          var transitions = transitionLogic.transitions;\n\n          if (transitions != null) {\n\n            for (var t = 0; t < transitions.length; t++) {\n              var transition = transitions[t];\n\n              if (transition != null) {\n                var to = transition.to;\n\n                if (toNodeId === to) {\n                  transitionsResults.push(transition);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return transitionsResults;\n  };\n\n  /**\n   * Retrieves the project JSON from Config.projectURL and returns it.\n   * If Config.projectURL is undefined, returns null.\n   */\n  retrieveProject() {\n    var projectURL = this.ConfigService.getConfigParam('projectURL');\n\n    if (projectURL == null) {\n      return null;\n    } else {\n      /*\n             * add a unique GET parameter value so that it always retrieves the\n             * latest version of the project file from the server and never\n             * retrieves the project from cache.\n             */\n      projectURL += '?noCache=' + (new Date()).getTime();\n    }\n\n    return this.$http.get(projectURL).then((result) => {\n      var projectJSON = result.data;\n      this.setProject(projectJSON);\n      return projectJSON;\n    });\n  };\n\n  /**\n   * Retrieve the project JSON\n   * @param projectId retrieve the project JSON with this id\n   * @return a promise to return the project JSON\n   */\n  retrieveProjectById(projectId) {\n\n    if (projectId != null) {\n\n      // get the config URL for the project\n      var configURL = window.configURL + '/' + projectId;\n\n      // get the config for the project\n      return this.$http.get(configURL).then((result) => {\n        var configJSON = result.data;\n\n        if (configJSON != null) {\n\n          // get the project URL and preview project URL\n          var projectURL = configJSON.projectURL;\n          var previewProjectURL = configJSON.previewProjectURL;\n\n          if (projectURL != null) {\n\n            // get the project JSON\n            return this.$http.get(projectURL).then((result) => {\n              var projectJSON = result.data;\n\n              /*\n                             * set the preview project URL into the project JSON\n                             * so that we easily obtain the preview project URL\n                             * later\n                             */\n              projectJSON.previewProjectURL = previewProjectURL;\n\n              return projectJSON;\n            });\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Saves the project to Config.saveProjectURL and returns commit history promise.\n   * if Config.saveProjectURL or Config.projectId are undefined, does not save and returns null\n   */\n  saveProject(commitMessage = \"\") {\n    this.$rootScope.$broadcast('savingProject');\n    // perform any cleanup before saving the project\n    this.cleanupBeforeSave();\n\n    var projectId = this.ConfigService.getProjectId();\n    var saveProjectURL = this.ConfigService.getConfigParam('saveProjectURL');\n    if (projectId == null || saveProjectURL == null) {\n      return null;\n    }\n\n    // Get the project from this service\n    var projectJSONString = angular.toJson(this.project, 4);\n\n    var httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = saveProjectURL;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    var params = {};\n    params.projectId = projectId;\n    params.commitMessage = commitMessage;\n    params.projectJSONString = projectJSONString;\n    httpParams.data = $.param(params);\n\n    return this.$http(httpParams).then((result) => {\n      var commitHistory = result.data;\n      this.$rootScope.$broadcast('projectSaved');\n      return commitHistory;\n    });\n  };\n\n  /**\n   * Notifies others that the specified project is being authored\n   * @param projectId id of the project\n   */\n  notifyAuthorProjectBegin(projectId = null) {\n    if (projectId == null) {\n      if (this.project != null) {\n        projectId = this.project.id;\n      } else {\n        return;\n      }\n    }\n    let notifyProjectBeginURL = this.ConfigService.getConfigParam('notifyProjectBeginURL') + projectId;\n    let httpParams = {\n      method: \"POST\",\n      url: notifyProjectBeginURL\n    };\n\n    return this.$http(httpParams).then((result) => {\n      let otherAuthors = result.data;\n      return otherAuthors;\n    });\n  }\n\n  /**\n   * Notifies others that the specified project is being authored\n   * @param projectId id of the project\n   */\n  notifyAuthorProjectEnd(projectId = null) {\n    return this.$q((resolve, reject) => {\n      if (projectId == null) {\n        if (this.project != null) {\n          projectId = this.ConfigService.getProjectId();\n        } else {\n          resolve();\n        }\n      }\n      let notifyProjectEndURL = this.ConfigService.getConfigParam('notifyProjectEndURL') + projectId;\n      let httpParams = {};\n      httpParams.method = 'POST';\n      httpParams.url = notifyProjectEndURL;\n\n      this.$http(httpParams).then(() => {\n        resolve();\n      })\n    });\n  }\n\n  /**\n   * Perform any necessary cleanup before we save the project.\n   * For example we need to remove the checked field in the inactive node\n   * objects.\n   */\n  cleanupBeforeSave() {\n    let activeNodes = this.getActiveNodes();\n    for (let activeNode of activeNodes) {\n      if (activeNode != null) {\n        delete activeNode.checked;\n      }\n    }\n\n    let inactiveNodes = this.getInactiveNodes();\n    for (let inactiveNode of inactiveNodes) {\n      if (inactiveNode != null) {\n        delete inactiveNode.checked;\n      }\n    }\n  }\n\n  /**\n   * Copies the project with the specified id and returns a new project id if the project is\n   * successfully copied\n   */\n  copyProject(projectId) {\n    var copyProjectURL = this.ConfigService.getConfigParam('copyProjectURL');\n\n    if (copyProjectURL == null) {\n      return null;\n    }\n\n    var httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = copyProjectURL + \"/\" + projectId;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    var params = {};\n    httpParams.data = $.param(params);\n\n    return this.$http(httpParams).then((result) => {\n      var projectId = result.data;\n      return projectId;\n    });\n  };\n\n  /**\n   * Registers a new project having the projectJSON content with the server.\n   * Returns a new project Id if the project is successfully registered.\n   * Returns null if Config.registerNewProjectURL is undefined.\n   * Throws an error if projectJSONString is invalid JSON string\n   */\n  registerNewProject(projectJSONString, commitMessage) {\n    var registerNewProjectURL = this.ConfigService.getConfigParam('registerNewProjectURL');\n\n    if (registerNewProjectURL == null) {\n      return null;\n    }\n\n    try {\n      // Try parsing the JSON string and throw an error if there's an issue parsing it.\n      JSON.parse(projectJSONString);\n    } catch (e) {\n      throw new Error(\"Invalid projectJSONString.\");\n    }\n\n    if (!commitMessage) {\n      commitMessage = \"\";\n    }\n\n    var httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = registerNewProjectURL;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    var params = {};\n    params.commitMessage = commitMessage;\n    params.projectJSONString = projectJSONString;\n    httpParams.data = $.param(params);\n\n    return this.$http(httpParams).then((result) => {\n      var projectId = result.data;\n      return projectId;\n    });\n  };\n\n  /**\n   * Retrieves and returns the project's commit history.\n   */\n  getCommitHistory() {\n    var commitProjectURL = this.ConfigService.getConfigParam('commitProjectURL');\n\n    return this.$http({\n      url: commitProjectURL,\n      method: 'GET'\n    }).then((result) => {\n      return result.data;\n    });\n  };\n\n  /**\n   * Returns the theme path for the current project\n   */\n  getThemePath() {\n    let wiseBaseURL = this.ConfigService.getWISEBaseURL();\n    let project = this.project;\n    if (project && project.theme) {\n      // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n      return wiseBaseURL + '/wise5/themes/' + project.theme;\n    } else {\n      // TODO: get default theme name from ConfigService\n      return wiseBaseURL + '/wise5/themes/default';\n    }\n  };\n\n  /**\n   * Returns the theme settings for the current project\n   */\n  getThemeSettings() {\n    let themeSettings = {};\n    let project = this.project;\n\n    if (project && project.themeSettings) {\n      if (project.theme) {\n        // TODO: check if this is a valid theme (using ConfigService) rather than just truthy\n        themeSettings = project.themeSettings[project.theme];\n      } else {\n        // TODO: get default theme name from ConfigService\n        themeSettings = project.themeSettings[\"default\"];\n      }\n    }\n\n    return themeSettings ? themeSettings : {};\n  };\n\n  /**\n   * Flatten the project to obtain a list of node ids\n   * @param recalculate Whether to force recalculating the flattened node ids.\n   * @return An array of the flattened node ids in the project.\n   */\n  getFlattenedProjectAsNodeIds(recalculate) {\n    if (!recalculate && this.flattenedProjectAsNodeIds != null) {\n      // use the previously calculated flattened node ids\n      return this.flattenedProjectAsNodeIds;\n    }\n\n    var nodeIds = [];\n\n    // get the start node id\n    var startNodeId = this.getStartNodeId();\n\n    /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n    var pathsSoFar = [];\n\n    // get all the possible paths through the project\n    var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n    // consolidate all the paths to create a single list of node ids\n    nodeIds = this.consolidatePaths(allPaths);\n\n    /*\n         * Remember the flattened node ids so that we don't have to calculate\n         * it again.\n         */\n    this.flattenedProjectAsNodeIds = nodeIds;\n\n    return nodeIds;\n  };\n\n  /**\n   * Get all the possible paths through the project. This function\n   * recursively calls itself to traverse the project depth first.\n   * @param pathSoFar the node ids in the path so far. the node ids\n   * in this array are referenced to make sure we don't loop back\n   * on the path.\n   * @param nodeId the node id we want to get the paths from\n   * @param includeGroups whether to include the group node ids in the paths\n   * @return an array of paths. each path is an array of node ids.\n   */\n  getAllPaths(pathSoFar, nodeId, includeGroups) {\n    var allPaths = [];\n\n    if (nodeId != null) {\n      if (this.isApplicationNode(nodeId)) {\n        // the node is an application node\n\n        var path = [];\n\n        // get all the transitions from this node\n        var transitions = this.getTransitionsByFromNodeId(nodeId);\n\n        if (transitions != null) {\n\n          if (includeGroups) {\n            // get the parent group\n            var parentGroup = this.getParentGroup(nodeId);\n            if (parentGroup != null) {\n\n              // get the parent group id\n              var parentGroupId = parentGroup.id;\n\n              if (parentGroupId != null && pathSoFar.indexOf(parentGroupId) == -1) {\n                // add the parent group id\n                pathSoFar.push(parentGroup.id);\n              }\n            }\n          }\n\n          /*\n                     * add the node id to the path so far so we can later check\n                     * which nodes are already in the path to prevent looping\n                     * back in the path\n                     */\n          pathSoFar.push(nodeId);\n\n          if (transitions.length === 0) {\n            /*\n                         * there are no transitions from the node id so we will\n                         * look for a transition in the parent group\n                         */\n\n            var addedCurrentNodeId = false;\n\n            var parentGroupId = this.getParentGroupId(nodeId);\n            var parentGroupTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n\n            if (parentGroupTransitions != null) {\n              for (var p = 0; p < parentGroupTransitions.length; p++) {\n                var parentGroupTransition = parentGroupTransitions[p];\n\n                if (parentGroupTransition != null) {\n\n                  var toNodeId = parentGroupTransition.to;\n\n                  if (pathSoFar.indexOf(toNodeId) == -1) {\n                    /*\n                                         * recursively get the paths by getting all\n                                         * the paths for the to node\n                                         */\n                    var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                    for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                      // get a path\n                      var tempPath = allPathsFromToNode[a];\n\n                      // prepend the current node id to the path\n                      tempPath.unshift(nodeId);\n\n                      // add the path to our collection of paths\n                      allPaths.push(tempPath);\n\n                      addedCurrentNodeId = true;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (!addedCurrentNodeId) {\n              /*\n                             * if the parent group doesn't have any transitions we will\n                             * need to add the current node id to the path\n                             */\n\n              // add the node id to the path\n              path.push(nodeId);\n\n              // add the path to the all paths array\n              allPaths.push(path);\n            }\n          } else {\n            // there are transitions from this node id\n\n            // loop through all the transitions from this node id\n            for (var t = 0; t < transitions.length; t++) {\n              var transitionResult = [];\n\n              // get a transition\n              var transition = transitions[t];\n\n              if (transition != null) {\n                // get the to node id\n                var toNodeId = transition.to;\n\n                if (toNodeId != null && pathSoFar.indexOf(toNodeId) == -1) {\n                  // we have not found the to node in the path yet so we can traverse it\n\n                  /*\n                                     * recursively get the paths by getting all\n                                     * the paths from the to node\n                                     */\n                  var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                  if (allPathsFromToNode != null) {\n                    // loop through all the paths from the to node\n                    for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                      // get a path\n                      var tempPath = allPathsFromToNode[a];\n\n                      if (includeGroups) {\n                        // we need to add the group id to the path\n\n                        if (tempPath.length > 0) {\n\n                          // get the first node id in the path\n                          var firstNodeId = tempPath[0];\n\n                          // get the parent id of the first node\n                          var firstParentGroupId = this.getParentGroupId(firstNodeId);\n\n                          // get the parent id of the current node\n                          var parentGroupId = this.getParentGroupId(nodeId);\n\n                          if (parentGroupId != firstParentGroupId) {\n                            /*\n                                                         * the parent ids are different which means this is a boundary\n                                                         * between two groups. for example if the project looked like\n                                                         * group1>node1>node2>group2>node3>node4\n                                                         * and the current node was node2 then the first node in the\n                                                         * path would be node3 which means we would need to place\n                                                         * group2 on the path before node3\n                                                         */\n                            tempPath.unshift(firstParentGroupId);\n                          }\n                        }\n                      }\n\n                      // prepend the current node id to the path\n                      tempPath.unshift(nodeId);\n\n                      // add the path to our collection of paths\n                      allPaths.push(tempPath);\n                    }\n                  }\n                } else {\n                  /*\n                                     * the node is already in the path so far which means\n                                     * the transition is looping back to a previous node.\n                                     * we do not want to take this transition because\n                                     * it will lead to an infinite loop. we will just\n                                     * add the current node id to the path and not take\n                                     * the transition which essentially ends the path.\n                                     */\n                  // add the node id to the path\n                  path.push(nodeId);\n\n                  // add the path to the all paths array\n                  allPaths.push(path);\n                }\n              }\n            }\n          }\n\n          if (pathSoFar.length > 0) {\n            // get the last node id\n            var lastNodeId = pathSoFar[pathSoFar.length - 1];\n\n            // check if the last node id is a group id\n            if (this.isGroupNode(lastNodeId)) {\n              /*\n                             * the last node id is a group id so we will remove it\n                             * since we are moving back up the path as we traverse\n                             * the nodes depth first\n                             */\n              pathSoFar.pop();\n            }\n          }\n\n          /*\n                     * remove the latest node id (this will be a step node id)\n                     * since we are moving back up the path as we traverse the\n                     * nodes depth first\n                     */\n          pathSoFar.pop();\n\n          if (includeGroups) {\n            if (pathSoFar.length == 1) {\n\n              /*\n                             * we are including groups and we have traversed\n                             * back up to the start node id for the project.\n                             * the only node id left in pathSoFar is now the\n                             * parent group of the start node id. we will\n                             * now add this parent group of the start node id\n                             * to all of the paths\n                             */\n\n              // loop through all the paths\n              for (var ap = 0; ap < allPaths.length; ap++) {\n\n                // get a path\n                var path = allPaths[ap];\n\n                if (path != null) {\n                  /*\n                                     * prepend the parent group of the start node id\n                                     * to the path\n                                     */\n                  path.unshift(pathSoFar[0]);\n                }\n              }\n\n              /*\n                             * remove the parent group of the start node id from\n                             * pathSoFar which leaves us with an empty pathSoFar\n                             * which means we are completely done with\n                             * calculating all the paths\n                             */\n              pathSoFar.pop();\n            }\n          }\n        }\n      } else if (this.isGroupNode(nodeId)) {\n        // the node is a group node\n\n        /*\n                 * add the node id to the path so far so we can later check\n                 * which nodes are already in the path to prevent looping\n                 * back in the path\n                 */\n        pathSoFar.push(nodeId);\n\n        // get the group node\n        var groupNode = this.getNodeById(nodeId);\n\n        if (groupNode != null) {\n          var startId = groupNode.startId;\n\n          if (startId == null || startId == \"\") {\n            // there is no start id so we will take the transition from the group\n            // TODO? there is no start id so we will loop through all the child nodes\n\n            // get the transitions from the group\n            var transitions = this.getTransitionsByFromNodeId(groupNode.id);\n\n            if (transitions != null && transitions.length > 0) {\n\n              // loop through all the transitions from the group\n              for (var t = 0; t < transitions.length; t++) {\n                var transition = transitions[t];\n\n                if (transition != null) {\n                  var toNodeId = transition.to;\n\n                  // get the paths from the to node to the end of the project\n                  var allPathsFromToNode = this.getAllPaths(pathSoFar, toNodeId, includeGroups);\n\n                  if (allPathsFromToNode != null) {\n                    // loop through all the paths from the to node\n                    for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                      // get a path\n                      var tempPath = allPathsFromToNode[a];\n\n                      // prepend the current node id to the path\n                      tempPath.unshift(nodeId);\n\n                      // add the path to our collection of paths\n                      allPaths.push(tempPath);\n                    }\n                  }\n                }\n              }\n            } else {\n              /*\n                             * this activity does not have any transitions so\n                             * we have reached the end of this path\n                             */\n\n              var tempPath = [];\n\n              // prepend the current node id to the path\n              tempPath.unshift(nodeId);\n\n              // add the path to our collection of paths\n              allPaths.push(tempPath);\n            }\n          } else {\n            // there is a start id so we will traverse it\n\n            // get the paths from the start id to the end of the project\n            var allPathsFromToNode = this.getAllPaths(pathSoFar, startId, includeGroups);\n\n            if (allPathsFromToNode != null) {\n              // loop through all the paths from the to node\n              for (var a = 0; a < allPathsFromToNode.length; a++) {\n\n                // get a path\n                var tempPath = allPathsFromToNode[a];\n\n                // prepend the current node id to the path\n                tempPath.unshift(nodeId);\n\n                // add the path to our collection of paths\n                allPaths.push(tempPath);\n              }\n            }\n          }\n        }\n\n        /*\n                 * remove the latest node id since we are moving back\n                 * up the path as we traverse the nodes depth first\n                 */\n        pathSoFar.pop();\n      }\n    }\n\n    return allPaths;\n  };\n\n  /**\n   * Consolidate all the paths into a linear list of node ids\n   * @param paths an array of paths. each path is an array of node ids.\n   * @return an array of node ids that have been properly ordered\n   */\n  consolidatePaths(paths) {\n    var consolidatedPath = [];\n\n    if (paths != null) {\n\n      /*\n             * continue until all the paths are empty. as we consolidate\n             * node ids, we will remove them from the paths. once all the\n             * paths are empty we will be done consolidating the paths.\n             */\n      while(!this.arePathsEmpty(paths)) {\n\n        // start with the first path\n        var currentPath = this.getNonEmptyPathIndex(paths);\n\n        // get the first node id in the current path\n        var nodeId = this.getFirstNodeIdInPathAtIndex(paths, currentPath);\n\n        if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n          // the first node ids in all the paths are the same\n\n          // remove the node id from all the paths\n          this.removeNodeIdFromPaths(nodeId, paths);\n\n          // add the node id to our consolidated path\n          consolidatedPath.push(nodeId);\n        } else {\n          // not all the top node ids are the same which means we have branched\n\n          // get all the paths that contain the node id\n          var pathsThatContainNodeId = this.getPathsThatContainNodeId(nodeId, paths);\n\n          if (pathsThatContainNodeId != null) {\n            if (pathsThatContainNodeId.length === 1) {\n              // only the current path we are on has the node id\n\n              // remove the node id from the path\n              this.removeNodeIdFromPath(nodeId, paths, currentPath);\n\n              // add the node id to our consolidated path\n              consolidatedPath.push(nodeId);\n            } else {\n              // there are multiple paths that have this node id\n\n              // consume all the node ids up to the given node id\n              var consumedPath = this.consumePathsUntilNodeId(paths, nodeId);\n\n              // remove the node id from the paths\n              this.removeNodeIdFromPaths(nodeId, paths);\n\n              // add the node id to the end of the consumed path\n              consumedPath.push(nodeId);\n\n              // add the consumed path to our consolidated path\n              consolidatedPath = consolidatedPath.concat(consumedPath);\n            }\n          }\n        }\n\n      }\n    }\n\n    return consolidatedPath;\n  };\n\n  /**\n   * Consume the node ids in the paths until we get to the given node id\n   * @param paths the paths to consume\n   * @param nodeId the node id to stop consuming at\n   * @return an array of node ids that we have consumed\n   */\n  consumePathsUntilNodeId(paths, nodeId) {\n    var consumedNodeIds = [];\n\n    if (paths != null && nodeId != null) {\n\n      // loop through all the paths\n      for (var p = 0; p < paths.length; p++) {\n\n        // get a path\n        var path = paths[p];\n\n        // check if the path contains the node id to stop consuming at\n        if (path != null && path.indexOf(nodeId) != -1) {\n          /*\n                     * the path does contain the node id to stop consuming at\n                     * so we will consume the node ids in this path until\n                     * we get to the given node id to stop consuming at\n                     */\n\n          // loop through the node ids in the path\n          for (var x = 0; x < path.length; x++) {\n\n            // get a node id\n            var tempNodeId = path[x];\n\n            if (nodeId === tempNodeId) {\n              /*\n                             * the node id is the same as the one we need to\n                             * stop consuming at so we will stop looking\n                             * at this path\n                             */\n              break;\n            } else {\n              /*\n                             * the node id is not the one that we need to stop consuming at\n                             * so we will consume it\n                             */\n\n              // get all the paths that contain the node id\n              var pathsThatContainNodeId = this.getPathsThatContainNodeId(tempNodeId, paths);\n\n              if (pathsThatContainNodeId.length === 1) {\n                // there is only one path with this node id\n\n                // remove the node id from the path\n                this.removeNodeIdFromPath(tempNodeId, paths, p);\n\n                // move the counter back one since we have just removed a node id\n                x--;\n\n                // add the node id to the consumed node ids array\n                consumedNodeIds.push(tempNodeId);\n              } else {\n                // there are multiple paths with this node id\n\n                // tempNodeId must come before nodeId\n\n                var pathsToConsume = [];\n\n                // loop through all the paths that contain the node id\n                for (var g = 0; g < pathsThatContainNodeId.length; g++) {\n\n                  // get a path that contains the node id\n                  var pathThatContainsNodeId = pathsThatContainNodeId[g];\n\n                  // get the index of the node id we want to remove\n                  var tempNodeIdIndex = pathThatContainsNodeId.indexOf(tempNodeId);\n\n                  // get the index of the node id we want to stop consuming at\n                  var nodeIdIndex = pathThatContainsNodeId.indexOf(nodeId);\n\n                  /*\n                                     * check if the node id we want to remove comes before\n                                     * the node id we want to stop consuming at. we need to\n                                     * do this to prevent an infinite loop. an example of\n                                     * when this can happen is if there are two paths\n                                     *\n                                     * path1 = 1, 2, 3, 4, 5\n                                     * path2 = 1, 2, 4, 3, 5\n                                     *\n                                     * as we consume path1 we will need to consume 3. in order to\n                                     * consume 3, we must consume consume up to 3 in path2.\n                                     * in order to consume up to 3 in path2 we must consume 4.\n                                     * in order to consume 4, we must consume everything before\n                                     * 4 in path1. everything before 4 in path1 is 1, 2, 3.\n                                     * this means we need to consume 3 which brings us back up\n                                     * to the top of this paragraph creating an infinite loop.\n                                     *\n                                     * this check below will prevent infinite loops by only\n                                     * adding paths that have the tempNodeId come before the\n                                     * nodeId to stop consuming at.\n                                     */\n                  if (tempNodeIdIndex < nodeIdIndex) {\n                    pathsToConsume.push(pathThatContainsNodeId);\n                  }\n                }\n\n                /*\n                                 * take the paths that contain the given node id and consume\n                                 * the paths until the given node id\n                                 */\n                var tempConsumedNodeIds = this.consumePathsUntilNodeId(pathsToConsume, tempNodeId);\n\n                // remove the node id from the paths that contain it\n                this.removeNodeIdFromPaths(tempNodeId, pathsThatContainNodeId);\n\n                // add the temp consumed node ids to our consumed node ids array\n                consumedNodeIds = consumedNodeIds.concat(tempConsumedNodeIds);\n\n                // move the counter back one since we have just removed a node id\n                x--;\n\n                // add the node id to the consumed node ids array\n                consumedNodeIds.push(tempNodeId);\n              }\n            }\n          }\n        }\n      }\n\n    }\n\n    return consumedNodeIds;\n  };\n\n  /**\n   * Get the path at the given index and get the first node id in\n   * the path\n   * @param paths an array of paths. each path is an array of node ids\n   * @param index the index of the path we want\n   * @return the first node in the given path\n   */\n  getFirstNodeIdInPathAtIndex(paths, index) {\n    var nodeId = null;\n\n    if (paths != null && index != null) {\n      // get the path at the given index\n      var path = paths[index];\n\n      if (path != null && path.length > 0) {\n        // get the first node id in the path\n        nodeId = path[0];\n      }\n    }\n\n    return nodeId;\n  };\n\n  /**\n   * Remove the node ifrom the paths\n   * @param nodeId the node id to remove\n   * @param paths an array of paths. each path is an array of node ids\n   */\n  removeNodeIdFromPaths(nodeId, paths) {\n\n    if (nodeId != null && paths != null) {\n      // loop through all the paths\n      for (var p = 0; p < paths.length; p++) {\n\n        // get a path\n        var path = paths[p];\n\n        // loop through all the node ids in the path\n        for (var x = 0; x < path.length; x++) {\n          // get a node id\n          var tempNodeId = path[x];\n\n          /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n          if (nodeId === tempNodeId) {\n            /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n            path.splice(x, 1);\n\n            /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n            x--;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Remove the node id from the path\n   * @param nodeId the node id to remove\n   * @param paths an array of paths. each path is an array of node ids\n   * @param pathIndex the path to remove from\n   */\n  removeNodeIdFromPath(nodeId, paths, pathIndex) {\n\n    if (nodeId != null && paths != null && pathIndex != null) {\n\n      // get the path at the given index\n      var path = paths[pathIndex];\n\n      if (path != null) {\n\n        // loop through all the node ids in the path\n        for (var x = 0; x < path.length; x++) {\n          // get a ndoe id\n          var tempNodeId = path[x];\n\n          /*\n                     * check if the node id matches the one we are looking\n                     * for\n                     */\n          if (nodeId === tempNodeId) {\n            /*\n                         * we have found the node id we are looking for so\n                         * we will remove it from the path\n                         */\n            path.splice(x, 1);\n\n            /*\n                         * move the counter back since we just removed a\n                         * node id. we will continue searching this path\n                         * for the node id in case the path contains it\n                         * multiple times.\n                         */\n            x--;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Check if the first node ids in the paths are the same\n   * @param paths an array of paths. each path is an array of node ids\n   * @return whether all the paths have the same first node id\n   */\n  areFirstNodeIdsInPathsTheSame(paths) {\n    var result = true;\n\n    var nodeId = null;\n\n    if (paths != null) {\n\n      // loop through all the paths\n      for (var p = 0; p < paths.length; p++) {\n\n        // get a path\n        var path = paths[p];\n\n        // get the first node id in the path\n        var tempNodeId = path[0];\n\n        if (nodeId == null) {\n          /*\n                     * this is the first path we have looked at so we will\n                     * remember the node id\n                     */\n          nodeId = tempNodeId;\n        } else if (nodeId != tempNodeId) {\n          /*\n                     * the node id does not match the first node id from a\n                     * previous path so the paths do not all have the same\n                     * first node id\n                     */\n          result = false;\n          break;\n        }\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Check if all the paths are empty\n   * @param paths an array of paths. each path is an array of node ids\n   * @return whether all the paths are empty\n   */\n  arePathsEmpty(paths) {\n    var result = true;\n\n    if (paths != null) {\n\n      // loop through all the paths\n      for (var p = 0; p < paths.length; p++) {\n\n        // get a path\n        var path = paths[p];\n\n        if (path != null) {\n\n          // get the length of the path\n          if (path.length !== 0) {\n            // the path is not empty\n            result = false;\n            break;\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Get the paths that contain the node id\n   * @param nodeId the node id we are looking for\n   * @param paths an array of paths. each path is an array of node ids\n   * @return an array of paths that contain the given node id\n   */\n  getPathsThatContainNodeId(nodeId, paths) {\n    var pathsThatContainNodeId = [];\n\n    if (nodeId != null && paths != null) {\n      // loop through all the paths\n      for (var p = 0; p < paths.length; p++) {\n\n        // get a path\n        var path = paths[p];\n\n        // check if the path contains the node id\n        if (path.indexOf(nodeId) != -1) {\n          /*\n                     * add the path to the array of paths that contain\n                     * the node id\n                     */\n          pathsThatContainNodeId.push(path);\n        }\n      }\n    }\n\n    return pathsThatContainNodeId;\n  };\n\n  /**\n   * Get a non empty path index. It will loop through the paths and\n   * return the index of the first non empty path.\n   * @param paths an array of paths. each path is an array of node ids\n   * @return the index of the path that is not empty\n   */\n  getNonEmptyPathIndex(paths) {\n    var index = null;\n\n    if (paths != null) {\n      // loop through all the paths\n      for (var p = 0; p < paths.length; p++) {\n        // get a path\n        var path = paths[p];\n\n        // check the length of the path\n        if (path.length !== 0) {\n          // the path is not empty so we will return this index\n          index = p;\n          break;\n        }\n      }\n    }\n\n    return index;\n  };\n\n  /**\n   * Get the branches in the project\n   */\n  getBranches() {\n\n    // get the start node id\n    var startNodeId = this.getStartNodeId();\n\n    /*\n         * an array to keep track of the node ids in the path that\n         * we are currently on as we traverse the nodes in the project\n         * depth first\n         */\n    var pathsSoFar = [];\n\n    // get all the paths in the project\n    var allPaths = this.getAllPaths(pathsSoFar, startNodeId);\n\n    // find the branches in the project from the paths\n    var branches = this.findBranches(allPaths);\n\n    return branches;\n  };\n\n  /**\n   * Find the branches in the project\n   * @param paths all the possible paths through the project\n   * @return an array of branch objects. each branch object contains\n   * the branch start point, the branch paths, and the branch\n   * end point\n   */\n  findBranches(paths) {\n    var branches = [];\n\n    var previousNodeId = null;\n\n    /*\n         * continue until all the paths are empty. we will remove\n         * node ids from the paths as we traverse the paths to find\n         * the branches\n         */\n    while (!this.arePathsEmpty(paths)) {\n\n      // get the first node id in the first path\n      var nodeId = this.getFirstNodeIdInPathAtIndex(paths, 0);\n\n      if (this.areFirstNodeIdsInPathsTheSame(paths)) {\n        // the first node ids in all the paths are the same\n\n        // remove the node id from all the paths\n        this.removeNodeIdFromPaths(nodeId, paths);\n\n        // remember this node id for the next iteration of the loop\n        previousNodeId = nodeId;\n      } else {\n        // not all the top node ids are the same which means we have branched\n\n        // create a branch object\n        var branchMetaObject = this.createBranchMetaObject(previousNodeId);\n        branchMetaObject.branchStartPoint = previousNodeId;\n\n        // find the branch end point\n        var nextCommonNodeId = this.findNextCommonNodeId(paths);\n        branchMetaObject.branchEndPoint = nextCommonNodeId;\n\n        // get the branch paths\n        var branchPaths = this.extractPathsUpToNodeId(paths, nextCommonNodeId);\n        branchPaths = this.removeDuplicatePaths(branchPaths);\n        branchMetaObject.branchPaths = branchPaths;\n\n        // add the branch object to our array\n        branches.push(branchMetaObject);\n\n        // trim the paths so that they start at the branch end point\n        this.trimPathsUpToNodeId(paths, nextCommonNodeId);\n\n        // remember this node id for the next iteration of the loop\n        previousNodeId = nextCommonNodeId;\n      }\n    }\n\n    return branches;\n  };\n\n  /**\n   * Create a branch meta object that will contain the branch start\n   * point, branch paths, and branch end point\n   * @return an object that contains a branch start point, branch paths,\n   * and a branch end point\n   */\n  createBranchMetaObject() {\n    var branchMetaObject = {};\n\n    branchMetaObject.branchStartPoint = null;\n    branchMetaObject.branchPaths = [];\n    branchMetaObject.branchEndPoint = null;\n\n    return branchMetaObject;\n  };\n\n  /**\n   * Find the next common node id in all the paths\n   * @param paths the paths to find the common node id in\n   * @return a node id that is in all the paths or null\n   * if there is no node id that is in all the paths\n   */\n  findNextCommonNodeId(paths) {\n    var nextCommonNodeId = null;\n    var subPaths = [];\n\n    if (paths != null) {\n      if (paths.length > 0) {\n        // get the first path\n        var path = paths[0];\n\n        // loop through all the node ids in the first path\n        for (var x = 0; x < path.length; x++) {\n          // get a node id\n          var tempNodeId = path[x];\n\n          // check if the node id is in all the paths\n          if (this.allPathsContainNodeId(paths, tempNodeId)) {\n            /*\n                         * the node id is in all the paths so we have found\n                         * what we were looking for\n                         */\n            nextCommonNodeId = tempNodeId;\n            break;\n          }\n        }\n      }\n    }\n\n    return nextCommonNodeId;\n  };\n\n  /**\n   * Check if all the paths contain the node id\n   * @param paths an array of paths. each path contains an array of node ids\n   * @param nodeId the node id that we will check is in all the paths\n   * @return whether the node id is in all the paths\n   */\n  allPathsContainNodeId(paths, nodeId) {\n    var result = false;\n\n    if (paths != null) {\n\n      // loop through all the paths\n      for (var p = 0; p < paths.length; p++) {\n        // get a path\n        var path = paths[p];\n\n        // get the index of the node id in the path\n        var index = path.indexOf(nodeId);\n\n        if (index == -1) {\n          // the node id is not in the path\n          result = false;\n          break;\n        } else {\n          // the node id is in the path\n          result = true;\n        }\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Trim the paths up to the given node id so that the paths will contain\n   * the given node id and all the node ids after it. This function will\n   * modify the paths.\n   * @param paths the paths to trim\n   * @param nodeId the node id to trim up to\n   */\n  trimPathsUpToNodeId(paths, nodeId) {\n    if (paths != null) {\n      // loop through all the paths\n      for (var p = 0; p < paths.length; p++) {\n        // get a path\n        var path = paths[p];\n\n        if (path != null) {\n          // get the index of the node id in the path\n          var index = path.indexOf(nodeId);\n\n          if (index == -1) {\n            /*\n                         * the node id is not in the path so we will\n                         * trim the path to the end which will make\n                         * the path empty\n                         */\n            index = path.length;\n          }\n\n          /*\n                     * trim the path up to the node id index. this will\n                     * modify the path array.\n                     */\n          path.splice(0, index);\n        }\n      }\n    }\n  };\n\n\n  /**\n   * Extract the paths up to a given node id. This will be used to\n   * obtain branch paths.\n   * @param paths the paths to extract from\n   * @param nodeId the node id to extract up to\n   * @return paths that go up to but do not include the node id\n   */\n  extractPathsUpToNodeId(paths, nodeId) {\n    var extractedPaths = [];\n\n    if (paths != null) {\n      // loop through the paths\n      for (var p = 0; p < paths.length; p++) {\n\n        // get a path\n        var path = paths[p];\n\n        if (path != null) {\n\n          // get the index of the node id in the path\n          var index = path.indexOf(nodeId);\n\n          if (index == -1) {\n            /*\n                         * the node id is not in the path so we will\n                         * extract up to the end of the path\n                         */\n            index = path.length;\n          }\n\n          /*\n                     * get the path up to the node id index. this does\n                     * not modify the path array.\n                     */\n          var extractedPath = path.slice(0, index);\n\n          // add the\n          extractedPaths.push(extractedPath);\n        }\n      }\n    }\n\n    return extractedPaths;\n  };\n\n  /**\n   * Removes duplicate paths\n   * @param paths an array of paths. each path contains an array of node ids\n   * @return an array of unique paths\n   */\n  removeDuplicatePaths(paths) {\n    var uniquePaths = [];\n\n    if (paths != null) {\n      // loop through all the paths\n      for (var p = 0; p < paths.length; p++) {\n        // get a path\n        var path = paths[p];\n\n        var isPathInUniquePaths = false;\n\n        // loop through all the unique paths so far\n        for (var u = 0; u < uniquePaths.length; u++) {\n          // get a unique path\n          var uniquePath = uniquePaths[u];\n\n          // check if the paths are equal\n          if (this.pathsEqual(path, uniquePath)) {\n            // the paths are equal\n            isPathInUniquePaths = true;\n          }\n        }\n\n        if (!isPathInUniquePaths) {\n          // the path is not equal to any paths in the unique\n          // paths array so we will add it to the unique paths array\n          uniquePaths.push(path);\n        }\n      }\n    }\n\n    return uniquePaths;\n  };\n\n  /**\n   * Check if two paths are equal\n   * @param path1 an array of node ids\n   * @param path2 an array of node ids\n   * @return whether the two paths contain the same node ids\n   * in the same order\n   */\n  pathsEqual(path1, path2) {\n    var result = false;\n\n    if (path1 != null && path2 != null) {\n\n      // check if the paths are the same length\n      if (path1.length === path2.length) {\n        result = true;\n\n        // loop through each element of the first path\n        for (var x = 0; x < path1.length; x++) {\n          // get the node id from the first path\n          var path1NodeId = path1[x];\n\n          // get the node id from the second path\n          var path2NodeId = path2[x];\n\n          // check if the node ids are the same\n          if (path1NodeId !== path2NodeId) {\n            // the node ids are not the same to the paths are not equal\n            result = false;\n            break;\n          }\n        }\n      }\n    }\n\n    return result;\n  };\n\n  /**\n   * Check if a node id is in any branch\n   * @param branches an array of branch objects\n   * @param nodeId the node id to check\n   * @return whether the node id is in any branch\n   */\n  isNodeIdInABranch(branches, nodeId) {\n\n    if (branches != null && nodeId != null) {\n\n      // loop through all the branch objects\n      for (var b = 0; b < branches.length; b++) {\n\n        // get a branch object\n        var branch = branches[b];\n\n        if (branch != null) {\n\n          // get the branch paths for this branch object\n          var branchPaths = branch.branchPaths;\n\n          if (branchPaths != null) {\n\n            // loop through all the branch paths\n            for (var bp = 0; bp < branchPaths.length; bp++) {\n\n              // get a branch path\n              var branchPath = branchPaths[bp];\n\n              if (branchPath != null) {\n\n                // check if the node id is in the branch path\n                var index = branchPath.indexOf(nodeId);\n\n                if (index != -1) {\n                  // the node id is in this branch path\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * Get the branch paths that a node id is in\n   * @param branches an array of branch objects\n   * @param nodeId the node id to check\n   * @return an array of the branch paths that the node id is in\n   */\n  getBranchPathsByNodeId(branches, nodeId) {\n    var branchPathsIn = [];\n\n    if (branches != null && nodeId != null) {\n\n      // loop through all the branches\n      for (var b = 0; b < branches.length; b++) {\n\n        // get a branch\n        var branch = branches[b];\n\n        if (branch != null) {\n\n          // get the branch paths\n          var branchPaths = branch.branchPaths;\n\n          if (branchPaths != null) {\n\n            // loop through all the branch paths\n            for (var bp = 0; bp < branchPaths.length; bp++) {\n\n              // get a branch path\n              var branchPath = branchPaths[bp];\n\n              if (branchPath != null) {\n\n                // get the index of the node id in the branch path\n                var index = branchPath.indexOf(nodeId);\n\n                if (index != -1) {\n                  /*\n                                     * the node is in this branch path so we will\n                                     * add the branch path to our array\n                                     */\n                  branchPathsIn.push(branchPath);\n\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return branchPathsIn;\n  }\n\n  /**\n   * Get the component by node id and component id\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns the component or null if the nodeId or componentId are null or does not exist in the project.\n   */\n  getComponentByNodeIdAndComponentId(nodeId, componentId) {\n    var component = null;\n\n    if (nodeId != null && componentId != null) {\n\n      var components = this.getComponentsByNodeId(nodeId);\n\n      // loop through all the components\n      for (var c = 0; c < components.length; c++) {\n        var tempComponent = components[c];\n\n        if (tempComponent != null) {\n          var tempComponentId = tempComponent.id;\n\n          if (componentId === tempComponentId) {\n            // we have found the component we want\n            component = tempComponent;\n            break;\n          }\n        }\n      }\n\n    }\n\n    return component;\n  };\n\n  /**\n   * Returns the position of the component in the node by node id and component id, 0-indexed.\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns the component's position or -1 if nodeId or componentId are null or doesn't exist in the project.\n   */\n  getComponentPositionByNodeIdAndComponentId(nodeId, componentId) {\n    var componentPosition = -1;\n\n    if (nodeId != null && componentId != null) {\n\n      var components = this.getComponentsByNodeId(nodeId);\n\n      // loop through all the components\n      for (var c = 0; c < components.length; c++) {\n        var tempComponent = components[c];\n\n        if (tempComponent != null) {\n          var tempComponentId = tempComponent.id;\n\n          if (componentId === tempComponentId) {\n            // we have found the component we want\n            componentPosition = c;\n            break;\n          }\n        }\n      }\n    }\n\n    return componentPosition;\n  };\n\n  /**\n   * Get the components in a node\n   * @param nodeId the node id\n   * @returns an array of components or empty array if nodeId is null or doesn't exist in the project.\n   * if the node exists but doesn't have any components, returns an empty array.\n   */\n  getComponentsByNodeId(nodeId) {\n    var components = [];\n\n    if (nodeId != null) {\n\n      // get the node\n      var node = this.getNodeById(nodeId);\n\n      if (node != null) {\n\n        // get the components\n        if (node.components != null) {\n          components = node.components;\n        }\n      }\n    }\n\n    return components;\n  };\n\n  getNodeContentByNodeId(nodeId) {\n    var nodeContent = null;\n\n    if (nodeId != null) {\n      var node = this.getNodeById(nodeId);\n\n      if (node != null) {\n        nodeContent = node;\n      }\n    }\n\n    return nodeContent;\n  };\n\n  /**\n   * Replace a component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @param component the new component\n   */\n  replaceComponent(nodeId, componentId, component) {\n\n    if (nodeId != null && componentId != null && component != null) {\n\n      // get all the components for the node\n      var components = this.getComponentsByNodeId(nodeId);\n\n      if (components != null) {\n\n        // loop through all the components\n        for (var c = 0; c < components.length; c++) {\n          var tempComponent = components[c];\n\n          if (tempComponent != null) {\n\n            if (tempComponent.id === componentId) {\n              // the component id matches the one we want so we will replace it\n              components[c] = component;\n              break;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * Create a new group\n   * @param title the title of the group\n   * @returns the group object\n   */\n  createGroup(title) {\n\n    // get the next available group id\n    var newGroupId = this.getNextAvailableGroupId();\n\n    // create the group object\n    var newGroup = {};\n    newGroup.id = newGroupId;\n    newGroup.type = 'group';\n    newGroup.title = title;\n    newGroup.startId = '';\n    newGroup.ids = [];\n\n    return newGroup;\n  };\n\n  /**\n   * Create a new node\n   * @param title the title of the node\n   * @returns the node object\n   */\n  createNode(title) {\n\n    // get the next available node id\n    var newNodeId = this.getNextAvailableNodeId();\n\n    // create the node object\n    var newNode = {};\n    newNode.id = newNodeId;\n    newNode.title = title;\n    newNode.type = 'node';\n    newNode.constraints = [];\n    newNode.transitionLogic = {};\n    newNode.transitionLogic.transitions = [];\n\n    newNode.showSaveButton = false;\n    newNode.showSubmitButton = false;\n    newNode.components = [];\n\n    return newNode;\n  };\n\n  /**\n   * Create a node inside the group\n   * @param node the new node\n   * @param nodeId the node id of the group to create the node in\n   */\n  createNodeInside(node, nodeId) {\n\n    if (nodeId == 'inactiveNodes') {\n      // add the node to the inactive nodes\n\n      // add the node to the inactive nodes\n      this.addInactiveNode(node);\n\n      // add the node to our mapping of node id to node\n      this.setIdToNode(node.id, node);\n      this.setIdToElement(node.id, node);\n    } else if (nodeId == 'inactiveGroups') {\n      // add the node to the inactive groups\n      this.addInactiveNode(node);\n\n      // add the node to our mapping of node id to node\n      this.setIdToNode(node.id, node);\n      this.setIdToElement(node.id, node);\n    } else {\n      // add the node to the active nodes\n\n      // add the node to the project\n      this.addNode(node);\n\n      // add the node to our mapping of node id to node\n      this.setIdToNode(node.id, node);\n\n      // create the transitions for the node\n      this.insertNodeInsideInTransitions(node.id, nodeId);\n\n      // add the node to the group\n      this.insertNodeInsideInGroups(node.id, nodeId);\n    }\n  }\n\n  /**\n   * Create a node after the given node id\n   * @param node the new node\n   * @param nodeId the node to add after\n   */\n  createNodeAfter(node, nodeId) {\n\n    if (this.isInactive(nodeId)) {\n      // we are adding the node after a node that is inactive\n\n      // add the node to the inactive nodes\n      this.addInactiveNode(node, nodeId);\n\n      this.setIdToNode(node.id, node);\n      this.setIdToElement(node.id, node);\n    } else {\n      // we are adding the node after a node that is active\n\n      // add the node to the project\n      this.addNode(node);\n\n      // add the node to our mapping of node id to node\n      this.setIdToNode(node.id, node);\n\n      // insert the new node id into the array of children ids\n      this.insertNodeAfterInGroups(node.id, nodeId);\n\n      // create the transition to the node\n      this.insertNodeAfterInTransitions(node, nodeId);\n    }\n\n    if (this.isGroupNode(node.id)) {\n      /*\n             * we are creating a group node so we will update/create the\n             * transitions that traverse from the previous group to this group\n             */\n\n      var oldToGroupIds = [];\n\n      // get the transitions that come out of the previous group\n      var transitionsFromGroup = this.getTransitionsByFromNodeId(nodeId);\n\n      if (transitionsFromGroup != null) {\n\n        /*\n                 * loop through all the transitions that come out of the previous group\n                 * and get the node ids that the group transitions to\n                 */\n        for (var t = 0; t < transitionsFromGroup.length; t++) {\n          var transitionFromGroup = transitionsFromGroup[t];\n\n          if (transitionFromGroup != null) {\n            var toNodeId = transitionFromGroup.to;\n\n            if (toNodeId != null) {\n              oldToGroupIds.push(toNodeId);\n            }\n          }\n        }\n      }\n\n      var fromGroupId = nodeId;\n      var oldToGroupIds = oldToGroupIds;\n      var newToGroupId = node.id;\n\n      /*\n             * make the transitions point to the new group and make the new\n             * group transition to the old group\n             */\n      this.updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId);\n    }\n  }\n\n  /**\n   * Insert the node after the given node id in the group's\n   * array of children ids\n   * @param nodeIdToInsert the node id we want to insert\n   * @param nodeIdToInsertAfter the node id we want to insert after\n   */\n  insertNodeAfterInGroups(nodeIdToInsert, nodeIdToInsertAfter) {\n    var groupNodes = this.getGroupNodes();\n\n    if (groupNodes != null) {\n\n      // loop through the groups\n      for (var g = 0; g < groupNodes.length; g++) {\n        var group = groupNodes[g];\n\n        if (group != null) {\n          var ids = group.ids;\n\n          if (ids != null) {\n\n            // loop through the children ids\n            for (var i = 0; i < ids.length; i++) {\n              var id = ids[i];\n\n              if (nodeIdToInsertAfter === id) {\n                // we have found the node id we want to insert after\n\n                // insert the new node id\n                ids.splice(i + 1, 0, nodeIdToInsert);\n                return;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Update the transitions to handle inserting a node after another node\n   * @param node the node to insert\n   * @param nodeId the node id to insert after\n   */\n  insertNodeAfterInTransitions(node, nodeId) {\n\n    // get the node that will end up before\n    var previousNode = this.getNodeById(nodeId);\n\n    if (previousNode != null) {\n\n      if (previousNode.transitionLogic == null) {\n        previousNode.transitionLogic = {};\n        previousNode.transitionLogic.transitions = [];\n      }\n\n      if (node.transitionLogic == null) {\n        node.transitionLogic = {};\n      }\n\n      if (node.transitionLogic.transitions == null) {\n        node.transitionLogic.transitions = [];\n      }\n\n      if (this.isGroupNode(node.id)) {\n        /*\n                 * the node we are inserting is a group so we will update\n                 * the transitions of its children so that they transition\n                 * to the correct node\n                 */\n        this.updateChildrenTransitionsForMovingGroup(node, nodeId);\n      }\n\n      var previousNodeTransitionLogic = previousNode.transitionLogic;\n\n      if (previousNodeTransitionLogic != null) {\n\n        // get the transitions from the before node\n        var transitions = previousNodeTransitionLogic.transitions;\n\n        if (transitions != null) {\n\n          // make a copy of the transitions\n          var transitionsJSONString = angular.toJson(transitions);\n          var transitionsCopy = angular.fromJson(transitionsJSONString);\n\n          // set the transitions from the before node into the inserted node\n          node.transitionLogic.transitions = transitionsCopy;\n        }\n      }\n\n      if (node.transitionLogic.transitions.length == 0) {\n        /*\n                 * The node does not have any transitions so we will look for\n                 * a transition on the parent group. If the parent has a\n                 * transition we will use it for the node.\n                 */\n\n        // get the parent group\n        var parentGroupId = this.getParentGroupId(nodeId);\n\n        if (parentGroupId != null &&\n          parentGroupId != '' &&\n          parentGroupId != 'group0') {\n\n          // get the parent transitions\n          var parentTransitions = this.getTransitionsByFromNodeId(parentGroupId);\n\n          if (parentTransitions != null) {\n\n            // loop through all the parent transitions\n            for (var p = 0; p < parentTransitions.length; p++) {\n              var parentTransition = parentTransitions[p];\n\n              var newTransition = {};\n\n              if (parentTransition != null) {\n                var toNodeId = parentTransition.to;\n\n                if (this.isGroupNode(toNodeId)) {\n                  // the transition is to a group\n\n                  // get the start id of the group\n                  var startId = this.getGroupStartId(toNodeId);\n\n                  if (startId == null || startId == '') {\n                    // there is no start id so we will just use the group id\n                    newTransition.to = toNodeId;\n                  } else {\n                    // there is a start id so we will use it as the to node\n                    newTransition.to = startId;\n                  }\n                } else {\n                  // the tranisition is to a step\n                  newTransition.to = toNodeId;\n                }\n              }\n\n              // add the new transition to the node\n              node.transitionLogic.transitions.push(newTransition);\n            }\n          }\n        }\n      }\n\n      var newNodeId = node.id;\n\n      // TODO handle branching case\n\n      // remove the transitions from the before node\n      previousNode.transitionLogic.transitions = [];\n\n      var transitionObject = {};\n      transitionObject.to = newNodeId;\n\n      // make the before node point to the new node\n      previousNode.transitionLogic.transitions.push(transitionObject);\n\n      // remove the branch path taken constraints from the node we are moving\n      this.removeBranchPathTakenNodeConstraints(node.id);\n\n      // get the branch path taken constraints from the previous node\n      var branchPathTakenConstraints = this.getBranchPathTakenConstraintsByNodeId(nodeId);\n\n      /*\n             * if the previous node was in a branch path, we will also put the\n             * inserted node into the branch path\n             */\n      if (branchPathTakenConstraints != null && branchPathTakenConstraints.length > 0) {\n\n        if (node.constraints == null) {\n          node.constraints = [];\n        }\n\n        // loop through all the branch path taken constraints\n        for (var c = 0; c < branchPathTakenConstraints.length; c++) {\n\n          // get a branch path taken constraint\n          var branchPathTakenConstraint = branchPathTakenConstraints[c];\n\n          if (branchPathTakenConstraint != null) {\n\n            // create a new constraint with the same branch path taken parameters\n            var newConstraint = {};\n            newConstraint.id = this.getNextAvailableConstraintIdForNodeId(node.id);\n            newConstraint.action = branchPathTakenConstraint.action;\n            newConstraint.targetId = node.id;\n            newConstraint.removalCriteria = this.UtilService.makeCopyOfJSONObject(branchPathTakenConstraint.removalCriteria);\n\n            // add the constraint to the node\n            node.constraints.push(newConstraint);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Insert a node into a group\n   * @param nodeIdToInsert the node id to insert\n   * @param nodeIdToInsertInside the node id of the group we will insert into\n   */\n  insertNodeInsideInGroups(nodeIdToInsert, nodeIdToInsertInside) {\n\n    // get the group we will insert into\n    var group = this.getNodeById(nodeIdToInsertInside);\n\n    if (group != null) {\n      var ids = group.ids;\n\n      if (ids != null) {\n\n        // insert the node node id into the beginning of the child ids\n        ids.splice(0, 0, nodeIdToInsert);\n\n        // set the inserted node id as the start id\n        group.startId = nodeIdToInsert;\n      }\n    }\n  }\n\n  /**\n   * Update the transitions to handle inserting a node into a group\n   * @param nodeIdToInsert node id that we will insert\n   * @param nodeIdToInsertInside the node id of the group we are inserting into\n   */\n  insertNodeInsideInTransitions(nodeIdToInsert, nodeIdToInsertInside) {\n\n    // get the node we are inserting\n    var nodeToInsert = this.getNodeById(nodeIdToInsert);\n\n    if (nodeToInsert != null &&\n      nodeToInsert.transitionLogic != null &&\n      nodeToInsert.transitionLogic.transitions != null) {\n\n      // clear out any existing transitions\n      nodeToInsert.transitionLogic.transitions = [];\n\n      /*\n             * remove the branch path taken constraints from the node we are\n             * inserting\n             */\n      this.removeBranchPathTakenNodeConstraints(nodeIdToInsert);\n    }\n\n    // get the group we are inserting into\n    var group = this.getNodeById(nodeIdToInsertInside);\n\n    if (this.isGroupNode(nodeIdToInsert)) {\n      /*\n             * the node we are inserting is a group so we will update\n             * the transitions of its children so that they transition\n             * to the correct node\n             */\n      this.updateChildrenTransitionsForMovingGroup(nodeToInsert, null);\n    }\n\n    /*\n         * since we are inserting a node into a group, the node will become\n         * the first node in the group. this means we need to update any nodes\n         * that point to the old start id and make them point to the node\n         * we are inserting.\n         */\n    if (nodeToInsert != null && group != null) {\n\n      // get the start node\n      var startId = group.startId;\n\n      // get transitions that point to the start node\n      var previousNodes = this.getNodesByToNodeId(startId);\n\n      if (previousNodes == null || previousNodes.length == 0) {\n        // there are no transitions to the start node\n\n        // find all the groups that point to this group\n        var previousGroups = this.getGroupNodesByToNodeId(nodeIdToInsertInside);\n\n        // loop through all the groups that point to this group\n        for (var g = 0; g < previousGroups.length; g++) {\n          var previousGroup = previousGroups[g];\n\n          if (previousGroup != null) {\n            // get the nodes that do not have a transition in the previous group\n            var lastNodesInGroup = this.getLastNodesInGroup(previousGroup.id);\n\n            for (var n = 0; n < lastNodesInGroup.length; n++) {\n              // get a node that does not have a transition\n              var node = lastNodesInGroup[n];\n\n              // add a transition from the node to the node we are inserting\n              this.addToTransition(node, nodeIdToInsert);\n            }\n          }\n        }\n      } else {\n        // there are transitions to the start node\n\n        for (var p = 0; p < previousNodes.length; p++) {\n          var previousNode = previousNodes[p];\n\n          if (previousNode != null && previousNode.id != 'group0') {\n            // change the transition to point to the node we are inserting\n            this.updateToTransition(previousNode, startId, nodeIdToInsert);\n          }\n        }\n      }\n\n      /*\n             * update all the transitions that point to the group and change\n             * them to point to the new start id\n             */\n      var nodesThatTransitionToGroup = this.getNodesByToNodeId(nodeIdToInsertInside);\n\n      if (nodesThatTransitionToGroup != null) {\n        for (var n = 0; n < nodesThatTransitionToGroup.length; n++) {\n          var nodeThatTransitionsToGroup = nodesThatTransitionToGroup[n];\n\n          if (!this.isGroupNode(nodeThatTransitionsToGroup.id)) {\n            this.updateToTransition(nodeThatTransitionsToGroup, nodeIdToInsertInside, nodeIdToInsert);\n          }\n        }\n      }\n\n      /*\n             * create a transition from the node we are inserting to the node that\n             * was previously the start node\n             */\n      if (startId != null && startId != '') {\n        // there is a start id\n\n        var startNode = this.getNodeById(startId);\n\n        if (startNode != null) {\n          // the group has a start node which will become the transition to node\n\n          if (nodeToInsert.transitionLogic == null) {\n            nodeToInsert.transitionLogic = {};\n          }\n\n          if (nodeToInsert.transitionLogic.transitions == null) {\n            nodeToInsert.transitionLogic.transitions = [];\n          }\n\n          /*\n                     * make the inserted node transition to the previous start node\n                     */\n          var transitionObject = {};\n          transitionObject.to = startId;\n          nodeToInsert.transitionLogic.transitions.push(transitionObject);\n        }\n      }\n\n      //check if the node we inserted has any transitions now\n      var transitions = this.getTransitionsByFromNodeId(nodeIdToInsert);\n\n      if (transitions == null || transitions.length == 0) {\n        /*\n                 * the node doesn't have any transitions so we will see if\n                 * the parent group transitions to anything and use that\n                 * transition\n                 */\n\n        // get the transitions from the parent\n        var parentTransitions = this.getTransitionsByFromNodeId(nodeIdToInsertInside);\n\n        if (parentTransitions != null) {\n\n          // loop through all the parent transitions\n          for (var t = 0; t < parentTransitions.length; t++) {\n            var parentTransition = parentTransitions[t];\n\n            if (parentTransition != null) {\n              var toNodeId = parentTransition.to;\n\n              if (this.isGroupNode(toNodeId)) {\n                // the to node is a group\n\n                // get the to group\n                var nextGroup = this.getNodeById(toNodeId);\n\n                if (nextGroup != null) {\n\n                  // get the start id of the to group\n                  var startId = nextGroup.startId;\n\n                  if (startId == null || startId == '') {\n                    // there is no start id so we will just transition to the group\n                    this.addToTransition(nodeToInsert, toNodeId);\n                  } else {\n                    // there is a start id so we will transition to that\n                    this.addToTransition(nodeToInsert, startId);\n                  }\n                }\n              } else {\n                // the to node is not a group\n\n                /*\n                                 * we will add a transition from the node we are inserting to\n                                 * to that node\n                                 */\n                this.addToTransition(nodeToInsert, toNodeId);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Add a transition to a node\n   * @param node the node we are adding a transition to\n   * @param toNodeId the node id we going to transition to\n   * @param criteria (optional) a criteria object specifying\n   * what needs to be satisfied in order to use this transition\n   */\n  addToTransition(node, toNodeId, criteria) {\n    if (node != null) {\n      if (node.transitionLogic == null) {\n        node.transitionLogic = {};\n      }\n\n      if (node.transitionLogic.transitions == null) {\n        node.transitionLogic.transitions = [];\n      }\n\n      var transition = {};\n\n      // set the to node id\n      transition.to = toNodeId;\n\n      if (criteria != null) {\n        // set the criteria\n        transition.criteria = criteria;\n      }\n\n      // add the transition to the node's transitions\n      node.transitionLogic.transitions.push(transition);\n    }\n  }\n\n  /**\n   * Update the to value of aa transition\n   * @param node the node to update\n   * @param oldToNodeId the previous to node id\n   * @param newToNodeId the new to node id\n   */\n  updateToTransition(node, oldToNodeId, newToNodeId) {\n    if (node != null) {\n      if (node.transitionLogic == null) {\n        node.transitionLogic = {};\n      }\n\n      if (node.transitionLogic.transitions == null) {\n        node.transitionLogic.transitions = [];\n      }\n\n      var transitions = node.transitionLogic.transitions;\n\n      // loop through all the transitions\n      for (var t = 0; t < transitions.length; t++) {\n        var transition = transitions[t];\n\n        if (transition != null) {\n          var toNodeId = transition.to;\n\n          if (oldToNodeId === toNodeId) {\n            // we have found the transition we want to update\n\n            // update the to node id\n            transition.to = newToNodeId;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the nodes in a group that do not have transitions\n   * @param groupId the group id\n   * @returns the nodes in the group that do not have transitions\n   */\n  getLastNodesInGroup(groupId) {\n    var lastNodes = [];\n\n    if (groupId != null) {\n      var group = this.getNodeById(groupId);\n\n      if (group != null) {\n        var childIds = group.ids;\n\n        if (childIds != null) {\n\n          // loop through all the child ids\n          for (var c = 0; c < childIds.length; c++) {\n            var childId = childIds[c];\n\n            if (childId != null) {\n              var child = this.getNodeById(childId);\n\n              if (child != null) {\n                var transitionLogic = child.transitionLogic;\n\n                if (transitionLogic != null) {\n\n                  // get the transitions\n                  var transitions = transitionLogic.transitions;\n\n                  if (transitions == null || transitions.length == 0) {\n                    // this child does not have any transitions\n                    lastNodes.push(child);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return lastNodes;\n  }\n\n  /**\n   * Get the next available group id\n   * @returns the next available group id\n   */\n  getNextAvailableGroupId() {\n\n    // get all the group ids\n    var groupIds = this.getGroupIds();\n\n    var largestGroupIdNumber = null;\n\n    // loop through all the existing group ids\n    for (var g = 0; g < groupIds.length; g++) {\n      var groupId = groupIds[g];\n\n      // get the number from the group id e.g. the number of 'group2' would be 2\n      var groupIdNumber = groupId.replace('group', '');\n\n      // make sure the number is an actual number\n      if (!isNaN(groupIdNumber)) {\n\n        groupIdNumber = parseInt(groupIdNumber);\n\n        // update the largest group id number if necessary\n        if (largestGroupIdNumber == null) {\n          largestGroupIdNumber = groupIdNumber;\n        } else if (groupIdNumber > largestGroupIdNumber) {\n          largestGroupIdNumber = groupIdNumber;\n        }\n      }\n    }\n\n    // create the next available group id\n    var nextAvailableGroupId = 'group' + (largestGroupIdNumber + 1);\n\n    return nextAvailableGroupId;\n  }\n\n  /**\n   * Get all the group ids\n   * @returns an array with all the group ids\n   */\n  getGroupIds() {\n    var groupIds = [];\n\n    // Get the active group node ids.\n    var groupNodes = this.groupNodes;\n    for (var g = 0; g < groupNodes.length; g++) {\n      var group = groupNodes[g];\n      if (group != null) {\n        var groupId = group.id;\n        if (groupId != null) {\n          groupIds.push(groupId);\n        }\n      }\n    }\n\n    // Get the inactive group node ids.\n    var inactiveGroupNodes = this.getInactiveGroupNodes();\n    for (var inactiveGroup of inactiveGroupNodes) {\n      if (inactiveGroup != null) {\n        var inactiveGroupId = inactiveGroup.id;\n        if (inactiveGroupId != null) {\n          groupIds.push(inactiveGroupId);\n        }\n      }\n    }\n\n    return groupIds;\n  }\n\n  /**\n   * Get the next available node id\n   * @param nodeIdsToSkip (optional) An array of additional node ids to not\n   * use. This parameter is used in cases where we are creating multiple new\n   * nodes at once.\n   * Example\n   * We ask for two new node ids by calling getNextAvailableNodeId() twice.\n   * The first time it returns \"node10\".\n   * If we ask the second time without actually creating and adding node10,\n   * it will return \"node10\" again. If we provide \"node10\" in the\n   * nodeIdsToSkip, then getNextAvailableNodeId() will properly return to us\n   * \"node11\".\n   * @returns the next available node id\n   */\n  getNextAvailableNodeId(nodeIdsToSkip) {\n\n    // get all the node ids\n    var nodeIds = this.getNodeIds();\n\n    var largestNodeIdNumber = null;\n\n    // loop through all the existing node ids\n    for (var n = 0; n < nodeIds.length; n++) {\n      var nodeId = nodeIds[n];\n\n      // get the number from the node id e.g. the number of 'node2' would be 2\n      var nodeIdNumber = nodeId.replace('node', '');\n\n      // make sure the number is an actual number\n      if (!isNaN(nodeIdNumber)) {\n        nodeIdNumber = parseInt(nodeIdNumber);\n\n        // update the largest node id number if necessary\n        if (largestNodeIdNumber == null) {\n          largestNodeIdNumber = nodeIdNumber;\n        } else if (nodeIdNumber > largestNodeIdNumber) {\n          largestNodeIdNumber = nodeIdNumber;\n        }\n      }\n    }\n\n    // get all the inactive node ids\n    var inactiveNodeIds = this.getInactiveNodeIds();\n\n    for (var i = 0; i < inactiveNodeIds.length; i++) {\n      var inactiveNodeId = inactiveNodeIds[i];\n\n      // get the number from the node id e.g. the number of 'node2' would be 2\n      var nodeIdNumber = inactiveNodeId.replace('node', '');\n\n      // make sure the number is an actual number\n      if (!isNaN(nodeIdNumber)) {\n        nodeIdNumber = parseInt(nodeIdNumber);\n\n        // update the largest node id number if necessary\n        if (largestNodeIdNumber == null) {\n          largestNodeIdNumber = nodeIdNumber;\n        } else if (nodeIdNumber > largestNodeIdNumber) {\n          largestNodeIdNumber = nodeIdNumber;\n        }\n      }\n    }\n\n    if (nodeIdsToSkip != null) {\n      // there are node ids to skip\n\n      // loop through all the node ids to skip\n      for (var s = 0; s < nodeIdsToSkip.length; s++) {\n        var nodeIdToSkip = nodeIdsToSkip[s];\n\n        // get the number from the node id e.g. the number of 'node2' would be 2\n        var nodeIdNumber = nodeIdToSkip.replace('node', '');\n\n        // make sure the number is an actual number\n        if (!isNaN(nodeIdNumber)) {\n          nodeIdNumber = parseInt(nodeIdNumber);\n\n          // update the largest node id number if necessary\n          if (largestNodeIdNumber == null) {\n            largestNodeIdNumber = nodeIdNumber;\n          } else if (nodeIdNumber > largestNodeIdNumber) {\n            largestNodeIdNumber = nodeIdNumber;\n          }\n        }\n      }\n    }\n\n    // create the next available node id\n    var nextAvailableNodeId = 'node' + (largestNodeIdNumber + 1);\n\n    return nextAvailableNodeId;\n  }\n\n  /**\n   * Get all the node ids from steps (not groups)\n   * @returns an array with all the node ids\n   */\n  getNodeIds() {\n\n    var nodeIds = [];\n\n    var nodes = this.applicationNodes;\n\n    // loop through all the nodes\n    for (var n = 0; n < nodes.length; n++) {\n      var node = nodes[n];\n\n      if (node != null) {\n        var nodeId = node.id;\n\n        if (nodeId != null) {\n          nodeIds.push(nodeId);\n        }\n      }\n    }\n\n    return nodeIds;\n  }\n\n  /**\n   * Get all the node ids from inactive steps\n   * @returns an array with all the inactive node ids\n   */\n  getInactiveNodeIds() {\n\n    var nodeIds = [];\n\n    var inactiveNodes = this.project.inactiveNodes;\n\n    if (inactiveNodes != null) {\n\n      // loop through all the inactive nodes\n      for (var n = 0; n < inactiveNodes.length; n++) {\n        var inactiveNode = inactiveNodes[n];\n\n        if (inactiveNode != null) {\n          var nodeId = inactiveNode.id;\n\n          if (nodeId != null) {\n            nodeIds.push(nodeId);\n          }\n        }\n      }\n    }\n\n    return nodeIds;\n  }\n\n  /**\n   * Move nodes inside a group node\n   * @param nodeIds the node ids to move\n   * @param nodeId the node id of the group we are moving the nodes inside\n   */\n  moveNodesInside(nodeIds, nodeId) {\n\n    var movedNodes = [];\n\n    // loop through all the nodes we are moving\n    for (var n = 0; n < nodeIds.length; n++) {\n\n      // get the node we are moving\n      var tempNodeId = nodeIds[n];\n      var tempNode = this.getNodeById(tempNodeId);\n      movedNodes.push(tempNode);\n\n      var movingNodeIsActive = this.isActive(tempNodeId);\n      var stationaryNodeIsActive = this.isActive(nodeId);\n\n      if (movingNodeIsActive && stationaryNodeIsActive) {\n        // we are moving from active to active\n\n        // remove the transitions\n        this.removeNodeIdFromTransitions(tempNodeId);\n\n        // remove the node from the group\n        this.removeNodeIdFromGroups(tempNodeId);\n\n        if (n == 0) {\n          /*\n                     * this is the first node we are moving so we will insert it\n                     * into the beginning of the group\n                     */\n          this.insertNodeInsideInTransitions(tempNodeId, nodeId);\n          this.insertNodeInsideInGroups(tempNodeId, nodeId);\n        } else {\n          /*\n                     * this is not the first node we are moving so we will insert\n                     * it after the node we previously inserted\n                     */\n          this.insertNodeAfterInTransitions(tempNode, nodeId);\n          this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        }\n      } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n        // we are moving from active to inactive\n\n        // remove the transitions\n        this.removeNodeIdFromTransitions(tempNodeId);\n\n        // remove the node from the group\n        this.removeNodeIdFromGroups(tempNodeId);\n\n        // move the node to the inactive array\n        this.moveToInactive(tempNode, nodeId);\n      } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n        // we are moving from inactive to active\n\n        this.moveToActive(tempNode);\n\n        if (n == 0) {\n          /*\n                     * this is the first node we are moving so we will insert it\n                     * into the beginning of the group\n                     */\n          this.insertNodeInsideInTransitions(tempNodeId, nodeId);\n          this.insertNodeInsideInGroups(tempNodeId, nodeId);\n        } else {\n          /*\n                     * this is not the first node we are moving so we will insert\n                     * it after the node we previously inserted\n                     */\n          this.insertNodeAfterInTransitions(tempNode, nodeId);\n          this.insertNodeAfterInGroups(tempNodeId, nodeId);\n        }\n      } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n        // we are moving from inactive to inactive\n\n        // move the node within the inactive nodes\n        this.moveInactiveNode(tempNode, nodeId);\n      }\n\n      /*\n             * remember the node id so we can put the next node (if any)\n             * after this one\n             */\n      nodeId = tempNode.id;\n    }\n\n    return movedNodes;\n  }\n\n  /**\n   * Move nodes after a certain node id\n   * @param nodeIds the node ids to move\n   * @param nodeId the node id we will put the moved nodes after\n   */\n  moveNodesAfter(nodeIds, nodeId) {\n\n    var movedNodes = [];\n\n    // loop through all the nodes we are moving\n    for (var n = 0; n < nodeIds.length; n++) {\n\n      // get the node we are moving\n      var tempNodeId = nodeIds[n];\n      var node = this.getNodeById(tempNodeId);\n      movedNodes.push(node);\n\n      var movingNodeIsActive = this.isActive(tempNodeId);\n      var stationaryNodeIsActive = this.isActive(nodeId);\n\n      if (movingNodeIsActive && stationaryNodeIsActive) {\n        // we are moving from active to active\n\n        // remove the transitions\n        this.removeNodeIdFromTransitions(tempNodeId);\n\n        // remove the node from the groups\n        this.removeNodeIdFromGroups(tempNodeId);\n\n        // insert the node into the parent group\n        this.insertNodeAfterInGroups(tempNodeId, nodeId);\n\n        // create the transition\n        this.insertNodeAfterInTransitions(node, nodeId);\n      } else if (movingNodeIsActive && !stationaryNodeIsActive) {\n        // we are moving from active to inactive\n\n        // remove the transitions\n        this.removeNodeIdFromTransitions(tempNodeId);\n\n        // remove the node from the groups\n        this.removeNodeIdFromGroups(tempNodeId);\n\n        // move the node to the inactive array\n        this.moveToInactive(node, nodeId);\n      } else if (!movingNodeIsActive && stationaryNodeIsActive) {\n        // we are moving from inactive to active\n\n        // move the node to the active nodes array\n        this.moveToActive(node);\n\n        // insert the node into the parent group\n        this.insertNodeAfterInGroups(tempNodeId, nodeId);\n\n        // create the transition\n        this.insertNodeAfterInTransitions(node, nodeId);\n      } else if (!movingNodeIsActive && !stationaryNodeIsActive) {\n        // we are moving from inactive to inactive\n\n        // move the node within the inactive nodes\n        this.moveInactiveNode(node, nodeId);\n      }\n\n      // remember the node id so we can put the next node (if any) after this one\n      nodeId = node.id;\n    }\n\n    return movedNodes;\n  }\n\n  /**\n   * Copy nodes and put them after a certain node id\n   * @param nodeIds the node ids to copy\n   * @param nodeId the node id we will put the copied nodes after\n   */\n  copyNodesInside(nodeIds, nodeId) {\n\n    var newNodes = [];\n\n    // loop through all the nodes we are copying\n    for (var n = 0; n < nodeIds.length; n++) {\n\n      // get the node we are copying\n      var nodeIdToCopy = nodeIds[n];\n\n      // create a copy of the node\n      var newNode = this.copyNode(nodeIdToCopy);\n      var newNodeId = newNode.id;\n\n      if (n == 0) {\n        // this is the first node we are copying so we will insert it\n        // into the beginning of the group\n        this.createNodeInside(newNode, nodeId);\n      } else {\n        // this is not the first node we are copying so we will insert\n        // it after the node we previously inserted\n        this.createNodeAfter(newNode, nodeId);\n      }\n\n      // remember the node id so we can put the next node (if any) after this one\n      nodeId = newNodeId;\n      this.parseProject();  // refresh project and update references because a new node have been added.\n\n      newNodes.push(newNode);\n    }\n\n    return newNodes;\n  }\n\n  /**\n   * Copy nodes and put them after a certain node id\n   * @param nodeIds the node ids to copy\n   * @param nodeId the node id we will put the copied nodes after\n   */\n  copyNodesAfter(nodeIds, nodeId) {\n\n    var newNodes = [];\n\n    // loop through all the nodes we are copying\n    for (var n = 0; n < nodeIds.length; n++) {\n\n      // get the node we are copying\n      var nodeIdToCopy = nodeIds[n];\n\n      // create a copy of the node\n      var newNode = this.copyNode(nodeIdToCopy);\n      var newNodeId = newNode.id;\n\n      this.createNodeAfter(newNode, nodeId);\n\n      // remember the node id so we can put the next node (if any) after this one\n      nodeId = newNodeId;\n      this.parseProject();  // refresh project and update references because a new node have been added.\n\n      newNodes.push(newNode);\n    }\n\n    return newNodes;\n  }\n\n  /**\n   * Copy the node with the specified nodeId\n   * @param nodeId the node id to copy\n   * @return copied node\n   */\n  copyNode(nodeId) {\n    var node = this.getNodeById(nodeId);\n\n    // make a copy of the node\n    var nodeCopy = this.UtilService.makeCopyOfJSONObject(node);\n    nodeCopy.id = this.getNextAvailableNodeId();\n    nodeCopy.transitionLogic = {};  // clear transition logic\n    nodeCopy.constraints = [];  // clear constraints\n\n    // used to hold the new component ids\n    var newComponentIds = [];\n\n    // loop through all the components and give them a new component id\n    for (var c = 0; c < nodeCopy.components.length; c++) {\n\n      // get a component\n      var component = nodeCopy.components[c];\n\n      // give the component a new id\n      var newComponentId = this.getUnusedComponentId(newComponentIds);\n\n      // remember the new component id\n      newComponentIds.push(newComponentId);\n\n      // set the new component id into the component\n      component.id = newComponentId;\n    }\n    return nodeCopy;\n  }\n\n  /**\n   * Delete a node\n   * @param nodeId the node id\n   */\n  deleteNode(nodeId) {\n\n    /*\n         * flag for whether we are deleting the project start node id.\n         * if we are deleting the project start node id, we will need\n         * to change it to the next logical node id that will be used\n         * as the project start.\n         */\n    var removingProjectStartNodeId = false;\n\n    if (this.isGroupNode(nodeId)) {\n      // the node is a group node so we will also remove all of its children\n      var group = this.getNodeById(nodeId);\n\n      // TODO check if the child is in another group, if so do not remove\n\n      if (group != null) {\n        var ids = group.ids;\n\n        // loop through all the children\n        for (var i = 0; i < ids.length; i++) {\n          var id = ids[i];\n\n          // remove the child\n          this.removeNodeIdFromTransitions(id);\n          this.removeNodeIdFromGroups(id);\n          this.removeNodeIdFromNodes(id);\n\n          if (this.project.startNodeId == id) {\n            removingProjectStartNodeId = true;\n          }\n\n          /*\n                     * move the counter back because we have removed a child\n                     * from the parent group's array of child ids so all of\n                     * the child ids were shifted back one and the next child\n                     * we want will be at i--\n                     */\n          i--;\n        }\n      }\n    }\n\n    var parentGroup = this.getParentGroup(nodeId);\n\n    // check if we need to update the start id of the parent group\n    if (parentGroup != null) {\n\n      /*\n             * the node is the start node of the parent group so we need\n             * to update the start id of the parent group to point to\n             * the next node\n             */\n      if (nodeId === parentGroup.startId) {\n\n        var hasSetNewStartId = false;\n\n        // get the node\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n          var transitionLogic = node.transitionLogic;\n\n          if (transitionLogic != null) {\n            var transitions = transitionLogic.transitions;\n\n            if (transitions != null && transitions.length > 0) {\n              var transition = transitions[0];\n\n              if (transition != null) {\n                var toNodeId = transition.to;\n\n                if (toNodeId != null) {\n\n                  // check that the to node is in the same group\n                  if (this.isNodeInGroup(toNodeId, parentGroup.id)) {\n\n                    // update the parent group start id\n                    parentGroup.startId = toNodeId;\n                    hasSetNewStartId = true;\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (!hasSetNewStartId) {\n          parentGroup.startId = '';\n        }\n      }\n    }\n\n    if (nodeId === this.getStartNodeId()) {\n      // the node we are removing is the project start node id\n      removingProjectStartNodeId = true;\n    }\n\n    if (removingProjectStartNodeId) {\n      /*\n             * we are removing the project start node id so we need to update\n             * the startNodeId to something else\n             */\n\n      if (this.isGroupNode(nodeId)) {\n        /*\n                 * we are removing a group so we need to set the startNodeId to\n                 * the first node of the next group or if the next group doesn't\n                 * have any nodes, we will just use the next group\n                 */\n\n        // get the transitions of the group we are removing\n        var transitions = this.getTransitionsByFromNodeId(nodeId);\n\n        if (transitions == null || transitions.length == 0) {\n          /*\n                     * the group doesn't have any transitions so we will set\n                     * the startNodeId to 'group0'\n                     */\n          this.setStartNodeId('group0');\n        } else {\n          // the group has transitions\n\n          var nextNodeId = null;\n\n          if (transitions[0] != null && transitions[0].to != null) {\n            // get the first transition\n            nextNodeId = transitions[0].to;\n          }\n\n          if (nextNodeId != null) {\n            if (this.isGroupNode(nextNodeId)) {\n              // the transition is to a group\n\n              // get the next group\n              var nextGroupNode = this.getNodeById(nextNodeId);\n\n              if (nextGroupNode != null) {\n\n                // get the start id of the next group\n                var nextGroupStartId = nextGroupNode.startId;\n\n                if (nextGroupStartId == null) {\n                  /*\n                                     * the next group does not have a start id so we\n                                     * will just use the next group id as the project\n                                     * start node id\n                                     */\n                  this.setStartNodeId(nextNodeId);\n                } else {\n                  /*\n                                     * the next group has a start id so we will use\n                                     * it as the project start node id\n                                     */\n                  this.setStartNodeId(nextGroupStartId);\n                }\n              }\n            } else {\n              /*\n                             * the transition is to a step so we will use it as the\n                             * project start node id\n                             */\n              this.setStartNodeId(nextNodeId);\n            }\n          }\n        }\n      } else {\n        /*\n                 * we are removing a step node so we will set the startNodeId to\n                 * the next node in the transitions, or if there are no\n                 * transitions, we will use the parent group\n                 */\n\n        // get the transitions from the step we are removing\n        var transitions = this.getTransitionsByFromNodeId(nodeId);\n\n        if (transitions == null || transitions.length == 0) {\n          /*\n                     * the step doesn't have any transitions so we will use the\n                     * its parent group as the start node id\n                     */\n          var parentGroupId = this.getParentGroupId(nodeId);\n          this.setStartNodeId(parentGroupId);\n        } else {\n          // the step has transitions\n\n          if (transitions[0] != null && transitions[0].to != null) {\n            /*\n                         * get the first transition and set it as the project\n                         * start node id\n                         */\n            var transitionToNodeId = transitions[0].to;\n            this.setStartNodeId(transitionToNodeId);\n          }\n        }\n      }\n    }\n\n    // remove the node\n    this.removeNodeIdFromTransitions(nodeId);\n    this.removeNodeIdFromGroups(nodeId);\n    this.removeNodeIdFromNodes(nodeId);\n\n    if (parentGroup != null) {\n      this.recalculatePositionsInGroup(parentGroup.id);\n    }\n  }\n\n  /**\n   * Update the transitions to handle removing a node\n   * @param nodeId the node id to remove\n   */\n  removeNodeIdFromTransitions(nodeId) {\n\n    // get the node we are removing\n    var nodeToRemove = this.getNodeById(nodeId);\n\n    // get all the nodes that have a transition to the node we are removing\n    var nodesByToNodeId = this.getNodesByToNodeId(nodeId);\n\n    // get the transitions of the node we are removing\n    var nodeToRemoveTransitionLogic = nodeToRemove.transitionLogic;\n    var nodeToRemoveTransitions = [];\n\n    if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n      nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n    }\n\n    var parentIdOfNodeToRemove = this.getParentGroupId(nodeId);\n\n    var parentGroup = this.getNodeById(parentIdOfNodeToRemove);\n\n    // update the start id if we are removing the start node of a group\n    if (parentGroup != null) {\n      var parentGroupStartId = parentGroup.startId;\n\n      if (parentGroupStartId != null) {\n        if (parentGroupStartId === nodeId) {\n          // the node we are removing is the start node\n\n          if (nodeToRemoveTransitions != null && nodeToRemoveTransitions.length > 0) {\n\n            // loop through all the transitions from the node to choose a new start id\n            for (var t = 0; t < nodeToRemoveTransitions.length; t++) {\n              var nodeToRemoveTransition = nodeToRemoveTransitions[t];\n\n              if (nodeToRemoveTransition != null) {\n                var toNodeId = nodeToRemoveTransition.to;\n\n                if (toNodeId != null) {\n                  /*\n                                     * we need to check that the to node id is in the\n                                     * same group. some transitions point to a node id\n                                     * in the next group which we would not want to use\n                                     * for the start id.\n                                     */\n                  if (this.getParentGroupId(toNodeId) == parentIdOfNodeToRemove) {\n\n                    // set the new start id\n                    parentGroup.startId = toNodeId;\n                  }\n                }\n              }\n            }\n          } else {\n            // there are no transitions so we will have an empty start id\n            parentGroup.startId = '';\n          }\n        }\n      }\n    }\n\n    // loop through all the nodes that transition to the node we are removing\n    for (var n = 0; n < nodesByToNodeId.length; n++) {\n\n      // get a node that has a transition to the node we are removing\n      var node = nodesByToNodeId[n];\n\n      if (node != null) {\n        var parentIdOfFromNode = this.getParentGroupId(node.id);\n\n        var transitionLogic = node.transitionLogic;\n\n        if (transitionLogic != null) {\n          var transitions = transitionLogic.transitions;\n\n          // loop through all the transitions of this node\n          for (var t = 0; t < transitions.length; t++) {\n            var transition = transitions[t];\n\n            if (nodeId === transition.to) {\n              // we have found the transition to the node we are removing\n\n              // copy the transitions from the node we are removing\n              var transitionsCopy = angular.toJson(nodeToRemoveTransitions);\n              transitionsCopy = angular.fromJson(transitionsCopy);\n\n              /*\n                             * if the parent from group is different than the parent removing group\n                             * remove transitions that are to a node in a different group than\n                             * the parent removing group\n                             */\n\n              if (parentIdOfFromNode != parentIdOfNodeToRemove) {\n\n                for (var tc = 0; tc < transitionsCopy.length; tc++) {\n                  var tempTransition = transitionsCopy[tc];\n\n                  if (tempTransition != null) {\n                    var tempToNodeId = tempTransition.to;\n\n                    if (tempToNodeId != null) {\n                      var parentIdOfToNode = this.getParentGroupId(tempToNodeId);\n\n                      if (parentIdOfNodeToRemove != parentIdOfToNode) {\n                        // remove the transition\n\n                        transitionsCopy.splice(tc, 1);\n                        tc--;\n                      }\n                    }\n                  }\n                }\n              }\n\n              if (this.isFirstNodeInBranchPath(nodeId)) {\n                /*\n                                 * Get the node ids that have a branchPathTaken\n                                 * constraint from the before node and to the node\n                                 * we are removing. If there are any, we need to\n                                 * update the branchPathTaken constraint with the\n                                 * next nodeId that comes after the node we are\n                                 * removing.\n                                 */\n                var nodeIdsInBranch = this.getNodeIdsInBranch(node.id, nodeId);\n\n                if (nodeIdsInBranch != null) {\n\n                  // loop through all the node ids in the branch\n                  for (var nib = 0; nib < nodeIdsInBranch.length; nib++) {\n                    var nodeIdInBranch = nodeIdsInBranch[nib];\n                    var nodeInBranch = this.getNodeById(nodeIdInBranch);\n\n                    // loop through all the transitions in the node we are removing\n                    for (var tc = 0; tc < transitionsCopy.length; tc++) {\n                      var transitionCopy = transitionsCopy[tc];\n\n                      if (transitionCopy != null) {\n                        var currentFromNodeId = node.id;\n                        var currentToNodeId = nodeId;\n                        var newFromNodeId = node.id;\n                        var newToNodeId = transitionCopy.to;\n\n                        /*\n                                                 * change the branch path taken constraint by changing\n                                                 * the toNodeId\n                                                 */\n                        this.updateBranchPathTakenConstraint(nodeInBranch, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId);\n                      }\n                    }\n                  }\n                }\n              } else if (this.isBranchPoint(nodeId)) {\n                // the node we are removing is a branch point\n\n                /*\n                                 * get all the branches that have the node we\n                                 * are removing as the start point\n                                 */\n                var branches = this.getBranchesByBranchStartPointNodeId(nodeId);\n\n                // loop through all branches\n                for (var b = 0; b < branches.length; b++) {\n                  var branch = branches[b];\n\n                  if (branch != null) {\n\n                    /*\n                                         * get the branch paths. these paths do not\n                                         * contain the start point or merge point.\n                                         */\n                    var branchPaths = branch.branchPaths;\n\n                    if (branchPaths != null) {\n\n                      // loop through all the branch paths\n                      for (var bp = 0; bp < branchPaths.length; bp++) {\n                        var branchPath = branchPaths[bp];\n\n                        if (branchPath != null) {\n\n                          // get the start point\n                          var currentFromNodeId = nodeId;\n\n                          // get the first node in this branch\n                          var currentToNodeId = branchPath[0];\n\n                          // this will be the new start point\n                          var newFromNodeId = node.id;\n\n                          // get the first node in this branch\n                          var newToNodeId = branchPath[0];\n\n                          // loop through all the nodes in the branch path\n                          for (var bpn = 0; bpn < branchPath.length; bpn++) {\n\n                            // get the node id\n                            var branchPathNodeId = branchPath[bpn];\n\n                            // get the node\n                            var branchPathNode = this.getNodeById(branchPathNodeId);\n\n                            // update the constraints related to the branching\n                            this.updateBranchPathTakenConstraint(branchPathNode, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId);\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n\n              // remove the transition to the node we are removing\n              transitions.splice(t, 1);\n\n              if (transitionsCopy != null) {\n                var insertIndex = t;\n\n                /*\n                                 * loop through all the transitions from the node we are removing\n                                 * and insert them into the transitions of the from node\n                                 * e.g.\n                                 * the node that comes before the node we are removing has these transitions\n                                 * \"transitions\": [\n                                 *     {\n                                 *         \"to\": \"node4\"\n                                 *     },\n                                 *     {\n                                 *         \"to\": \"node6\"\n                                 *     }\n                                 * ]\n                                 *\n                                 * we are removing node4. node4 has a transition to node5.\n                                 *\n                                 * the node that comes before the node we are removing now has these transitions\n                                 * \"transitions\": [\n                                 *     {\n                                 *         \"to\": \"node5\"\n                                 *     },\n                                 *     {\n                                 *         \"to\": \"node6\"\n                                 *     }\n                                 * ]\n                                 */\n                for (var tc = 0; tc < transitionsCopy.length; tc++) {\n                  // insert a transition from the node we are removing\n                  transitions.splice(insertIndex, 0, transitionsCopy[tc]);\n                  insertIndex++;\n                }\n              }\n\n              // check if the node we are moving is a group\n              if (this.isGroupNode(nodeId)) {\n                /*\n                                 * we are moving a group so we need to update transitions that\n                                 * go into the group\n                                 */\n                var groupIdWeAreMoving = nodeId;\n                var groupThatTransitionsToGroupWeAreMoving = node;\n                this.updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving);\n              }\n            }\n          }\n\n          if (this.isBranchPoint(nodeId)) {\n            /*\n                         * the node we are deleting is a branch point so we to\n                         * copy the transition logic to the node that comes\n                         * before it\n                         */\n            node.transitionLogic = this.UtilService.makeCopyOfJSONObject(nodeToRemoveTransitionLogic);\n\n            /*\n                         * set the transitions for the node that comes before\n                         * the one we are removing\n                         */\n            node.transitionLogic.transitions = transitions;\n          }\n        }\n      }\n    }\n\n    if (nodeToRemoveTransitionLogic != null) {\n      // clear the transitions of the node we are removing\n      nodeToRemoveTransitionLogic.transitions = [];\n    }\n\n    if (this.isGroupNode(nodeId)) {\n      /*\n             * this is a group node so we will remove all child transitions that\n             * go out of this group\n             */\n\n      //this.removeTransitionsIntoGroup(nodeId);\n      this.removeTransitionsOutOfGroup(nodeId);\n    }\n  };\n\n  /**\n   * Remove the node id from a group\n   * @param nodeId the node id to remove\n   */\n  removeNodeIdFromGroups(nodeId) {\n\n    var groups = this.groupNodes;\n\n    if (groups != null) {\n\n      // loop through all the groups\n      for (var g = 0; g < groups.length; g++) {\n        var group = groups[g];\n\n        if (group != null) {\n\n          // get the start id of the group\n          var startId = group.startId;\n\n          // get the child ids of the group\n          var ids = group.ids;\n\n          // loop through all the child ids\n          for (var i = 0; i < ids.length; i++) {\n            var id = ids[i];\n\n            if (nodeId === id) {\n              // we have found the node id we want to remove\n              ids.splice(i, 1);\n\n              if (nodeId === startId) {\n                /*\n                                 * the node id is also the start id so we will get the\n                                 * next node id and set it as the new start id\n                                 */\n\n                var hasSetNewStartId = false;\n\n                // get the node we are removing\n                var node = this.getNodeById(id);\n\n                if (node != null) {\n                  var transitionLogic = node.transitionLogic;\n\n                  if (transitionLogic != null) {\n                    var transitions = transitionLogic.transitions;\n\n                    if (transitions != null && transitions.length > 0) {\n\n                      // get the first transition\n                      // TODO handle the case when the node we are removing is a branch point\n                      var transition = transitions[0];\n\n                      if (transition != null) {\n                        // get the node that this node transitions to\n                        var to = transition.to;\n\n                        if (to != null) {\n                          // set the to node as the start id\n                          group.startId = to;\n                          hasSetNewStartId = true;\n                        }\n                      }\n                    }\n                  }\n                }\n\n                if (!hasSetNewStartId) {\n                  /*\n                                     * the node we are removing did not have a transition\n                                     * so there will be no start id\n                                     */\n                  group.startId = '';\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the array of nodes\n   * @param nodeId the node id to remove\n   */\n  removeNodeIdFromNodes(nodeId) {\n\n    // get all the nodes in the project\n    var nodes = this.project.nodes;\n\n    // loop through all the nodes\n    for (var n = 0; n < nodes.length; n++) {\n      var node = nodes[n];\n\n      if (node != null) {\n        if (nodeId === node.id) {\n          // we have found the node we want to remove\n          nodes.splice(n, 1);\n        }\n      }\n    }\n\n    // get all the inactive nodes\n    var inactiveNodes = this.project.inactiveNodes;\n\n    if (inactiveNodes != null) {\n\n      // loop through all the inactive nodes\n      for (var i = 0; i < inactiveNodes.length; i++) {\n        var inactiveNode = inactiveNodes[i];\n\n        if (inactiveNode != null) {\n          if (nodeId === inactiveNode.id) {\n            // we have found the inactive node we want to remove\n            inactiveNodes.splice(i, 1);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive nodes array\n   * @param nodeId the node to remove from the inactive nodes array\n   */\n  removeNodeIdFromInactiveNodes(nodeId) {\n\n    // get the inactive nodes array\n    var inactiveNodes = this.project.inactiveNodes;\n\n    if (inactiveNodes != null) {\n\n      // loop through the inactive nodes\n      for (var i = 0; i < inactiveNodes.length; i++) {\n        var inactiveNode = inactiveNodes[i];\n\n        if (inactiveNode != null) {\n          var inactiveNodeId = inactiveNode.id;\n\n          if (nodeId === inactiveNodeId) {\n            /*\n                         * we have found the node we are looking for so we will\n                         * remove it\n                         */\n            inactiveNodes.splice(i, 1);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Create a new component\n   * @param nodeId the node id to create the component in\n   * @param componentType the component type\n   * @param insertAfterComponentId Insert the new compnent after the given\n   * component id. If this argument is null, we will place the new component\n   * in the first position.\n   */\n  createComponent(nodeId, componentType, insertAfterComponentId) {\n\n    var component = null;\n\n    if (nodeId != null && componentType != null) {\n      // get the node we will create the component in\n      var node = this.getNodeById(nodeId);\n\n      // get the service for the component type\n      var service = this.$injector.get(componentType + 'Service');\n\n      if (node != null && service != null) {\n\n        // create the new component\n        component = service.createComponent();\n\n        if (service.componentHasWork()) {\n          /*\n                     * the component has student work so we will need to\n                     * determine if we need to show the save button on the\n                     * component or the step\n                     */\n\n          if (node.showSaveButton == true) {\n            /*\n                         * the step is showing a save button so we will not show\n                         * the save button on this new component\n                         */\n          } else {\n            // the step is not showing a save button\n\n            if (this.doesAnyComponentShowSubmitButton(node.id)) {\n              /*\n                             * at least one of the other components in the step are\n                             * showing a submit button so we will also show the save\n                             * button on this new component\n                             */\n\n              // turn on the component save button\n              component.showSaveButton = true;\n            } else {\n              /*\n                             * none of the other components are showing a submit button\n                             * so we will show the save button on the step\n                             */\n\n              // turn on the step save button\n              node.showSaveButton = true;\n            }\n          }\n        }\n\n        // add the component to the node\n        this.addComponentToNode(node, component, insertAfterComponentId);\n      }\n    }\n\n    return component;\n  }\n\n  /**\n   * Does any component in the step generate work\n   * @param nodeId the node id\n   * @return whether any components in the step generates work\n   */\n  doesAnyComponentHaveWork(nodeId) {\n\n    // get the node\n    var node = this.getNodeById(nodeId);\n\n    if (node != null) {\n\n      // get the components in the node\n      var components = node.components;\n\n      if (components != null) {\n\n        // loop through all the components\n        for (var c = 0; c < components.length; c++) {\n\n          // get a component\n          var component = components[c];\n\n          if (component != null) {\n            var componentType = component.type;\n\n            // get the service for the component type\n            var service = this.$injector.get(componentType + 'Service');\n\n            if (service != null) {\n              if (service.componentHasWork()) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if any of the components in the node are showing their save button\n   * @param nodeId the node id to check\n   * @return whether any of the components in the node show their save button\n   */\n  doesAnyComponentShowSaveButton(nodeId) {\n\n    var result = false;\n\n    // get the node\n    var node = this.getNodeById(nodeId);\n\n    if (node != null) {\n\n      // get the components in the node\n      var components = node.components;\n\n      if (components != null) {\n\n        // loop through all the components\n        for (var c = 0; c < components.length; c++) {\n\n          // get a component\n          var component = components[c];\n\n          if (component != null) {\n            if (component.showSaveButton == true) {\n              // the component is showing their save button\n              result = true;\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if any of the components in the node are showing their submit button\n   * @param nodeId the node id to check\n   * @return whether any of the components in the node show their submit button\n   */\n  doesAnyComponentShowSubmitButton(nodeId) {\n\n    var result = false;\n\n    // get the node\n    var node = this.getNodeById(nodeId);\n\n    if (node != null) {\n\n      // get the components in the node\n      var components = node.components;\n\n      if (components != null) {\n\n        // loop through all the components\n        for (var c = 0; c < components.length; c++) {\n\n          // get a component\n          var component = components[c];\n\n          if (component != null) {\n            if (component.showSubmitButton == true) {\n              // the component is showing their save button\n              result = true;\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Turn on the save button in all the components in the step\n   * @param nodeId the node id\n   */\n  turnOnSaveButtonInComponents(nodeId) {\n\n    // get the node\n    var node = this.getNodeById(nodeId);\n\n    if (node != null) {\n\n      // get the components in the node\n      var components = node.components;\n\n      if (components != null) {\n\n        // loop through all the components\n        for (var c = 0; c < components.length; c++) {\n\n          // get a component\n          var component = components[c];\n\n          if (component != null) {\n\n            // get the component type\n            var componentType = component.type;\n\n            if (componentType != null) {\n\n              // get the service for the component type\n              var service = this.$injector.get(componentType + 'Service');\n\n              if (service != null) {\n\n                // check if this component uses a save button\n                if (service.componentUsesSaveButton()) {\n\n                  // turn on the save button in the component\n                  component.showSaveButton = true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Turn off the submit button in all the components in the step\n   * @param nodeId the node id\n   */\n  turnOffSaveButtonInComponents(nodeId) {\n    // get the node\n    var node = this.getNodeById(nodeId);\n\n    if (node != null) {\n\n      // get the components in the node\n      var components = node.components;\n\n      if (components != null) {\n\n        // loop through all the components\n        for (var c = 0; c < components.length; c++) {\n\n          // get a component\n          var component = components[c];\n\n          if (component != null) {\n\n            // get the component type\n            var componentType = component.type;\n\n            if (componentType != null) {\n\n              // get the service for the component type\n              var service = this.$injector.get(componentType + 'Service');\n\n              if (service != null) {\n\n                // check if this component uses a save button\n                if (service.componentUsesSaveButton()) {\n\n                  // turn on the save button in the component\n                  component.showSaveButton = false;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Add the component to the node\n   * @param node the node\n   * @param component the component\n   * @param insertAfterComponentId Insert the component after this given\n   * component id. If this argument is null, we will place the new component\n   * in the first position.\n   */\n  addComponentToNode(node, component, insertAfterComponentId) {\n\n    if (node != null && component != null) {\n\n      if (insertAfterComponentId == null) {\n        /*\n                 * insertAfterComponentId is null so we will place the new\n                 * component in the first position\n                 */\n        node.components.splice(0, 0, component);\n      } else {\n        // place the new component after the insertAfterComponentId\n\n        // boolean flag for whether we have added the component yet\n        var added = false;\n\n        // get the components in the step\n        var components = node.components;\n\n        // loop through all the components\n        for (var c = 0; c < components.length; c++) {\n          var tempComponent = components[c];\n\n          if (tempComponent != null && tempComponent.id != null && tempComponent.id == insertAfterComponentId) {\n            /*\n                         * we have found the component we want to add the new\n                         * one after\n                         */\n\n            // add the component\n            components.splice(c + 1, 0, component);\n            added = true;\n            break;\n          }\n        }\n\n        if (!added) {\n          /*\n                     * the component has not been added yet so we will just add\n                     * it at the end\n                     */\n          node.components.push(component);\n        }\n      }\n    }\n  }\n\n  /**\n   * Move the component(s) within the node\n   * @param nodeId we are moving component(s) in this node\n   * @param componentIds the component(s) we are moving\n   * @param insertAfterComponentId Insert the component(s) after this given\n   * component id. If this argument is null, we will place the new\n   * component(s) in the first position.\n   */\n  moveComponent(nodeId, componentIds, insertAfterComponentId) {\n\n    // get the node for which we are moving components\n    var node = this.getNodeById(nodeId);\n\n    // get the components in the node\n    var components = node.components;\n\n    var componentsToMove = [];\n\n    // remove the component(s)\n    for (var a = components.length - 1; a >= 0; a--) {\n      var tempComponent = components[a];\n\n      if (tempComponent != null) {\n\n        if (componentIds.indexOf(tempComponent.id) != -1) {\n          // we have found a component we want to move\n\n          // add the component to our array of components we are moving\n          componentsToMove.splice(0, 0, tempComponent);\n\n          // remove the component from the components array in the node\n          components.splice(a, 1);\n        }\n      }\n    }\n\n    // insert the component(s)\n    if (insertAfterComponentId == null) {\n      // insert the components at the beginning of the components list\n\n      // loop through all the components we are moving\n      for (var c = 0; c < componentsToMove.length; c++) {\n\n        // insert a component\n        components.splice(c, 0, componentsToMove[c]);\n      }\n    } else {\n      // insert the component(s) after the given insertAfterComponentId\n\n      // loop through all the components\n      for (var b = 0; b < components.length; b++) {\n        var tempComponent = components[b];\n\n        if (tempComponent != null && tempComponent.id == insertAfterComponentId) {\n          // we have found the component we want to add after\n\n          // loop through all the components we are moving\n          for (var c = 0; c < componentsToMove.length; c++) {\n            // insert a component\n            components.splice(b + 1 + c, 0, componentsToMove[c]);\n          }\n\n          break;\n        }\n      }\n    }\n\n    return componentsToMove;\n  }\n\n  /**\n   * Delete the component\n   * @param nodeId the node id\n   * @param componentId the component id\n   */\n  deleteComponent(nodeId, componentId) {\n    if (nodeId != null && componentId != null) {\n      var node = this.getNodeById(nodeId);\n\n      if (node != null) {\n        var components = node.components;\n\n        if (components != null) {\n\n          // loop through all the components\n          for (var c = 0; c < components.length; c++) {\n            var component = components[c];\n\n            if (component.id === componentId) {\n              // we have found the component we want to delete\n\n              // remove the component\n              components.splice(c, 1);\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * TODO: Deprecated, should be removed; replaced by getMaxScoreForWorkgroupId in StudentStatusService\n   * Get the max score for the project. If the project contains branches, we\n   * will only calculate the max score for a single path from the first node\n   * to the last node in the project.\n   * @returns the max score for the project or null if none of the components in the project\n   * has max scores.\n   */\n  getMaxScore() {\n\n    var maxScore = null;\n\n    // get the start node id of the project\n    var startNodeId = this.getStartNodeId()\n\n    // get all the paths in the project\n    var allPaths = this.getAllPaths([], startNodeId);\n\n    if (allPaths != null && allPaths.length > 0) {\n\n      // get the first path\n      var firstPath = allPaths[0];\n\n      // loop through all the node ids in the path\n      for (var n = 0; n < firstPath.length; n++) {\n\n        // get a node id\n        var nodeId = firstPath[n];\n\n        // get the max score for the node\n        var nodeMaxScore = this.getMaxScoreForNode(nodeId);\n\n        if (nodeMaxScore != null) {\n          if (maxScore == null) {\n            maxScore = nodeMaxScore;\n          } else {\n            maxScore += nodeMaxScore;\n          }\n        }\n      }\n    }\n\n    return maxScore;\n  }\n\n  /**\n   * Get the max score for the node\n   * @param nodeId the node id\n   * @returns the max score for the node\n   */\n  getMaxScoreForNode(nodeId) {\n    var maxScore = null;\n\n    // get the node\n    var node = this.getNodeById(nodeId);\n\n    if (node != null) {\n      var components = node.components;\n\n      if (components != null) {\n\n        // loop through all the components\n        for (var c = 0; c < components.length; c++) {\n          var component = components[c];\n\n          if (component != null) {\n\n            // get the max score for the component\n            var componentMaxScore = component.maxScore;\n\n            // check if the component has a max score\n            if (componentMaxScore != null) {\n\n              // make sure the max score is a valid number\n              if (!isNaN(componentMaxScore)) {\n\n                if (maxScore == null) {\n                  maxScore = componentMaxScore;\n                } else {\n                  // accumulate the max score\n                  maxScore += componentMaxScore;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return maxScore;\n  }\n\n  /**\n   * Get the max score for a component\n   * @param nodeId get the max score from a component in this node\n   * @param componentId get the max score from this component\n   */\n  getMaxScoreForComponent(nodeId, componentId) {\n    var maxScore = null;\n\n    var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n    if (component != null) {\n      maxScore = component.maxScore;\n    }\n\n    return maxScore;\n  }\n\n  /**\n   * Set the max score for a component\n   * @param nodeId set the max score from a component in this node\n   * @param componentId set the max score from this component\n   * @param maxScore set it to this maxScore\n   */\n  setMaxScoreForComponent(nodeId, componentId, maxScore) {\n    if (nodeId != null && componentId != null && maxScore != null && typeof maxScore === 'number') {\n      let component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n      if (component != null) {\n        component.maxScore = maxScore;\n      }\n    }\n  }\n\n  /**\n   * Determine if a node id is a direct child of a group\n   * @param nodeId the node id\n   * @param groupId the group id\n   */\n  isNodeInGroup(nodeId, groupId) {\n\n    var result = false;\n\n    var group = this.getNodeById(groupId);\n\n    var childIds = group.ids;\n\n    if (childIds != null) {\n      if (childIds.indexOf(nodeId) != -1) {\n        result = true;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the first leaf node by traversing all the start ids\n   * until a leaf node id is found\n   */\n  getFirstLeafNodeId() {\n\n    var firstLeafNodeId = null;\n\n    // get the start group id\n    var startGroupId = this.project.startGroupId;\n\n    // get the start group node\n    var node = this.getNodeById(startGroupId);\n\n    var done = false;\n\n    // loop until we have found a leaf node id or something went wrong\n    while (!done) {\n\n      if (node == null) {\n        done = true;\n      } else if (this.isGroupNode(node.id)) {\n        // set the first leaf node id to the group id for now\n        firstLeafNodeId = node.id;\n\n        // the current node is a group\n        node = this.getNodeById(node.startId);\n      } else if (this.isApplicationNode(node.id)) {\n        // the current node is a leaf\n        firstLeafNodeId = node.id;\n        done = true;\n      } else {\n        done = true;\n      }\n    }\n\n    return firstLeafNodeId;\n  }\n\n  /**\n   * Replace a node. This is used when we want to revert a node back to a\n   * previous version in the authoring tool.\n   * @param nodeId the node id\n   * @param node the node object\n   */\n  replaceNode(nodeId, node) {\n\n    if (nodeId != null && node != null) {\n\n      // set the id to node mapping\n      this.setIdToNode(nodeId, node);\n\n      // set the id to element mapping\n      this.setIdToElement(nodeId, node);\n\n      // update the nodes array\n      var nodes = this.getNodes();\n\n      if (nodes != null) {\n\n        for (var n = 0; n < nodes.length; n++) {\n          var tempNode = nodes[n];\n\n          if (tempNode != null) {\n            var tempNodeId = tempNode.id;\n\n            if (nodeId === tempNodeId) {\n              // we have found the node we want to replace\n              nodes.splice(n, 1, node);\n              break;\n            }\n          }\n        }\n      }\n\n      // update the application nodes array\n      var applicationNodes = this.applicationNodes;\n\n      if (applicationNodes != null) {\n        for (var a = 0; a < applicationNodes.length; a++) {\n          var tempApplicationNode = applicationNodes[a];\n\n          if (tempApplicationNode != null) {\n            var tempApplicationNodeId = tempApplicationNode.id;\n\n            if (nodeId === tempApplicationNodeId) {\n              // we have found the node we want to replace\n              applicationNodes.splice(a, 1, node);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if a node is a planning node\n   * @param nodeId the node id\n   * @returns whether the node is a planning node\n   */\n  isPlanning(nodeId) {\n    var result = false;\n\n    if (nodeId != null) {\n      var node = this.getNodeById(nodeId);\n\n      if (node != null) {\n        if (node.planning) {\n          result = true;\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if a node is a planning node instance\n   * @param nodeId the node id\n   * @returns whether the node is a planning node instance\n   */\n  isPlanningInstance(nodeId) {\n    var result = false;\n\n    if (nodeId != null) {\n      var node = this.getNodeById(nodeId);\n\n      if (node.planningNodeTemplateId) {\n        result = true;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the available planning node ids for a node\n   * @param nodeId the node we want available planning nodes for\n   * @returns an array of available planning node ids\n   */\n  getAvailablePlanningNodeIds(nodeId) {\n    var availablePlanningNodeIds = [];\n\n    if (nodeId != null) {\n      var node = this.getNodeById(nodeId);\n\n      if (node != null && node.availablePlanningNodeIds != null) {\n        availablePlanningNodeIds = node.availablePlanningNodeIds;\n      }\n    }\n\n    return availablePlanningNodeIds;\n  }\n\n  /**\n   * Get the available planning nodes for a given group\n   * @param nodeId the node id of the group\n   * @returns an array of planning node templates\n   */\n  getAvailablePlanningNodes(nodeId) {\n    var availablePlanningNodesSoFar = [];\n\n    if (nodeId != null) {\n      var node = this.getNodeById(nodeId);\n\n      if (node != null && node.availablePlanningNodes != null) {\n        let availablePlanningNodes = node.availablePlanningNodes;\n\n        // loop through all the nodes and retrieve the actual node\n        for (var a = 0; a < availablePlanningNodes.length; a++) {\n          var availablePlanningNode = availablePlanningNodes[a];\n\n          if (availablePlanningNode != null) {\n\n            // get the node\n            var availablePlanningNodeActual = this.getNodeById(availablePlanningNode.nodeId);\n\n            if (availablePlanningNodeActual != null) {\n              if (availablePlanningNode.max != null) {\n                availablePlanningNodeActual.max = availablePlanningNode.max;\n              }\n              availablePlanningNodesSoFar.push(availablePlanningNodeActual);\n            }\n          }\n        }\n      }\n    }\n\n    return availablePlanningNodesSoFar;\n  }\n\n  /**\n   * Create a planning node instance and add it to the project\n   * @param groupId the group id to add the planning node instance to\n   * @param nodeId the node id of the planning node template\n   */\n  createPlanningNodeInstance(groupId, nodeId, nextAvailablePlanningNodeId) {\n\n    var planningNodeInstance = null;\n\n    if (nodeId != null && nextAvailablePlanningNodeId != null) {\n      // get the planning node template\n      var node = this.getNodeById(nodeId);\n\n      // create a planning node instance by copying the planning node template\n      planningNodeInstance = this.copyNode(nodeId);\n\n      // set the template id to point back to the planning template node\n      planningNodeInstance.planningNodeTemplateId = nodeId;\n\n      // set the planning node instance node id\n      planningNodeInstance.id = nextAvailablePlanningNodeId;\n    }\n\n    return planningNodeInstance;\n  }\n\n  /**\n   * Add a planning node instance inside a group node\n   * @param nodeIdToInsertInside the group id to insert into\n   * @param planningNodeInstance the planning node instance to add\n   */\n  addPlanningNodeInstanceInside(nodeIdToInsertInside, planningNodeInstance) {\n    // get the node id\n    var planningNodeInstanceNodeId = planningNodeInstance.id;\n\n    // add an entry in our mapping data structures of node id to object\n    this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\n    this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\n\n    // add the node to the nodes array in the project\n    this.addNode(planningNodeInstance);\n\n    // update the transitions\n    this.insertNodeInsideInTransitions(planningNodeInstanceNodeId, nodeIdToInsertInside);\n\n    // update the child ids of the group\n    this.insertNodeInsideInGroups(planningNodeInstanceNodeId, nodeIdToInsertInside);\n\n    // recalculate all the position values in the group\n    this.recalculatePositionsInGroup(nodeIdToInsertInside);\n\n    /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n    this.setNodeOrder(this.rootNode, 0);\n  }\n\n  /**\n   * Add a planning node instance after a node\n   * @param nodeIdToInsertAfter the node to insert after\n   * @param planningNodeInstance the planning node instance to add\n   */\n  addPlanningNodeInstanceAfter(nodeIdToInsertAfter, planningNodeInstance) {\n    // get the node id\n    var planningNodeInstanceNodeId = planningNodeInstance.id;\n\n    // add an entry in our mapping data structures of node id to object\n    this.setIdToNode(planningNodeInstanceNodeId, planningNodeInstance);\n    this.setIdToElement(planningNodeInstanceNodeId, planningNodeInstance);\n\n    // add the node to the nodes array in the project\n    this.addNode(planningNodeInstance);\n\n    // update the transitions\n    this.insertNodeAfterInTransitions(planningNodeInstance, nodeIdToInsertAfter);\n\n    // update the child ids of the group\n    this.insertNodeAfterInGroups(planningNodeInstanceNodeId, nodeIdToInsertAfter);\n\n    var parentGroup = this.getParentGroup(nodeIdToInsertAfter);\n\n    if (parentGroup != null) {\n      var parentGroupId = parentGroup.id;\n\n      // recalculate all the position values in the group\n      this.recalculatePositionsInGroup(parentGroupId);\n    }\n\n    /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n    this.setNodeOrder(this.rootNode, 0);\n  }\n\n  /**\n   * Move a planning node instance inside a group\n   * @param nodeIdToMove the node to move\n   * @param nodeIdToInsertInside the group to move the node into\n   */\n  movePlanningNodeInstanceInside(nodeIdToMove, nodeIdToInsertInside) {\n\n    // move the node inside the group node\n    this.moveNodesInside([nodeIdToMove], nodeIdToInsertInside);\n\n    // recalculate all the position values in the group\n    this.recalculatePositionsInGroup(nodeIdToInsertInside);\n\n    /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n    this.setNodeOrder(this.rootNode, 0);\n  }\n\n  /**\n   * Move a planning node instance after a node\n   * @param nodeIdToMove the node to move\n   * @param nodeIdToInsertAfter the other node to move the node after\n   */\n  movePlanningNodeInstanceAfter(nodeIdToMove, nodeIdToInsertAfter) {\n\n    // move the node after the other node\n    this.moveNodesAfter([nodeIdToMove], nodeIdToInsertAfter);\n\n    var parentGroup = this.getParentGroup(nodeIdToInsertAfter);\n\n    if (parentGroup != null) {\n      var parentGroupId = parentGroup.id;\n\n      // recalculate all the position values in the group\n      this.recalculatePositionsInGroup(parentGroupId);\n    }\n\n    /*\n         * set the order of the planning node instance so that it shows up\n         * in the select step drop down in the correct order\n         */\n    this.setNodeOrder(this.rootNode, 0);\n  }\n\n  /**\n   * Recalculate the positions of the children in the group.\n   * The positions are the numbers usually seen before the title\n   * e.g. if the step is seen as 1.3: Gather Evidence, then 1.3\n   * is the position\n   * @param groupId recalculate all the children of this group\n   */\n  recalculatePositionsInGroup(groupId) {\n\n    if (groupId != null) {\n      let childIds = this.getChildNodeIdsById(groupId);\n\n      // loop through all the children\n      for (let c = 0; c < childIds.length; c++) {\n        let childId = childIds[c];\n\n        // calculate the position of the child id\n        let pos = this.getPositionById(childId);\n\n        // set the mapping of node id to position\n        this.setIdToPosition(childId, pos);\n      }\n    }\n  }\n\n  /**\n   * Get the message that describes how to disable the constraint\n   * @param nodeId the node the student is trying to go to\n   * @param constraint the constraint that is preventing the student\n   * from going to the node\n   * @returns the message to display to the student that describes how\n   * to disable the constraint\n   */\n  getConstraintMessage(nodeId, constraint) {\n\n    var message = '';\n\n    if (nodeId != null && constraint != null) {\n\n      // get the node title the student is trying to go to\n      var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n\n      var removalConditional = constraint.removalConditional;\n      var removalCriteria = constraint.removalCriteria;\n\n      if (removalCriteria != null) {\n        var criteriaMessages = '';\n\n        // loop through all the criteria\n        for (var x = 0; x < removalCriteria.length; x++) {\n          var tempRemovalCriteria = removalCriteria[x];\n\n          if (tempRemovalCriteria != null) {\n\n            // get the message that describes the criteria that needs to be satisfied\n            var criteriaMessage = this.getCriteriaMessage(tempRemovalCriteria);\n\n            if (criteriaMessage != null && criteriaMessage != '') {\n              // separate criteria messages with a line break\n              if (criteriaMessages != '') {\n                criteriaMessages += '<br/>';\n              }\n              criteriaMessages += criteriaMessage;\n            }\n          }\n        }\n\n        message += criteriaMessages;\n      }\n    }\n\n    return message;\n  }\n\n  /**\n   * Get the message that describes how to satisfy the criteria\n   * TODO: check if the criteria is satisfied\n   * @param criteria the criteria object that needs to be satisfied\n   * @returns the message to display to the student that describes how to\n   * satisfy the criteria\n   */\n  getCriteriaMessage(criteria) {\n    var message = '';\n\n    if (criteria != null) {\n      var name = criteria.name;\n      var params = criteria.params;\n\n      if (name === 'isCompleted') {\n        var nodeId = params.nodeId;\n        if (nodeId != null) {\n          var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('completeNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'isVisited') {\n        var nodeId = params.nodeId;\n        if (nodeId != null) {\n          var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('visitNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'isCorrect') {\n        var nodeId = params.nodeId;\n        if (nodeId != null) {\n          var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('correctlyAnswerNodeTitle', { nodeTitle: nodeTitle });\n        }\n      } else if (name === 'score') {\n        var nodeId = params.nodeId;\n        var nodeTitle = '';\n        var scoresString = '';\n\n        if (nodeId != null) {\n          // get the step number and title\n          nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n        }\n\n        var scores = params.scores;\n\n        if (scores != null) {\n          // get the required score\n          scoresString = scores.join(', ');\n        }\n\n        // generate the message\n        message += this.$translate('obtainAScoreOfXOnNodeTitle', { score: scoresString, nodeTitle: nodeTitle });\n      } else if (name === 'choiceChosen') {\n\n      } else if (name === 'usedXSubmits') {\n        var nodeId = params.nodeId;\n        var nodeTitle = '';\n\n        // get the number of times the student must submit\n        var requiredSubmitCount = params.requiredSubmitCount;\n\n        if (nodeId != null) {\n          // get the step number and title\n          nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n        }\n\n        // generate the message\n        if (requiredSubmitCount == 1) {\n          message += this.$translate('submitXTimeOnNodeTitle', { requiredSubmitCount: requiredSubmitCount, nodeTitle: nodeTitle });\n        } else {\n          message += this.$translate('submitXTimesOnNodeTitle', { requiredSubmitCount: requiredSubmitCount, nodeTitle: nodeTitle });\n        }\n      } else if (name === 'branchPathTaken') {\n\n      } else if (name === 'isPlanningActivityCompleted') {\n        var nodeId = params.nodeId;\n        if (nodeId != null) {\n          var nodeTitle = this.getNodePositionAndTitleByNodeId(nodeId);\n          message += this.$translate('completeNodeTitle', { nodeTitle: nodeTitle });\n        }\n      }\n    }\n\n    return message;\n  }\n\n  /**\n   * Get the start id of a group\n   * @param nodeId get the start id of this group\n   * @returns the start id of the group\n   */\n  getGroupStartId(nodeId) {\n\n    var startId = null;\n\n    if (nodeId != null) {\n\n      // get the group\n      var node = this.getNodeById(nodeId);\n\n      if (node != null) {\n        // get the start id\n        startId = node.startId;\n      }\n    }\n\n\n    return startId;\n  }\n\n  /**\n   * Get the start id of the node's parent group\n   * @param nodeId we will get the parent of this node and then look\n   * for the start id of the parent\n   * @returns the start id of the parent\n   */\n  getParentGroupStartId(nodeId) {\n    var parentGroupStartId = null;\n\n    if (nodeId != null) {\n      var parentGroup = this.getParentGroup(nodeId);\n\n      if (parentGroup != null) {\n        parentGroupStartId = parentGroup.startId;\n      }\n    }\n\n    return parentGroupStartId;\n  }\n\n  /**\n   * Update the transitions so that the fromGroup points to the newToGroup\n   *\n   * Before\n   * fromGroup -> oldToGroup -> newToGroup\n   *\n   * After\n   * fromGroup -> newToGroup\n   * oldToGroup becomes dangling and has no transitions to or from it\n   */\n  updateTransitionsForExtractingGroup(fromGroupId, oldToGroupId, newToGroupId) {\n\n    /*\n         * make the transitions\n         * fromGroup -> newToGroup\n         */\n    if (fromGroupId != null && oldToGroupId != null) {\n      var fromGroup = this.getNodeById(fromGroupId);\n      var oldToGroup = this.getNodeById(oldToGroupId);\n      var newToGroup = null;\n      var newToGroupStartId = null;\n\n      if (newToGroupId != null) {\n        newToGroup = this.getNodeById(newToGroupId);\n      }\n\n      if (newToGroup != null) {\n        newToGroupStartId = newToGroup.startId;\n      }\n\n      if (fromGroup != null && oldToGroup != null) {\n        var childIds = fromGroup.ids;\n\n        // update the children of the from group to point to the new to group\n        if (childIds != null) {\n          for (var c = 0; c < childIds.length; c++) {\n            var childId = childIds[c];\n            var child = this.getNodeById(childId);\n            var transitions = this.getTransitionsByFromNodeId(childId);\n\n            if (transitions != null) {\n\n              // loop through all the transitions from the from group\n              for (var t = 0; t < transitions.length; t++) {\n                var transition = transitions[t];\n\n                if (transition != null) {\n                  var toNodeId = transition.to;\n\n                  if (toNodeId === oldToGroupId) {\n                    // the transition is to the group\n                    if (newToGroupId == null && newToGroupStartId == null) {\n                      // there is no new to group so we will remove the transition\n                      transitions.splice(t, 1);\n                      t--;\n                    } else {\n                      // make the transition point to the new to group\n                      transition.to = newToGroupId;\n                    }\n                  } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                    // the transition is to a node in the group\n                    if (newToGroupId == null && newToGroupStartId == null) {\n                      // there is no new to group so we will remove the transition\n                      transitions.splice(t, 1);\n                      t--;\n                    } else if (newToGroupStartId == null || newToGroupStartId == '') {\n                      // make the transition point to the new to group\n                      transition.to = newToGroupId;\n                    } else {\n                      // make the transition point to the new group start id\n                      transition.to = newToGroupStartId;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /*\n         * remove the transitions from the oldToGroup\n         */\n    if (oldToGroupId != null && newToGroupId != null) {\n\n      var oldToGroup = this.getNodeById(oldToGroupId);\n\n      if (oldToGroup != null) {\n        var childIds = oldToGroup.ids;\n\n        // remove the transitions from the old to group that point to the new to group\n        if (childIds != null) {\n          for (var c = 0; c < childIds.length; c++) {\n            var childId = childIds[c];\n            var child = this.getNodeById(childId);\n            var transitions = this.getTransitionsByFromNodeId(childId);\n\n            if (transitions != null) {\n\n              // loop through all the transitions from the old to group\n              for (var t = 0; t < transitions.length; t++) {\n                var transition = transitions[t];\n\n                if (transition != null) {\n                  var toNodeId = transition.to;\n\n                  if (toNodeId === newToGroupId) {\n                    // the transition is to the group so we will remove it\n                    transitions.splice(t, 1);\n                    t--;\n                  } else if (this.isNodeInGroup(toNodeId, newToGroupId)) {\n                    // the transition is to a node in the group so we will remove it\n                    transitions.splice(t, 1);\n                    t--;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Update the transitions so that the fromGroup points to the newToGroup\n   *\n   * Before\n   * fromGroup -> oldToGroup\n   * newToGroup is dangling and has no transitions to or from it\n   *\n   * After\n   * fromGroup -> newToGroup -> oldToGroup\n   */\n  updateTransitionsForInsertingGroup(fromGroupId, oldToGroupIds, newToGroupId) {\n\n    var fromGroup = null;\n    var newToGroup = null;\n\n    if (fromGroupId != null) {\n      fromGroup = this.getNodeById(fromGroupId);\n    }\n\n    if (newToGroupId != null) {\n      newToGroup = this.getNodeById(newToGroupId);\n    }\n\n    /*\n         * make the transitions that point to the old group now point\n         * to the new group\n         * fromGroup -> newToGroup\n         */\n    if (fromGroup != null && newToGroup != null) {\n      var childIds = fromGroup.ids;\n      var newToGroupStartId = newToGroup.startId;\n\n      if (childIds != null) {\n\n        // loop through all the nodes in the from group\n        for (var c = 0; c < childIds.length; c++) {\n          var childId = childIds[c];\n          var child = this.getNodeById(childId);\n\n          // get the transitions from the child\n          var transitions = this.getTransitionsByFromNodeId(childId);\n\n          if (transitions == null || transitions.length == 0) {\n            /*\n                         * the child does not have any transitions so we will make it\n                         * point to the new group\n                         */\n            if (newToGroupStartId == null || newToGroupStartId == '') {\n              this.addToTransition(child, newToGroupId);\n            } else {\n              this.addToTransition(child, newToGroupStartId)\n            }\n          } else if (transitions != null) {\n\n            // loop through all the transitions from the child\n            for (var t = 0; t < transitions.length; t++) {\n              var transition = transitions[t];\n\n              if (transition != null) {\n                var toNodeId = transition.to;\n\n                if (oldToGroupIds != null) {\n\n                  /*\n                                     * loop through all the old to group ids to find transitions\n                                     * to the old to group\n                                     */\n                  for (var ot = 0; ot < oldToGroupIds.length; ot++) {\n                    var oldToGroupId = oldToGroupIds[ot];\n\n                    if (toNodeId === oldToGroupId) {\n                      /*\n                                             * the transition is to the group so we will update the transition\n                                             * to the new group\n                                             */\n                      transition.to = newToGroupId;\n                    } else if (this.isNodeInGroup(toNodeId, oldToGroupId)) {\n                      /*\n                                             * the transition is to a node in the old group so we will update\n                                             * the transition to point to the new group\n                                             */\n                      if (newToGroupStartId == null || newToGroupStartId == '') {\n                        transition.to = newToGroupId;\n                      } else {\n                        transition.to = newToGroupStartId;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /*\n         * make the steps that do not have a transition now point to the old\n         * group\n         * newToGroup -> oldToGroup\n         */\n    if (newToGroup != null) {\n      var childIds = newToGroup.ids;\n\n      if (childIds != null) {\n\n        // loop through all the children in the new group\n        for (var c = 0; c < childIds.length; c++) {\n          var childId = childIds[c];\n          var child = this.getNodeById(childId);\n\n          // get the transitions for the child\n          var transitions = this.getTransitionsByFromNodeId(childId);\n\n          if (transitions == null || transitions.length == 0) {\n\n            if (oldToGroupIds != null) {\n\n              // loop through all the old groups\n              for (var ot = 0; ot < oldToGroupIds.length; ot++) {\n                var oldToGroupId = oldToGroupIds[ot];\n                var oldToGroup = this.getNodeById(oldToGroupId);\n\n                if (oldToGroup != null) {\n\n                  var oldToGroupStartId = oldToGroup.startId;\n\n                  var transition = {};\n\n                  var toNodeId = '';\n\n                  if (oldToGroupStartId == null) {\n                    // there is no start node id so we will just point to the group\n                    toNodeId = oldToGroup;\n                  } else {\n                    // there is a start node id so we will point to it\n                    toNodeId = oldToGroupStartId;\n                  }\n\n                  // create the transition from the child to the old group\n                  this.addToTransition(child, toNodeId);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Update the child transitions because we are moving a group. We will\n   * update the transitions into and out of the group in the location\n   * we are extracting the group from and also in the location we are\n   * inserting the group into.\n   * @param node the group we are moving\n   * @param nodeId we will put the group after this node id\n   */\n  updateChildrenTransitionsForMovingGroup(node, nodeId) {\n    var transitionsBefore = null;\n\n    // get the group nodes that point to the group we are moving\n    var previousGroupNodes = this.getGroupNodesByToNodeId(node.id);\n\n    // get all the transitions from the group we are moving\n    var transitionsAfter = this.getTransitionsByFromNodeId(node.id);\n\n    var extracted = false;\n\n    /*\n         * extract the group we are moving by updating the transitions of the\n         * from group and the new to group. also remove the transitions from the\n         * group we are moving.\n         */\n\n    // loop through all the groups that point to the group we are moving\n    for (var p = 0; p < previousGroupNodes.length; p++) {\n      var previousGroupNode = previousGroupNodes[p];\n\n      if (transitionsAfter == null || transitionsAfter.length == 0) {\n        // the group we are moving does not have any transitions\n\n        /*\n                 * remove the transitions to the group we are moving and make\n                 * new transitions from the from group to the new to group\n                 */\n        this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, null);\n        extracted = true;\n      } else {\n        // the group we are moving has transitions\n\n        // make the previous group point to the new to group\n        for (var t = 0; t < transitionsAfter.length; t++) {\n          var transitionAfter = transitionsAfter[t];\n\n          if (transitionAfter != null) {\n            var toNodeId = transitionAfter.to;\n\n            /*\n                         * remove the transitions to the group we are moving and make\n                         * new transitions from the from group to the new to group\n                         */\n            this.updateTransitionsForExtractingGroup(previousGroupNode.id, node.id, toNodeId);\n            extracted = true;\n          }\n        }\n      }\n    }\n\n    if (!extracted) {\n      /*\n             * we have not removed the transitions yet because the group\n             * we are moving does not have any groups before it\n             */\n\n      if (transitionsAfter != null) {\n        // remove the transitions from the group we are moving\n        for (var t = 0; t < transitionsAfter.length; t++) {\n          var transitionAfter = transitionsAfter[t];\n\n          if (transitionAfter != null) {\n            var toNodeId = transitionAfter.to;\n\n            // remove the transitions to the group we are moving\n            this.updateTransitionsForExtractingGroup(null, node.id, toNodeId);\n            extracted = true;\n          }\n        }\n      }\n    }\n\n    var inserted = false;\n\n    /*\n         * create the transitions from the from group to the group we are moving\n         * and the transitions from the group we are moving to the old to group\n         */\n    if (nodeId != null) {\n      // get the transitions from the previous group to the next group\n      var transitionsAfter = this.getTransitionsByFromNodeId(nodeId);\n\n      for (var t = 0; t < transitionsAfter.length; t++) {\n        var transitionAfter = transitionsAfter[t];\n\n        if (transitionAfter != null) {\n          var toNodeId = transitionAfter.to;\n\n          /*\n                     * create the transitions that traverse from the from group\n                     * to the group we are moving. also create the transitions\n                     * that traverse from the group we are moving to the old\n                     * to group.\n                     */\n          this.updateTransitionsForInsertingGroup(nodeId, [toNodeId], node.id);\n          inserted = true;\n        }\n      }\n    }\n\n    if (!inserted) {\n      /*\n             * we have not inserted the transitions yet because there were no\n             * previous group transitions\n             */\n\n      if (nodeId == null) {\n        /*\n                 * the previous node id is null which means there was no previous\n                 * group. this means the group we are inserting will become the\n                 * first group. this happens when the group we are moving\n                 * is moved inside the root (group0).\n                 */\n\n        var startGroupId = this.getStartGroupId();\n\n        if (startGroupId != null) {\n\n          // get the start group for the whole project (group0)\n          var startGroup = this.getNodeById(startGroupId);\n\n          if (startGroup != null) {\n\n            // get the first activity\n            var firstGroupId = startGroup.startId;\n\n            /*\n                         * create the transitions that traverse from the group\n                         * we are moving to the previous first activity.\n                         */\n            this.updateTransitionsForInsertingGroup(nodeId, [firstGroupId], node.id);\n          }\n        }\n\n      } else {\n        /*\n                 * we have not inserted the group yet because the from group doesn't\n                 * have a group after it\n                 */\n\n        /*\n                 * create the transitions that traverse from the from group\n                 * to the group we are moving.\n                 */\n        this.updateTransitionsForInsertingGroup(nodeId, null, node.id);\n      }\n    }\n  }\n\n  /**\n   * Check if a component is a connected component\n   * @param nodeId the node id of the component\n   * @param componentId the component that is listening for connected changes\n   * @param connectedComponentId the component that is broadcasting connected changes\n   * @returns whether the componentId is connected to the connectedComponentId\n   */\n  isConnectedComponent(nodeId, componentId, connectedComponentId) {\n\n    var result = false;\n\n    // get the component\n    var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n    if (component != null) {\n\n      var connectedComponents = component.connectedComponents;\n\n      if (connectedComponents != null) {\n\n        // loop through all the connected components\n        for (var c = 0; c < connectedComponents.length; c++) {\n          var connectedComponent = connectedComponents[c];\n\n          if (connectedComponent != null) {\n\n            /*\n                         * check if the connected component id matches the one\n                         * we are looking for. connectedComponent.id is the old\n                         * field we used to store the component id in so we will\n                         * look for that field for the sake of backwards\n                         * compatibility. connectedComponent.componentId is the\n                         * new field we store the component id in.\n                         */\n            if (connectedComponentId === connectedComponent.id ||\n              connectedComponentId === connectedComponent.componentId) {\n              // we have found the connected component id we are looking for\n              result = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get a connected component params\n   * @param componentId the connected component id\n   * @returns the params for the connected component\n   */\n  getConnectedComponentParams(componentContent, componentId) {\n\n    var connectedComponentParams = null;\n\n    if (componentContent != null && componentId != null) {\n\n      // get the connected components\n      var connectedComponents = componentContent.connectedComponents;\n\n      if (connectedComponents != null) {\n\n        // loop through all the connected components\n        for (var c = 0; c < connectedComponents.length; c++) {\n          var connectedComponent = connectedComponents[c];\n\n          if (connectedComponent != null) {\n\n            /*\n                         * check if the connected component id matches the one\n                         * we are looking for. connectedComponent.id is the old\n                         * field we used to store the component id in so we will\n                         * look for that field for the sake of backwards\n                         * compatibility. connectedComponent.componentId is the\n                         * new field we store the component id in.\n                         */\n            if (componentId === connectedComponent.id ||\n              componentId === connectedComponent.componentId) {\n              // we have found the connected component we are looking for\n              connectedComponentParams = connectedComponent;\n            }\n          }\n        }\n      }\n    }\n\n    return connectedComponentParams;\n  }\n\n  /**\n   * Get the active nodes.\n   * @return An array of the active node objects.\n   */\n  getActiveNodes() {\n    return this.project.nodes;\n  }\n\n  /**\n   * Get the inactive nodes\n   * @returns the inactive nodes\n   */\n  getInactiveNodes() {\n    var inactiveNodes = [];\n\n    if (this.project != null) {\n\n      if (this.project.inactiveNodes == null) {\n        this.project.inactiveNodes = [];\n      }\n\n      inactiveNodes = this.project.inactiveNodes;\n    }\n\n    return inactiveNodes;\n  }\n\n  /**\n   * Remove the node from the active nodes\n   * @param nodeId the node to remove\n   * @returns the node that we have removed\n   */\n  removeNodeFromActiveNodes(nodeId) {\n    var node = null;\n\n    if (nodeId != null) {\n      var activeNodes = this.project.nodes;\n      if (activeNodes != null) {\n        for (var a = 0; a < activeNodes.length; a++) {\n          var activeNode = activeNodes[a];\n          if (activeNode != null) {\n            if (nodeId === activeNode.id) {\n              // we have found the node we want to remove\n              node = activeNode;\n\n              // remove the node from the array\n              activeNodes.splice(a, 1);\n\n              if (activeNode.type == 'group') {\n                this.removeChildNodesFromActiveNodes(activeNode);\n              }\n\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return node;\n  }\n\n  /**\n   * Move the child nodes of a group from the active nodes and put them into\n   * the inactive nodes.\n   * @param node The group node.\n   */\n  removeChildNodesFromActiveNodes(node) {\n    if (node != null) {\n      let childIds = node.ids;\n      for (let childId of childIds) {\n        this.removeNodeFromActiveNodes(childId);\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive nodes array\n   * @param nodeId the node to remove\n   * @returns the node that was removed\n   */\n  removeNodeFromInactiveNodes(nodeId) {\n    var node = null;\n\n    if (nodeId != null) {\n\n      let parentGroup = this.getParentGroup(nodeId);\n      if (parentGroup != null) {\n        // The node has a parent so we will remove it from the parent.\n        this.removeChildFromParent(nodeId);\n      }\n\n      // get all the inactive nodes\n      let inactiveNodes = this.project.inactiveNodes;\n\n      if (inactiveNodes != null) {\n\n        // loop through all the inactive nodes\n        for (let i = 0; i < inactiveNodes.length; i++) {\n          let inactiveNode = inactiveNodes[i];\n\n          if (inactiveNode != null) {\n            if (nodeId === inactiveNode.id) {\n              // we have found the node we want to remove\n              node = inactiveNode;\n\n              // remove the node from the array\n              inactiveNodes.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n\n      this.removeNodeFromInactiveStepNodes(nodeId);\n      this.removeNodeFromInactiveGroupNodes(nodeId);\n    }\n\n    return node;\n  }\n\n  /**\n   * Remove the child node from the parent group.\n   * @param nodeId The child node to remove from the parent.\n   */\n  removeChildFromParent(nodeId) {\n    let parentGroup = this.getParentGroup(nodeId);\n    if (parentGroup != null) {\n      // Remove the child from the parent\n      for (let i = 0; i < parentGroup.ids.length; i++) {\n        let childId = parentGroup.ids[i];\n        if (nodeId == childId) {\n          parentGroup.ids.splice(i, 1);\n          break;\n        }\n      }\n      if (nodeId == parentGroup.startId) {\n        /*\n                 * The child we removed was the start id of the group so we\n                 * will update the start id.\n                 */\n        let startIdUpdated = false;\n        let transitions = this.getTransitionsByFromNodeId(nodeId);\n        if (transitions != null &&\n          transitions.length > 0 &&\n          transitions[0] != null &&\n          transitions[0].to != null) {\n          parentGroup.startId = transitions[0].to;\n          startIdUpdated = true;\n        }\n        if (!startIdUpdated && parentGroup.ids.length > 0) {\n          parentGroup.startId = parentGroup.ids[0];\n          startIdUpdated = true;\n        }\n        if (!startIdUpdated) {\n          parentGroup.startId = '';\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive step nodes array.\n   * @param nodeId The node id of the node we want to remove from the\n   * inactive step nodes array.\n   */\n  removeNodeFromInactiveStepNodes(nodeId) {\n    for (let i = 0; i < this.inactiveStepNodes.length; i++) {\n      let inactiveStepNode = this.inactiveStepNodes[i];\n      if (nodeId == inactiveStepNode.id) {\n        this.inactiveStepNodes.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Remove the node from the inactive group nodes array.\n   * @param nodeId The node id of the group we want to remove from the\n   * inactive group nodes array.\n   */\n  removeNodeFromInactiveGroupNodes(nodeId) {\n    for (let i = 0; i < this.inactiveGroupNodes.length; i++) {\n      let inactiveGroupNode = this.inactiveGroupNodes[i];\n      if (nodeId == inactiveGroupNode.id) {\n        this.inactiveGroupNodes.splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  /**\n   * Load the inactive nodes\n   * @param nodes the inactive nodes\n   */\n  loadInactiveNodes(nodes) {\n\n    if (nodes != null) {\n      for (var n = 0; n < nodes.length; n++) {\n        var node = nodes[n];\n\n        if (node != null) {\n          var nodeId = node.id;\n\n          // set the node into the mapping data structures\n          this.setIdToNode(nodeId, node);\n          this.setIdToElement(nodeId, node);\n          if (node.type == 'group') {\n            this.inactiveGroupNodes.push(node);\n          } else {\n            this.inactiveStepNodes.push(node);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Check if the node is active\n   * @param nodeId the node to check\n   * @param componentId (optional) the component to check\n   * @returns whether the node or component is active\n   */\n  isActive(nodeId, componentId) {\n\n    if (nodeId != null) {\n\n      if (nodeId === 'inactiveNodes') {\n        // this occurs when the author puts a step into the inactive nodes\n        return false;\n      } else if (nodeId === 'inactiveGroups') {\n        // this occurs when the author puts a group into the inactive groups\n        return false;\n      } else if (this.isGroupNode(nodeId)) {\n        return this.isGroupActive(nodeId);\n      } else {\n        // the node is a step node\n\n        // get all the active nodes\n        var activeNodes = this.project.nodes;\n\n        if (activeNodes != null) {\n\n          // loop through all the active nodes\n          for (var n = 0; n < activeNodes.length; n++) {\n\n            // get an active node\n            var activeNode = activeNodes[n];\n\n            if (activeNode != null) {\n\n              // get the active node id\n              var activeNodeId = activeNode.id;\n\n              if (nodeId == activeNodeId) {\n                // we have found the node id we are looking for\n\n                if (componentId != null) {\n                  // we need to find the node id and component id\n\n                  // get the components in the node\n                  var activeComponents = activeNode.components;\n\n                  if (activeComponents != null) {\n\n                    // loop through all the components\n                    for (var c = 0; c < activeComponents.length; c++) {\n\n                      // get a component\n                      var activeComponent = activeComponents[c];\n\n                      if (activeComponent != null) {\n                        var activeComponentId = activeComponent.id;\n\n                        if (componentId == activeComponentId) {\n                          /*\n                                                     * we have found the component id we are\n                                                     * looking for so we are done\n                                                     */\n                          return true;\n                        }\n                      }\n                    }\n                  }\n                } else {\n                  //we only need to find the node id so we are done\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if a group is active.\n   * @param nodeId the node id of the group\n   */\n  isGroupActive(nodeId) {\n    for (let activeNode of this.project.nodes) {\n      if (nodeId == activeNode.id) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Move the node to the active nodes array\n   */\n  moveToActive(node) {\n    if (node != null) {\n\n      // make sure the node is inactive\n      if (!this.isActive(node.id)) {\n        // the node is inactive so we will move it to the active array\n\n        // remove the node from inactive nodes array\n        this.removeNodeFromInactiveNodes(node.id);\n\n        // add the node to the active array\n        this.addNode(node);\n\n        if (this.isGroupNode(node.id)) {\n          /*\n                     * This is a group node so we will also move all of its\n                     * children to active.\n                     */\n          let childIds = node.ids;\n          for (let childId of childIds) {\n            let childNode = this.removeNodeFromInactiveNodes(childId);\n            this.addNode(childNode);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Move the node to the inactive nodes array\n   * @param node the node to move\n   * @param nodeIdToInsertAfter place the node after this\n   */\n  moveToInactive(node, nodeIdToInsertAfter) {\n    if (node != null) {\n\n      // make sure the node is active\n      if (this.isActive(node.id)) {\n        // the node is active so we will move it to the inactive array\n\n        // remove the node from the active array\n        this.removeNodeFromActiveNodes(node.id);\n\n        // add the node to the inactive array\n        this.addInactiveNode(node, nodeIdToInsertAfter);\n      }\n    }\n  }\n\n  /**\n   * Add the node to the inactive nodes array\n   * @param node the node to move\n   * @param nodeIdToInsertAfter place the node after this\n   */\n  addInactiveNode(node, nodeIdToInsertAfter) {\n    if (node != null) {\n      var inactiveNodes = this.project.inactiveNodes;\n\n      if (inactiveNodes != null) {\n\n        // clear the transitions from this node\n        if (node.transitionLogic != null) {\n          node.transitionLogic.transitions = [];\n        }\n\n        if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveNodes' || nodeIdToInsertAfter === 'inactiveSteps' || nodeIdToInsertAfter === 'inactiveGroups') {\n          // put the node at the beginning of the inactive steps\n          inactiveNodes.splice(0, 0, node);\n        } else {\n          // put the node after one of the inactive nodes\n\n          var added = false;\n\n          // loop through all the inactive nodes\n          for (var i = 0; i < inactiveNodes.length; i++) {\n            var inactiveNode = inactiveNodes[i];\n\n            if (inactiveNode != null) {\n              if (nodeIdToInsertAfter === inactiveNode.id) {\n                // we have found the position to place the node\n                inactiveNodes.splice(i + 1, 0, node);\n                added = true;\n              }\n            }\n          }\n\n          if (!added) {\n            /*\n                         * we haven't added the node yet so we will just add it\n                         * to the end of the array\n                         */\n            inactiveNodes.push(node);\n          }\n        }\n\n        if (node.type == 'group') {\n          this.inactiveGroupNodes.push(node.id);\n          this.addGroupChildNodesToInactive(node);\n        } else {\n          this.inactiveStepNodes.push(node.id);\n        }\n      }\n    }\n  }\n\n  /**\n   * Add a group's child nodes to the inactive nodes.\n   * @param node The group node.\n   */\n  addGroupChildNodesToInactive(node) {\n    if (node != null) {\n      let childIds = node.ids;\n      for (let childId of childIds) {\n        let childNode = this.getNodeById(childId);\n        this.project.inactiveNodes.push(childNode);\n        this.inactiveStepNodes.push(childNode);\n      }\n    }\n  }\n\n  /**\n   * Move an inactive node within the inactive nodes array\n   * @param node the node to move\n   * @param nodeIdToInsertAfter place the node after this\n   */\n  moveInactiveNode(node, nodeIdToInsertAfter) {\n\n    if (node != null) {\n      var inactiveNodes = this.project.inactiveNodes;\n\n      if (inactiveNodes != null) {\n\n        // remove the node from inactive nodes\n\n        // loop through all the inactive nodes\n        for (var i = 0; i < inactiveNodes.length; i++) {\n          var inactiveNode = inactiveNodes[i];\n\n          if (inactiveNode != null) {\n            if (node.id === inactiveNode.id) {\n              // we have found the node we want to remove\n              inactiveNodes.splice(i, 1);\n            }\n          }\n        }\n\n        // add the node back into the inactive nodes\n\n        if (nodeIdToInsertAfter == null || nodeIdToInsertAfter === 'inactiveSteps' || nodeIdToInsertAfter === 'inactiveNodes') {\n          // put the node at the beginning of the inactive nodes\n          inactiveNodes.splice(0, 0, node);\n        } else {\n          // put the node after one of the inactive nodes\n\n          var added = false;\n\n          // loop through all the inactive nodes\n          for (var i = 0; i < inactiveNodes.length; i++) {\n            var inactiveNode = inactiveNodes[i];\n\n            if (inactiveNode != null) {\n              if (nodeIdToInsertAfter === inactiveNode.id) {\n                // we have found the position to place the node\n                inactiveNodes.splice(i + 1, 0, node);\n                added = true;\n              }\n            }\n          }\n\n          if (!added) {\n            /*\n                         * we haven't added the node yet so we will just add it\n                         * to the end of the array\n                         */\n            inactiveNodes.push(node);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove transitions that go into the group\n   * @param nodeId the group id\n   */\n  removeTransitionsIntoGroup(nodeId) {\n\n    if (nodeId != null) {\n\n      var group = this.getNodeById(nodeId);\n\n      if (group != null) {\n        var childIds = group.ids;\n\n        if (childIds != null) {\n\n          // loop through all the children\n          for (var c = 0; c < childIds.length; c++) {\n            var childId = childIds[c];\n\n            if (childId != null) {\n              this.removeTransitionsThatPointToNodeIdFromOutsideGroup(childId);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove the transitions that point to the node that does not have\n   * the same parent\n   * @param nodeId remove transitions to this node\n   */\n  removeTransitionsThatPointToNodeIdFromOutsideGroup(nodeId) {\n\n    if (nodeId != null) {\n\n      // get the parent of the node\n      var parentGroupId = this.getParentGroupId(nodeId);\n\n      // get all the nodes that point to the node\n      var nodesThatPointToTargetNode = this.getNodesByToNodeId(nodeId);\n\n      if (nodesThatPointToTargetNode != null) {\n\n        // loop through all the nodes that point to the node\n        for (var n = 0; n < nodesThatPointToTargetNode.length; n++) {\n          var nodeThatPointsToTargetNode = nodesThatPointToTargetNode[n];\n\n          if (nodeThatPointsToTargetNode != null) {\n\n            // get the parent of the node that points to the node target node\n            var nodeThatPointsToTargetNodeParentGroupId = this.getParentGroupId(nodeThatPointsToTargetNode.id);\n\n            if (parentGroupId != nodeThatPointsToTargetNodeParentGroupId) {\n              /*\n                             * the parent groups are different so we will remove\n                             * the transition\n                             */\n              this.removeTransition(nodeThatPointsToTargetNode, nodeId);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove a transition\n   * @param node remove a transition in this node\n   * @param toNodeId remove the transition that goes to this node id\n   */\n  removeTransition(node, toNodeId) {\n\n    if (node != null && toNodeId != null) {\n\n      var transitionLogic = node.transitionLogic;\n\n      if (transitionLogic != null) {\n        var transitions = transitionLogic.transitions;\n\n        if (transitions != null) {\n\n          // loop through all the transitions\n          for (var t = 0; t < transitions.length; t++) {\n            var transition = transitions[t];\n\n            if (transition != null) {\n              if (toNodeId === transition.to) {\n                // we have found a transition that goes to the toNodeId\n\n                // remove the transition\n                transitions.splice(t, 1);\n                t--;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Remove transitions that go out of the group\n   * @param nodeId the group id\n   */\n  removeTransitionsOutOfGroup(nodeId) {\n    if (nodeId != null) {\n      var group = this.getNodeById(nodeId);\n\n      if (group != null) {\n        var childIds = group.ids;\n\n        if (childIds != null) {\n\n          // loop through all the child ids\n          for (var c = 0; c < childIds.length; c++) {\n            var childId = childIds[c];\n\n            if (childId != null) {\n\n              // get the transitions of the child\n              var transitions = this.getTransitionsByFromNodeId(childId);\n\n              if (transitions != null) {\n\n                // loop through all the transitions\n                for (var t = 0; t < transitions.length; t++) {\n                  var transition = transitions[t];\n\n                  if (transition != null) {\n\n                    // get the to node id of the transition\n                    var toNodeId = transition.to;\n\n                    if (toNodeId != null) {\n\n                      // get the parent group id of the toNodeId\n                      var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n\n                      if (nodeId != toNodeIdParentGroupId) {\n                        /*\n                                                 * the parent group is different which means it is a\n                                                 * transition that goes out of the group\n                                                 */\n\n                        // remove the transition\n                        transitions.splice(t, 1);\n                        t--;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /*\n     * Update the step transitions that point into the group we are moving\n     * For example\n     * group1 has children node1 and node2 (node2 transitions to node3)\n     * group2 has children node3 and node4 (node4 transitions to node5)\n     * group3 has children node5 and node6\n     * if we move group2 after group3 we will need to change the\n     * transition from node2 to node3 and make node2 transition to node5\n     * the result will be\n     * group1 has children node1 and node2 (node2 transitions to node5)\n     * group3 has children node5 and node6\n     * group2 has children node3 and node4 (node4 transitions to node5)\n     * note: the (node4 transition to node5) will be removed later\n     * when is called removeTransitionsOutOfGroup\n     * note: when group2 is added in a later function call, we will add\n     * the node6 to node3 transition\n     * @param groupThatTransitionsToGroupWeAreMoving the group object\n     * that transitions to the group we are moving. we may need to update\n     * the transitions of this group's children.\n     * @param groupIdWeAreMoving the group id of the group we are moving\n     */\n  updateChildrenTransitionsIntoGroupWeAreMoving(groupThatTransitionsToGroupWeAreMoving, groupIdWeAreMoving) {\n\n    if (groupThatTransitionsToGroupWeAreMoving != null && groupIdWeAreMoving != null) {\n      var group = this.getNodeById(groupIdWeAreMoving);\n\n      if (group != null) {\n        // get all the nodes that have a transition to the node we are removing\n        var nodesByToNodeId = this.getNodesByToNodeId(groupIdWeAreMoving);\n\n        // get the transitions of the node we are removing\n        var nodeToRemoveTransitionLogic = group.transitionLogic;\n        var nodeToRemoveTransitions = [];\n\n        if (nodeToRemoveTransitionLogic != null && nodeToRemoveTransitionLogic.transitions != null) {\n          nodeToRemoveTransitions = nodeToRemoveTransitionLogic.transitions;\n        }\n\n        if (nodeToRemoveTransitions.length == 0) {\n          /*\n                     * The group we are moving is the last group in the project\n                     * and does not have any transitions. We will loop through\n                     * all the nodes that transition into this group and remove\n                     * those transitions.\n                     */\n\n          // get child ids of the group that comes before the group we are moving\n          var childIds = groupThatTransitionsToGroupWeAreMoving.ids;\n\n          if (childIds != null) {\n\n            // loop through all the children\n            for (var c = 0; c < childIds.length; c++) {\n              var childId = childIds[c];\n\n              var transitionsFromChild = this.getTransitionsByFromNodeId(childId);\n\n              if (transitionsFromChild != null) {\n\n                // loop through all the transitions from the child\n                for (var tfc = 0; tfc < transitionsFromChild.length; tfc++) {\n                  var transitionFromChild = transitionsFromChild[tfc];\n\n                  if (transitionFromChild != null) {\n                    var toNodeId = transitionFromChild.to;\n\n                    // get the parent group id of the toNodeId\n                    var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n\n                    if (groupIdWeAreMoving === toNodeIdParentGroupId) {\n                      // the transition is to a child in the group we are moving\n\n                      // remove the transition\n                      transitionsFromChild.splice(tfc, 1);\n\n                      /*\n                                             * move the counter back one because we have just removed an\n                                             * element from the array\n                                             */\n                      tfc--;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        } else if (nodeToRemoveTransitions.length > 0) {\n\n          // get the first group that comes after the group we are removing\n          var firstNodeToRemoveTransition = nodeToRemoveTransitions[0];\n          var firstNodeToRemoveTransitionToNodeId = firstNodeToRemoveTransition.to;\n\n          if (this.isGroupNode(firstNodeToRemoveTransitionToNodeId)) {\n\n            // get the group that comes after the group we are moving\n            var groupNode = this.getNodeById(firstNodeToRemoveTransitionToNodeId);\n\n            // get child ids of the group that comes before the group we are moving\n            var childIds = groupThatTransitionsToGroupWeAreMoving.ids;\n\n            if (childIds != null) {\n\n              // loop through all the children\n              for (var c = 0; c < childIds.length; c++) {\n                var childId = childIds[c];\n\n                var transitionsFromChild = this.getTransitionsByFromNodeId(childId);\n\n                if (transitionsFromChild != null) {\n\n                  // loop through all the transitions from the child\n                  for (var tfc = 0; tfc < transitionsFromChild.length; tfc++) {\n                    var transitionFromChild = transitionsFromChild[tfc];\n\n                    if (transitionFromChild != null) {\n                      var toNodeId = transitionFromChild.to;\n\n                      // get the parent group id of the toNodeId\n                      var toNodeIdParentGroupId = this.getParentGroupId(toNodeId);\n\n                      if (groupIdWeAreMoving === toNodeIdParentGroupId) {\n                        // the transition is to a child in the group we are moving\n\n                        if (groupNode.startId == null) {\n                          // change the transition to point to the after group\n                          transitionFromChild.to = firstNodeToRemoveTransitionToNodeId;\n                        } else {\n                          // change the transition to point to the start id of the after group\n                          transitionFromChild.to = groupNode.startId;\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the node ids and component ids in a node\n   * @param nodeId get the node ids and component ids in this node\n   * @returns an array of objects. the objects contain a node id\n   * and component id.\n   */\n  getNodeIdsAndComponentIds(nodeId) {\n\n    var nodeIdAndComponentIds = [];\n\n    if (nodeId != null) {\n\n      var nodeContent = this.getNodeContentByNodeId(nodeId);\n\n      if (nodeContent != null) {\n\n        var components = nodeContent.components;\n\n        if (components != null) {\n\n          // loop through all the components in the node\n          for (var c = 0; c < components.length; c++) {\n            var component = components[c];\n\n            if (component != null) {\n\n              var componentId = component.id;\n\n              // create an object to hold the node id and component id\n              var nodeIdAndComponentId = {};\n              nodeIdAndComponentId.nodeId = nodeId;\n              nodeIdAndComponentId.componentId = componentId;\n\n              // add the object to the array\n              nodeIdAndComponentIds.push(nodeIdAndComponentId);\n            }\n          }\n        }\n      }\n    }\n\n    return nodeIdAndComponentIds;\n  }\n\n  /**\n   * Get the show previous work node ids and component ids in a node\n   * @param nodeId get the show previous work node ids and component ids in\n   * this node\n   * @returns an array of objects. the objects contain a node id\n   * and component id.\n   */\n  getShowPreviousWorkNodeIdsAndComponentIds(nodeId) {\n\n    var nodeIdAndComponentIds = [];\n\n    if (nodeId != null) {\n      var nodeContent = this.getNodeContentByNodeId(nodeId);\n\n      if (nodeContent != null) {\n\n        var components = nodeContent.components;\n\n        if (components != null) {\n\n          // loop through all the components\n          for (var c = 0; c < components.length; c++) {\n            var component = components[c];\n\n            if (component != null) {\n              var showPreviousWorkNodeId = component.showPreviousWorkNodeId;\n              var showPreviousWorkComponentId = component.showPreviousWorkComponentId;\n\n              if (showPreviousWorkNodeId != null && showPreviousWorkComponentId != null) {\n\n                // create an object to hold the node id and component id\n                var nodeIdAndComponentId = {};\n                nodeIdAndComponentId.nodeId = showPreviousWorkNodeId;\n                nodeIdAndComponentId.componentId = showPreviousWorkComponentId;\n\n                // add the object to the array\n                nodeIdAndComponentIds.push(nodeIdAndComponentId);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return nodeIdAndComponentIds;\n  }\n\n  /**\n   * Check if we need to display the annotation to the student\n   * @param annotation the annotation\n   * @returns whether we need to display the annotation to the student\n   */\n  displayAnnotation(annotation) {\n\n    var result = true;\n\n    if (annotation != null) {\n      var nodeId = annotation.nodeId;\n      var componentId = annotation.componentId;\n\n      // get the component content\n      var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n      if (component != null) {\n        var componentType = component.type;\n\n        // get the component service\n        var componentService = this.$injector.get(componentType + 'Service');\n\n        if (componentService != null && componentService.displayAnnotation != null) {\n          // check if we need to display the annotation to the student\n          result = componentService.displayAnnotation(component, annotation);\n          /*if (annotation.data != null && annotation.data.isGlobal && annotation.data.isPopup) {\n                        result = false;  // don't display annotation inline; it will be displayed in a popup\n                    }*/\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the global annotation properties for the specified component and score, if exists.\n   * @param component the component content\n   * @param previousScore the previousScore we want the annotation properties for, can be null, which means we just want to look at\n   * the currentScore\n   * @param currentScore the currentScore we want the annotation properties for\n   * @returns the annotation properties for the given score\n   */\n  getGlobalAnnotationGroupByScore(component, previousScore, currentScore) {\n\n    let annotationGroup = null;\n\n    if (component.globalAnnotationSettings != null && component.globalAnnotationSettings.globalAnnotationGroups != null) {\n      let globalAnnotationGroups = component.globalAnnotationSettings.globalAnnotationGroups;\n\n      for (let g = 0; g < globalAnnotationGroups.length; g++) {\n        let globalAnnotationGroup = globalAnnotationGroups[g];\n\n        if (globalAnnotationGroup.enableCriteria != null && globalAnnotationGroup.enableCriteria.scoreSequence != null) {\n          let scoreSequence = globalAnnotationGroup.enableCriteria.scoreSequence;\n\n          if (scoreSequence != null) {\n            /*\n                         * get the expected previous score and current score\n                         * that will satisfy the rule\n                         */\n            let previousScoreMatch = scoreSequence[0];\n            let currentScoreMatch = scoreSequence[1];\n\n            if (previousScore == null) {\n              // just matching on the current score\n              if (previousScoreMatch == \"\" &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                // found a match\n                annotationGroup = globalAnnotationGroup;\n                break;\n              }\n            } else {\n              if (previousScore.toString().match(\"[\" + previousScoreMatch + \"]\") &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                /*\n                                 * the previous score and current score match the\n                                 * expected scores so we have found the rule we want\n                                 */\n                annotationGroup = globalAnnotationGroup;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return annotationGroup;\n  }\n\n  /**\n   * Get the notification for the given score, if exists.\n   * @param component the component content\n   * @param previousScore the previousScore we want notification for, can be null, which means we just want to look at\n   * the currentScore\n   * @param currentScore the currentScore we want notification for\n   * @returns the notification for the given score\n   */\n  getNotificationByScore(component, previousScore, currentScore) {\n\n    let notificationResult = null;\n\n    if (component.notificationSettings != null && component.notificationSettings.notifications != null) {\n      let notifications = component.notificationSettings.notifications;\n      for (let n = 0; n < notifications.length; n++) {\n        let notification = notifications[n];\n        if (notification.enableCriteria != null && notification.enableCriteria.scoreSequence != null) {\n          let scoreSequence = notification.enableCriteria.scoreSequence;\n\n          if (scoreSequence != null) {\n\n            /*\n                         * get the expected previous score and current score\n                         * that will satisfy the rule\n                         */\n            let previousScoreMatch = scoreSequence[0];\n            let currentScoreMatch = scoreSequence[1];\n\n            if (previousScore == null) {\n              // just matching on the current score\n              if (previousScoreMatch == \"\" &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                // found a match\n                notificationResult = notification;\n                break;\n              }\n            } else {\n              if (previousScore.toString().match(\"[\" + previousScoreMatch + \"]\") &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                /*\n                                 * the previous score and current score match the\n                                 * expected scores so we have found the rule we want\n                                 */\n                notificationResult = notification;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return notificationResult;\n  }\n\n  /**\n   * Returns a project template for new projects\n   */\n  getNewProjectTemplate() {\n    return {\n      \"nodes\": [\n        {\n          \"id\": \"group0\",\n          \"type\": \"group\",\n          \"title\": \"Master\",\n          \"startId\": \"group1\",\n          \"ids\": [\n            \"group1\"\n          ]\n        },\n        {\n          \"id\": \"group1\",\n          \"type\": \"group\",\n          \"title\": this.$translate('FIRST_ACTIVITY'),\n          \"startId\": \"\",\n          \"ids\": [\n          ],\n          \"icons\": {\n            \"default\": {\n              \"color\": \"#2196F3\",\n              \"type\": \"font\",\n              \"fontSet\": \"material-icons\",\n              \"fontName\": \"info\"\n            }\n          }\n        }\n      ],\n      \"constraints\": [],\n      \"startGroupId\": \"group0\",\n      \"startNodeId\": \"group0\",\n      \"navigationMode\": \"guided\",\n      \"layout\": {\n        \"template\": \"starmap|leftNav|rightNav\"\n      },\n      \"metadata\": {\n        \"title\": \"\"\n      },\n      \"notebook\": {\n        \"enabled\": false,\n        \"label\": this.$translate('NOTEBOOK'),\n        \"enableAddNew\": true,\n        \"itemTypes\": {\n          \"note\": {\n            \"type\": \"note\",\n            \"enabled\": true,\n            \"enableLink\": true,\n            \"enableAddNote\": true,\n            \"enableClipping\": true,\n            \"enableStudentUploads\": true,\n            \"requireTextOnEveryNote\": false,\n            \"label\": {\n              \"singular\": this.$translate('NOTE_LOWERCASE'),\n              \"plural\": this.$translate('NOTES_LOWERCASE'),\n              \"link\": this.$translate('NOTES'),\n              \"icon\": \"note\",\n              \"color\": \"#1565C0\"\n            }\n          },\n          \"question\": {\n            \"type\": \"question\",\n            \"enabled\": false,\n            \"enableLink\": true,\n            \"enableClipping\": true,\n            \"enableStudentUploads\": true,\n            \"label\": {\n              \"singular\": this.$translate('QUESTION_LOWER_CASE'),\n              \"plural\": this.$translate('QUESTIONS_LOWER_CASE'),\n              \"link\": this.$translate('QUESTIONS'),\n              \"icon\": \"live_help\",\n              \"color\": \"#F57C00\"\n            }\n          },\n          \"report\": {\n            \"enabled\": false,\n            \"label\": {\n              \"singular\": this.$translate('REPORT_LOWERCASE'),\n              \"plural\": this.$translate('REPORTS_LOWERCASE'),\n              \"link\": this.$translate('REPORT'),\n              \"icon\": \"assignment\",\n              \"color\": \"#AD1457\"\n            },\n            \"notes\": [\n              {\n                \"reportId\": \"finalReport\",\n                \"title\": this.$translate('FINAL_REPORT'),\n                \"description\": this.$translate('REPORT_DESCRIPTION'),\n                \"prompt\": this.$translate('REPORT_PROMPT'),\n                \"content\": this.$translate('REPORT_CONTENT')\n              }\n            ]\n          }\n        }\n      },\n      \"inactiveNodes\": []\n    };\n  }\n\n  /**\n   * Check if a node generates work by looking at all of its components\n   * @param nodeId the node id\n   * @return whether the node generates work\n   */\n  nodeHasWork(nodeId) {\n    var result = false;\n\n    if (nodeId != null) {\n\n      // get the node content object\n      var nodeContent = this.getNodeContentByNodeId(nodeId);\n\n      if (nodeContent != null) {\n        var components = nodeContent.components;\n\n        if (components != null) {\n\n          // loop through all the components in the node\n          for (var c = 0; c < components.length; c++) {\n            var component = components[c];\n\n            if (component != null) {\n\n              // check if the component generates work\n              var componentHasWork = this.componentHasWork(component);\n\n              if (componentHasWork) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if a component generates work\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @return whether the component generates work\n   */\n  componentHasWorkByNodeIdAndComponentId(nodeId, componentId) {\n    var result = false;\n\n    if (nodeId != null) {\n\n      // get the node content object\n      var nodeContent = this.getNodeContentByNodeId(nodeId);\n\n      if (nodeContent != null) {\n        var components = nodeContent.components;\n\n        if (components != null) {\n\n          // loop through the components\n          for (var c = 0; c < components.length; c++) {\n            var component = components[c];\n\n            if (component != null && componentId == component.id) {\n              // we have found the component we are looking for\n\n              // check if the component generates work\n              var componentHasWork = this.componentHasWork(component);\n\n              if (componentHasWork) {\n                // the component generates work\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if a component generates work\n   * @param component check if this component generates work\n   * @return whether the component generates work\n   */\n  componentHasWork(component) {\n    var result = false;\n\n    if (component != null) {\n      var componentType = component.type;\n\n      // get the component service\n      var componentService = this.getComponentService(componentType);\n\n      if (componentService != null) {\n        // check if the component generates work\n        result = componentService.componentHasWork(component);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get a component service\n   * @param componentType the component type\n   * @return the component service\n   */\n  getComponentService(componentType) {\n\n    var componentService = null;\n\n    if (componentType != null) {\n\n      // get the component service name e.g. 'OpenResponseService'\n      var componentServiceName = componentType + 'Service';\n\n      /*\n             * check if we have previously retrieved the component service.\n             * if have previously retrieved the component service it will\n             * be in the componentServices map\n             */\n      componentService = this.componentServices[componentServiceName];\n\n      if (componentService == null) {\n        /*\n                 * we have not previously retrieved the component service so\n                 * we will get it now\n                 */\n        componentService = this.$injector.get(componentServiceName);\n\n        /*\n                 * save the component service to the map so we can easily\n                 * retrieve it later\n                 */\n        this.componentServices[componentServiceName] = componentService;\n      }\n    }\n\n    return componentService;\n  }\n\n  /**\n   * Check if a node is inactive. At the moment only step nodes can be\n   * inactive.\n   * @param nodeId the node id of the step\n   */\n  isInactive(nodeId) {\n\n    var result = false;\n\n    if (nodeId != null && this.project.inactiveNodes != null) {\n\n      // loop through all the inactive nodes\n      for (var i = 0; i < this.project.inactiveNodes.length; i++) {\n\n        // get an inactive node\n        var inactiveNode = this.project.inactiveNodes[i];\n\n        if (inactiveNode != null) {\n\n          if (nodeId === inactiveNode.id) {\n            /*\n                         * we have found the node id we are looking for which\n                         * means the node is inactive\n                         */\n            result = true;\n            break;\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Get an unused component id\n   * @param componentIdsToSkip (optional) An array of additional component ids\n   * to skip. This is used when we are creating multiple new components. There\n   * is avery small chance that we create duplicate component ids that aren't\n   * already in the project. We avoid this problem by using this parameter.\n   * Example\n   * We want to create two new components. We first generate a new component\n   * id for the first new component for example \"1234567890\". Then we generate\n   * a new component id for the second new component and pass in\n   * [\"1234567890\"] as componentIdsToSkip because the new \"1234567890\"\n   * component hasn't actually been added to the project yet.\n   * @return a component id that isn't already being used in the project\n   */\n  getUnusedComponentId(componentIdsToSkip) {\n    // we want to make an id with 10 characters\n    var idLength = 10;\n\n    // generate a new id\n    var newComponentId = this.UtilService.generateKey(idLength);\n\n    // check if the component id is already used in the project\n    if (this.isComponentIdUsed(newComponentId)) {\n      /*\n             * the component id is already used in the project so we need to\n             * try generating another one\n             */\n      var alreadyUsed = true;\n\n      /*\n             * keep trying to generate a new component id until we have found\n             * one that isn't already being used\n             */\n      while(!alreadyUsed) {\n        // generate a new id\n        newComponentId = this.UtilService.generateKey(idLength);\n\n        // check if the id is already being used in the project\n        alreadyUsed = this.isComponentIdUsed(newComponentId);\n\n        if (componentIdsToSkip != null && componentIdsToSkip.indexOf(newComponentId) != -1) {\n          /*\n                     * the new component is in the componentIdsToSkip so it has\n                     * already been used\n                     */\n          alreadyUsed = true;\n        }\n      }\n    }\n\n    return newComponentId;\n  }\n\n  /**\n   * Check if the component id is already being used in the project\n   * @param componentId check if this component id is already being used in\n   * the project\n   * @return whether the component id is already being used in the project\n   */\n  isComponentIdUsed(componentId) {\n    var isUsed = false;\n\n    // loop through all the active nodes\n    for (var n = 0; n < this.project.nodes.length; n++) {\n\n      // get an active node\n      var node = this.project.nodes[n];\n\n      if (node != null) {\n        var components = node.components;\n\n        if (components != null) {\n\n          // loop through all the components\n          for (var c = 0; c < components.length; c++) {\n            var component = components[c];\n\n            if (component != null) {\n              if (componentId === component.id) {\n                // the component id is already being used\n                isUsed = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // loop through all the inactive nodes\n    for (var n = 0; n < this.project.inactiveNodes.length; n++) {\n\n      // get an inactive node\n      var node = this.project.inactiveNodes[n];\n\n      if (node != null) {\n        var components = node.components;\n\n        if (components != null) {\n\n          // loop through all the components\n          for (var c = 0; c < components.length; c++) {\n            var component = components[c];\n\n            if (component != null) {\n              if (componentId === component.id) {\n                // the component id is already being used\n                isUsed = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return isUsed;\n  }\n\n  /**\n   * Check if a node id is already being used in the project\n   * @param nodeId check if this node id is already being used in the project\n   * @return whether the node id is already being used in the project\n   */\n  isNodeIdUsed(nodeId) {\n    var isUsed = false;\n\n    // loop through all the active nodes\n    for (var n = 0; n < this.project.nodes.length; n++) {\n\n      // get an active node\n      var node = this.project.nodes[n];\n\n      if (node != null) {\n\n        if (nodeId === node.id) {\n          return true;\n        }\n      }\n    }\n\n    // loop through all the inactive nodes\n    for (var n = 0; n < this.project.inactiveNodes.length; n++) {\n\n      // get an inactive node\n      var node = this.project.inactiveNodes[n];\n\n      if (node != null) {\n\n        if (nodeId === node.id) {\n          return true;\n        }\n      }\n    }\n\n    return isUsed;\n  }\n\n  /**\n   * Copy the nodes into the project\n   * @param selectedNodes the nodes to import\n   * @param fromProjectId copy the nodes from this project\n   * @param toProjectId copy the nodes into this project\n   * @param nodeIdToInsertInsideOrAfter If this is a group, we will make the\n   * new step the first step in the group. If this is a step, we will place\n   * the new step after it.\n   */\n  copyNodes(selectedNodes, fromProjectId, toProjectId, nodeIdToInsertInsideOrAfter) {\n\n    // get the import steps URL\n    var importStepsURL = this.ConfigService.getConfigParam('importStepsURL');\n\n    var httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = importStepsURL;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    // set the POST params\n    var params = {};\n    params.steps = angular.toJson(selectedNodes);\n    params.fromProjectId = fromProjectId;\n    params.toProjectId = toProjectId;\n    httpParams.data = $.param(params);\n\n    /*\n         * Make the request to import the steps. This will copy the asset files\n         * and change file names if necessary. If an asset file with the same\n         * name exists in both projects we will check if their content is the\n         * same. If the content is the same we don't need to copy the file. If\n         * the content is different, we need to make a copy of the file with a\n         * new name and change all the references in the steps to use the new\n         * name.\n         */\n    return this.$http(httpParams).then((result) => {\n\n      // get the selected nodes from the result that may have been modified\n      selectedNodes = result.data;\n\n      // get the inactive nodes from the project\n      var inactiveNodes = this.getInactiveNodes();\n\n      // used to hold all the new nodes\n      var newNodes = [];\n\n      // used to hold all the new node ids\n      var newNodeIds = [];\n\n      // loop through the nodes we will import\n      for (var n = 0; n < selectedNodes.length; n++) {\n\n        // get a node\n        var selectedNode = selectedNodes[n];\n\n        if (selectedNode != null) {\n\n          // make a copy of the node so that we don't modify the source\n          var tempNode = this.UtilService.makeCopyOfJSONObject(selectedNode);\n\n          // check if the node id is already being used in the current project\n          if (this.isNodeIdUsed(tempNode.id)) {\n            // the node id is already being used in the current project\n\n            // get the next available node id\n            var nextAvailableNodeId = this.getNextAvailableNodeId(newNodeIds);\n\n            // change the node id of the node we are importing\n            tempNode.id = nextAvailableNodeId;\n          }\n\n          // get the components in the node\n          var tempComponents = tempNode.components;\n\n          if (tempComponents != null) {\n\n            // loop through all the components in the node we are importing\n            for (var c = 0; c < tempComponents.length; c++) {\n\n              // get a component\n              var tempComponent = tempComponents[c];\n\n              if (tempComponent != null) {\n\n                // check if the component id is already being used\n                if (this.isComponentIdUsed(tempComponent.id)) {\n                  // we are already using the component id so we will need to change it\n\n                  // find a component id that isn't currently being used\n                  var newComponentId = this.getUnusedComponentId();\n\n                  // set the new component id into the component\n                  tempComponent.id = newComponentId;\n                }\n              }\n            }\n          }\n\n          // clear the constraints\n          tempNode.constraints = [];\n\n          // add the new node and new node id to our arrays\n          newNodes.push(tempNode);\n          newNodeIds.push(tempNode.id);\n        }\n      }\n\n      if (nodeIdToInsertInsideOrAfter == null) {\n        /*\n                 * the place to put the new node has not been specified so we\n                 * will place it in the inactive steps section\n                 */\n\n        /*\n                 * Insert the node after the last inactive node. If there\n                 * are no inactive nodes it will just be placed in the\n                 * inactive nodes section. In the latter case we do this by\n                 * setting nodeIdToInsertInsideOrAfter to 'inactiveSteps'.\n                 */\n        if (inactiveNodes != null && inactiveNodes.length > 0) {\n          nodeIdToInsertInsideOrAfter = inactiveNodes[inactiveNodes.length - 1];\n        } else {\n          nodeIdToInsertInsideOrAfter = 'inactiveSteps';\n        }\n      }\n\n      // loop through all the new nodes\n      for (var nn = 0; nn < newNodes.length; nn++) {\n        var newNode = newNodes[nn];\n\n        if (this.isGroupNode(nodeIdToInsertInsideOrAfter)) {\n          // we want to make the new step the first step in the given activity\n          this.createNodeInside(newNode, nodeIdToInsertInsideOrAfter);\n        } else {\n          // we want to place the new step after the given step\n          this.createNodeAfter(newNode, nodeIdToInsertInsideOrAfter);\n        }\n\n        /*\n                 * Update the nodeIdToInsertInsideOrAfter so that when we are\n                 * importing multiple steps, the steps get placed in the correct\n                 * order.\n                 *\n                 * Example\n                 * We are importing nodeA and nodeB and want to place them after\n                 * nodeX. Therefore we want the order to be\n                 *\n                 * nodeX\n                 * nodeA\n                 * nodeB\n                 *\n                 * This means after we add nodeA, we must update\n                 * nodeIdToInsertInsideOrAfter to be nodeA so that when we add\n                 * nodeB, it will be placed after nodeA.\n                 */\n        nodeIdToInsertInsideOrAfter = newNode.id;\n      }\n\n      return newNodes;\n    });\n  }\n\n  /**\n   * Get the next available constraint id for a node\n   * @param nodeId get the next available constraint id for this node\n   * e.g. node8Constraint2\n   * @return the next available constraint id for the node\n   */\n  getNextAvailableConstraintIdForNodeId(nodeId) {\n\n    var nextAvailableConstraintId = null;\n\n    if (nodeId != null) {\n\n      // an array to hold the constraint ids that are already being used\n      var usedConstraintIds = [];\n\n      // get the node\n      var node = this.getNodeById(nodeId);\n\n      if (node != null) {\n        var constraints = node.constraints;\n\n        if (constraints != null) {\n\n          // loop through all the constraints\n          for (var c = 0; c < constraints.length; c++) {\n            var constraint = constraints[c];\n\n            if (constraint != null) {\n              var constraintId = constraint.id;\n\n              // add the constraint id to the array of used constraint ids\n              usedConstraintIds.push(constraintId);\n            }\n          }\n        }\n      }\n\n      var foundNextAvailableConstraintId = false;\n      var counter = 1;\n\n      // loop until we have found a constraint id that hasn't been used\n      while(!foundNextAvailableConstraintId) {\n\n        // generate a constraint id\n        var potentialConstraintId = nodeId + 'Constraint' + counter;\n\n        // check if the constraint id has been used\n        if (usedConstraintIds.indexOf(potentialConstraintId) == -1) {\n          // we have found a constraint id that has not been used\n          nextAvailableConstraintId = potentialConstraintId;\n\n          // we are done looping\n          foundNextAvailableConstraintId = true;\n        } else {\n          // we have found a constraint id that has been used\n          counter++;\n        }\n      }\n    }\n\n    return nextAvailableConstraintId;\n  }\n\n  /**\n   * Set a field in the transition logic of a node\n   */\n  setTransitionLogicField(nodeId, field, value) {\n\n    if (nodeId != null && field != null) {\n\n      // get the node\n      var node = this.getNodeById(nodeId);\n\n      if (node != null) {\n\n        // get the transition logic\n        var transitionLogic = node.transitionLogic;\n\n        if (transitionLogic != null) {\n\n          // set the value of the field\n          transitionLogic[field] = value;\n        }\n      }\n    }\n  }\n\n  /**\n   * Set the criteria params field\n   * @param criteria the criteria object\n   * @param field the field name\n   * @param value the value to set into the field\n   */\n  setCriteriaParamsField(criteria, field, value) {\n\n    if (criteria != null) {\n\n      if (criteria.params == null) {\n\n        // create a params field since it does not exist\n        criteria.params = {};\n      }\n\n      // set the value of the field\n      criteria.params[field] = value;\n    }\n  }\n\n  /**\n   * Get the criteria params field\n   * @param criteria the criteria object\n   * @param field the field name\n   */\n  getCriteriaParamsField(criteria, field) {\n\n    if (criteria != null) {\n\n      // get the params\n      var params = criteria.params;\n\n      if (params != null) {\n        // get the field value\n        return params[field];\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Set the transition to value of a node\n   * @param fromNodeId the from node\n   * @param toNodeId the to node\n   */\n  setTransition(fromNodeId, toNodeId) {\n    var node = this.getNodeById(fromNodeId);\n\n    if (node != null) {\n      // get the transition logic of the node\n      var transitionLogic = node.transitionLogic;\n\n      if (transitionLogic != null) {\n\n        // get the transitions\n        var transitions = transitionLogic.transitions;\n\n        if (transitions == null || transitions.length == 0) {\n          // there are no transitions so we will create one\n          transitionLogic.transitions = [];\n\n          // create a transition object\n          var transition = {};\n          transitionLogic.transitions.push(transition);\n\n          transitions = transitionLogic.transitions;\n        }\n\n        if (transitions != null && transitions.length > 0) {\n\n          // get the first transition. we will assume there is only one transition.\n          var transition = transitions[0];\n\n          if (transition != null) {\n            // set the to value\n            transition.to = toNodeId;\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the node id that comes after a given node id\n   * @param nodeId get the node id that comes after this node id\n   * @param the node id that comes after the one that is passed in as a parameter\n   */\n  getNodeIdAfter(nodeId) {\n\n    var nodeIdAfter = null;\n\n    // get an array of ordered items. each item represents a node\n    var orderedItems = this.$filter('orderBy')(this.$filter('toArray')(this.idToOrder), 'order');\n\n    if (orderedItems != null) {\n\n      var foundNodeId = false;\n\n      // loop through all the items\n      for (var i = 0; i < orderedItems.length; i++) {\n\n        // get an item\n        var item = orderedItems[i];\n\n        if (item != null) {\n          // get the node id of the item\n          var tempNodeId = item.$key;\n\n          // check if we have found the node id that was passed in as a parameter\n          if (foundNodeId) {\n            /*\n                         * we have previously found the node id that was passed in which means\n                         * the current temp node id is the one that comes after it\n                         */\n            nodeIdAfter = tempNodeId;\n            break;\n          } else {\n\n            if (nodeId == tempNodeId) {\n              // we have found the node id that was passed in as a parameter\n              foundNodeId = true;\n            }\n          }\n        }\n      }\n    }\n\n    return nodeIdAfter;\n  }\n\n  /**\n   * Get the node ids in the branch by looking for nodes that have branch\n   * path taken constraints with the given fromNodeId and toNodeId\n   * @param fromNodeId the from node id\n   * @param toNodeId the to node id\n   * @return an array of nodes that are in the branch path\n   */\n  getNodeIdsInBranch(fromNodeId, toNodeId) {\n\n    var nodeIdsInBranch = [];\n\n    // get all the nodes in the project\n    var nodes = this.getNodes();\n\n    if (nodes != null) {\n\n      // loop through all the nodes\n      for (var n = 0; n < nodes.length; n++) {\n        var node = nodes[n];\n\n        if (node != null) {\n          if (this.hasBranchPathTakenConstraint(node, fromNodeId, toNodeId)) {\n            /*\n                         * this node has the the branch path taken constraint we are\n                         * looking for\n                         */\n            nodeIdsInBranch.push(node.id);\n          }\n        }\n      }\n    }\n\n    this.orderNodeIds(nodeIdsInBranch);\n\n    return nodeIdsInBranch;\n  }\n\n  /**\n   * Order the node ids so that they show up in the same order as in the\n   * project.\n   * @param constraints An array of node ids.\n   * @return An array of ordered node ids.\n   */\n  orderNodeIds(nodeIds) {\n    let orderedNodeIds = this.getFlattenedProjectAsNodeIds();\n    return nodeIds.sort(this.nodeIdsComparatorGenerator(orderedNodeIds));\n  }\n\n  /**\n   * Create the node ids comparator function that is used for sorting an\n   * array of node ids.\n   * @param orderedNodeIds An array of node ids in the order in which they\n   * show up in the project.\n   * @return A comparator that orders node ids in the order in which they show\n   * up in the project.\n   */\n  nodeIdsComparatorGenerator(orderedNodeIds) {\n    return function(nodeIdA, nodeIdB) {\n      let nodeIdAIndex = orderedNodeIds.indexOf(nodeIdA);\n      let nodeIdBIndex = orderedNodeIds.indexOf(nodeIdB);\n      if (nodeIdAIndex < nodeIdBIndex) {\n        return -1;\n      } else if (nodeIdAIndex > nodeIdBIndex) {\n        return 1;\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Check if a node has a branch path taken constraint\n   * @param node the node to check\n   * @param fromNodeId the from node id of the branch path taken\n   * @param toNodeId the to node id of the branch path taken\n   * @return whether the node has a branch path taken constraint with the\n   * given from node id and to node id\n   */\n  hasBranchPathTakenConstraint(node, fromNodeId, toNodeId) {\n\n    if (node != null) {\n\n      // get the constraints in the node\n      var constraints = node.constraints;\n\n      if (constraints != null) {\n\n        // loop through all the constraints\n        for (var c = 0; c < constraints.length; c++) {\n          var constraint = constraints[c];\n\n          if (constraint != null) {\n\n            // get the removal criteria of the constraint\n            var removalCriteria = constraint.removalCriteria;\n\n            if (removalCriteria != null) {\n\n              // loop through all the removal criterion\n              for (var r = 0; r < removalCriteria.length; r++) {\n\n                // get a removal criterion\n                var removalCriterion = removalCriteria[r];\n\n                if (removalCriterion != null) {\n\n                  // get the removal criterion name\n                  var name = removalCriterion.name;\n\n                  if (name == 'branchPathTaken') {\n                    // this is a branch path taken constraint\n\n                    // get the removal criterion params\n                    var params = removalCriterion.params;\n\n                    if (params != null) {\n                      if (fromNodeId == params.fromNodeId && toNodeId == params.toNodeId) {\n                        // the params match the from node id and to node id\n                        return true;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Add branch path taken constraints to the node\n   * @param targetNodeId the node to add the constraints to\n   * @param fromNodeId the from node id of the branch path taken constraint\n   * @param toNodeId the to node id of the branch path taken constraint\n   */\n  addBranchPathTakenConstraints(targetNodeId, fromNodeId, toNodeId) {\n\n    if (targetNodeId != null) {\n\n      // get the node\n      var node = this.getNodeById(targetNodeId);\n\n      if (node != null) {\n\n        /*\n                 * create the constraint that makes the node not visible until\n                 * the given branch path is taken\n                 */\n        var makeThisNodeNotVisibleConstraint = {};\n        makeThisNodeNotVisibleConstraint.id = this.getNextAvailableConstraintIdForNodeId(targetNodeId);\n        makeThisNodeNotVisibleConstraint.action = 'makeThisNodeNotVisible';\n        makeThisNodeNotVisibleConstraint.targetId = targetNodeId;\n        makeThisNodeNotVisibleConstraint.removalCriteria = [];\n        var notVisibleRemovalCriterion = {};\n        notVisibleRemovalCriterion.name = 'branchPathTaken';\n        notVisibleRemovalCriterion.params = {};\n        notVisibleRemovalCriterion.params.fromNodeId = fromNodeId;\n        notVisibleRemovalCriterion.params.toNodeId = toNodeId;\n        makeThisNodeNotVisibleConstraint.removalConditional = 'all';\n        makeThisNodeNotVisibleConstraint.removalCriteria.push(notVisibleRemovalCriterion);\n        node.constraints.push(makeThisNodeNotVisibleConstraint);\n\n        /*\n                 * create the constraint that makes the node not visitable until\n                 * the given branch path is taken\n                 */\n        var makeThisNodeNotVisitableConstraint = {};\n        makeThisNodeNotVisitableConstraint.id = this.getNextAvailableConstraintIdForNodeId(targetNodeId);\n        makeThisNodeNotVisitableConstraint.action = 'makeThisNodeNotVisitable';\n        makeThisNodeNotVisitableConstraint.targetId = targetNodeId;\n        makeThisNodeNotVisitableConstraint.removalCriteria = [];\n        var notVisitableRemovalCriterion = {};\n        notVisitableRemovalCriterion.name = 'branchPathTaken';\n        notVisitableRemovalCriterion.params = {};\n        notVisitableRemovalCriterion.params.fromNodeId = fromNodeId;\n        notVisitableRemovalCriterion.params.toNodeId = toNodeId;\n        makeThisNodeNotVisitableConstraint.removalConditional = 'all';\n        makeThisNodeNotVisitableConstraint.removalCriteria.push(notVisitableRemovalCriterion);\n        node.constraints.push(makeThisNodeNotVisitableConstraint);\n      }\n    }\n  }\n\n  /**\n   * Remove the branch path taken constraints from a node\n   * @param nodeId remove the constraints from this node\n   */\n  removeBranchPathTakenNodeConstraints(nodeId) {\n\n    // get a node\n    var node = this.getNodeById(nodeId);\n\n    if (node != null) {\n\n      // get the constraints\n      var constraints = node.constraints;\n\n      if (constraints != null) {\n\n        // loop through all the constraints\n        for (var c = 0; c < constraints.length; c++) {\n          var constraint = constraints[c];\n\n          if (constraint != null) {\n\n            // get the removal criteria\n            var removalCriteria = constraint.removalCriteria;\n\n            if (removalCriteria != null) {\n\n              // loop through all the removal criteria\n              for (var rc = 0; rc < removalCriteria.length; rc++) {\n\n                // get a removal criterion\n                var removalCriterion = removalCriteria[rc];\n\n                if (removalCriterion != null) {\n                  if (removalCriterion.name == 'branchPathTaken') {\n                    // this is a branch path taken removal criterion\n                    var params = removalCriterion.params;\n\n                    // remove the constraint\n                    constraints.splice(c, 1);\n\n                    // move the counter back one because we just removed a constraint\n                    c--;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the branch path taken constraints from a node\n   * @param nodeId get the branch path taken constraints from this node\n   * @return an array of branch path taken constraints from the node\n   */\n  getBranchPathTakenConstraintsByNodeId(nodeId) {\n\n    var branchPathTakenConstraints = [];\n\n    if (nodeId != null) {\n\n      // get the node\n      var node = this.getNodeById(nodeId);\n\n      if (node != null) {\n\n        // get the constraints from the node\n        var constraints = node.constraints;\n\n        if (constraints != null) {\n\n          // loop through all the constraints\n          for (var c = 0; c < constraints.length; c++) {\n            var constraint = constraints[c];\n\n            if (constraint != null) {\n\n              // get the removal criteria from the constraint\n              var removalCriteria = constraint.removalCriteria;\n\n              if (removalCriteria != null) {\n\n                // loop through all the removal criteria\n                for (var rc = 0; rc < removalCriteria.length; rc++) {\n                  var removalCriterion = removalCriteria[rc];\n\n                  if (removalCriterion != null) {\n                    if (removalCriterion.name == 'branchPathTaken') {\n                      /*\n                                             * we have found a branch path taken constraint so\n                                             * we will add the constraint to the array\n                                             */\n                      branchPathTakenConstraints.push(constraint);\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return branchPathTakenConstraints;\n  }\n\n  /**\n   * Update the branch path taken constraint\n   * @param node update the branch path taken constraints in this node\n   * @param currentFromNodeId the current from node id\n   * @param currentToNodeId the current to node id\n   * @param newFromNodeId the new from node id\n   * @param newToNodeId the new to node id\n   */\n  updateBranchPathTakenConstraint(node, currentFromNodeId, currentToNodeId, newFromNodeId, newToNodeId) {\n\n    if (node != null) {\n      var constraints = node.constraints;\n\n      if (constraints != null) {\n\n        // loop through all the constraints for the node\n        for (var c = 0; c < constraints.length; c++) {\n          var constraint = constraints[c];\n\n          if (constraint != null) {\n\n            var removalCriteria = constraint.removalCriteria;\n\n            if (removalCriteria != null) {\n\n              // loop through all the removal criteria\n              for (var r = 0; r < removalCriteria.length; r++) {\n                var removalCriterion = removalCriteria[r];\n\n                if (removalCriterion != null) {\n\n                  if (removalCriterion.name === 'branchPathTaken') {\n                    // we have found a branchPathTaken removal criterion\n\n                    var params = removalCriterion.params;\n\n                    if (params != null) {\n\n                      if (params.fromNodeId === currentFromNodeId &&\n                        params.toNodeId === currentToNodeId) {\n\n                        /*\n                                                 * we have found a branchPathTaken removal criterion\n                                                 * with the fromNodeId and toNodeId that we are\n                                                 * looking for so we will now update the values\n                                                 */\n                        params.fromNodeId = newFromNodeId;\n                        params.toNodeId = newToNodeId;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get the project level rubric\n   * @return the project level rubric\n   */\n  getProjectRubric() {\n    return this.project.rubric;\n  }\n\n  /**\n   * Set the project level rubric\n   */\n  setProjectRubric(html) {\n    this.project.rubric = html;\n  }\n\n  /**\n   * Check if a node is a branch point\n   * @param nodeId the node id\n   * @return whether the node is a branch point\n   */\n  isBranchPoint(nodeId) {\n\n    var transitions = this.getTransitionsByFromNodeId(nodeId);\n\n    if (transitions != null) {\n      if (transitions.length > 1) {\n        /*\n                 * the node contains more than one transition which means it is\n                 * a branch point\n                 */\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if a node is the first node in a branch path\n   * @param nodeId the node id\n   * @return whether the node is the first node in a branch path\n   */\n  isFirstNodeInBranchPath(nodeId) {\n\n    var nodes = this.getNodes();\n\n    if (nodes != null) {\n      for (var n = 0; n < nodes.length; n++) {\n        var node = nodes[n];\n\n        if (node != null &&\n          node.transitionLogic != null &&\n          node.transitionLogic.transitions != null) {\n\n          var transitions = node.transitionLogic.transitions;\n\n          if (transitions.length > 1) {\n            /*\n                         * there is more than one transition from this node\n                         * which means it is a branch point\n                         */\n\n            for (var t = 0; t < transitions.length; t++) {\n              var transition = transitions[t];\n\n              if (transition != null) {\n                var transitionTo = transition.to;\n\n                if (transitionTo === nodeId) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if the node is in any branch path\n   * @param nodeId the node id of the node\n   * @return whether the node is in any branch path\n   */\n  isNodeInAnyBranchPath(nodeId) {\n\n    var result = false;\n\n    if (this.nodeIdToIsInBranchPath[nodeId] == null) {\n      /*\n             * we have not calculated whether the node id is in a branch path\n             * before so we will now\n             */\n\n      // get the branches in the project\n      var branches = this.getBranches();\n\n      // check if the node id is in any of the branches\n      result = this.isNodeIdInABranch(branches, nodeId);\n\n      // remember the result for this node id\n      this.nodeIdToIsInBranchPath[nodeId] = result;\n    } else {\n      /*\n             * we have calculated whether the node id is in a branch path\n             * before\n             */\n      result = this.nodeIdToIsInBranchPath[nodeId];\n    }\n\n    return result;\n  }\n\n  /**\n   * Check if a node is a branch start point\n   * @param nodeId look for a branch with this start node id\n   * @return whether the node is a branch start point\n   */\n  isBranchStartPoint(nodeId) {\n\n    /*\n         * Get all the branches. Each branch is represented as an object that\n         * contains the branchStartPoint, branchEndPoint, and branchPaths.\n         */\n    var branches = this.getBranches();\n\n    if (branches != null) {\n\n      // loop through all the branches\n      for (var b = 0; b < branches.length; b++) {\n        var branch = branches[b];\n\n        if (branch != null) {\n          if (branch.branchStartPoint == nodeId) {\n            /*\n                         * we have found a branch with the given nodeId as the\n                         * start point\n                         */\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if a node is a branch end point\n   * @param nodeId look for a branch with this end node id\n   * @return whether the node is a branch end point\n   */\n  isBranchMergePoint(nodeId) {\n\n    /*\n         * Get all the branches. Each branch is represented as an object that\n         * contains the branchStartPoint, branchEndPoint, and branchPaths.\n         */\n    var branches = this.getBranches();\n\n    if (branches != null) {\n\n      // loop through all the branches\n      for (var b = 0; b < branches.length; b++) {\n        var branch = branches[b];\n\n        if (branch != null) {\n          if (branch.branchEndPoint == nodeId) {\n            /*\n                         * we have found a branch with the given nodeId as the\n                         * end point\n                         */\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get all the branches whose branch start point is the given node id\n   * @param nodeId the branch start point\n   * @return an array of branches that have the given branch start point\n   */\n  getBranchesByBranchStartPointNodeId(nodeId) {\n\n    var branches = [];\n\n    // get all the branches in the project\n    var allBranches = this.getBranches();\n\n    if (allBranches != null) {\n\n      // loop through all the branches in the project\n      for (var b = 0; b < allBranches.length; b++) {\n        var branch = allBranches[b];\n\n        if (branch != null) {\n\n          if (nodeId == branch.branchStartPoint) {\n            /*\n                         * the branch start point matches the node id we are\n                         * looking for\n                         */\n            branches.push(branch);\n          }\n        }\n      }\n    }\n\n    return branches;\n  }\n\n  /**\n   * Calculate the node numbers and set them into the nodeIdToNumber map\n   */\n  calculateNodeNumbers() {\n\n    // clear the node id to number mapping\n    this.nodeIdToNumber = {};\n\n    // clear the node id to branch path letter mapping\n    this.nodeIdToBranchPathLetter = {};\n\n    // get the start node id\n    var startNodeId = this.getStartNodeId();\n\n    var currentActivityNumber = 0;\n    var currentStepNumber = 0;\n\n    /*\n         * recursively calculate the node numbers by traversing the project\n         * tree\n         */\n    this.calculateNodeNumbersHelper(startNodeId, currentActivityNumber, currentStepNumber);\n  }\n\n  /**\n   * Recursively calcualte the node numbers by traversing the project tree\n   * using transitions\n   * @param nodeId the current node id we are on\n   * @param currentActivityNumber the current activity number\n   * @param currentStepNumber the current step number\n   * @param branchLetterCode (optional) the character code for the branch\n   * letter e.g. 1=A, 2=B, etc.\n   */\n  calculateNodeNumbersHelper(nodeId, currentActivityNumber, currentStepNumber, branchLetterCode) {\n\n    if (nodeId != null) {\n      if (this.isApplicationNode(nodeId)) {\n        // the node is a step node\n\n        // get the node object\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n\n          // get the parent group of the node\n          var parentGroup = this.getParentGroup(nodeId);\n\n          if (parentGroup != null) {\n\n            // check if the parent group has previously been assigned a number\n            if (this.nodeIdToNumber[parentGroup.id] == null) {\n              /*\n                             * the parent group has not been assigned a number so\n                             * we will assign a number now\n                             */\n\n              // set the activity number\n              currentActivityNumber = parseInt(currentActivityNumber) + 1;\n\n              /*\n                             * set the current step number to 1 now that we have\n                             * entered a new group\n                             */\n              currentStepNumber = 1;\n\n              // set the activity number\n              this.nodeIdToNumber[parentGroup.id] = \"\" + currentActivityNumber;\n            } else {\n              /*\n                             * the parent group has previously been assigned a number so we\n                             * will use it\n                             */\n              currentActivityNumber = this.nodeIdToNumber[parentGroup.id];\n            }\n          }\n\n          if (this.isBranchMergePoint(nodeId)) {\n            /*\n                         * the node is a merge point so we will not use a letter\n                         * anymore now that we are no longer in a branch path\n                         */\n            branchLetterCode = null;\n          }\n\n          if (this.isBranchStartPoint(nodeId)) {\n            // the node is a branch start point\n\n            // get the branch that this node is a start point for\n            var branchesByBranchStartPointNodeId = this.getBranchesByBranchStartPointNodeId(nodeId);\n\n            // get the branch object, there should only be one\n            var branchesObject = branchesByBranchStartPointNodeId[0];\n\n            /*\n                         * this is used to obtain the max step number that has\n                         * been used in the branch paths so that we know what\n                         * step number to give the merge end point\n                         */\n            var maxCurrentStepNumber = 0;\n\n            // set the step number for the branch start point\n            this.nodeIdToNumber[nodeId] = currentActivityNumber + '.' + currentStepNumber;\n\n            // increment the step counteer\n            currentStepNumber++;\n\n            // get the branch paths\n            var branchPaths = branchesObject.branchPaths;\n\n            // loop through all the branch paths\n            for (var bp = 0; bp < branchPaths.length; bp++) {\n\n              // get a branch path\n              var branchPath = branchPaths[bp];\n\n              // step number counter for this branch path\n              var branchCurrentStepNumber = currentStepNumber;\n\n              // get the letter code e.g. 1=A, 2=B, etc.\n              var branchLetterCode = bp;\n\n              // loop through all the nodes in the branch path\n              for (var bpn = 0; bpn < branchPath.length; bpn++) {\n                if (bpn == 0) {\n\n                  /*\n                                     * Recursively call calculateNodeNumbersHelper on the\n                                     * first step in this branch path. This will recursively\n                                     * calculate the numbers for all the nodes in this\n                                     * branch path.\n                                     */\n                  var branchPathNodeId = branchPath[bpn];\n                  this.calculateNodeNumbersHelper(branchPathNodeId, currentActivityNumber, branchCurrentStepNumber, branchLetterCode);\n                }\n\n                // increment the step counter for this branch path\n                branchCurrentStepNumber++;\n\n                /*\n                                 * update the max current step number if we have found\n                                 * a larger number\n                                 */\n                if (branchCurrentStepNumber > maxCurrentStepNumber) {\n                  maxCurrentStepNumber = branchCurrentStepNumber;\n                }\n              }\n            }\n\n            // get the step number we should use for the end point\n            currentStepNumber = maxCurrentStepNumber;\n\n            var branchEndPointNodeId = branchesObject.branchEndPoint;\n\n            /*\n                         * calculate the node number for the branch end point and\n                         * continue calculating node numbers for the nodes that\n                         * come after it\n                         */\n            this.calculateNodeNumbersHelper(branchEndPointNodeId, currentActivityNumber, currentStepNumber);\n          } else {\n            // the node is not a branch start point\n\n            /*\n                         * check if we have already set the number for this node so\n                         * that we don't need to unnecessarily re-calculate the\n                         * node number\n                         */\n            if (this.nodeIdToNumber[nodeId] == null) {\n              // we have not calculated the node number yet\n\n              var number = null;\n\n              if (branchLetterCode == null) {\n                // we do not need to add a branch letter\n\n                // get the node number e.g. 1.5\n                number = currentActivityNumber + '.' + currentStepNumber;\n              } else {\n                // we need to add a branch letter\n\n                // get the branch letter\n                var branchLetter = String.fromCharCode(65 + branchLetterCode);\n\n                // get the node number e.g. 1.5 A\n                number = currentActivityNumber + '.' + currentStepNumber + ' ' + branchLetter;\n\n                // remember the branch path letter for this node\n                this.nodeIdToBranchPathLetter[nodeId] = branchLetter;\n              }\n\n              // set the number for the node\n              this.nodeIdToNumber[nodeId] = number;\n            } else {\n              /*\n                             * We have calculated the node number before so we\n                             * will return. This will prevent infinite looping\n                             * within the project.\n                             */\n              return;\n            }\n\n            // increment the step number for the next node to use\n            currentStepNumber++;\n\n            var transitions = [];\n\n            if (node.transitionLogic != null && node.transitionLogic.transitions) {\n              transitions = node.transitionLogic.transitions;\n            }\n\n            if (transitions.length > 0) {\n\n              /*\n                             * loop through all the transitions, there should only\n                             * be one but we will loop through them just to be complete.\n                             * if there was more than one transition, it would mean\n                             * this node is a branch start point in which case we\n                             * would have gone inside the other block of code where\n                             * this.isBranchStartPoint() is true.\n                             */\n              for (var t = 0; t < transitions.length; t++) {\n                var transition = transitions[t];\n\n                if (transition != null) {\n                  if (this.isBranchMergePoint(transition.to)) {\n\n                  } else {\n                    this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\n                  }\n                }\n              }\n            } else {\n              // if there are no transitions, check if the parent group has a transition\n\n              if (parentGroup != null &&\n                parentGroup.transitionLogic != null &&\n                parentGroup.transitionLogic.transitions != null &&\n                parentGroup.transitionLogic.transitions.length > 0) {\n\n                for (var pg = 0; pg < parentGroup.transitionLogic.transitions.length; pg++) {\n                  var transition = parentGroup.transitionLogic.transitions[pg];\n\n                  if (transition != null) {\n                    this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\n                  }\n                }\n              }\n            }\n          }\n        }\n      } else {\n        // the node is a group node\n\n        // get the node object\n        var node = this.getNodeById(nodeId);\n\n        if (node != null) {\n          // check if the group has previously been assigned a number\n          if (this.nodeIdToNumber[nodeId] == null) {\n            /*\n                         * the group has not been assigned a number so\n                         * we will assign a number now\n                         */\n\n            if (nodeId == 'group0') {\n              // group 0 will always be given the activity number of 0\n              this.nodeIdToNumber[nodeId] = \"\" + 0;\n            } else {\n              // set the activity number\n              currentActivityNumber = parseInt(currentActivityNumber) + 1;\n\n              /*\n                             * set the current step number to 1 now that we have\n                             * entered a new group\n                             */\n              currentStepNumber = 1;\n\n              // set the activity number\n              this.nodeIdToNumber[nodeId] = \"\" + currentActivityNumber;\n            }\n          } else {\n            /*\n                         * We have calculated the node number before so we\n                         * will return. This will prevent infinite looping\n                         * within the project.\n                         */\n            return;\n          }\n\n          if (node.startId != null && node.startId != '') {\n            /*\n                         * calculate the node number for the first step in this\n                         * activity and any steps after it\n                         */\n            this.calculateNodeNumbersHelper(node.startId, currentActivityNumber, currentStepNumber, branchLetterCode);\n          } else {\n            /*\n                         * this activity doesn't have a start step so we will\n                         * look for a transition\n                         */\n\n            if (node != null &&\n              node.transitionLogic != null &&\n              node.transitionLogic.transitions != null &&\n              node.transitionLogic.transitions.length > 0) {\n\n              // loop through all the transitions\n              for (var t = 0; t < node.transitionLogic.transitions.length; t++) {\n                var transition = node.transitionLogic.transitions[t];\n\n                if (transition != null) {\n                  /*\n                                     * calculate the node number for the next group\n                                     * and all its children steps\n                                     */\n                  this.calculateNodeNumbersHelper(transition.to, currentActivityNumber, currentStepNumber, branchLetterCode);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Get script for this project\n   */\n  getProjectScript() {\n    return this.project.script;\n  }\n\n  /**\n   * Retrieve the script with the provided script filename\n   * @param scriptFilename\n   */\n  retrieveScript(scriptFilename) {\n    let assetDirectoryPath = this.ConfigService.getProjectAssetsDirectoryPath();\n    let scriptPath = assetDirectoryPath + \"/\" + scriptFilename;\n    return this.$http.get(scriptPath).then((result) => {\n      return result.data;\n    });\n  };\n\n  /**\n   * Registers an additionalProcessingFunction for the specified node and component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @param additionalProcessingFunction the function to register for the node and component.\n   */\n  addAdditionalProcessingFunction(nodeId, componentId, additionalProcessingFunction) {\n    let key = nodeId + \"_\" + componentId;\n    if (this.additionalProcessingFunctionsMap[key] == null) {\n      this.additionalProcessingFunctionsMap[key] = [];\n    }\n    this.additionalProcessingFunctionsMap[key].push(additionalProcessingFunction);\n  }\n\n  /**\n   * Returns true iff the specified node and component has any registered additionalProcessingFunctions\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns true/false\n   */\n  hasAdditionalProcessingFunctions(nodeId, componentId) {\n    return this.getAdditionalProcessingFunctions(nodeId, componentId) != null;\n  }\n\n  /**\n   * Returns an array of registered additionalProcessingFunctions for the specified node and component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns an array of additionalProcessingFunctions\n   */\n  getAdditionalProcessingFunctions(nodeId, componentId) {\n    let key = nodeId + \"_\" + componentId;\n    return this.additionalProcessingFunctionsMap[key];\n  }\n\n  /**\n   * Get the previous node\n   * @param nodeId get the node id that comes before this one\n   * @return the node id that comes before\n   */\n  getPreviousNodeId(nodeId) {\n    var previousNodeId = null;\n\n    // get the node ids in the project as a flat array\n    var flattenedNodeIds = this.getFlattenedProjectAsNodeIds();\n\n    if (flattenedNodeIds != null) {\n\n      // get the index of the node id\n      var indexOfNodeId = flattenedNodeIds.indexOf(nodeId);\n\n      if (indexOfNodeId != -1) {\n\n        // get the index of the previous node id\n        var indexOfPreviousNodeId = indexOfNodeId - 1;\n\n        // get the previous node id\n        previousNodeId = flattenedNodeIds[indexOfPreviousNodeId];\n      }\n    }\n\n    return previousNodeId;\n  }\n\n  /**\n   * Get the next node\n   * @param nodeId get the node id that comes after this one\n   * @return the node id that comes after\n   */\n  getNextNodeId(nodeId) {\n\n    var nextNodeId = null;\n\n    // get the node ids in the project as a flat array\n    var flattenedNodeIds = this.getFlattenedProjectAsNodeIds();\n\n    if (flattenedNodeIds != null) {\n\n      // get the index of the node id\n      var indexOfNodeId = flattenedNodeIds.indexOf(nodeId);\n\n      if (indexOfNodeId != -1) {\n\n        // get the index of the next node id\n        var indexOfNextNodeId = indexOfNodeId + 1;\n\n        // get the next node id\n        nextNodeId = flattenedNodeIds[indexOfNextNodeId];\n      }\n    }\n\n    return nextNodeId;\n  }\n\n  /**\n   * Set the project script filename\n   * @param script the script filename\n   */\n  setProjectScriptFilename(scriptFilename) {\n    this.project.script = scriptFilename;\n  }\n\n  /**\n   * Get the project script filename\n   */\n  getProjectScriptFilename() {\n\n    var scriptFilename = null;\n\n    if (this.project != null && this.project.script != null) {\n      scriptFilename = this.project.script;\n    }\n\n    return scriptFilename;\n  }\n\n  /**\n   * Get all the achievements object in the project. The achievements object\n   * contains the isEnabled field and an array of items.\n   * @return the achievement object\n   */\n  getAchievements() {\n    var achievements = null;\n\n    if (this.project != null) {\n      if (this.project.achievements == null) {\n        this.project.achievements = {\n          isEnabled: true,\n          items: []\n        };\n      }\n      achievements = this.project.achievements;\n    }\n\n    return achievements;\n  }\n\n  /**\n   * Get the achievement items in the project\n   * @return the achievement items\n   */\n  getAchievementItems() {\n    var achievementItems = null;\n\n    // get the achievements object\n    var achievements = this.getAchievements();\n\n    if (achievements != null) {\n      if (achievements.items == null) {\n        achievements.items = [];\n      }\n\n      // get the achievement items\n      achievementItems = achievements.items;\n    }\n\n    return achievementItems;\n  }\n\n  /**\n   * Get an achievement by the 10 character alphanumeric achievement id\n   * @param achievementId the 10 character alphanumeric achievement id\n   * @return the achievement with the given achievement id\n   */\n  getAchievementByAchievementId(achievementId) {\n\n    if (achievementId != null) {\n\n      // get the achievements object\n      var achievements = this.getAchievements();\n\n      if (achievements != null) {\n\n        // get the achievement items\n        var achievementItems = achievements.items;\n\n        if (achievementItems != null) {\n\n          // loop through the achievement items\n          for (var a = 0; a < achievementItems.length; a++) {\n\n            // get an achievement\n            var achievement = achievementItems[a];\n\n            if (achievement != null && achievement.id == achievementId) {\n              /*\n                             * the achievement id matches so we have found the\n                             * achievement we are looking for\n                             */\n              return achievement;\n            }\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Check if there are any rubrics in the project. There can potentially be\n   * a project rubric, node rubrics, and component rubrics.\n   * @return whether there are any rubrics in the project\n   */\n  hasRubrics() {\n\n    if (this.project != null) {\n\n      if (this.project.rubric != null && this.project.rubric != \"\") {\n        // there is a project rubric\n        return true;\n      }\n\n      // loop through all the nodes\n      for (var n = 0; n < this.project.nodes.length; n++) {\n        var node = this.project.nodes[n];\n\n        if (node != null) {\n          if (node.rubric != null && node.rubric != \"\") {\n            // there is a node rubric\n            return true;\n          }\n\n          if (node.components != null) {\n            // loop through all the components\n            for (var c = 0; c < node.components.length; c++) {\n              var component = node.components[c];\n\n              if (component != null) {\n                if (component.rubric != null && component.rubric != \"\") {\n                  // there is a component rubric\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the branch letter in the node position string if the node is in a\n   * branch path\n   * @param nodeId the node id we want the branch letter for\n   * @return the branch letter in the node position if the node is in a branch\n   * path\n   */\n  getBranchLetter(nodeId) {\n\n    var branchLetter = null;\n\n    if (nodeId != null) {\n\n      // get the node position e.g. \"1.8\" or \"1.9 A\"\n      var nodePosition = this.getNodePositionById(nodeId);\n\n      if (nodePosition != null) {\n\n        // regex for extracting the branch letter\n        var branchLetterRegex = /.*([A-Z])/;\n\n        // run the regex on the node position string\n        var match = branchLetterRegex.exec(nodePosition);\n\n        if (match != null) {\n          /*\n                     * the node position has a branch letter so we will get it\n                     * from the matched group\n                     */\n          branchLetter = match[1];\n        }\n      }\n    }\n\n    return branchLetter;\n  }\n\n  /**\n   * Get the total number of rubrics (step + components) for the given nodeId\n   * @param nodeId the node id\n   * @return Number of rubrics for the node\n   */\n  getNumberOfRubricsByNodeId(nodeId) {\n    let n = 0;\n    let nodeContent = this.getNodeContentByNodeId(nodeId);\n\n    if (nodeContent) {\n\n      // get the step rubric if any\n      let nodeRubric = nodeContent.rubric;\n\n      if (nodeRubric != null && nodeRubric != '') {\n        // the step has a rubric\n        n++;\n      }\n\n      // get the components\n      let components = nodeContent.components;\n\n      if (components && components.length) {\n\n        // loop through all the components\n        for (let c = 0; c < components.length; c++) {\n          var component = components[c];\n\n          if (component) {\n\n            // get a component rubric\n            var componentRubric = component.rubric;\n\n            if (componentRubric != null && componentRubric != '') {\n              // a component has a rubric\n              n++;\n            }\n          }\n        }\n      }\n    }\n\n    return n;\n  }\n\n  /**\n   * Copy a component and insert it into the step\n   * @param nodeId we are copying a component in this node\n   * @param componentIds the components to copy\n   * @param insertAfterComponentId Which component to place the new components\n   * after. If this is null, we will put the new components at the beginning.\n   * @return an array of the new components\n   */\n  copyComponentAndInsert(nodeId, componentIds, insertAfterComponentId) {\n\n    // get the node for which we are moving components\n    var node = this.getNodeById(nodeId);\n\n    // array of new components\n    var newComponents = [];\n\n    // array of new component ids\n    var newComponentIds = [];\n\n    // loop through all the components we want to copy\n    for (var c = 0; c < componentIds.length; c++) {\n      var componentId = componentIds[c];\n\n      // create a copy of the component\n      var newComponent = this.copyComponent(nodeId, componentId, newComponentIds);\n\n      newComponents.push(newComponent);\n      newComponentIds.push(newComponent.id);\n    }\n\n    // get the components in the node\n    var components = node.components;\n\n    if (components != null) {\n\n      var insertPosition = 0;\n\n      if (insertAfterComponentId == null) {\n        // place the new components at the beginning\n        insertPosition = 0;\n      } else {\n        // place the new components after the specified component id\n        insertPosition = this.getComponentPositionByNodeIdAndComponentId(nodeId, insertAfterComponentId) + 1;\n      }\n\n      // loop through all the new components\n      for (var n = 0; n < newComponents.length; n++) {\n        var newComponent = newComponents[n];\n\n        // insert the new component\n        components.splice(insertPosition, 0, newComponent);\n\n        /*\n                 * increment the insert position for cases when we have multiple\n                 * new components\n                 */\n        insertPosition += 1;\n      }\n    }\n\n    return newComponents;\n  }\n\n  /**\n   * Copy a component\n   * @param nodeId the node id\n   * @param componentId the compnent id\n   * @param componentIdsToSkip component ids that we can't use for our new\n   * component\n   * @return a new component object\n   */\n  copyComponent(nodeId, componentId, componentIdsToSkip) {\n\n    // get the component we want to copy\n    var component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n    // make a copy of the component\n    var newComponent = this.UtilService.makeCopyOfJSONObject(component);\n\n    // get a new component id for the component\n    var newComponentId = this.getUnusedComponentId(componentIdsToSkip);\n    newComponent.id = newComponentId;\n\n    return newComponent;\n  }\n\n  /**\n   * Import components from a project. Also import asset files that are\n   * referenced in any of those components.\n   * @param components an array of component objects that we are importing\n   * @param importProjectId the id of the project we are importing from\n   * @param nodeId the node we are adding the components to\n   * @param insertAfterComponentId insert the components after this component\n   * id\n   * @return an array of the new components\n   */\n  importComponents(components, importProjectId, nodeId, insertAfterComponentId) {\n\n    var newComponents = [];\n    var newComponentIds = [];\n\n    /*\n         * loop through all the components and make sure their ids are not\n         * already used in the project\n         */\n    for (var c = 0; c < components.length; c++) {\n      var component = components[c];\n\n      if (component != null) {\n\n        // make a copy of the component object\n        var newComponent = this.UtilService.makeCopyOfJSONObject(component);\n        var newComponentId = newComponent.id;\n\n        // check if the component id is used in this project\n        if (this.isComponentIdUsed(newComponentId)) {\n          /*\n                     * the component id is already used so we will find a new\n                     * component id\n                     */\n\n          // get a new component id\n          newComponentId = this.getUnusedComponentId(newComponentIds);\n\n          // set the new component id into our new component\n          newComponent.id = newComponentId;\n        }\n\n        // add the new component and new component id to our arrays\n        newComponents.push(newComponent);\n        newComponentIds.push(newComponentId);\n      }\n    }\n\n    // get the import steps URL\n    var importStepsURL = this.ConfigService.getConfigParam('importStepsURL');\n\n    var httpParams = {};\n    httpParams.method = 'POST';\n    httpParams.url = importStepsURL;\n    httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n\n    // get the project id we are importing into\n    var toProjectId = this.ConfigService.getConfigParam('projectId');\n\n    // get the project id we are importing from\n    var fromProjectId = importProjectId;\n\n    // set the POST params\n    var params = {};\n    params.steps = angular.toJson(newComponents);\n    params.fromProjectId = fromProjectId;\n    params.toProjectId = toProjectId;\n    httpParams.data = $.param(params);\n\n    /*\n         * Make the request to import the components. This will copy the asset files\n         * and change file names if necessary. If an asset file with the same\n         * name exists in both projects we will check if their content is the\n         * same. If the content is the same we don't need to copy the file. If\n         * the content is different, we need to make a copy of the file with a\n         * new name and change all the references in the steps to use the new\n         * name.\n         */\n    return this.$http(httpParams).then((result) => {\n\n      // get the components from the result that may have been modified\n      newComponents = result.data;\n\n      // get the current components in the node\n      var node = this.getNodeById(nodeId);\n      var currentComponents = node.components;\n\n      var insertPosition = 0;\n\n      if (insertAfterComponentId == null) {\n        // place the new components at the beginning\n        insertPosition = 0;\n      } else {\n        // place the new components after the specified component id\n        insertPosition = this.getComponentPositionByNodeIdAndComponentId(nodeId, insertAfterComponentId) + 1;\n      }\n\n      // loop through all the new components and add them to the project\n      for (var n = 0; n < newComponents.length; n++) {\n        var newComponent = newComponents[n];\n\n        // insert the new component\n        currentComponents.splice(insertPosition, 0, newComponent);\n\n        /*\n                 * increment the insert position for cases when we have multiple\n                 * new components\n                 */\n        insertPosition += 1;\n      }\n\n      return newComponents;\n    });\n  }\n\n  /**\n   * Get the branch path letter\n   * @param nodeId get the branch path letter for this node if it is in a\n   * branch\n   * @return the branch path letter for the node if it is in a branch\n   */\n  getBranchPathLetter(nodeId) {\n    return this.nodeIdToBranchPathLetter[nodeId];\n  }\n\n  /**\n   * Set the node into the project by replacing the existing node with the\n   * given node id\n   * @param nodeId the node id of the node\n   * @param node the node object\n   */\n  setNode(nodeId, node) {\n\n    if (nodeId != null && node != null) {\n\n      // loop through all the nodes\n      for (let n = 0; n < this.project.nodes.length; n++) {\n        let tempNode = this.project.nodes[n];\n\n        if (tempNode != null && tempNode.id == nodeId) {\n          // we have found the node we want to replace\n          this.project.nodes[n] = node;\n        }\n      }\n\n      // loop through all the inactive nodes\n      for (let i = 0; i < this.project.inactiveNodes.length; i++) {\n        let tempNode = this.project.inactiveNodes[i];\n\n        if (tempNode != null && tempNode.id == nodeId) {\n          // we have found the node we want to replace\n          this.project.inactiveNodes[i] = node;\n        }\n      }\n\n      // update the id to node mapping with the new node\n      this.idToNode[nodeId] = node;\n    }\n  }\n\n  /**\n   * Remember the result for whether the node is affected by the constraint\n   * @param nodeId the node id\n   * @param constraintId the constraint id\n   * @param whether the node is affected by the constraint\n   */\n  setIsNodeAffectedByConstraintResult(nodeId, constraintId, result) {\n    this.isNodeAffectedByConstraintResult[nodeId + '-' + constraintId] = result;\n  }\n\n  /**\n   * Check if we have calculated the result for whether the node is affected\n   * by the constraint\n   * @param nodeId the node id\n   * @param constraintId the constraint id\n   * @return Return the result if we have calculated the result before. If we\n   * have not calculated the result before, we will return null.\n   */\n  getIsNodeAffectedByConstraintResult(nodeId, constraintId) {\n    return this.isNodeAffectedByConstraintResult[nodeId + '-' + constraintId];\n  }\n\n  /**\n   * Get the id to node mappings.\n   * @return An object the keys as node ids and the values as nodes.\n   */\n  getIdToNode() {\n    return this.idToNode;\n  }\n}\n\nProjectService.$inject = [\n  '$filter',\n  '$http',\n  '$injector',\n  '$q',\n  '$rootScope',\n  'ConfigService',\n  'UtilService'\n];\n\nexport default ProjectService;\n"]}