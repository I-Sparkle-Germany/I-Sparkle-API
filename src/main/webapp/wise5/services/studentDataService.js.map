{"version":3,"sources":["studentDataService.es6"],"names":["StudentDataService","$filter","$http","$injector","$q","$rootScope","AnnotationService","ConfigService","ProjectService","UtilService","$translate","currentNode","previousStep","studentData","stackHistory","visitedNodesHistory","nodeStatuses","runStatus","maxScore","maxPlanningNodeNumber","saveToServerRequestCount","dummyStudentWorkId","$on","event","args","calculateActiveGlobalAnnotationGroups","globalAnnotationGroups","getActiveGlobalAnnotationGroups","map","globalAnnotationGroup","globalAnnotations","annotations","globalAnnotation","data","isGlobal","unGlobalizeConditional","unGlobalizeCriteriaArray","unGlobalizeCriteria","anySatified","unGlobalizeCriteriaResult","evaluateCriteria","unGlobalizedTimestamp","Date","parse","saveAnnotations","allSatisfied","annotation","handleAnnotationReceived","isPreview","componentStates","nodeStates","events","userName","userId","setAnnotations","populateHistories","updateNodeStatuses","studentDataURL","getConfigParam","httpParams","method","url","params","workgroupId","getWorkgroupId","runId","getRunId","getStudentWork","getEvents","getAnnotations","toWorkgroupId","then","result","resultData","studentWorkList","studentWork","componentId","push","project","nodes","length","planningGroupNode","planning","lastestNodeStateForPlanningGroupNode","getLatestNodeStateByNodeId","id","studentModifiedNodes","studentModifiedNode","studentModifiedNodeId","n","ids","parseProject","runStatusURL","headers","nodeId","nodeStatus","getNodes","planningNodes","getPlanningNodes","groups","getGroups","concat","node","isGroupNode","updateNodeStatusByNode","group","depth","getNodeDepth","sort","a","b","getMaxScore","$broadcast","tempNodeStatus","isVisitable","isCompleted","constraintsForNode","getConstraintsForNode","getFlattenedProjectAsNodeIds","indexOf","isVisible","isVisibleResults","isVisitableResults","firstResult","constraintForNode","tempResult","evaluateConstraint","action","isVisibleResult","isVisitableResult","isVisited","isNodeVisited","getNodeStatusByNodeId","setNodeStatusByNodeId","previousIsCompletedValue","progress","getNodeProgressById","icon","getNodeIconByNodeId","latestComponentStatesForNode","getLatestComponentStateByNodeId","latestComponentStateClientSaveTime","clientSaveTime","latestComponentStateServerSaveTime","serverSaveTime","removalCriteria","evaluateNodeConstraint","visitedNodes","getVisitedNodesHistory","transitionsToNodeId","visitedNodeId","transitions","getTransitionsByFromAndToNodeId","isStartNode","removalConditional","tempCriteria","criteria","functionName","name","evaluateBranchPathTakenCriteria","evaluateIsVisitedCriteria","evaluateIsVisitedAfterCriteria","evaluateIsRevisedAfterCriteria","evaluateIsVisitedAndRevisedAfterCriteria","evaluateIsCompletedCriteria","evaluateIsCorrectCriteria","evaluateChoiceChosenCriteria","evaluateIsPlanningActivityCompletedCriteria","evaluateScoreCriteria","evaluateUsedXSubmitsCriteria","getComponentStatesByNodeIdAndComponentId","componentState","isCorrect","planningStepsCreated","planningStepsCompleted","planningStepsCreatedSatisfied","planningStepsCompletedSatisfied","getNodeStatesByNodeId","ns","planningStepCount","nodeState","type","planningNodeTemplateId","expectedFromNodeId","fromNodeId","expectedToNodeId","toNodeId","branchPathTakenEvents","getBranchPathTakenEventsByNodeId","branchPathTakenEvent","isVisitedAfter","isVisitedAfterNodeId","criteriaCreatedTimestamp","isRevisedAfter","isRevisedAfterNodeId","isRevisedAfterComponentId","latestComponentStateForRevisedComponent","getLatestComponentStateByNodeIdAndComponentId","isVisitedAndRevisedAfter","serviceName","has","service","get","choiceChosen","scores","scoreType","latestScoreAnnotation","getLatestScoreAnnotation","scoreValue","getScoreValueFromScoreAnnotation","toString","requiredSubmitCount","manualSubmitCounter","highestSubmitCounter","isSubmit","submitCounter","updateStackHistory","updateVisitedNodesHistory","index","stackHistoryResult","indexOfNodeId","splice","timestamp","nodeStatesByNodeId","tempNodeId","notebookItemId","component","category","alert","context","componentType","saveEvent","newEvent","createNewEvent","saveToServer","projectId","getProjectId","periodId","getPeriodId","requestToken","generateKey","addComponentState","addNodeState","addEvent","addAnnotation","savedStudentDataResponse","saveToServerSuccess","deferred","defer","resolve","promise","angular","toJson","$","param","saveStudentStatus","savedStudentWorkList","localStudentWorkList","savedStudentWork","l","localStudentWork","getMode","savedEvents","localEvents","savedEvent","localEvent","savedAnnotations","localAnnotations","savedAnnotation","localAnnotation","studentStatusURL","getStudentStatusURL","currentNodeId","getCurrentNodeId","getNodeStatuses","projectCompletion","getProjectCompletion","studentStatusJSON","status","studentStatusParams","latestComponentState","submitDirty","getLatestComponentState","latestNodeState","allNodeStatesByNodeId","c","componentStateNodeId","componentStateComponentId","studentWorkId","componentStatesByNodeId","componentStatesByNodeIdAndComponentId","eventsByNodeId","eventNodeId","eventComponentId","e","eventName","getNodeById","isActive","completedItems","completedItemsWithWork","totalItems","totalItemsWithWork","nodeIds","getChildNodeIdsById","groupProgress","hasWork","nodeHasWork","completionPct","Math","round","completionPctWithWork","componentEvents","getEventsByNodeIdAndComponentId","nodeEvents","getEventsByNodeId","getComponentByNodeIdAndComponentId","isGroup","components","getComponentsByNodeId","showPreviousWorkNodeId","showPreviousWorkComponentId","tempNode","tempComponentId","tempComponent","isComponentCompleted","console","log","setCurrentNode","previousCurrentNode","previousNode","nodeToExit","endCurrentNode","setCurrentNodeByNodeId","nodeClickLocked","strData","strDelimiter","objPattern","RegExp","arrData","arrMatches","exec","strMatchedDelimiter","strMatchedValue","replace","finalValue","floatVal","parseFloat","isNaN","getTotalScore","currentMaxPlanningNodeNumber","getNodeStates","nodeStateNodeId","isPlanning","planningNodeIdRegEx","match","planningNodeNumber","parseInt","latestComponentStates","getComponentStatesByNodeId","completionCriteria","inOrder","tempTimestamp","completionCriterion","tempComponentState","getComponentStateSubmittedAfter","getComponentStateSavedAfter","tempEvent","getVisitEventAfter","showClassmateWorkSource","onlyGetLatest","p","hasOwnProperty","nodeMaxScore","getMaxScoreForNode","$inject"],"mappings":"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","file":"studentDataService.js","sourcesContent":["class StudentDataService {\n  constructor(\n      $filter,\n      $http,\n      $injector,\n      $q,\n      $rootScope,\n      AnnotationService,\n      ConfigService,\n      ProjectService,\n      UtilService) {\n    this.$filter = $filter;\n    this.$http = $http;\n    this.$injector = $injector;\n    this.$q = $q;\n    this.$rootScope = $rootScope;\n    this.AnnotationService = AnnotationService;\n    this.ConfigService = ConfigService;\n    this.ProjectService = ProjectService;\n    this.UtilService = UtilService;\n    this.$translate = this.$filter('translate');\n    this.currentNode = null;\n    this.previousStep = null;\n    this.studentData = null;\n    this.stackHistory = [];  // array of node id's\n    this.visitedNodesHistory = [];\n    this.nodeStatuses = {};\n    this.runStatus = null;\n    this.maxScore = null;\n\n    this.maxPlanningNodeNumber = 0;\n\n    /*\n     * A counter to keep track of how many saveToServer requests we have\n     * made that we haven't received a response for yet. When this value\n     * goes back down to 0, we will send update the student status and then\n     * save it to the server.\n     */\n    this.saveToServerRequestCount = 0;\n\n    /*\n     * A dummy student work id that is used in preview mode when we simulate\n     * saving of student data.\n     */\n    this.dummyStudentWorkId = 1;\n\n    // listen for node status changes\n    this.$rootScope.$on('nodeStatusesChanged', (event, args) => {\n      // calculate active global annotations and group them by group name as needed\n      this.AnnotationService.calculateActiveGlobalAnnotationGroups();\n\n      // go through the global annotations and see if they can be un-globalized by checking if their criterias have been met.\n      let globalAnnotationGroups = this.AnnotationService.getActiveGlobalAnnotationGroups();\n      globalAnnotationGroups.map((globalAnnotationGroup) => {\n        let globalAnnotations = globalAnnotationGroup.annotations;\n        globalAnnotations.map((globalAnnotation) => {\n          if (globalAnnotation.data != null && globalAnnotation.data.isGlobal) {\n            let unGlobalizeConditional = globalAnnotation.data.unGlobalizeConditional;\n            let unGlobalizeCriteriaArray = globalAnnotation.data.unGlobalizeCriteria;\n            if (unGlobalizeCriteriaArray != null) {\n              if (unGlobalizeConditional === \"any\") {\n                // at least one criteria in unGlobalizeCriteriaArray must be satisfied in any order before un-globalizing this annotation\n                let anySatified = false;\n                for (let unGlobalizeCriteria of unGlobalizeCriteriaArray) {\n                  let unGlobalizeCriteriaResult = this.evaluateCriteria(unGlobalizeCriteria);\n                  anySatified = anySatified || unGlobalizeCriteriaResult;\n                }\n                if (anySatified) {\n                  globalAnnotation.data.unGlobalizedTimestamp = Date.parse(new Date());  // save when criteria was satisfied\n                  this.saveAnnotations([globalAnnotation]);  // save changes to server\n                }\n              } else if (unGlobalizeConditional === \"all\") {\n                // all criteria in unGlobalizeCriteriaArray must be satisfied in any order before un-globalizing this annotation\n                let allSatisfied = true;\n                for (let unGlobalizeCriteria of unGlobalizeCriteriaArray) {\n                  let unGlobalizeCriteriaResult = this.evaluateCriteria(unGlobalizeCriteria);\n                  allSatisfied = allSatisfied && unGlobalizeCriteriaResult;\n                }\n                if (allSatisfied) {\n                  globalAnnotation.data.unGlobalizedTimestamp = Date.parse(new Date());  // save when criteria was satisfied\n                  this.saveAnnotations([globalAnnotation]);  // save changes to server\n                }\n              }\n            }\n          }\n        });\n      })\n    });\n\n    /**\n     * Listen for the 'newAnnotationReceived' event which is fired when\n     * student receives a new annotation from the server\n     */\n    this.$rootScope.$on('newAnnotationReceived', (event, args) => {\n      if (args) {\n        // get the annotation that was saved to the server\n        let annotation = args.annotation;\n        this.handleAnnotationReceived(annotation);\n      }\n    });\n  }\n\n  retrieveStudentData() {\n    if (this.ConfigService.isPreview()) {\n      // we are previewing the project\n\n      // initialize dummy student data\n      this.studentData = {};\n      this.studentData.componentStates = [];\n      this.studentData.nodeStates = [];\n      this.studentData.events = [];\n      this.studentData.annotations = [];\n      this.studentData.userName = this.$translate('PREVIEW_STUDENT');\n      this.studentData.userId = '0';\n\n      // set the annotations into the annotation service\n      this.AnnotationService.setAnnotations(this.studentData.annotations);\n\n      // populate the student history\n      this.populateHistories(this.studentData.events);\n\n      // update the node statuses\n      this.updateNodeStatuses();\n    } else {\n      // we are in a run\n\n      // get the url to get the student data\n      const studentDataURL = this.ConfigService.getConfigParam('studentDataURL');\n\n      const httpParams = {};\n      httpParams.method = 'GET';\n      httpParams.url = studentDataURL;\n\n      // set the workgroup id and run id\n      const params = {};\n      params.workgroupId = this.ConfigService.getWorkgroupId();\n      params.runId = this.ConfigService.getRunId();\n      params.getStudentWork = true;\n      params.getEvents = true;\n      params.getAnnotations = true;\n      params.toWorkgroupId = this.ConfigService.getWorkgroupId();\n      httpParams.params = params;\n\n      // make the request for the student data\n      return this.$http(httpParams).then((result) => {\n        const resultData = result.data;\n        if (resultData != null) {\n          this.studentData = {};\n\n          // get student work\n          this.studentData.componentStates = [];\n          this.studentData.nodeStates = [];\n          const studentWorkList = resultData.studentWorkList;\n          for (let studentWork of studentWorkList) {\n            if (studentWork.componentId != null) {\n              this.studentData.componentStates.push(studentWork);\n            } else {\n              this.studentData.nodeStates.push(studentWork);\n            }\n          }\n\n          // Check to see if this Project contains any Planning activities\n          if (this.ProjectService.project.nodes != null && this.ProjectService.project.nodes.length > 0) {\n            // Overload/add new nodes based on student's work in the NodeState for the planning group.\n            for (let planningGroupNode of this.ProjectService.project.nodes) {\n              if (planningGroupNode.planning) {\n                let lastestNodeStateForPlanningGroupNode = this.getLatestNodeStateByNodeId(planningGroupNode.id);\n                if (lastestNodeStateForPlanningGroupNode != null) {\n                  let studentModifiedNodes = lastestNodeStateForPlanningGroupNode.studentData.nodes;\n                  if (studentModifiedNodes != null) {\n                    for (let studentModifiedNode of studentModifiedNodes) {\n                      let studentModifiedNodeId = studentModifiedNode.id;\n                      if (studentModifiedNode.planning) {\n                        // If this is a Planning Node that exists in the project, replace the one in the original project with this one.\n                        for (let n = 0; n < this.ProjectService.project.nodes.length; n++) {\n                          if (this.ProjectService.project.nodes[n].id === studentModifiedNodeId) {\n                            // Only overload the ids. This will allow authors to add more planningNodes during the run if needed.\n                            this.ProjectService.project.nodes[n].ids = studentModifiedNode.ids;\n                          }\n                        }\n                      } else {\n                        // Otherwise, this is an instance of a PlanningNode template, so just append it to the end of the Project.nodes\n                        this.ProjectService.project.nodes.push(studentModifiedNode);\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            // Re-parse the project with the modified changes\n            this.ProjectService.parseProject();\n          }\n\n          // get events\n          this.studentData.events = resultData.events;\n\n          // get annotations\n          this.studentData.annotations = resultData.annotations;\n\n          this.AnnotationService.setAnnotations(this.studentData.annotations);\n\n          // populate the student history\n          this.populateHistories(this.studentData.events);\n\n          // update the node statuses\n          this.updateNodeStatuses();\n        }\n\n        return this.studentData;\n      });\n    }\n  };\n\n  /**\n   * Retrieve the run status\n   */\n  retrieveRunStatus() {\n    if (this.ConfigService.isPreview()) {\n      // we are previewing the project\n      this.runStatus = {};\n    } else {\n      // we are in a run\n      const runStatusURL = this.ConfigService.getConfigParam('runStatusURL');\n      const runId = this.ConfigService.getConfigParam('runId');\n\n      //create the params for the request\n      const params = {\n        runId:runId\n      };\n\n      const httpParams = {};\n      httpParams.method = 'GET';\n      httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n      httpParams.url = runStatusURL;\n      httpParams.params = params;\n\n      // make the request for the run status\n      return this.$http(httpParams).then((result) => {\n        if (result != null) {\n          const data = result.data;\n          if (data != null) {\n            // remember the run status\n            this.runStatus = data;\n          }\n        }\n      });\n    }\n  }\n\n  getNodeStatuses() {\n    return this.nodeStatuses;\n  };\n\n  setNodeStatusByNodeId(nodeId, nodeStatus) {\n    if (nodeId != null && nodeStatus != null) {\n      const nodeStatuses = this.nodeStatuses;\n      if (nodeStatuses != null) {\n        nodeStatuses[nodeId] = nodeStatus;\n      }\n    }\n  }\n\n  getNodeStatusByNodeId(nodeId) {\n    let nodeStatus = null;\n    const nodeStatuses = this.nodeStatuses;\n    if (nodeId != null && nodeStatuses != null) {\n      nodeStatus = nodeStatuses[nodeId];\n    }\n    return nodeStatus;\n  };\n\n  updateNodeStatuses() {\n    let nodes = this.ProjectService.getNodes();\n    let planningNodes = this.ProjectService.getPlanningNodes();\n    const groups = this.ProjectService.getGroups();\n\n    if (nodes != null) {\n      if (planningNodes != null) {\n        nodes = nodes.concat(planningNodes);\n      }\n      for (let node of nodes) {\n        if (!this.ProjectService.isGroupNode(node.id)) {\n          this.updateNodeStatusByNode(node);\n        }\n      }\n    }\n\n    let group;\n    if (groups != null) {\n      for (let group of groups) {\n        group.depth = this.ProjectService.getNodeDepth(group.id);\n      }\n\n      // sort by descending depth order (need to calculate completion for lowest level groups first)\n      groups.sort(function(a, b) {\n        return b.depth - a.depth;\n      });\n\n      for (let group of groups) {\n        this.updateNodeStatusByNode(group);\n      }\n    }\n\n    // update max score\n    this.maxScore = this.getMaxScore();\n    this.$rootScope.$broadcast('nodeStatusesChanged');\n  };\n\n  /**\n   * Update the node status for a node\n   * @param node the node to update\n   */\n  updateNodeStatusByNode(node) {\n    if (node != null) {\n      const nodeId = node.id;\n      const tempNodeStatus = {};\n      tempNodeStatus.nodeId = nodeId;\n      tempNodeStatus.isVisitable = true;\n      tempNodeStatus.isCompleted = true;\n\n      // get the constraints that affect this node\n      let constraintsForNode = this.ProjectService.getConstraintsForNode(node);\n\n      if (this.ConfigService.getConfigParam('constraints') == false) {\n        /*\n         * constraints have been disabled, most likely because we are\n         * in preview without constraints mode\n         */\n        constraintsForNode = null;\n      }\n\n      if (constraintsForNode == null || constraintsForNode.length == 0) {\n        if (this.ProjectService.getFlattenedProjectAsNodeIds().indexOf(nodeId) == -1 &&\n          !this.ProjectService.isGroupNode(nodeId)) {\n          // there are no transitions to this node so it is not visible\n          tempNodeStatus.isVisible = false;\n          tempNodeStatus.isVisitable = true;\n        } else {\n          // this node does not have any constraints so it is clickable\n          tempNodeStatus.isVisible = true;\n          tempNodeStatus.isVisitable = true;\n        }\n      } else {\n        const isVisibleResults = [];\n        const isVisitableResults = [];\n\n        let result = false;\n        const firstResult = true;\n\n        // loop through all the constraints that affect this node\n        for (let constraintForNode of constraintsForNode) {\n          if (constraintForNode != null) {\n            // evaluate the constraint to see if the node can be visited\n            const tempResult = this.evaluateConstraint(node, constraintForNode);\n\n            const action = constraintForNode.action;\n\n            if (action != null) {\n              if (action === 'makeThisNodeNotVisible') {\n                isVisibleResults.push(tempResult);\n              } else if (action === 'makeThisNodeNotVisitable') {\n                isVisitableResults.push(tempResult);\n              } else if (action === 'makeAllNodesAfterThisNotVisible') {\n                isVisibleResults.push(tempResult);\n              } else if (action === 'makeAllNodesAfterThisNotVisitable') {\n                isVisitableResults.push(tempResult);\n              } else if (action === 'makeAllOtherNodesNotVisible') {\n                isVisibleResults.push(tempResult);\n              } else if (action === 'makeAllOtherNodesNotVisitable') {\n                isVisitableResults.push(tempResult);\n              }\n            }\n          }\n        }\n\n        let isVisible = true;\n        let isVisitable = true;\n\n        for (let isVisibleResult of isVisibleResults) {\n          isVisible = isVisible && isVisibleResult;\n        }\n\n        for (let isVisitableResult of isVisitableResults) {\n          isVisitable = isVisitable && isVisitableResult;\n        }\n\n        tempNodeStatus.isVisible = isVisible;\n        tempNodeStatus.isVisitable = isVisitable;\n      }\n\n      tempNodeStatus.isCompleted = this.isCompleted(nodeId);\n      tempNodeStatus.isVisited = this.isNodeVisited(nodeId);\n\n      const nodeStatus = this.getNodeStatusByNodeId(nodeId);\n\n      if (nodeStatus == null) {\n        this.setNodeStatusByNodeId(nodeId, tempNodeStatus);\n      } else {\n        /*\n         * get the previous isCompleted value so that we can later check\n         * if it has changed\n         */\n        const previousIsCompletedValue = this.nodeStatuses[nodeId].isCompleted;\n\n        this.nodeStatuses[nodeId].isVisited = tempNodeStatus.isVisited;\n        this.nodeStatuses[nodeId].isVisible = tempNodeStatus.isVisible;\n        this.nodeStatuses[nodeId].isVisitable = tempNodeStatus.isVisitable;\n        this.nodeStatuses[nodeId].isCompleted = tempNodeStatus.isCompleted;\n\n        if (previousIsCompletedValue == false && tempNodeStatus.isCompleted) {\n          /*\n           * the node status just changed from false to true so we\n           * will fire an event\n           */\n          this.$rootScope.$broadcast('nodeCompleted', { nodeId: nodeId });\n        }\n      }\n\n      this.nodeStatuses[nodeId].progress = this.getNodeProgressById(nodeId);\n      this.nodeStatuses[nodeId].icon = this.ProjectService.getNodeIconByNodeId(nodeId);\n\n      // get the latest component state for the node\n      const latestComponentStatesForNode = this.getLatestComponentStateByNodeId(nodeId);\n      if (latestComponentStatesForNode != null) {\n        // set the latest component state timestamp into the node status\n        this.nodeStatuses[nodeId].latestComponentStateClientSaveTime = latestComponentStatesForNode.clientSaveTime;\n        this.nodeStatuses[nodeId].latestComponentStateServerSaveTime = latestComponentStatesForNode.serverSaveTime;\n      }\n    }\n\n    //return nodeStatus;\n  };\n\n  /**\n   * Evaluate the constraint\n   * @param node the node\n   * @param constraintForNode the constraint object\n   * @returns whether the node has satisfied the constraint\n   */\n  evaluateConstraint(node, constraintForNode) {\n    let result = false;\n    if (constraintForNode != null) {\n      const removalCriteria = constraintForNode.removalCriteria;\n      if (removalCriteria != null) {\n        result = this.evaluateNodeConstraint(node, constraintForNode);\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Evaluate the guided navigation constraint\n   * @param node the node\n   * @param constraintForNode the constraint object\n   * @returns whether the node can be visited or not\n   */\n  evaluateGuidedNavigationConstraint(node, constraintForNode) {\n    let result = false;\n    if (node != null) {\n      const nodeId = node.id;\n\n      if (this.isNodeVisited(nodeId)) {\n        // the node has been visited before so it should be clickable\n        result = true;\n      } else {\n        // get all the nodes that have been visited\n        const visitedNodes = this.getVisitedNodesHistory();\n\n        let transitionsToNodeId = [];\n\n        // loop through all the ndoes that have been visited\n        for (let visitedNodeId of visitedNodes) {\n          // get the transitions from the visited node to the node status node\n          const transitions = this.ProjectService.getTransitionsByFromAndToNodeId(visitedNodeId, nodeId);\n\n          // TODO: check if the transition can be used by the student\n\n          // concat the node ids\n          transitionsToNodeId = transitionsToNodeId.concat(transitions);\n        }\n\n        if (transitionsToNodeId != null && transitionsToNodeId.length > 0) {\n          // there is a transition between the current node and the node status node\n\n          /*\n           * there are transitions from the current node to the node status node so\n           * the node status node is clickable\n           */\n          result = true;\n        } else {\n          /*\n           * there is no transition between the visited nodes and the node status node\n           * so we will set the node to be not clickable\n           */\n          result = false;\n        }\n\n        if (this.ProjectService.isStartNode(node)) {\n          /*\n           * the node is the start node of the project or a start node of a group\n           * so we will make it clickable\n           */\n          result = true;\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Evaluate the node constraint\n   * @param node the node\n   * @param constraintForNode the constraint object\n   * @returns whether the node satisifies the constraint\n   */\n  evaluateNodeConstraint(node, constraintForNode) {\n    let result = false;\n\n    if (constraintForNode != null) {\n      const removalCriteria = constraintForNode.removalCriteria;\n      const removalConditional = constraintForNode.removalConditional;\n      if (removalCriteria == null) {\n        result = true;\n      } else {\n        let firstResult = true;\n\n        // loop through all the criteria that need to be satisifed\n        for (let tempCriteria of removalCriteria) {\n          if (tempCriteria != null) {\n            // evaluate the criteria\n            const tempResult = this.evaluateCriteria(tempCriteria);\n\n            if (firstResult) {\n              // this is the first criteria in this for loop\n              result = tempResult;\n              firstResult = false;\n            } else {\n              // this is not the first criteria\n\n              if (removalConditional === 'any') {\n                // any of the criteria can be true to remove the constraint\n                result = result || tempResult;\n              } else {\n                // all the criteria need to be true to remove the constraint\n                result = result && tempResult;\n              }\n            }\n          }\n        }\n      }\n    }\n    return result;\n  };\n\n\n  /**\n   * Evaluate the criteria\n   * @param criteria the criteria\n   * @returns whether the criteria is satisfied or not\n   */\n  evaluateCriteria(criteria) {\n    let result = false;\n    if (criteria != null) {\n      const functionName = criteria.name;\n      if (functionName == null) {\n\n      } else if (functionName === 'branchPathTaken') {\n        result = this.evaluateBranchPathTakenCriteria(criteria);\n      } else if (functionName === 'isVisible') {\n\n      } else if (functionName === 'isVisitable') {\n\n      } else if (functionName === 'isVisited') {\n        result = this.evaluateIsVisitedCriteria(criteria);\n      } else if (functionName === 'isVisitedAfter') {\n        result = this.evaluateIsVisitedAfterCriteria(criteria);\n      } else if (functionName === 'isRevisedAfter') {\n        result = this.evaluateIsRevisedAfterCriteria(criteria);\n      } else if (functionName === 'isVisitedAndRevisedAfter') {\n        result = this.evaluateIsVisitedAndRevisedAfterCriteria(criteria);\n      } else if (functionName === 'isCompleted') {\n        result = this.evaluateIsCompletedCriteria(criteria);\n      } else if (functionName === 'isCorrect') {\n        result = this.evaluateIsCorrectCriteria(criteria);\n      } else if (functionName === 'choiceChosen') {\n        result = this.evaluateChoiceChosenCriteria(criteria);\n      } else if (functionName === 'isPlanningActivityCompleted') {\n        result = this.evaluateIsPlanningActivityCompletedCriteria(criteria);\n      } else if (functionName === 'score') {\n        result = this.evaluateScoreCriteria(criteria);\n      } else if (functionName === 'usedXSubmits') {\n        result = this.evaluateUsedXSubmitsCriteria(criteria);\n      } else if (functionName === '') {\n\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Check if the isCompleted criteria was satisfied\n   * @param criteria an isCompleted criteria\n   * @returns whether the criteria was satisfied or not\n   */\n  evaluateIsCompletedCriteria(criteria) {\n    let result = false;\n    if (criteria != null && criteria.params != null) {\n      const params = criteria.params;\n      const nodeId = params.nodeId;\n      result = this.isCompleted(nodeId);\n    }\n    return result;\n  }\n\n  /**\n   * Check if the isCorrect criteria was satisfied\n   * @param criteria an isCorrect criteria\n   * @returns whether the criteria was satisfied or not\n   */\n  evaluateIsCorrectCriteria(criteria) {\n    if (criteria != null && criteria.params != null) {\n      // get the criteria params\n      const params = criteria.params;\n      const nodeId = params.nodeId;\n      const componentId = params.componentId;\n\n      if (nodeId != null && componentId != null) {\n        // get the component states for the component\n        const componentStates = this.getComponentStatesByNodeIdAndComponentId(nodeId, componentId);\n\n        if (componentStates != null) {\n          // loop through all the component states\n          for (let componentState of componentStates) {\n            if (componentState != null) {\n              const studentData = componentState.studentData;\n              if (studentData != null) {\n                if (studentData.isCorrect) {\n                  // the student answered correctly\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Check if the isPlanningActivityCompleted criteria was satisfied\n   * @param criteria a isPlanningActivityCompleted criteria\n   * @returns whether the criteria was satisfied or not\n   */\n  evaluateIsPlanningActivityCompletedCriteria(criteria) {\n    let result = false;\n    if (criteria != null && criteria.params != null) {\n      const params = criteria.params;\n\n      // get the group id\n      const nodeId = params.nodeId;\n\n      // get the number of planning steps the student needs to create\n      const planningStepsCreated = params.planningStepsCreated;\n\n      // get whether the student needs to complete all the steps in the activity\n      const planningStepsCompleted = params.planningStepsCompleted;\n\n      let planningStepsCreatedSatisfied = false;\n      let planningStepsCompletedSatisfied = false;\n\n      let planningNodes = [];\n\n      if (planningStepsCreated == null) {\n        // there is no value set so we will regard it as satisfied\n        planningStepsCreatedSatisfied = true;\n      } else {\n        /*\n         * there is a value for number of planning steps that need to be created\n         * so we will check if the student created enough planning steps\n         */\n\n        // get the node states for the activity\n        const nodeStates = this.getNodeStatesByNodeId(nodeId);\n\n        if (nodeStates != null) {\n          /*\n           * loop through all the node states from newest to oldest\n           * for the sake of efficiency\n           */\n          for (let ns = nodeStates.length - 1; ns >= 0; ns--) {\n            let planningStepCount = 0;\n            const nodeState = nodeStates[ns];\n            if (nodeState != null) {\n              // get the student data\n              const studentData = nodeState.studentData;\n\n              if (studentData != null) {\n                // get the nodes\n                const nodes = studentData.nodes;\n\n                if (nodes != null) {\n                  // loop through the nodes\n                  for (let node of nodes) {\n                    if (node != null) {\n                      if (node.type === 'node' && node.planningNodeTemplateId != null) {\n                        // we have found a planning step the student created\n                        planningStepCount++;\n                      }\n                    }\n                  }\n\n                  if (planningStepCount >= planningStepsCreated) {\n                    // the student has created a sufficient number of planning steps\n                    planningStepsCreatedSatisfied = true;\n                    planningNodes = nodes;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (planningStepsCompleted == null) {\n        planningStepsCompletedSatisfied = true;\n      } else {\n        /*\n         * check if the activity is completed. this checks if all\n         * the children of the activity are completed.\n         */\n        if (this.isCompleted(nodeId)) {\n          planningStepsCompletedSatisfied = true;\n        }\n      }\n\n      if (planningStepsCreatedSatisfied && planningStepsCompletedSatisfied) {\n        result = true;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Check if this branchPathTaken criteria was satisfied\n   * @param criteria a branchPathTaken criteria\n   * @returns whether the branchPathTaken criteria was satisfied\n   */\n  evaluateBranchPathTakenCriteria(criteria) {\n    let result = false;\n    if (criteria != null && criteria.params != null) {\n      // get the expected from and to node ids\n      const expectedFromNodeId = criteria.params.fromNodeId;\n      const expectedToNodeId = criteria.params.toNodeId;\n\n      // get all the branchPathTaken events from the from node id\n      const branchPathTakenEvents = this.getBranchPathTakenEventsByNodeId(expectedFromNodeId);\n\n      if (branchPathTakenEvents != null) {\n        // loop through all the branchPathTaken events\n        for (let branchPathTakenEvent of branchPathTakenEvents) {\n          if (branchPathTakenEvent != null) {\n            const data = branchPathTakenEvent.data;\n            if (data != null) {\n              // get the from and to node ids of the event\n              const fromNodeId = data.fromNodeId;\n              const toNodeId = data.toNodeId;\n              if (expectedFromNodeId === fromNodeId && expectedToNodeId === toNodeId) {\n                // the from and to node ids match the ones we are looking for\n                result = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Check if the isVisited criteria was satisfied\n   * @param criteria the isVisited criteria\n   * @returns whether the node id is visited\n   */\n  evaluateIsVisitedCriteria(criteria) {\n    let isVisited = false;\n    if (criteria != null && criteria.params != null) {\n      // get the node id we want to check if was visited\n      const nodeId = criteria.params.nodeId;\n\n      // get all the events\n      const events = this.studentData.events;\n      if (events != null) {\n        // loop through all the events\n        for (let event of events) {\n          if (event != null) {\n            if (nodeId == event.nodeId && 'nodeEntered' === event.event) {\n              // the student has entered the node before\n              isVisited = true;\n            }\n          }\n        }\n      }\n    }\n    return isVisited;\n  }\n\n  /**\n   * Check if the isVisitedAfter criteria was satisfied\n   * @param criteria the isVisitedAfter criteria\n   * @returns whether the node id is visited after the criteriaCreatedTimestamp\n   */\n  evaluateIsVisitedAfterCriteria(criteria) {\n    let isVisitedAfter = false;\n    if (criteria != null && criteria.params != null) {\n      // get the node id we want to check if was visited\n      let isVisitedAfterNodeId = criteria.params.isVisitedAfterNodeId;\n      let criteriaCreatedTimestamp = criteria.params.criteriaCreatedTimestamp;\n\n      // get all the events\n      let events = this.studentData.events;\n\n      if (events != null) {\n        // loop through all the events\n        for (let event of events) {\n          if (event != null) {\n            if (isVisitedAfterNodeId == event.nodeId && 'nodeEntered' === event.event && event.clientSaveTime > criteriaCreatedTimestamp) {\n              // the student has entered the node after the criteriaCreatedTimestamp\n              isVisitedAfter = true;\n            }\n          }\n        }\n      }\n    }\n    return isVisitedAfter;\n  }\n\n  /**\n   * Check if the isRevisedAfter criteria was satisfied\n   * @param criteria the isRevisedAfter criteria\n   * @returns whether the specified node&component was revisted after the criteriaCreatedTimestamp\n   */\n  evaluateIsRevisedAfterCriteria(criteria) {\n    let isRevisedAfter = false;\n    if (criteria != null && criteria.params != null) {\n      // get the node id we want to check if was visited\n      let isRevisedAfterNodeId = criteria.params.isRevisedAfterNodeId;\n      let isRevisedAfterComponentId = criteria.params.isRevisedAfterComponentId;\n      let criteriaCreatedTimestamp = criteria.params.criteriaCreatedTimestamp;\n\n      // the student has entered the node after the criteriaCreatedTimestamp.\n      // now check if student has revised the work after this event\n      let latestComponentStateForRevisedComponent = this.getLatestComponentStateByNodeIdAndComponentId(isRevisedAfterNodeId, isRevisedAfterComponentId);\n      if (latestComponentStateForRevisedComponent.clientSaveTime > criteriaCreatedTimestamp) {\n        isRevisedAfter = true;\n      }\n    }\n    return isRevisedAfter;\n  }\n\n  /**\n   * Check if the isVisitedAndRevisedAfter criteria was satisfied\n   * @param criteria the isVisitedAndRevisedAfter criteria\n   * @returns whether the specified nodes were visited and specified node&component was revisted after the criteriaCreatedTimestamp\n   */\n  evaluateIsVisitedAndRevisedAfterCriteria(criteria) {\n    let isVisitedAndRevisedAfter = false;\n    if (criteria != null && criteria.params != null) {\n      // get the node id we want to check if was visited\n      let isVisitedAfterNodeId = criteria.params.isVisitedAfterNodeId;\n      let isRevisedAfterNodeId = criteria.params.isRevisedAfterNodeId;\n      let isRevisedAfterComponentId = criteria.params.isRevisedAfterComponentId;\n      let criteriaCreatedTimestamp = criteria.params.criteriaCreatedTimestamp;\n\n      // get all the events\n      let events = this.studentData.events;\n\n      if (events != null) {\n        // loop through all the events\n        for (let event of events) {\n          if (event != null) {\n            if (isVisitedAfterNodeId == event.nodeId && 'nodeEntered' === event.event && event.clientSaveTime > criteriaCreatedTimestamp) {\n              // the student has entered the node after the criteriaCreatedTimestamp.\n              // now check if student has revised the work after this event\n              let latestComponentStateForRevisedComponent = this.getLatestComponentStateByNodeIdAndComponentId(isRevisedAfterNodeId, isRevisedAfterComponentId);\n              if (latestComponentStateForRevisedComponent.clientSaveTime > event.clientSaveTime) {\n                isVisitedAndRevisedAfter = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return isVisitedAndRevisedAfter;\n  }\n\n  /**\n   * Get all the branchPathTaken events by node id\n   * @params fromNodeId the from node id\n   * @returns all the branchPathTaken events from the given node id\n   */\n  getBranchPathTakenEventsByNodeId(fromNodeId) {\n    const branchPathTakenEvents = [];\n    const events = this.studentData.events;\n    if (events != null) {\n      // loop through all the events\n      for (let event of events) {\n        if (event != null) {\n          if (fromNodeId === event.nodeId && 'branchPathTaken' === event.event) {\n            // we have found a branchPathTaken event from the from node id\n            branchPathTakenEvents.push(event);\n          }\n        }\n      }\n    }\n    return branchPathTakenEvents;\n  }\n\n  /**\n   * Evaluate the choice chosen criteria\n   * @param criteria the criteria to evaluate\n   * @returns a boolean value whether the criteria was satisfied or not\n   */\n  evaluateChoiceChosenCriteria(criteria) {\n    let result = false;\n    const serviceName = 'MultipleChoiceService';  // Assume MC component.\n    if (this.$injector.has(serviceName)) {\n      // get the MultipleChoiceService\n      const service = this.$injector.get(serviceName);\n\n      // check if the criteria was satisfied\n      result = service.choiceChosen(criteria);\n    }\n    return result;\n  };\n\n  /**\n   * Evaluate the score criteria\n   * @param criteria the criteria to evaluate\n   * @returns a boolean value whether the criteria was satisfied or not\n   */\n  evaluateScoreCriteria(criteria) {\n    let result = false;\n    const params = criteria.params;\n    if (params != null) {\n      const nodeId = params.nodeId;\n      const componentId = params.componentId;\n      const scores = params.scores;\n      const workgroupId = this.ConfigService.getWorkgroupId();\n      const scoreType = 'any';\n      if (nodeId != null && componentId != null && scores != null) {\n        // get the latest score annotation\n        const latestScoreAnnotation = this.AnnotationService.getLatestScoreAnnotation(nodeId, componentId, workgroupId, scoreType);\n\n        if (latestScoreAnnotation != null) {\n          // get the score value\n          const scoreValue = this.AnnotationService.getScoreValueFromScoreAnnotation(latestScoreAnnotation);\n\n          // check if the score value matches what the criteria is looking for. works when scores is array of integers or integer strings\n          if (scores.indexOf(scoreValue) != -1 || (scoreValue != null && scores.indexOf(scoreValue.toString()) != -1)) {\n            /*\n             * the student has received a score that matches a score\n             * we're looking for\n             */\n            result = true;\n          }\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Evaluate the used x submits criteria which requires the student to submit\n   * at least x number of times.\n   * @param criteria the criteria to evaluate\n   * @returns a boolean value whether the student submitted at least x number\n   * of times\n   */\n  evaluateUsedXSubmitsCriteria(criteria) {\n    let result = false;\n    const params = criteria.params;\n    if (params != null) {\n      // get the node id and component id to check the submit counter for\n      const nodeId = params.nodeId;\n      const componentId = params.componentId;\n\n      // get the number of submits required\n      const requiredSubmitCount = params.requiredSubmitCount;\n\n      if (nodeId != null && componentId != null) {\n        // get the component states for the component\n        const componentStates = this.getComponentStatesByNodeIdAndComponentId(nodeId, componentId);\n        if (componentStates != null) {\n          // counter for manually counting the component states with isSubmit=true\n          let manualSubmitCounter = 0;\n\n          // counter for remembering the highest submitCounter value found in studentData objects\n          let highestSubmitCounter = 0;\n\n          /*\n           * We are counting with two submit counters for backwards compatibility.\n           * Some componentStates only have isSubmit=true and do not keep an\n           * updated submitCounter for the number of submits.\n           */\n\n          // loop through all the component states\n          for (let componentState of componentStates) {\n            if (componentState != null) {\n              if (componentState.isSubmit) {\n                // this is a submit component state\n                manualSubmitCounter++;\n              }\n              const studentData = componentState.studentData;\n              if (studentData != null) {\n                if (studentData.submitCounter != null) {\n                  if (studentData.submitCounter > highestSubmitCounter) {\n                    /*\n                     * the submit counter in the student data is higher\n                     * than we have previously seen\n                     */\n                    highestSubmitCounter = studentData.submitCounter;\n                  }\n                }\n              }\n            }\n          }\n\n          if (manualSubmitCounter >= requiredSubmitCount || highestSubmitCounter >= requiredSubmitCount) {\n            // the student submitted the required number of times\n            result = true;\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Populate the stack history and visited nodes history\n   * @param events the events\n   */\n  populateHistories(events) {\n    this.stackHistory = [];\n    this.visitedNodesHistory = [];\n\n    if (events != null) {\n      // loop through all the events\n      for (let event of events) {\n        if (event != null) {\n          // look for the nodeEntered event\n          if (event.event === 'nodeEntered') {\n            // the student has visited this node id before\n            this.updateStackHistory(event.nodeId);\n            this.updateVisitedNodesHistory(event.nodeId);\n          }\n        }\n      }\n    }\n  };\n\n  getStackHistoryAtIndex(index) {\n    if (index < 0) {\n      index = this.stackHistory.length + index;\n    }\n    let stackHistoryResult = null;\n    if (this.stackHistory != null && this.stackHistory.length > 0) {\n      stackHistoryResult = this.stackHistory[index];\n    }\n    return stackHistoryResult;\n  };\n\n  getStackHistory() {\n    return this.stackHistory;\n  };\n\n  updateStackHistory(nodeId) {\n    const indexOfNodeId = this.stackHistory.indexOf(nodeId);\n    if (indexOfNodeId === -1) {\n      this.stackHistory.push(nodeId);\n    } else {\n      this.stackHistory.splice(indexOfNodeId + 1, this.stackHistory.length);\n    }\n  };\n\n  updateVisitedNodesHistory(nodeId) {\n    const indexOfNodeId = this.visitedNodesHistory.indexOf(nodeId);\n    if (indexOfNodeId === -1) {\n      this.visitedNodesHistory.push(nodeId);\n    }\n  };\n\n  getVisitedNodesHistory() {\n    return this.visitedNodesHistory;\n  };\n\n  isNodeVisited(nodeId) {\n    let result = false;\n    const visitedNodesHistory = this.visitedNodesHistory;\n    if (visitedNodesHistory != null) {\n      const indexOfNodeId = visitedNodesHistory.indexOf(nodeId);\n      if (indexOfNodeId !== -1) {\n        result = true;\n      }\n    }\n    return result;\n  };\n\n  createComponentState() {\n    const componentState = {};\n    componentState.timestamp = Date.parse(new Date());\n    return componentState;\n  };\n\n  addComponentState(componentState) {\n    if (this.studentData != null && this.studentData.componentStates != null) {\n      this.studentData.componentStates.push(componentState);\n    }\n  };\n\n  addNodeState(nodeState) {\n    if (this.studentData != null && this.studentData.nodeStates != null) {\n      this.studentData.nodeStates.push(nodeState);\n    }\n  };\n\n  /**\n   * Returns all NodeStates\n   * @returns Array of all NodeStates\n   */\n  getNodeStates() {\n    let nodeStates = [];\n    if (this.studentData != null && this.studentData.nodeStates != null) {\n      nodeStates = this.studentData.nodeStates;\n    }\n    return nodeStates;\n  };\n\n  /**\n   * Get all NodeStates for a specific node\n   * @param nodeId id of node\n   * @returns Array of NodeStates for the specified node\n   */\n  getNodeStatesByNodeId(nodeId) {\n    const nodeStatesByNodeId = [];\n    if (this.studentData != null && this.studentData.nodeStates != null) {\n      const nodeStates = this.studentData.nodeStates;\n      for (let nodeState of nodeStates) {\n        if (nodeState != null) {\n          const tempNodeId = nodeState.nodeId;\n          if (nodeId === tempNodeId) {\n            nodeStatesByNodeId.push(nodeState);\n          }\n        }\n      }\n    }\n    return nodeStatesByNodeId;\n  };\n\n  addEvent(event) {\n    if (this.studentData != null && this.studentData.events != null) {\n      this.studentData.events.push(event);\n    }\n  };\n\n  addAnnotation(annotation) {\n    if (this.studentData != null && this.studentData.annotations != null) {\n      this.studentData.annotations.push(annotation);\n    }\n  };\n\n  handleAnnotationReceived(annotation) {\n    // add the annotation to the local annotations array\n    this.studentData.annotations.push(annotation);\n\n    if (annotation.notebookItemId) {\n      // broadcast the event that a new notebook item annotation has been received\n      this.$rootScope.$broadcast('notebookItemAnnotationReceived', {annotation: annotation});\n    } else {\n      // broadcast the event that a new annotation has been received\n      this.$rootScope.$broadcast('annotationReceived', {annotation: annotation});\n    }\n  }\n\n  saveComponentEvent(component, category, event, data) {\n    if (component == null || category == null || event == null) {\n      alert(this.$translate('STUDENT_DATA_SERVICE_SAVE_COMPONENT_EVENT_COMPONENT_CATEGORY_EVENT_ERROR'));\n      return;\n    }\n    const context = \"Component\";\n    const nodeId = component.nodeId;\n    const componentId = component.componentId;\n    const componentType = component.componentType;\n    if (nodeId == null || componentId == null || componentType == null) {\n      alert(this.$translate('STUDENT_DATA_SERVICE_SAVE_COMPONENT_EVENT_NODE_ID_COMPONENT_ID_COMPONENT_TYPE_ERROR'));\n      return;\n    }\n    this.saveEvent(context, nodeId, componentId, componentType, category, event, data);\n  };\n\n  saveVLEEvent(nodeId, componentId, componentType, category, event, data) {\n    if (category == null || event == null) {\n      alert(this.$translate('STUDENT_DATA_SERVICE_SAVE_VLE_EVENT_CATEGORY_EVENT_ERROR'));\n      return;\n    }\n    const context = \"VLE\";\n    this.saveEvent(context, nodeId, componentId, componentType, category, event, data);\n  };\n\n  saveEvent(context, nodeId, componentId, componentType, category, event, data) {\n    const events = [];\n    const newEvent = this.createNewEvent();\n    newEvent.context = context;\n    newEvent.nodeId = nodeId;\n    newEvent.componentId = componentId;\n    newEvent.type = componentType;\n    newEvent.category = category;\n    newEvent.event = event;\n    newEvent.data = data;\n    events.push(newEvent);\n    const componentStates = null;\n    const nodeStates = null;\n    const annotations = null;\n    this.saveToServer(componentStates, nodeStates, events, annotations);\n  };\n\n  /**\n   * Create a new empty event\n   * @return a new empty event\n   */\n  createNewEvent() {\n    const event = {};\n    event.projectId = this.ConfigService.getProjectId();\n    event.runId = this.ConfigService.getRunId();\n    event.periodId = this.ConfigService.getPeriodId();\n    event.workgroupId = this.ConfigService.getWorkgroupId();\n    event.clientSaveTime = Date.parse(new Date());\n    return event;\n  };\n\n  saveNodeStates(nodeStates) {\n    const componentStates = null;\n    const events = null;\n    const annotations = null;\n    this.saveToServer(componentStates, nodeStates, events, annotations);\n  };\n\n\n  saveAnnotations(annotations) {\n    const componentStates = null;\n    const nodeStates = null;\n    const events = null;\n    this.saveToServer(componentStates, nodeStates, events, annotations);\n  };\n\n  saveToServer(componentStates, nodeStates, events, annotations) {\n    /*\n     * increment the request count since we are about to save data\n     * to the server\n     */\n    this.saveToServerRequestCount += 1;\n\n    // merge componentStates and nodeStates into StudentWork before posting\n    const studentWorkList = [];\n    if (componentStates != null && componentStates.length > 0) {\n      for (let componentState of componentStates) {\n        if (componentState != null) {\n          componentState.requestToken = this.UtilService.generateKey(); // use this to keep track of unsaved componentStates.\n          this.addComponentState(componentState);\n          studentWorkList.push(componentState);\n        }\n      }\n    }\n\n    if (nodeStates != null && nodeStates.length > 0) {\n      for (let nodeState of nodeStates) {\n        if (nodeState != null) {\n          nodeState.requestToken = this.UtilService.generateKey(); // use this to keep track of unsaved componentStates.\n          this.addNodeState(nodeState);\n          studentWorkList.push(nodeState);\n        }\n      }\n    }\n\n    if (events != null && events.length > 0) {\n      for (let event of events) {\n        if (event != null) {\n          event.requestToken = this.UtilService.generateKey(); // use this to keep track of unsaved events.\n          this.addEvent(event);\n        }\n      }\n    } else {\n      events = [];\n    }\n\n    if (annotations != null && annotations.length > 0) {\n      for (let annotation of annotations) {\n        if (annotation != null) {\n          annotation.requestToken = this.UtilService.generateKey(); // use this to keep track of unsaved annotations.\n          if (annotation.id == null) {\n            // add to local annotation array if this annotation has not been saved to the server before.\n            this.addAnnotation(annotation);\n          }\n        }\n      }\n    } else {\n      annotations = [];\n    }\n\n    if (this.ConfigService.isPreview()) {\n      const savedStudentDataResponse = {\n        studentWorkList: studentWorkList,\n        events: events,\n        annotations: annotations\n      };\n\n      // if we're in preview, don't make any request to the server but pretend we did\n      this.saveToServerSuccess(savedStudentDataResponse);\n      let deferred = this.$q.defer();\n      deferred.resolve(savedStudentDataResponse);\n      return deferred.promise;\n    } else {\n      // set the workgroup id and run id\n      const params = {};\n      params.projectId = this.ConfigService.getProjectId();\n      params.runId = this.ConfigService.getRunId();\n      params.workgroupId = this.ConfigService.getWorkgroupId();\n      params.studentWorkList = angular.toJson(studentWorkList);\n      params.events = angular.toJson(events);\n      params.annotations = angular.toJson(annotations);\n\n      // get the url to POST the student data\n      const httpParams = {};\n      httpParams.method = 'POST';\n      httpParams.url = this.ConfigService.getConfigParam('studentDataURL');\n      httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n      httpParams.data = $.param(params);\n\n      // make the request to post the student data\n      return this.$http(httpParams).then(\n        result => {\n          // get the local references to the component states that were posted and set their id and serverSaveTime\n          if (result != null && result.data != null) {\n            const savedStudentDataResponse = result.data;\n\n            this.saveToServerSuccess(savedStudentDataResponse);\n\n            return savedStudentDataResponse;\n          }\n        }, result => {\n          // a server error occured\n\n          /*\n           * decrement the request count since this request failed\n           * but is now completed\n           */\n          this.saveToServerRequestCount -= 1;\n\n          return null;\n        }\n      );\n    }\n  };\n\n  saveToServerSuccess(savedStudentDataResponse) {\n    /*\n     * decrement the request count since we have received a response to\n     * one of our save requests\n     */\n    this.saveToServerRequestCount -= 1;\n\n    if (this.saveToServerRequestCount == 0) {\n      /*\n       * we have received the reponse to all of the saveToServer requests\n       * so we will now update the student status and save it to the\n       * server\n       */\n      this.updateNodeStatuses();\n      this.saveStudentStatus();\n    }\n\n    // set dummy serverSaveTime for use if we're in preview mode\n    let serverSaveTime = Date.parse(new Date());\n\n    // handle saved studentWork\n    if (savedStudentDataResponse.studentWorkList) {\n      let savedStudentWorkList = savedStudentDataResponse.studentWorkList;\n      let localStudentWorkList = this.studentData.componentStates;\n      if (this.studentData.nodeStates) {\n        localStudentWorkList = localStudentWorkList.concat(this.studentData.nodeStates);\n      }\n\n      // set the id and serverSaveTime in the local studentWorkList\n      for (let savedStudentWork of savedStudentWorkList) {\n        /*\n         * loop through all the student work that were posted\n         * to find the one with the matching request token\n         */\n        for (let l = localStudentWorkList.length - 1; l >= 0; l--) {\n          const localStudentWork = localStudentWorkList[l];\n          if (localStudentWork.requestToken &&\n            localStudentWork.requestToken === savedStudentWork.requestToken) {\n            localStudentWork.id = savedStudentWork.id;\n            localStudentWork.serverSaveTime = savedStudentWork.serverSaveTime ? savedStudentWork.serverSaveTime : serverSaveTime;\n            localStudentWork.requestToken = null; // requestToken is no longer needed.\n\n            if (this.ConfigService.getMode() == \"preview\" && localStudentWork.id == null) {\n              /*\n               * we are in preview mode so we will set a dummy\n               * student work id into the student work\n               */\n              localStudentWork.id = this.dummyStudentWorkId;\n\n              /*\n               * increment the dummy student work id for the next\n               * student work\n               */\n              this.dummyStudentWorkId++;\n            }\n\n            this.$rootScope.$broadcast('studentWorkSavedToServer', {studentWork: localStudentWork});\n            break;\n          }\n        }\n      }\n    }\n    // handle saved events\n    if (savedStudentDataResponse.events) {\n      const savedEvents = savedStudentDataResponse.events;\n\n      const localEvents = this.studentData.events;\n\n      // set the id and serverSaveTime in the local event\n      for (let savedEvent of savedEvents) {\n        /*\n         * loop through all the events that were posted\n         * to find the one with the matching request token\n         */\n        for (let l = localEvents.length - 1; l >= 0; l--) {\n          const localEvent = localEvents[l];\n          if (localEvent.requestToken &&\n            localEvent.requestToken === savedEvent.requestToken) {\n            localEvent.id = savedEvent.id;\n            localEvent.serverSaveTime = savedEvent.serverSaveTime ? savedEvent.serverSaveTime : serverSaveTime;\n            localEvent.requestToken = null; // requestToken is no longer needed.\n\n            this.$rootScope.$broadcast('eventSavedToServer', {event: localEvent});\n            break;\n          }\n        }\n      }\n    }\n\n    // handle saved annotations\n    if (savedStudentDataResponse.annotations) {\n      const savedAnnotations = savedStudentDataResponse.annotations;\n      const localAnnotations = this.studentData.annotations;\n\n      // set the id and serverSaveTime in the local annotation\n      for (let savedAnnotation of savedAnnotations) {\n        /*\n         * loop through all the events that were posted\n         * to find the one with the matching request token\n         */\n        for (let l = localAnnotations.length - 1; l >= 0; l--) {\n          const localAnnotation = localAnnotations[l];\n          if (localAnnotation.requestToken &&\n            localAnnotation.requestToken === savedAnnotation.requestToken) {\n            localAnnotation.id = savedAnnotation.id;\n            localAnnotation.serverSaveTime = savedAnnotation.serverSaveTime ? savedAnnotation.serverSaveTime : serverSaveTime;\n            localAnnotation.requestToken = null; // requestToken is no longer needed.\n\n            this.$rootScope.$broadcast('annotationSavedToServer', {annotation: localAnnotation});\n            break;\n          }\n        }\n      }\n    }\n  };\n\n  /**\n   * POSTs student status to server\n   * Returns a promise of the POST request\n   */\n  saveStudentStatus() {\n    if (!this.ConfigService.isPreview()) {\n      // we are in a run\n      const studentStatusURL = this.ConfigService.getStudentStatusURL();\n      if (studentStatusURL != null) {\n        const runId = this.ConfigService.getRunId();\n        const periodId = this.ConfigService.getPeriodId();\n        const workgroupId = this.ConfigService.getWorkgroupId();\n\n        // get the current node id\n        const currentNodeId = this.getCurrentNodeId();\n\n        // get the node statuses\n        const nodeStatuses = this.getNodeStatuses();\n\n        // get the project completion percentage\n        const projectCompletion = this.getProjectCompletion();\n\n        // create the JSON that will be saved to the database\n        const studentStatusJSON = {};\n        studentStatusJSON.runId = runId;\n        studentStatusJSON.periodId = periodId;\n        studentStatusJSON.workgroupId = workgroupId;\n        studentStatusJSON.currentNodeId = currentNodeId;\n        studentStatusJSON.nodeStatuses = nodeStatuses;\n        studentStatusJSON.projectCompletion = projectCompletion;\n\n        // get the student status as a string\n        const status = angular.toJson(studentStatusJSON);\n\n        /*\n         * create the params for the message that will be sent\n         * to the StudentStatusController and saved in the\n         * database\n         */\n        const studentStatusParams = {};\n        studentStatusParams.runId = runId;\n        studentStatusParams.periodId = periodId;\n        studentStatusParams.workgroupId = workgroupId;\n        studentStatusParams.status = status;\n\n        // get the url to POST the student data\n        const httpParams = {};\n        httpParams.method = 'POST';\n        httpParams.url = studentStatusURL;\n        httpParams.headers = {'Content-Type': 'application/x-www-form-urlencoded'};\n        httpParams.data = $.param(studentStatusParams);\n\n        // make the request to post the student status\n        return this.$http(httpParams).then(\n          result => {\n            return true;\n          }, result => {\n            // a server error occured\n            return false;\n          }\n        );\n      }\n    }\n  };\n\n  retrieveComponentStates(runId, periodId, workgroupId) {\n\n  };\n\n  getLatestComponentState() {\n    let latestComponentState = null;\n    const studentData = this.studentData;\n    if (studentData != null) {\n      const componentStates = studentData.componentStates;\n      if (componentStates != null) {\n        latestComponentState = componentStates[componentStates.length - 1];\n      }\n    }\n    return latestComponentState;\n  };\n\n  /**\n   * Check whether the component has unsubmitted work\n   * @return boolean whether or not there is unsubmitted work\n   */\n  isComponentSubmitDirty() {\n    let submitDirty = false;\n    let latestComponentState = this.getLatestComponentState();\n    if (latestComponentState && !latestComponentState.isSubmit) {\n      submitDirty = true;\n    }\n    return submitDirty;\n  };\n\n  /**\n   * Get the latest NodeState for the specified node id\n   * @param nodeId the node id\n   * @return the latest node state with the matching node id or null if none are found\n   */\n  getLatestNodeStateByNodeId(nodeId) {\n    let latestNodeState = null;\n    let allNodeStatesByNodeId = this.getNodeStatesByNodeId(nodeId);\n    if (allNodeStatesByNodeId != null && allNodeStatesByNodeId.length > 0) {\n      latestNodeState = allNodeStatesByNodeId[allNodeStatesByNodeId.length - 1];\n    }\n    return latestNodeState;\n  };\n\n  /**\n   * Get the latest component state for the given node id and component\n   * id.\n   * @param nodeId the node id\n   * @param componentId the component id (optional)\n   * @return the latest component state with the matching node id and\n   * component id or null if none are found\n   */\n  getLatestComponentStateByNodeIdAndComponentId(nodeId, componentId) {\n    let latestComponentState = null;\n    if (nodeId) {\n      const studentData = this.studentData;\n      if (studentData) {\n        // get the component states\n        const componentStates = studentData.componentStates;\n        if (componentStates) {\n          // loop through all the component states from newest to oldest\n          for (let c = componentStates.length - 1; c >= 0; c--) {\n            const componentState = componentStates[c];\n            if (componentState) {\n              const componentStateNodeId = componentState.nodeId;\n\n              // compare the node id and component id\n              if (nodeId === componentStateNodeId) {\n                if (componentId) {\n                  const componentStateComponentId = componentState.componentId;\n                  if (componentId === componentStateComponentId) {\n                    latestComponentState = componentState;\n                    break;\n                  }\n                } else {\n                  latestComponentState = componentState;\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return latestComponentState;\n  };\n\n  /**\n   * Get the student work by specified student work id, which can be a ComponentState or NodeState\n   * @param studentWorkId the student work id\n   * @return an StudentWork or null\n   */\n  getStudentWorkByStudentWorkId(studentWorkId) {\n    if (studentWorkId != null) {\n      // get the component states\n      const componentStates = this.studentData.componentStates;\n      if (componentStates != null) {\n        // loop through all the component states\n        for (let componentState of componentStates) {\n          if (componentState != null && componentState.id === studentWorkId) {\n            return componentState;\n          }\n        }\n      }\n\n      // get the node states\n      const nodeStates = this.studentData.nodeStates;\n      if (nodeStates != null) {\n        // loop through all the node states\n        for (let nodeState of nodeStates) {\n          if (nodeState != null && nodeState.id === studentWorkId) {\n            return nodeState;\n          }\n        }\n      }\n    }\n    return null;\n  };\n\n  /**\n   * Returns all the component states for this workgroup\n   */\n  getComponentStates() {\n    return this.studentData.componentStates;\n  };\n\n  /**\n   * Get the component states for the given node id\n   * @param nodeId the node id\n   * @return an array of component states for the given node id\n   */\n  getComponentStatesByNodeId(nodeId) {\n    const componentStatesByNodeId = [];\n    if (nodeId != null) {\n      const studentData = this.studentData;\n      if (studentData != null) {\n        // get the component states\n        const componentStates = studentData.componentStates;\n\n        if (componentStates != null) {\n          // loop through all the component states\n          for (let componentState of componentStates) {\n            if (componentState != null) {\n              const componentStateNodeId = componentState.nodeId;\n\n              // compare the node id\n              if (nodeId == componentStateNodeId) {\n                componentStatesByNodeId.push(componentState);\n              }\n            }\n          }\n        }\n      }\n    }\n    return componentStatesByNodeId;\n  };\n\n  /**\n   * Get the component states for the given node id and component id\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @return an array of component states for the given node id and\n   * component id\n   */\n  getComponentStatesByNodeIdAndComponentId(nodeId, componentId) {\n    const componentStatesByNodeIdAndComponentId = [];\n    if (nodeId != null && componentId != null) {\n      const studentData = this.studentData;\n      if (studentData != null) {\n        // get the component states\n        const componentStates = studentData.componentStates;\n\n        if (componentStates != null) {\n          // loop through all the component states\n          for (let componentState of componentStates) {\n            if (componentState != null) {\n              const componentStateNodeId = componentState.nodeId;\n              const componentStateComponentId = componentState.componentId;\n\n              // compare the node id and component id\n              if (nodeId == componentStateNodeId &&\n                  componentId == componentStateComponentId) {\n                componentStatesByNodeIdAndComponentId.push(componentState);\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return componentStatesByNodeIdAndComponentId;\n  };\n\n  /**\n   * Get all events\n   * @returns all events for the student\n   */\n  getEvents() {\n    if (this.studentData != null && this.studentData.events != null) {\n      return this.studentData.events;\n    } else {\n      return [];\n    }\n  };\n\n  /**\n   * Get the events for a node id\n   * @param nodeId the node id\n   * @returns the events for the node id\n   */\n  getEventsByNodeId(nodeId) {\n    const eventsByNodeId = [];\n    if (nodeId != null) {\n      if (this.studentData != null && this.studentData.events != null) {\n        // get all the events\n        const events = this.studentData.events;\n\n        // loop through all the events\n        for (let event of events) {\n          if (event != null) {\n            const eventNodeId = event.nodeId;\n            if (nodeId === eventNodeId) {\n              // this event is for the node id we are looking for\n              eventsByNodeId.push(event);\n            }\n          }\n        }\n      }\n    }\n    return eventsByNodeId;\n  };\n\n\n  /**\n   * Get the events for a component id\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns an array of events for the component id\n   */\n  getEventsByNodeIdAndComponentId(nodeId, componentId) {\n    const eventsByNodeId = [];\n    if (nodeId != null) {\n      if (this.studentData != null && this.studentData.events != null) {\n        // get all the events\n        const events = this.studentData.events;\n\n        // loop through all the events\n        for (let event of events) {\n          if (event != null) {\n            const eventNodeId = event.nodeId;\n            const eventComponentId = event.componentId;\n            if (nodeId === eventNodeId && componentId === eventComponentId) {\n              // this events is for the component id we are looking for\n              eventsByNodeId.push(event);\n            }\n          }\n        }\n      }\n    }\n    return eventsByNodeId;\n  };\n\n  /**\n   * Get the node id of the latest node entered event for an active node that\n   * exists in the project. We need to check if the node exists in the project\n   * in case the node has been deleted from the project. We also need to check\n   * that the node is active in case the node has been moved to the inactive\n   * section of the project.\n   * @return the node id of the latest node entered event for an active node\n   * that exists in the project\n   */\n  getLatestNodeEnteredEventNodeIdWithExistingNode() {\n    // get all the events\n    const events = this.studentData.events;\n\n    // loop through all the events newest to oldest\n    for (let e = events.length - 1; e >= 0; e--) {\n      // get an event\n      const event = events[e];\n      if (event != null) {\n        // get the event name\n        const eventName = event.event;\n        if (eventName == 'nodeEntered') {\n          // we have found a nodeEntered event\n\n          // get the node id of the event\n          const nodeId = event.nodeId;\n\n          // check if the node exists in the project\n          const node = this.ProjectService.getNodeById(nodeId);\n\n          if (node != null) {\n            // check if the node is active\n            if (this.ProjectService.isActive(nodeId)) {\n              // the node exists in the project and is active\n              return nodeId;\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Check if the student can visit the node\n   * @param nodeId the node id\n   * @returns whether the student can visit the node\n   */\n  canVisitNode(nodeId) {\n    let result = false;\n    if (nodeId != null) {\n      // get the node status for the node\n      const nodeStatus = this.getNodeStatusByNodeId(nodeId);\n      if (nodeStatus != null) {\n        if (nodeStatus.isVisitable) {\n          result = true;\n        }\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Get the node status by node id\n   * @param nodeId the node id\n   * @returns the node status object for a node\n   */\n  getNodeStatusByNodeId(nodeId) {\n    const nodeStatuses = this.nodeStatuses;\n    let nodeStatus = null;\n    if (nodeId != null) {\n      nodeStatus = nodeStatuses[nodeId];\n    }\n    return nodeStatus;\n  };\n\n  /**\n   * Get progress information for a given node\n   * @param nodeId the node id\n   * @returns object with number of completed items (both all and for items\n   * that capture student work), number of visible items (all/with work),\n   * completion % (for all items, items with student work)\n   */\n  getNodeProgressById(nodeId) {\n    let completedItems = 0;\n    let completedItemsWithWork = 0;\n    let totalItems = 0;\n    let totalItemsWithWork = 0;\n    let progress = {};\n\n    if (this.ProjectService.isGroupNode(nodeId)) {\n      let nodeIds = this.ProjectService.getChildNodeIdsById(nodeId);\n      for (let id of nodeIds) {\n        let status = this.nodeStatuses[id];\n        if (this.ProjectService.isGroupNode(id)) {\n          if (status.progress.totalItemsWithWork > -1) {\n            completedItems += status.progress.completedItems;\n            totalItems += status.progress.totalItems;\n            completedItemsWithWork += status.progress.completedItemsWithWork;\n            totalItemsWithWork += status.progress.totalItemsWithWork;\n          } else {\n            // we have a legacy node status so we'll need to calculate manually\n            let groupProgress = this.getNodeProgressById(id);\n            completedItems += groupProgress.completedItems;\n            totalItems += groupProgress.totalItems;\n            completedItemsWithWork += groupProgress.completedItemsWithWork;\n            totalItemsWithWork += groupProgress.totalItemsWithWork;\n          }\n        } else {\n          if (status.isVisible) {\n            totalItems++;\n\n            let hasWork = this.ProjectService.nodeHasWork(id);\n            if (hasWork) {\n              totalItemsWithWork++;\n            }\n\n            if (status.isCompleted) {\n              completedItems++;\n\n              if (hasWork) {\n                completedItemsWithWork++;\n              }\n            }\n          }\n        }\n      }\n\n      let completionPct = totalItems ? Math.round(completedItems / totalItems * 100) : 0;\n      let completionPctWithWork = totalItemsWithWork ? Math.round(completedItemsWithWork / totalItemsWithWork * 100) : 0;\n\n      progress = {\n        \"completedItems\": completedItems,\n        \"completedItemsWithWork\": completedItemsWithWork,\n        \"totalItems\": totalItems,\n        \"totalItemsWithWork\": totalItemsWithWork,\n        \"completionPct\": completionPct,\n        \"completionPctWithWork\": completionPctWithWork\n      };\n    }\n\n    // TODO: implement for steps (using components instead of child nodes)?\n\n    return progress;\n  };\n\n  /**\n   * Check if the given node or component is completed\n   * @param nodeId the node id\n   * @param componentId (optional) the component id\n   * @returns whether the node or component is completed\n   */\n  isCompleted(nodeId, componentId) {\n    let result = false;\n    if (nodeId && componentId) {\n      // check that the component is completed\n\n      // get the component states for the component\n      const componentStates = this.getComponentStatesByNodeIdAndComponentId(nodeId, componentId);\n\n      // get the component events\n      const componentEvents = this.getEventsByNodeIdAndComponentId(nodeId, componentId);\n\n      // get the node events\n      const nodeEvents = this.getEventsByNodeId(nodeId);\n\n      // get the component object\n      const component = this.ProjectService.getComponentByNodeIdAndComponentId(nodeId, componentId);\n\n      const node = this.ProjectService.getNodeById(nodeId);\n      if (component != null) {\n        // get the component type\n        const componentType = component.type;\n\n        if (componentType != null) {\n          // get the service for the component type\n          const service = this.$injector.get(componentType + 'Service');\n\n          // check if the component is completed\n          if (service.isCompleted(component, componentStates, componentEvents, nodeEvents, node)) {\n            result = true;\n          }\n        }\n      }\n    } else if (nodeId) {\n      // check if node is a group\n      const isGroup = this.ProjectService.isGroupNode(nodeId);\n\n      const node = this.ProjectService.getNodeById(nodeId);\n\n      if (isGroup) {\n        // node is a group\n        let tempResult = true;\n\n        // check that all the nodes in the group are visible and completed\n        const nodeIds = this.ProjectService.getChildNodeIdsById(nodeId);\n\n        if (nodeIds.length) {\n          for (let id of nodeIds) {\n            if (this.nodeStatuses[id] == null || !this.nodeStatuses[id].isVisible || !this.nodeStatuses[id].isCompleted) {\n              // the child is not visible or not completed so the group is not completed\n              tempResult = false;\n              break;\n            }\n          }\n        } else {\n          // there are no nodes in the group (could be a planning activity, for example), so set isCompleted to false\n          tempResult = false;\n        }\n        result = tempResult;\n      } else {\n        // check that all the components in the node are completed\n\n        // get all the components in the node\n        const components = this.ProjectService.getComponentsByNodeId(nodeId);\n\n        // we will default to is completed true\n        let tempResult = true;\n\n        /*\n         * All components must be completed in order for the node to be completed\n         * so we will loop through all the components and check if they are\n         * completed\n         */\n        for (let component of components) {\n          if (component != null) {\n            const componentId = component.id;\n            const componentType = component.type;\n            const showPreviousWorkNodeId = component.showPreviousWorkNodeId;\n            const showPreviousWorkComponentId = component.showPreviousWorkComponentId;\n\n            let tempNodeId = nodeId;\n            let tempNode = node;\n            let tempComponentId = componentId;\n            let tempComponent = component;\n\n            if (showPreviousWorkNodeId != null && showPreviousWorkComponentId != null) {\n              /*\n               * this is a show previous work component so we will check if the\n               * previous component was completed\n               */\n              tempNodeId = showPreviousWorkNodeId;\n              tempComponentId = showPreviousWorkComponentId;\n              tempNode = this.ProjectService.getNodeById(tempNodeId);\n              tempComponent = this.ProjectService.getComponentByNodeIdAndComponentId(tempNodeId, tempComponentId);\n            }\n\n            if (componentType != null) {\n              try {\n                // get the service name\n                const serviceName = componentType + 'Service';\n\n                if (this.$injector.has(serviceName)) {\n                  // get the service for the component type\n                  const service = this.$injector.get(serviceName);\n\n                  // get the component states for the component\n                  const componentStates = this.getComponentStatesByNodeIdAndComponentId(tempNodeId, tempComponentId);\n\n                  // get the component events\n                  const componentEvents = this.getEventsByNodeIdAndComponentId(tempNodeId, tempComponentId);\n\n                  // get the node events\n                  const nodeEvents = this.getEventsByNodeId(tempNodeId);\n\n                  // check if the component is completed\n                  const isComponentCompleted = service.isCompleted(tempComponent, componentStates, componentEvents, nodeEvents, tempNode);\n\n                  tempResult = tempResult && isComponentCompleted;\n                }\n              } catch (e) {\n                console.log(this.$translate('ERROR_COULD_NOT_CALCULATE_IS_COMPLETED') + tempComponentId);\n              }\n            }\n          }\n        }\n        result = tempResult;\n      }\n    }\n    return result;\n  };\n\n  /**\n   * Get the current node\n   * @returns the current node object\n   */\n  getCurrentNode() {\n    return this.currentNode;\n  };\n\n  /**\n   * Get the current node id\n   * @returns the current node id\n   */\n  getCurrentNodeId() {\n    let currentNodeId = null;\n    if (this.currentNode != null) {\n      currentNodeId = this.currentNode.id;\n    }\n    return currentNodeId;\n  };\n\n  /**\n   * Set the current node\n   * @param nodeId the node id\n   */\n  setCurrentNodeByNodeId(nodeId) {\n    if (nodeId != null) {\n      const node = this.ProjectService.getNodeById(nodeId);\n      this.setCurrentNode(node);\n    }\n  };\n\n  /**\n   * Set the current node\n   * @param node the node object\n   */\n  setCurrentNode(node) {\n    const previousCurrentNode = this.currentNode;\n    if (previousCurrentNode !== node) {\n      // the current node is about to change\n\n      if (previousCurrentNode && !this.ProjectService.isGroupNode(previousCurrentNode.id)) {\n        // set the previous node to the current node\n        this.previousStep = previousCurrentNode;\n      }\n\n      // set the current node to the new node\n      this.currentNode = node;\n\n      // broadcast the event that the current node has changed\n      this.$rootScope.$broadcast('currentNodeChanged', {previousNode: previousCurrentNode, currentNode: this.currentNode});\n    }\n  };\n\n  /**\n   * End the current node\n   */\n  endCurrentNode() {\n    // get the current node\n    const previousCurrentNode = this.currentNode;\n    if (previousCurrentNode != null) {\n      // tell the node to exit\n      this.$rootScope.$broadcast('exitNode', {nodeToExit: previousCurrentNode});\n    }\n  };\n\n  /**\n   * End the current node and set the current node\n   * @param nodeId the node id of the new current node\n   */\n  endCurrentNodeAndSetCurrentNodeByNodeId(nodeId) {\n    // check if the node is visitable\n    if (this.nodeStatuses[nodeId].isVisitable) {\n      // the node is visitable\n      // end the current node\n      this.endCurrentNode();\n\n      // set the current node\n      this.setCurrentNodeByNodeId(nodeId);\n    } else {\n      // the node is not visitable\n      this.nodeClickLocked(nodeId);\n    }\n  };\n\n  /**\n   * Broadcast a listenable event that a locked node has been clicked (attempted to be opened)\n   * @param nodeId\n   */\n  nodeClickLocked(nodeId) {\n    this.$rootScope.$broadcast('nodeClickLocked', {nodeId: nodeId});\n  };\n\n  /**\n   * This will parse a delimited string into an array of\n   * arrays. The default delimiter is the comma, but this\n   * can be overriden in the second argument.\n   * Source: http://www.bennadel.com/blog/1504-ask-ben-parsing-csv-strings-with-javascript-exec-regular-expression-command.htm\n   */\n  CSVToArray( strData, strDelimiter ) {\n    // Check to see if the delimiter is defined. If not,\n    // then default to comma.\n    strDelimiter = (strDelimiter || \",\");\n\n    // Create a regular expression to parse the CSV values.\n    const objPattern = new RegExp(\n      (\n        // Delimiters.\n        \"(\\\\\" + strDelimiter + \"|\\\\r?\\\\n|\\\\r|^)\" +\n\n        // Quoted fields.\n        \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" +\n\n        // Standard fields.\n        \"([^\\\"\\\\\" + strDelimiter + \"\\\\r\\\\n]*))\"\n      ),\n      \"gi\"\n    );\n\n    // Create an array to hold our data. Give the array\n    // a default empty first row.\n    const arrData = [[]];\n\n    // Create an array to hold our individual pattern\n    // matching groups.\n    let arrMatches = null;\n\n\n    // Keep looping over the regular expression matches\n    // until we can no longer find a match.\n    while (arrMatches = objPattern.exec( strData )) {\n\n      // Get the delimiter that was found.\n      const strMatchedDelimiter = arrMatches[ 1 ];\n\n      // Check to see if the given delimiter has a length\n      // (is not the start of string) and if it matches\n      // field delimiter. If id does not, then we know\n      // that this delimiter is a row delimiter.\n      if (\n        strMatchedDelimiter.length &&\n        (strMatchedDelimiter != strDelimiter)\n      ){\n\n        // Since we have reached a new row of data,\n        // add an empty row to our data array.\n        arrData.push( [] );\n      }\n\n      // Now that we have our delimiter out of the way,\n      // let's check to see which kind of value we\n      // captured (quoted or unquoted).\n      if (arrMatches[ 2 ]){\n\n        // We found a quoted value. When we capture\n        // this value, unescape any double quotes.\n        const strMatchedValue = arrMatches[ 2 ].replace(\n          new RegExp( \"\\\"\\\"\", \"g\" ),\n          \"\\\"\"\n        );\n\n      } else {\n        // We found a non-quoted value.\n        const strMatchedValue = arrMatches[ 3 ];\n      }\n\n      // Now that we have our value string, let's add\n      // it to the data array.\n      let finalValue = strMatchedValue;\n      const floatVal = parseFloat(strMatchedValue);\n      if (!isNaN(floatVal)) {\n        finalValue = floatVal;\n      }\n      arrData[ arrData.length - 1 ].push( finalValue );\n    }\n    // Return the parsed data.\n    return( arrData );\n  };\n\n  /**\n   * Get the total score for the workgroup\n   * @returns the total score for the workgroup\n   */\n  getTotalScore() {\n    const annotations = this.studentData.annotations;\n    const workgroupId = this.ConfigService.getWorkgroupId();\n    return this.AnnotationService.getTotalScore(annotations, workgroupId);\n  }\n\n  /**\n   * Get the project completion for the signed in student\n   * @returns the project completion percentage for the signed in student\n   */\n  getProjectCompletion() {\n    // group0 is always the root node of the whole project\n    const nodeId = 'group0';\n\n    // get the progress including all of the children nodes\n    const progress = this.getNodeProgressById(nodeId);\n\n    return progress;\n  }\n\n  /**\n   * Get the run status\n   */\n  getRunStatus() {\n    return this.runStatus;\n  }\n\n  /**\n   * Get the next available planning node instance node id\n   * @returns the next available planning node instance node id\n   */\n  getNextAvailablePlanningNodeId() {\n    // used to keep track of the highest planning node number we have found, which is 1-based\n    let currentMaxPlanningNodeNumber = 1;\n\n    let nodeStates = this.getNodeStates();\n    if (nodeStates != null) {\n      // loop through all the NodeStates\n      for (let nodeState of nodeStates) {\n        if (nodeState != null) {\n          let nodeStateNodeId = nodeState.nodeId;\n          if (this.ProjectService.isPlanning(nodeStateNodeId) && nodeState.studentData != null) {\n            let nodes = nodeState.studentData.nodes;\n            for (let node of nodes) {\n              let nodeId = node.id;\n              // regex to match the planning node id e.g. planningNode2\n              let planningNodeIdRegEx = /planningNode(.*)/;\n\n              // run the regex on the node id\n              let result = nodeId.match(planningNodeIdRegEx);\n\n              if (result != null) {\n                // we have found a planning node instance node id\n\n                /*\n                 * get the number part of the planning node instance node id\n                 * e.g. if the nodeId is planningNode2, the number part\n                 * would be 2\n                 */\n                let planningNodeNumber = parseInt(result[1]);\n\n                if (planningNodeNumber > currentMaxPlanningNodeNumber) {\n                  /*\n                   * update the max number part if we have found a new\n                   * higher number\n                   */\n                  currentMaxPlanningNodeNumber = planningNodeNumber;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (this.maxPlanningNodeNumber < currentMaxPlanningNodeNumber) {\n      // Update maxPlanningNodeNumber if we find a bigger number in the NodeStates\n      this.maxPlanningNodeNumber = currentMaxPlanningNodeNumber;\n    }\n\n    // Increment maxPlanningNodeNumber each time this function is called.\n    this.maxPlanningNodeNumber++;\n\n    // return the next available planning node instance node id\n    return 'planningNode' + this.maxPlanningNodeNumber;\n  }\n\n  /**\n   * Get the annotations\n   * @returns the annotations\n   */\n  getAnnotations() {\n    let annotations = null;\n    if (this.studentData != null && this.studentData.annotations != null) {\n      annotations = this.studentData.annotations;\n    }\n    return annotations;\n  }\n\n  /**\n   * Get the latest component states for a node\n   * @param nodeId get the component states for the node\n   * @return an array containing the work for the node\n   */\n  getLatestComponentStatesByNodeId(nodeId) {\n    const latestComponentStates = [];\n    if (nodeId) {\n      const studentData = this.studentData;\n      if (studentData) {\n        // get the node\n        const node = this.ProjectService.getNodeById(nodeId);\n\n        if (node != null) {\n          // get the components in the node\n          const components = node.components;\n\n          if (components != null) {\n            // loop through all the components\n            for (let component of components) {\n              if (component != null) {\n                const componentId = component.id;\n\n                // get the latest component state for the component\n                let componentState = this.getLatestComponentStateByNodeIdAndComponentId(nodeId, componentId);\n\n                if (componentState == null) {\n                  /*\n                   * there is no component state for the component so we will\n                   * create an object that just contains the node id and\n                   * component id\n                   */\n                  componentState = {};\n                  componentState.nodeId = nodeId;\n                  componentState.componentId = componentId;\n                }\n                latestComponentStates.push(componentState);\n              }\n            }\n          }\n        }\n      }\n    }\n    return latestComponentStates;\n  }\n\n  /**\n   * Get the latest component state for a node\n   * @param nodeId get the latest component state for the node\n   * @return the latest component state for the node\n   */\n  getLatestComponentStateByNodeId(nodeId) {\n    let latestComponentState = null;\n    if (nodeId != null) {\n      const studentData = this.studentData;\n      if (studentData) {\n        // get the component states for the node\n        const componentStates = this.getComponentStatesByNodeId(nodeId);\n\n        // get the latest component state\n        latestComponentState = componentStates[componentStates.length - 1];\n      }\n    }\n    return latestComponentState;\n  }\n\n  /**\n   * Check if the completion criteria is satisfied\n   * @param completionCriteria the completion criteria\n   * @return whether the completion criteria was satisfied\n   */\n  isCompletionCriteriaSatisfied(completionCriteria) {\n    let result = true;\n    if (completionCriteria != null) {\n      if (completionCriteria.inOrder) {\n        // the criteria need to be satisfied in order\n\n        let tempTimestamp = 0;\n\n        // get all of the criteria\n        const criteria = completionCriteria.criteria;\n\n        // loop through all the criteria\n        for (let completionCriterion of criteria) {\n          let tempResult = true;\n          if (completionCriterion != null) {\n            // get the function name e.g. 'isVisited', 'isSaved', 'isSubmitted'\n            const functionName = completionCriterion.name;\n\n            if (functionName == 'isSubmitted') {\n              const nodeId = completionCriterion.nodeId;\n              const componentId = completionCriterion.componentId;\n\n              // get the first submit component state after the timestamp\n              const tempComponentState = this.getComponentStateSubmittedAfter(nodeId, componentId, tempTimestamp);\n\n              if (tempComponentState == null) {\n                // we did not find a component state\n                result = false;\n                break;\n              } else {\n                // we found a component state so we will update timestamp\n                tempTimestamp = tempComponentState.serverSaveTime;\n              }\n            } else if (functionName == 'isSaved') {\n              const nodeId = completionCriterion.nodeId;\n              const componentId = completionCriterion.componentId;\n\n              // get the first save component state after the timestamp\n              const tempComponentState = this.getComponentStateSavedAfter(nodeId, componentId, tempTimestamp);\n\n              if (tempComponentState == null) {\n                // we did not find a component state\n                result = false;\n                break;\n              } else {\n                // we found a component state so we will update timestamp\n                tempTimestamp = tempComponentState.serverSaveTime;\n              }\n            } else if (functionName == 'isVisited') {\n              const nodeId = completionCriterion.nodeId;\n\n              // get the first visit event after the timestamp\n              const tempEvent = this.getVisitEventAfter(nodeId, tempTimestamp);\n\n              if (tempEvent == null) {\n                // we did not find a component state\n                result = false;\n                break;\n              } else {\n                // we found a component state so we will update timestamp\n                tempTimestamp = tempEvent.serverSaveTime;\n              }\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Get the first save component state after the given timestamp\n   * @param nodeId the node id of the component state\n   * @param componentId the component id of the component state\n   * @param timestamp look for a save component state after this timestamp\n   */\n  getComponentStateSavedAfter(nodeId, componentId, timestamp) {\n    let componentState = null;\n\n    // get all the component states\n    const componentStates = this.studentData.componentStates;\n\n    if (componentStates != null) {\n      // loop through all the component states\n      for (let tempComponentState of componentStates) {\n        if (tempComponentState != null &&\n            tempComponentState.serverSaveTime > timestamp &&\n            tempComponentState.nodeId === nodeId &&\n            tempComponentState.componentId === componentId) {\n          // we have found a save component state after the timestamp\n          componentState = tempComponentState;\n          break;\n        }\n      }\n    }\n    return componentState;\n  }\n\n  /**\n   * Get the first submit component state after the given timestamp\n   * @param nodeId the node id of the component state\n   * @param componentId the component id of the component state\n   * @param timestamp look for a submit component state after this timestamp\n   */\n  getComponentStateSubmittedAfter(nodeId, componentId, timestamp) {\n    let componentState = null;\n\n    // get all the component states\n    const componentStates = this.studentData.componentStates;\n\n    if (componentStates != null) {\n      // loop through all the component states\n      for (let tempComponentState of componentStates) {\n        if (tempComponentState != null &&\n            tempComponentState.serverSaveTime > timestamp &&\n            tempComponentState.nodeId === nodeId &&\n            tempComponentState.componentId === componentId &&\n            tempComponentState.isSubmit) {\n          // we have found a submit component state after the timestamp\n          componentState = tempComponentState;\n          break;\n        }\n      }\n    }\n    return componentState;\n  }\n\n  /**\n   * Get the first visit event after the timestamp\n   */\n  getVisitEventAfter(nodeId, timestamp) {\n    let event = null;\n\n    // get all the events\n    const events = this.studentData.events;\n\n    if (events != null) {\n      // loop through all the events\n      for (let tempEvent of events) {\n        if (tempEvent != null &&\n            tempEvent.serverSaveTime > timestamp &&\n            tempEvent.nodeId === nodeId &&\n            tempEvent.event === 'nodeEntered') {\n          // we have found a visit event after the timestamp\n          event = tempEvent;\n          break;\n        }\n      }\n    }\n    return event;\n  }\n\n  /**\n   * Get classmate student work\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @param showClassmateWorkSource Where to get the work from.\n   * 'period' will get the classmate work only from the period the student is in.\n   * null will get work from the whole class (all periods).\n   *\n   * @return a promise that will return the component states from classmates\n   */\n  getClassmateStudentWork(nodeId, componentId, showClassmateWorkSource) {\n    // get the url to get the student data\n    const studentDataURL = this.ConfigService.getConfigParam('studentDataURL');\n\n    const httpParams = {};\n    httpParams.method = 'GET';\n    httpParams.url = studentDataURL;\n\n    // set the workgroup id and run id\n    const params = {};\n    params.runId = this.ConfigService.getRunId();\n    params.nodeId = nodeId;\n    params.componentId = componentId;\n    params.getStudentWork = true;\n    params.getEvents = false;\n    params.getAnnotations = false;\n    params.onlyGetLatest = true;\n\n    if (showClassmateWorkSource == 'period') {\n      // get the period the student is in\n      params.periodId = this.ConfigService.getPeriodId();\n    }\n\n    httpParams.params = params;\n\n    // make the request for the student data\n    return this.$http(httpParams).then((result) => {\n      let componentStates = [];\n      const resultData = result.data;\n\n      if (resultData != null) {\n        componentStates = resultData.studentWorkList;\n      }\n      return componentStates;\n    });\n  }\n\n  /**\n   * Get the max possible score for the project\n   * @returns the sum of the max scores for all the nodes in the project visible\n   * to the current workgroup or null if none of the visible components has max scores.\n   */\n  getMaxScore() {\n    let maxScore = null;\n\n    // loop through all the node statuses\n    for (let p in this.nodeStatuses) {\n      if (this.nodeStatuses.hasOwnProperty(p)) {\n        let nodeStatus = this.nodeStatuses[p];\n        let nodeId = nodeStatus.nodeId;\n\n        if (nodeStatus.isVisible && !this.ProjectService.isGroupNode(nodeId)) {\n          // node is visible and is not a group\n          // get node max score\n          let nodeMaxScore = this.ProjectService.getMaxScoreForNode(nodeId);\n\n          if (nodeMaxScore) {\n            // there is a max score for the node, so add to total\n            maxScore += nodeMaxScore;\n          }\n        }\n      }\n    }\n    return maxScore;\n  }\n}\n\nStudentDataService.$inject = [\n  '$filter',\n  '$http',\n  '$injector',\n  '$q',\n  '$rootScope',\n  'AnnotationService',\n  'ConfigService',\n  'ProjectService',\n  'UtilService'\n];\n\nexport default StudentDataService;\n"]}