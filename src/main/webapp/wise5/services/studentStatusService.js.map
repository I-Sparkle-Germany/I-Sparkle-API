{"version":3,"sources":["studentStatusService.es6"],"names":["StudentStatusService","$http","AnnotationService","ConfigService","ProjectService","studentStatuses","config","studentStatusURL","getStudentStatusURL","runId","getRunId","requestConfig","params","get","then","result","data","workgroupId","nodePositionAndTitle","studentStatus","getStudentStatusForWorkgroupId","currentNodeId","getNodePositionAndTitleByNodeId","getStudentStatuses","tempStudentStatus","tempWorkgroupId","x","length","splice","excludeNonWorkNodes","completion","totalItems","completedItems","completionPct","projectCompletion","completionPctWithWork","totalItemsWithWork","completedItemsWithWork","getNodeCompletion","nodeId","periodId","workgroupIds","push","isGroupNode","currentNode","getNodeById","group","isNodeDescendentOfGroup","numCompleted","numTotal","nodeStatuses","nodeStatus","progress","descendants","getDescendentsOfGroup","descendantId","descendantStatus","isVisible","nodeHasWork","isCompleted","includeNode","completionPercentage","Math","floor","workgroupsOnline","workgroupsOnlineInPeriod","workgroup","pId","workgroupsOnNode","getWorkgroupIdsOnNode","some","indexOf","w","studentScoreSum","numStudentsWithScore","score","getScore","averageScore","maxScore","p","hasOwnProperty","nodeMaxScore","getMaxScoreForNode","$inject"],"mappings":"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","file":"studentStatusService.js","sourcesContent":["class StudentStatusService {\n  constructor(\n      $http,\n      AnnotationService,\n      ConfigService,\n      ProjectService) {\n    this.$http = $http;\n    this.AnnotationService = AnnotationService;\n    this.ConfigService = ConfigService;\n    this.ProjectService = ProjectService;\n    this.studentStatuses = null;\n  }\n\n  retrieveStudentStatuses(config) {\n    const studentStatusURL = this.ConfigService.getStudentStatusURL();\n    const runId = this.ConfigService.getRunId();\n    const requestConfig = {\n      params: {\n        runId: runId\n      }\n    };\n\n    return this.$http.get(studentStatusURL, requestConfig).then((result) => {\n      const studentStatuses = result.data;\n      this.studentStatuses = studentStatuses;\n      return studentStatuses;\n    });\n  };\n\n  getStudentStatuses() {\n    return this.studentStatuses;\n  };\n\n  /**\n   * Get the current node position and title for a workgroup\n   * e.g. 2.2: Newton Scooter Concepts\n   * @param workgroupId the workgroup id\n   * @returns the node position and title\n   */\n  getCurrentNodePositionAndNodeTitleForWorkgroupId(workgroupId) {\n    let nodePositionAndTitle = null;\n    const studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\n    if (studentStatus != null) {\n      const currentNodeId = studentStatus.currentNodeId;\n      nodePositionAndTitle = this.ProjectService.getNodePositionAndTitleByNodeId(currentNodeId);\n    }\n    return nodePositionAndTitle;\n  };\n\n  getStudentStatusForWorkgroupId(workgroupId) {\n    let studentStatus = null;\n    const studentStatuses = this.getStudentStatuses();\n    for (let tempStudentStatus of studentStatuses) {\n      if (tempStudentStatus != null) {\n        const tempWorkgroupId = tempStudentStatus.workgroupId;\n        if (workgroupId == tempWorkgroupId) {\n          studentStatus = tempStudentStatus;\n          break;\n        }\n      }\n    }\n    return studentStatus;\n  };\n\n  setStudentStatusForWorkgroupId(workgroupId, studentStatus) {\n    const studentStatuses = this.getStudentStatuses();\n    for (let x = 0; x < studentStatuses.length; x++) {\n      const tempStudentStatus = studentStatuses[x];\n      if (tempStudentStatus != null) {\n        const tempWorkgroupId = tempStudentStatus.workgroupId;\n        if (workgroupId === tempWorkgroupId) {\n          studentStatuses.splice(x, 1, studentStatus);\n          break;\n        }\n      }\n    }\n  };\n\n  /**\n   * Get the student project completion data by workgroup id\n   * @param workgroupId the workgroup id\n   * @param excludeNonWorkNodes boolean whether to exclude nodes without\n   * @returns object with completed, total, and percent completed (integer\n   * between 0 and 100)\n   */\n  getStudentProjectCompletion(workgroupId, excludeNonWorkNodes) {\n    let completion = {\n      totalItems: 0,\n      completedItems: 0,\n      completionPct: 0\n    };\n\n    // get the student status for the workgroup\n    let studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\n\n    if (studentStatus) {\n      // get the project completion object\n      let projectCompletion = studentStatus.projectCompletion;\n\n      if (projectCompletion) {\n        if (excludeNonWorkNodes) {\n          // we're only looking for completion of nodes with work\n          let completionPctWithWork = projectCompletion.completionPctWithWork;\n\n          if (completionPctWithWork) {\n            completion.totalItems = projectCompletion.totalItemsWithWork;\n            completion.completedItems = projectCompletion.completedItemsWithWork;\n            completion.completionPct = projectCompletion.completionPctWithWork;\n          } else {\n            /*\n             * we have a legacy projectCompletion object that only includes information for all nodes\n             * so we need to calculate manually\n             */\n            completion = this.getNodeCompletion('group0', -1, workgroupId, true);\n          }\n        } else {\n          completion = projectCompletion;\n        }\n      }\n    }\n    return completion;\n  }\n\n  /**\n   * Get the workgroups on a node in the given period\n   * @param nodeId the node id\n   * @param periodId the period id. pass in -1 to select all periods.\n   * @returns an array of workgroup ids on a node in a period\n   */\n  getWorkgroupIdsOnNode(nodeId, periodId) {\n    let workgroupIds = [];\n    let studentStatuses = this.studentStatuses;\n    for (let studentStatus of studentStatuses) {\n      if (studentStatus != null) {\n        if (periodId == -1 || periodId == studentStatus.periodId) {\n          // the period matches the one we are looking for\n          let currentNodeId = studentStatus.currentNodeId;\n          if (nodeId === currentNodeId) {\n            // the node id matches the one we are looking for\n            workgroupIds.push(studentStatus.workgroupId);\n          } else if (this.ProjectService.isGroupNode(nodeId)) {\n            let currentNode = this.ProjectService.getNodeById(currentNodeId);\n            let group = this.ProjectService.getNodeById(nodeId);\n\n            if (this.ProjectService.isNodeDescendentOfGroup(currentNode, group)) {\n              // the node id is a descendent of the group we're looking for\n              workgroupIds.push(studentStatus.workgroupId);\n            }\n          }\n        }\n      }\n    }\n    return workgroupIds;\n  }\n\n  /**\n   * Get node completion info for the given parameters\n   * @param nodeId the node id\n   * @param periodId the period id (pass in -1 to select all periods)\n   * @param workgroupId the workgroup id to limit results to (optional)\n   * @param excludeNonWorkNodes boolean whether to exclude nodes without\n   * student work or not (optional)\n   * @returns object with completed, total, and percent completed (integer\n   * between 0 and 100).\n   */\n  getNodeCompletion(nodeId, periodId, workgroupId, excludeNonWorkNodes) {\n    let numCompleted = 0;\n    let numTotal = 0;\n    let isGroupNode = this.ProjectService.isGroupNode(nodeId);\n\n    let studentStatuses = this.studentStatuses;\n\n    for (let studentStatus of studentStatuses) {\n      if (studentStatus) {\n        if (periodId == -1 || periodId == studentStatus.periodId) {\n          // the period matches the one we are looking for\n\n          if (!workgroupId || workgroupId === studentStatus.workgroupId) {\n            // either no workgroupId was specified or the workgroupId matches the one we're looking for\n\n            let nodeStatuses = studentStatus.nodeStatuses;\n            if (nodeStatuses) {\n              // get the node status for the node\n              let nodeStatus = nodeStatuses[nodeId];\n\n              if (nodeStatus != null) {\n                if (isGroupNode) {\n                  // given node is a group\n                  // get progress object from the nodeStatus\n                  let progress = nodeStatus.progress;\n\n                  if (excludeNonWorkNodes) {\n                    // we're looking for only nodes with student work\n                    if (progress && progress.totalItemsWithWork) {\n                      numTotal += progress.totalItemsWithWork;\n                      numCompleted += progress.completedItemsWithWork;\n                    } else {\n                      /*\n                       * we have a legacy nodeStatus.progress that only includes completion information for all nodes\n                       * so we need to calculate manually\n                       */\n                      let group = this.ProjectService.getNodeById(nodeId);\n\n                      // get all the descendants of the group\n                      let descendants = this.ProjectService.getDescendentsOfGroup(group);\n\n                      for (let descendantId of descendants) {\n                        if (!this.ProjectService.isGroupNode(descendantId)) {\n                          // node is not a group, so add to totals if visible and has student work\n                          let descendantStatus = nodeStatuses[descendantId];\n\n                          if (descendantStatus && descendantStatus.isVisible && this.ProjectService.nodeHasWork(descendantId)) {\n                            numTotal++;\n\n                            if (descendantStatus.isCompleted) {\n                              numCompleted++;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  } else {\n                    // we're looking for completion percentage of all nodes\n                    if (progress) {\n                      numTotal += progress.totalItems;\n                      numCompleted += progress.completedItems;\n                    }\n                  }\n                } else {\n                  // given node is not a group\n                  if (nodeStatus.isVisible) {\n                    /*\n                     * the student can see the step. we need this check\n                     * for cases when a project has branching. this way\n                     * we only calculate the step completion percentage\n                     * based on the students that can actually go to\n                     * the step.\n                     */\n\n                    /*\n                     * check whether we should include the node in the calculation\n                     * i.e. either includeNonWorkNodes is true or the node has student work\n                     */\n                    let includeNode = !excludeNonWorkNodes || this.ProjectService.nodeHasWork(nodeId);\n\n                    if (includeNode) {\n                      numTotal++;\n\n                      if (nodeStatus.isCompleted) {\n                        // the student has completed the node\n                        numCompleted++;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // generate the percentage number rounded down to the nearest integer\n    let completionPercentage = (numTotal > 0 ? Math.floor(100 * numCompleted / numTotal) : 0);\n\n    return {\n      completedItems: numCompleted,\n      totalItems: numTotal,\n      completionPct: completionPercentage\n    };\n  }\n\n  /**\n   * Get the total number of steps that are descendants of a given node\n   * @param nodeId the node id\n   * @returns the total number of step (application node) descendants; returns\n   * @param periodId the period id. pass in -1 to select all periods.\n   * an average for all students in the selected period if the group is a\n   * planning activity\n   */\n  /*getTotalApplicationNodeDescendents(nodeId, periodId) {\n      let numTotal = 0;\n      let numWorkgroups = 0;\n\n      let isGroupNode = this.ProjectService.isGroupNode(nodeId);\n\n      if (isGroupNode) {\n          let isPlanning = this.ProjectService.isPlanning(nodeId);\n          let studentStatuses = this.studentStatuses;\n\n          // loop through all the student statuses\n          for (let ss = 0; ss < studentStatuses.length; ss++) {\n              let studentStatus = studentStatuses[ss];\n\n              if (studentStatus) {\n\n                  if (periodId == -1 || periodId == studentStatus.periodId) {\n                      // the period matches the one we are looking for\n\n                      let nodeStatuses = studentStatus.nodeStatuses;\n\n                      if (nodeStatuses) {\n                          // get the node status for the node\n                          let nodeStatus = nodeStatuses[nodeId];\n\n                          if (nodeStatus) {\n                              let progress = nodeStatus.progress;\n                              if (progress) {\n                                  let totalItems = progress.totalItems;\n                                  if (totalItems) {\n                                      numWorkgroups++;\n\n                                      if (isPlanning) {\n                                          numTotal += progress.totalItems;\n                                      } else {\n                                          // this is not a planning activity, so we can assume the total number of items is the same for all students\n                                          numTotal = progress.totalItems;\n                                          break;\n                                      }\n                                  }\n                              }\n                          }\n                      }\n                  }\n              }\n          }\n      }\n\n      return (numWorkgroups > 0 ? numTotal/numWorkgroups : 0);\n  };*/\n\n  /**\n   * Check if there is a workgroup that is online and on the node\n   * @param workgroupsOnline the workgroup ids that are online\n   * @param nodeId the node id\n   * @param periodId the period id. pass in -1 to select all periods.\n   * @returns whether there is a workgroup that is online and on the node\n   */\n  isWorkgroupOnlineOnNode(workgroupsOnline, nodeId, periodId) {\n    let result = false;\n\n    // find workgroups online in the given period\n    let workgroupsOnlineInPeriod = [];\n    for (let workgroup of workgroupsOnline) {\n      let studentStatus = this.getStudentStatusForWorkgroupId(workgroup);\n      if (studentStatus) {\n        let pId = studentStatus.periodId;\n        if (periodId == -1 || pId == periodId) {\n          workgroupsOnlineInPeriod.push(workgroup);\n        }\n      }\n    }\n\n    if (workgroupsOnlineInPeriod.length) {\n      // get workgroups on the given node\n      let workgroupsOnNode = this.getWorkgroupIdsOnNode(nodeId, periodId);\n\n      // check if any online workgroups in the current period are on this node\n      result = workgroupsOnNode.some(w => {\n        return workgroupsOnlineInPeriod.indexOf(w) > -1;\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the average score for a node for a period\n   * @param nodeId the node id\n   * @param periodId the period id. pass in -1 to select all periods.\n   * @returns the average score for the node for the period\n   */\n  getNodeAverageScore(nodeId, periodId) {\n    let studentScoreSum = 0;\n    let numStudentsWithScore = 0;\n    const studentStatuses = this.studentStatuses;\n\n    for (let studentStatus of studentStatuses) {\n      if (studentStatus != null) {\n        if (periodId == -1 || periodId == studentStatus.periodId) {\n          // the period matches the one we are looking for\n          let workgroupId = studentStatus.workgroupId;\n\n          // get the workgroups score on the node\n          let score = this.AnnotationService.getScore(workgroupId, nodeId);\n\n          if (score != null) {\n            // increment the counter of students with a score for this node\n            numStudentsWithScore++;\n\n            // accumulate the sum of the scores for this node\n            studentScoreSum += score;\n          }\n        }\n      }\n    }\n\n    let averageScore = null;\n\n    if (numStudentsWithScore != 0) {\n      // calculate the average score for this node rounded down to the nearest hundredth\n      averageScore = Math.floor(100 * studentScoreSum / numStudentsWithScore) / 100;\n    }\n\n    return averageScore;\n  }\n\n  /**\n   * Get the max score for the project for the given workgroup id\n   * @param workgroupId\n   * @returns the sum of the max scores for all the nodes in the project visible\n   * to the given workgroupId or null if none of the visible components has max scores.\n   */\n  getMaxScoreForWorkgroupId(workgroupId) {\n    let maxScore = null;\n    let studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\n    if (studentStatus) {\n      let nodeStatuses = studentStatus.nodeStatuses;\n      if (nodeStatuses) {\n        for (let p in nodeStatuses) {\n          if (nodeStatuses.hasOwnProperty(p)) {\n            let nodeStatus = nodeStatuses[p];\n            let nodeId = nodeStatus.nodeId;\n            if (nodeStatus.isVisible && !this.ProjectService.isGroupNode(nodeId)) {\n              // node is visible and is not a group\n              // get node max score\n              let nodeMaxScore = this.ProjectService.getMaxScoreForNode(nodeId);\n\n              if (nodeMaxScore) {\n                // there is a max score for the node, so add to total\n                maxScore += nodeMaxScore;\n              }\n            }\n          }\n        }\n      }\n    }\n    return maxScore;\n  }\n}\n\nStudentStatusService.$inject = [\n  '$http',\n  'AnnotationService',\n  'ConfigService',\n  'ProjectService'\n];\n\nexport default StudentStatusService;\n"]}