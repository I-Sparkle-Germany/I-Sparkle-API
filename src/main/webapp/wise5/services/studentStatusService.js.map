{"version":3,"sources":["studentStatusService.es6"],"names":["StudentStatusService","$http","AnnotationService","ConfigService","ProjectService","studentStatuses","config","studentStatusURL","getStudentStatusURL","runId","getRunId","requestConfig","params","get","then","result","data","workgroupId","studentStatus","getStudentStatusForWorkgroupId","currentNodeId","getNodePositionAndTitleByNodeId","getStudentStatuses","tempStudentStatus","tempWorkgroupId","x","length","splice","excludeNonWorkNodes","completion","totalItems","completedItems","completionPct","projectCompletion","completionPctWithWork","totalItemsWithWork","completedItemsWithWork","getNodeCompletion","nodeId","periodId","workgroupIds","push","isGroupNode","currentNode","getNodeById","group","isNodeDescendentOfGroup","numCompleted","numTotal","nodeStatuses","nodeStatus","progress","descendants","getDescendentsOfGroup","descendantId","descendantStatus","isVisible","nodeHasWork","isCompleted","includeNode","completionPercentage","Math","floor","workgroupsOnline","workgroupsOnlineInPeriod","workgroup","pId","workgroupsOnNode","getWorkgroupIdsOnNode","some","indexOf","w","studentScoreSum","numStudentsWithScore","score","getScore","averageScore","maxScore","p","hasOwnProperty","isApplicationNode","nodeMaxScore","getMaxScoreForNode","$inject"],"mappings":"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","file":"studentStatusService.js","sourcesContent":["class StudentStatusService {\n  constructor(\n      $http,\n      AnnotationService,\n      ConfigService,\n      ProjectService) {\n    this.$http = $http;\n    this.AnnotationService = AnnotationService;\n    this.ConfigService = ConfigService;\n    this.ProjectService = ProjectService;\n    this.studentStatuses = null;\n  }\n\n  retrieveStudentStatuses(config) {\n    const studentStatusURL = this.ConfigService.getStudentStatusURL();\n    const runId = this.ConfigService.getRunId();\n    const requestConfig = {\n      params: {\n        runId: runId\n      }\n    };\n\n    return this.$http.get(studentStatusURL, requestConfig).then((result) => {\n      const studentStatuses = result.data;\n      this.studentStatuses = studentStatuses;\n      return studentStatuses;\n    });\n  };\n\n  getStudentStatuses() {\n    return this.studentStatuses;\n  };\n\n  /**\n   * Get the current node position and title for a workgroup\n   * e.g. 2.2: Newton Scooter Concepts\n   * @param workgroupId the workgroup id\n   * @returns the node position and title\n   */\n  getCurrentNodePositionAndNodeTitleForWorkgroupId(workgroupId) {\n    const studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\n    if (studentStatus != null) {\n      const currentNodeId = studentStatus.currentNodeId;\n      return this.ProjectService.getNodePositionAndTitleByNodeId(currentNodeId);\n    }\n    return null;\n  };\n\n  getStudentStatusForWorkgroupId(workgroupId) {\n    const studentStatuses = this.getStudentStatuses();\n    for (let tempStudentStatus of studentStatuses) {\n      if (tempStudentStatus != null) {\n        const tempWorkgroupId = tempStudentStatus.workgroupId;\n        if (workgroupId == tempWorkgroupId) {\n          return tempStudentStatus;\n        }\n      }\n    }\n    return null;\n  };\n\n  setStudentStatusForWorkgroupId(workgroupId, studentStatus) {\n    const studentStatuses = this.getStudentStatuses();\n    for (let x = 0; x < studentStatuses.length; x++) {\n      const tempStudentStatus = studentStatuses[x];\n      if (tempStudentStatus != null) {\n        const tempWorkgroupId = tempStudentStatus.workgroupId;\n        if (workgroupId === tempWorkgroupId) {\n          studentStatuses.splice(x, 1, studentStatus);\n          break;\n        }\n      }\n    }\n  };\n\n  /**\n   * Get the student project completion data by workgroup id\n   * @param workgroupId the workgroup id\n   * @param excludeNonWorkNodes boolean whether to exclude nodes without\n   * @returns object with completed, total, and percent completed (integer\n   * between 0 and 100)\n   */\n  getStudentProjectCompletion(workgroupId, excludeNonWorkNodes) {\n    let completion = {\n      totalItems: 0,\n      completedItems: 0,\n      completionPct: 0\n    };\n\n    // get the student status for the workgroup\n    let studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\n\n    if (studentStatus) {\n      let projectCompletion = studentStatus.projectCompletion;\n\n      if (projectCompletion) {\n        if (excludeNonWorkNodes) {\n          // we're only looking for completion of nodes with work\n          let completionPctWithWork = projectCompletion.completionPctWithWork;\n\n          if (completionPctWithWork) {\n            completion.totalItems = projectCompletion.totalItemsWithWork;\n            completion.completedItems = projectCompletion.completedItemsWithWork;\n            completion.completionPct = projectCompletion.completionPctWithWork;\n          } else {\n            /*\n             * we have a legacy projectCompletion object that only includes information for all nodes\n             * so we need to calculate manually\n             */\n            completion = this.getNodeCompletion('group0', -1, workgroupId, true);\n          }\n        } else {\n          completion = projectCompletion;\n        }\n      }\n    }\n    return completion;\n  }\n\n  /**\n   * Get the workgroups on a node in the given period\n   * @param nodeId the node id\n   * @param periodId the period id. pass in -1 to select all periods.\n   * @returns an array of workgroup ids on a node in a period\n   */\n  getWorkgroupIdsOnNode(nodeId, periodId) {\n    let workgroupIds = [];\n    let studentStatuses = this.studentStatuses;\n    for (let studentStatus of studentStatuses) {\n      if (studentStatus != null) {\n        if (periodId == -1 || periodId == studentStatus.periodId) {\n          let currentNodeId = studentStatus.currentNodeId;\n          if (nodeId === currentNodeId) {\n            workgroupIds.push(studentStatus.workgroupId);\n          } else if (this.ProjectService.isGroupNode(nodeId)) {\n            let currentNode = this.ProjectService.getNodeById(currentNodeId);\n            let group = this.ProjectService.getNodeById(nodeId);\n\n            if (this.ProjectService.isNodeDescendentOfGroup(currentNode, group)) {\n              workgroupIds.push(studentStatus.workgroupId);\n            }\n          }\n        }\n      }\n    }\n    return workgroupIds;\n  }\n\n  /**\n   * Get node completion info for the given parameters\n   * @param nodeId the node id\n   * @param periodId the period id (pass in -1 to select all periods)\n   * @param workgroupId the workgroup id to limit results to (optional)\n   * @param excludeNonWorkNodes boolean whether to exclude nodes without\n   * student work or not (optional)\n   * @returns object with completed, total, and percent completed (integer\n   * between 0 and 100).\n   */\n  getNodeCompletion(nodeId, periodId, workgroupId, excludeNonWorkNodes) {\n    let numCompleted = 0;\n    let numTotal = 0;\n    let isGroupNode = this.ProjectService.isGroupNode(nodeId);\n\n    let studentStatuses = this.studentStatuses;\n    for (let studentStatus of studentStatuses) {\n      if (studentStatus) {\n        if (periodId == -1 || periodId == studentStatus.periodId) {\n          if (!workgroupId || workgroupId === studentStatus.workgroupId) {\n            let nodeStatuses = studentStatus.nodeStatuses;\n            if (nodeStatuses) {\n              let nodeStatus = nodeStatuses[nodeId];\n              if (nodeStatus != null) {\n                if (isGroupNode) {\n                  let progress = nodeStatus.progress;\n                  if (excludeNonWorkNodes) {\n                    // we're looking for only nodes with student work\n                    if (progress && progress.totalItemsWithWork) {\n                      numTotal += progress.totalItemsWithWork;\n                      numCompleted += progress.completedItemsWithWork;\n                    } else {\n                      /*\n                       * we have a legacy nodeStatus.progress that only includes completion information for all nodes\n                       * so we need to calculate manually\n                       */\n                      let group = this.ProjectService.getNodeById(nodeId);\n\n                      let descendants = this.ProjectService.getDescendentsOfGroup(group);\n\n                      for (let descendantId of descendants) {\n                        if (!this.ProjectService.isGroupNode(descendantId)) {\n                          let descendantStatus = nodeStatuses[descendantId];\n\n                          if (descendantStatus && descendantStatus.isVisible && this.ProjectService.nodeHasWork(descendantId)) {\n                            numTotal++;\n\n                            if (descendantStatus.isCompleted) {\n                              numCompleted++;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  } else {\n                    // we're looking for completion percentage of all nodes\n                    if (progress) {\n                      numTotal += progress.totalItems;\n                      numCompleted += progress.completedItems;\n                    }\n                  }\n                } else {\n                  // given node is not a group\n                  if (nodeStatus.isVisible) {\n                    /*\n                     * the student can see the step. we need this check\n                     * for cases when a project has branching. this way\n                     * we only calculate the step completion percentage\n                     * based on the students that can actually go to\n                     * the step.\n                     */\n\n                    /*\n                     * check whether we should include the node in the calculation\n                     * i.e. either includeNonWorkNodes is true or the node has student work\n                     */\n                    let includeNode = !excludeNonWorkNodes || this.ProjectService.nodeHasWork(nodeId);\n\n                    if (includeNode) {\n                      numTotal++;\n\n                      if (nodeStatus.isCompleted) {\n                        // the student has completed the node\n                        numCompleted++;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // generate the percentage number rounded down to the nearest integer\n    let completionPercentage = (numTotal > 0 ? Math.floor(100 * numCompleted / numTotal) : 0);\n\n    return {\n      completedItems: numCompleted,\n      totalItems: numTotal,\n      completionPct: completionPercentage\n    };\n  }\n\n  /**\n   * Check if there is a workgroup that is online and on the node\n   * @param workgroupsOnline the workgroup ids that are online\n   * @param nodeId the node id\n   * @param periodId the period id. pass in -1 to select all periods.\n   * @returns whether there is a workgroup that is online and on the node\n   */\n  isWorkgroupOnlineOnNode(workgroupsOnline, nodeId, periodId) {\n    let workgroupsOnlineInPeriod = [];\n    for (let workgroup of workgroupsOnline) {\n      let studentStatus = this.getStudentStatusForWorkgroupId(workgroup);\n      if (studentStatus) {\n        let pId = studentStatus.periodId;\n        if (periodId == -1 || pId == periodId) {\n          workgroupsOnlineInPeriod.push(workgroup);\n        }\n      }\n    }\n\n    if (workgroupsOnlineInPeriod.length) {\n      let workgroupsOnNode = this.getWorkgroupIdsOnNode(nodeId, periodId);\n\n      // check if any online workgroups in the current period are on this node\n      return workgroupsOnNode.some(w => {\n        return workgroupsOnlineInPeriod.indexOf(w) > -1;\n      });\n    }\n\n    return false;\n  }\n\n  /**\n   * Get the average score for a node for a period\n   * @param nodeId the node id\n   * @param periodId the period id. pass in -1 to select all periods.\n   * @returns the average score for the node for the period\n   */\n  getNodeAverageScore(nodeId, periodId) {\n    let studentScoreSum = 0;\n    let numStudentsWithScore = 0;\n    const studentStatuses = this.studentStatuses;\n\n    for (let studentStatus of studentStatuses) {\n      if (studentStatus != null) {\n        if (periodId == -1 || periodId == studentStatus.periodId) {\n          // the period matches the one we are looking for\n          let workgroupId = studentStatus.workgroupId;\n\n          // get the workgroups score on the node\n          let score = this.AnnotationService.getScore(workgroupId, nodeId);\n\n          if (score != null) {\n            // increment the counter of students with a score for this node\n            numStudentsWithScore++;\n\n            // accumulate the sum of the scores for this node\n            studentScoreSum += score;\n          }\n        }\n      }\n    }\n\n    let averageScore = null;\n\n    if (numStudentsWithScore != 0) {\n      // calculate the average score for this node rounded down to the nearest hundredth\n      averageScore = Math.floor(100 * studentScoreSum / numStudentsWithScore) / 100;\n    }\n\n    return averageScore;\n  }\n\n  /**\n   * Get the max score for the project for the given workgroup id\n   * @param workgroupId\n   * @returns the sum of the max scores for all the nodes in the project visible\n   * to the given workgroupId or null if none of the visible components has max scores.\n   */\n  getMaxScoreForWorkgroupId(workgroupId) {\n    let maxScore = null;\n    let studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\n    if (studentStatus) {\n      let nodeStatuses = studentStatus.nodeStatuses;\n      if (nodeStatuses) {\n        for (let p in nodeStatuses) {\n          if (nodeStatuses.hasOwnProperty(p)) {\n            let nodeStatus = nodeStatuses[p];\n            let nodeId = nodeStatus.nodeId;\n            if (nodeStatus.isVisible && this.ProjectService.isApplicationNode(nodeId)) {\n              let nodeMaxScore = this.ProjectService.getMaxScoreForNode(nodeId);\n              if (nodeMaxScore) {\n                // there is a max score for the node, so add to total\n                // TODO geoffreykwan: trying to add to null?\n                maxScore += nodeMaxScore;\n              }\n            }\n          }\n        }\n      }\n    }\n    return maxScore;\n  }\n}\n\nStudentStatusService.$inject = [\n  '$http',\n  'AnnotationService',\n  'ConfigService',\n  'ProjectService'\n];\n\nexport default StudentStatusService;\n"]}