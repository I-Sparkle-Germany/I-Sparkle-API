{"version":3,"sources":["studentStatusService.es6"],"names":["StudentStatusService","$http","AnnotationService","ConfigService","ProjectService","studentStatuses","config","studentStatusURL","getStudentStatusURL","runId","getRunId","requestConfig","params","get","then","result","data","workgroupId","nodePositionAndTitle","studentStatus","getStudentStatusForWorkgroupId","currentNodeId","getNodePositionAndTitleByNodeId","getStudentStatuses","x","length","tempStudentStatus","tempWorkgroupId","splice","excludeNonWorkNodes","completion","totalItems","completedItems","completionPct","projectCompletion","completionPctWithWork","totalItemsWithWork","completedItemsWithWork","getNodeCompletion","nodeId","periodId","workgroupIds","ss","push","isGroupNode","currentNode","getNodeById","group","isNodeDescendentOfGroup","numCompleted","numTotal","nodeStatuses","nodeStatus","progress","descendants","getDescendentsOfGroup","l","i","descendantId","descendantStatus","isVisible","nodeHasWork","isCompleted","includeNode","completionPercentage","Math","floor","workgroupsOnline","workgroupsOnlineInPeriod","n","workgroup","pId","workgroupsOnNode","getWorkgroupIdsOnNode","some","indexOf","w","studentScoreSum","numStudentsWithScore","score","getScore","averageScore","maxScore","p","hasOwnProperty","nodeMaxScore","getMaxScoreForNode","$inject"],"mappings":";;;;;;;;;;IAAMA,oB;AACF,kCAAYC,KAAZ,EACYC,iBADZ,EAEYC,aAFZ,EAGYC,cAHZ,EAG4B;AAAA;;AACxB,aAAKH,KAAL,GAAaA,KAAb;AACA,aAAKC,iBAAL,GAAyBA,iBAAzB;AACA,aAAKC,aAAL,GAAqBA,aAArB;AACA,aAAKC,cAAL,GAAsBA,cAAtB;AACA,aAAKC,eAAL,GAAuB,IAAvB;AACH;;;;gDAEuBC,M,EAAQ;AAAA;;AAC5B,gBAAIC,mBAAmB,KAAKJ,aAAL,CAAmBK,mBAAnB,EAAvB;AACA,gBAAIC,QAAQ,KAAKN,aAAL,CAAmBO,QAAnB,EAAZ;;AAEA,gBAAIC,gBAAgB;AAChBC,wBAAQ;AACJH,2BAAOA;AADH;AADQ,aAApB;;AAMA,mBAAO,KAAKR,KAAL,CAAWY,GAAX,CAAeN,gBAAf,EAAiCI,aAAjC,EAAgDG,IAAhD,CAAqD,UAACC,MAAD,EAAY;AACpE,oBAAIV,kBAAkBU,OAAOC,IAA7B;;AAEA,sBAAKX,eAAL,GAAuBA,eAAvB;;AAEA,uBAAOA,eAAP;AACH,aANM,CAAP;AAOH;;;6CAEoB;AACjB,mBAAO,KAAKA,eAAZ;AACH;;;;;AAED;;;;;;yEAMiDY,W,EAAa;AAC1D,gBAAIC,uBAAuB,IAA3B;;AAEA,gBAAIC,gBAAgB,KAAKC,8BAAL,CAAoCH,WAApC,CAApB;;AAEA,gBAAGE,iBAAiB,IAApB,EAA0B;AACtB,oBAAIE,gBAAgBF,cAAcE,aAAlC;AACAH,uCAAuB,KAAKd,cAAL,CAAoBkB,+BAApB,CAAoDD,aAApD,CAAvB;AACH;;AAED,mBAAOH,oBAAP;AACH;;;uDAE8BD,W,EAAa;;AAExC,gBAAIE,gBAAgB,IAApB;AACA,gBAAId,kBAAkB,KAAKkB,kBAAL,EAAtB;;AAEA,iBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAInB,gBAAgBoB,MAApC,EAA4CD,GAA5C,EAAiD;AAC7C,oBAAIE,oBAAoBrB,gBAAgBmB,CAAhB,CAAxB;;AAEA,oBAAIE,qBAAqB,IAAzB,EAA+B;AAC3B,wBAAIC,kBAAkBD,kBAAkBT,WAAxC;;AAEA,wBAAIA,eAAeU,eAAnB,EAAoC;AAChCR,wCAAgBO,iBAAhB;AACA;AACH;AACJ;AACJ;;AAED,mBAAOP,aAAP;AACH;;;uDAE8BF,W,EAAaE,a,EAAe;;AAEvD,gBAAId,kBAAkB,KAAKkB,kBAAL,EAAtB;;AAEA,iBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAInB,gBAAgBoB,MAApC,EAA4CD,GAA5C,EAAiD;AAC7C,oBAAIE,oBAAoBrB,gBAAgBmB,CAAhB,CAAxB;;AAEA,oBAAIE,qBAAqB,IAAzB,EAA+B;AAC3B,wBAAIC,kBAAkBD,kBAAkBT,WAAxC;;AAEA,wBAAIA,gBAAgBU,eAApB,EAAqC;AACjCtB,wCAAgBuB,MAAhB,CAAuBJ,CAAvB,EAA0B,CAA1B,EAA6BL,aAA7B;AACA;AACH;AACJ;AACJ;AACJ;;;;;AAED;;;;;;;oDAO4BF,W,EAAaY,mB,EAAqB;AAC1D,gBAAIC,aAAa;AACbC,4BAAY,CADC;AAEbC,gCAAgB,CAFH;AAGbC,+BAAe;AAHF,aAAjB;;AAMA;AACA,gBAAId,gBAAgB,KAAKC,8BAAL,CAAoCH,WAApC,CAApB;;AAEA,gBAAIE,aAAJ,EAAmB;AACjB;AACA,oBAAIe,oBAAoBf,cAAce,iBAAtC;;AAEA,oBAAIA,iBAAJ,EAAuB;AACnB,wBAAIL,mBAAJ,EAAyB;AACrB;AACA,4BAAIM,wBAAwBD,kBAAkBC,qBAA9C;;AAEA,4BAAIA,qBAAJ,EAA2B;AACvBL,uCAAWC,UAAX,GAAwBG,kBAAkBE,kBAA1C;AACAN,uCAAWE,cAAX,GAA4BE,kBAAkBG,sBAA9C;AACAP,uCAAWG,aAAX,GAA2BC,kBAAkBC,qBAA7C;AACH,yBAJD,MAIO;AACL;;;;AAIAL,yCAAa,KAAKQ,iBAAL,CAAuB,QAAvB,EAAiC,CAAC,CAAlC,EAAqCrB,WAArC,EAAkD,IAAlD,CAAb;AACD;AACJ,qBAfD,MAeO;AACHa,qCAAaI,iBAAb;AACH;AACJ;AACF;;AAED,mBAAOJ,UAAP;AACH;;AAED;;;;;;;;;8CAMsBS,M,EAAQC,Q,EAAU;AACpC,gBAAIC,eAAe,EAAnB;AACA,gBAAIpC,kBAAkB,KAAKA,eAA3B;;AAEA;AACA,iBAAK,IAAIqC,KAAK,CAAd,EAAiBA,KAAKrC,gBAAgBoB,MAAtC,EAA8CiB,IAA9C,EAAoD;AAChD,oBAAIvB,gBAAgBd,gBAAgBqC,EAAhB,CAApB;;AAEA,oBAAIvB,iBAAiB,IAArB,EAA2B;;AAEvB,wBAAIqB,YAAY,CAAC,CAAb,IAAkBA,YAAYrB,cAAcqB,QAAhD,EAA0D;AACtD;AACA,4BAAInB,gBAAgBF,cAAcE,aAAlC;AACA,4BAAIkB,WAAWlB,aAAf,EAA8B;AAC1B;AACAoB,yCAAaE,IAAb,CAAkBxB,cAAcF,WAAhC;AACH,yBAHD,MAGO,IAAI,KAAKb,cAAL,CAAoBwC,WAApB,CAAgCL,MAAhC,CAAJ,EAA6C;AAChD,gCAAIM,cAAc,KAAKzC,cAAL,CAAoB0C,WAApB,CAAgCzB,aAAhC,CAAlB;AACA,gCAAI0B,QAAQ,KAAK3C,cAAL,CAAoB0C,WAApB,CAAgCP,MAAhC,CAAZ;;AAEA,gCAAI,KAAKnC,cAAL,CAAoB4C,uBAApB,CAA4CH,WAA5C,EAAyDE,KAAzD,CAAJ,EAAqE;AACjE;AACAN,6CAAaE,IAAb,CAAkBxB,cAAcF,WAAhC;AACH;AACJ;AACJ;AACJ;AACJ;;AAED,mBAAOwB,YAAP;AACH;;AAED;;;;;;;;;;;;;0CAUkBF,M,EAAQC,Q,EAAUvB,W,EAAaY,mB,EAAqB;AAClE,gBAAIoB,eAAe,CAAnB;AACA,gBAAIC,WAAW,CAAf;AACA,gBAAIN,cAAc,KAAKxC,cAAL,CAAoBwC,WAApB,CAAgCL,MAAhC,CAAlB;;AAEA,gBAAIlC,kBAAkB,KAAKA,eAA3B;;AAEA;AACA,iBAAK,IAAIqC,KAAK,CAAd,EAAiBA,KAAKrC,gBAAgBoB,MAAtC,EAA8CiB,IAA9C,EAAoD;AAChD,oBAAIvB,gBAAgBd,gBAAgBqC,EAAhB,CAApB;;AAEA,oBAAIvB,aAAJ,EAAmB;;AAEf,wBAAIqB,YAAY,CAAC,CAAb,IAAkBA,YAAYrB,cAAcqB,QAAhD,EAA0D;AACtD;;AAEA,4BAAI,CAACvB,WAAD,IAAgBA,gBAAgBE,cAAcF,WAAlD,EAA+D;AAC3D;;AAEA,gCAAIkC,eAAehC,cAAcgC,YAAjC;;AAEA,gCAAIA,YAAJ,EAAkB;AACd;AACA,oCAAIC,aAAaD,aAAaZ,MAAb,CAAjB;;AAEA,oCAAIa,cAAc,IAAlB,EAAwB;AACpB,wCAAIR,WAAJ,EAAiB;AACb;AACA;AACA,4CAAIS,WAAWD,WAAWC,QAA1B;;AAEA,4CAAIxB,mBAAJ,EAAyB;AACrB;AACA,gDAAIwB,YAAYA,SAASjB,kBAAzB,EAA6C;AACzCc,4DAAYG,SAASjB,kBAArB;AACAa,gEAAgBI,SAAShB,sBAAzB;AACH,6CAHD,MAGO;AACH;;;;AAIA,oDAAIU,QAAQ,KAAK3C,cAAL,CAAoB0C,WAApB,CAAgCP,MAAhC,CAAZ;;AAEA;AACA,oDAAIe,cAAc,KAAKlD,cAAL,CAAoBmD,qBAApB,CAA0CR,KAA1C,CAAlB;AACA,oDAAIS,IAAIF,YAAY7B,MAApB;;AAEA;AACA,qDAAK,IAAIgC,IAAI,CAAb,EAAgBA,IAAID,CAApB,EAAuBC,GAAvB,EAA4B;AACxB,wDAAIC,eAAeJ,YAAYG,CAAZ,CAAnB;;AAEA,wDAAI,CAAC,KAAKrD,cAAL,CAAoBwC,WAApB,CAAgCc,YAAhC,CAAL,EAAoD;AAChD;AACA,4DAAIC,mBAAmBR,aAAaO,YAAb,CAAvB;;AAEA,4DAAIC,oBAAoBA,iBAAiBC,SAArC,IAAkD,KAAKxD,cAAL,CAAoByD,WAApB,CAAgCH,YAAhC,CAAtD,EAAqG;AACjGR;;AAEA,gEAAIS,iBAAiBG,WAArB,EAAkC;AAC9Bb;AACH;AACJ;AACJ;AACJ;AACJ;AACJ,yCAlCD,MAkCO;AACH;AACA,gDAAII,QAAJ,EAAc;AACVH,4DAAYG,SAAStB,UAArB;AACAkB,gEAAgBI,SAASrB,cAAzB;AACH;AACJ;AACJ,qCA9CD,MA8CO;AACH;AACA,4CAAIoB,WAAWQ,SAAf,EAA0B;AACtB;;;;;;;;AAQA;;;;AAIA,gDAAIG,cAAc,CAAClC,mBAAD,IAAwB,KAAKzB,cAAL,CAAoByD,WAApB,CAAgCtB,MAAhC,CAA1C;;AAEA,gDAAIwB,WAAJ,EAAiB;AACbb;;AAEA,oDAAIE,WAAWU,WAAf,EAA4B;AACxB;AACAb;AACH;AACJ;AACJ;AACJ;AACJ;AACJ;AACJ;AACJ;AACJ;AACJ;;AAED;AACA,gBAAIe,uBAAwBd,WAAW,CAAX,GAAee,KAAKC,KAAL,CAAW,MAAMjB,YAAN,GAAqBC,QAAhC,CAAf,GAA2D,CAAvF;;AAEA,mBAAO;AACHlB,gCAAgBiB,YADb;AAEHlB,4BAAYmB,QAFT;AAGHjB,+BAAe+B;AAHZ,aAAP;AAKH;;AAED;;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmDA;;;;;;;;;;gDAOwBG,gB,EAAkB5B,M,EAAQC,Q,EAAU;AACxD,gBAAIzB,SAAS,KAAb;;AAEA;AACA,gBAAIqD,2BAA2B,EAA/B;AACA,gBAAIC,IAAIF,iBAAiB1C,MAAzB;AACA,iBAAK,IAAIgC,IAAI,CAAb,EAAgBA,IAAIY,CAApB,EAAuBZ,GAAvB,EAA4B;AACxB,oBAAIa,YAAYH,iBAAiBV,CAAjB,CAAhB;AACA,oBAAItC,gBAAgB,KAAKC,8BAAL,CAAoCkD,SAApC,CAApB;AACA,oBAAInD,aAAJ,EAAmB;AACf,wBAAIoD,MAAMpD,cAAcqB,QAAxB;AACA,wBAAIA,YAAY,CAAC,CAAb,IAAkB+B,OAAO/B,QAA7B,EAAuC;AACnC4B,iDAAyBzB,IAAzB,CAA8B2B,SAA9B;AACH;AACJ;AACJ;;AAED,gBAAIF,yBAAyB3C,MAA7B,EAAqC;AACjC;AACA,oBAAI+C,mBAAmB,KAAKC,qBAAL,CAA2BlC,MAA3B,EAAmCC,QAAnC,CAAvB;;AAEA;AACAzB,yBAASyD,iBAAiBE,IAAjB,CAAsB,aAAK;AAChC,2BAAON,yBAAyBO,OAAzB,CAAiCC,CAAjC,IAAsC,CAAC,CAA9C;AACH,iBAFQ,CAAT;AAGH;;AAED,mBAAO7D,MAAP;AACH;;AAED;;;;;;;;;4CAMoBwB,M,EAAQC,Q,EAAU;AAClC,gBAAIqC,kBAAkB,CAAtB;AACA,gBAAIC,uBAAuB,CAA3B;;AAEA,gBAAIzE,kBAAkB,KAAKA,eAA3B;;AAEA;AACA,iBAAK,IAAIqC,KAAK,CAAd,EAAiBA,KAAKrC,gBAAgBoB,MAAtC,EAA8CiB,IAA9C,EAAoD;AAChD,oBAAIvB,gBAAgBd,gBAAgBqC,EAAhB,CAApB;;AAEA,oBAAIvB,iBAAiB,IAArB,EAA2B;;AAEvB,wBAAIqB,YAAY,CAAC,CAAb,IAAkBA,YAAYrB,cAAcqB,QAAhD,EAA0D;AACtD;;AAEA,4BAAIvB,cAAcE,cAAcF,WAAhC;;AAEA;AACA,4BAAI8D,QAAQ,KAAK7E,iBAAL,CAAuB8E,QAAvB,CAAgC/D,WAAhC,EAA6CsB,MAA7C,CAAZ;;AAEA,4BAAIwC,SAAS,IAAb,EAAmB;AACf;AACAD;;AAEA;AACAD,+CAAmBE,KAAnB;AACH;AACJ;AACJ;AACJ;;AAED,gBAAIE,eAAe,IAAnB;;AAEA,gBAAIH,wBAAwB,CAA5B,EAA+B;AAC3B;AACAG,+BAAehB,KAAKC,KAAL,CAAW,MAAMW,eAAN,GAAwBC,oBAAnC,IAA2D,GAA1E;AACH;;AAED,mBAAOG,YAAP;AACH;;AAED;;;;;;;;;kDAM0BhE,W,EAAa;AACnC,gBAAIiE,WAAW,IAAf;;AAEA,gBAAI/D,gBAAgB,KAAKC,8BAAL,CAAoCH,WAApC,CAApB;;AAEA,gBAAIE,aAAJ,EAAmB;AACf,oBAAIgC,eAAehC,cAAcgC,YAAjC;;AAEA,oBAAIA,YAAJ,EAAkB;AACd;AACA,yBAAK,IAAIgC,CAAT,IAAchC,YAAd,EAA4B;AACxB,4BAAIA,aAAaiC,cAAb,CAA4BD,CAA5B,CAAJ,EAAoC;AAChC,gCAAI/B,aAAaD,aAAagC,CAAb,CAAjB;AACA,gCAAI5C,SAASa,WAAWb,MAAxB;;AAEA,gCAAIa,WAAWQ,SAAX,IAAwB,CAAC,KAAKxD,cAAL,CAAoBwC,WAApB,CAAgCL,MAAhC,CAA7B,EAAsE;AAClE;AACA;AACA,oCAAI8C,eAAe,KAAKjF,cAAL,CAAoBkF,kBAApB,CAAuC/C,MAAvC,CAAnB;;AAEA,oCAAI8C,YAAJ,EAAkB;AACd;AACAH,gDAAYG,YAAZ;AACH;AACJ;AACJ;AACJ;AACJ;AACJ;;AAED,mBAAOH,QAAP;AACH;;;;;;AAGLlF,qBAAqBuF,OAArB,GAA+B,CAC3B,OAD2B,EAE3B,mBAF2B,EAG3B,eAH2B,EAI3B,gBAJ2B,CAA/B;;kBAOevF,oB","file":"studentStatusService.js","sourcesContent":["class StudentStatusService {\r\n    constructor($http,\r\n                AnnotationService,\r\n                ConfigService,\r\n                ProjectService) {\r\n        this.$http = $http;\r\n        this.AnnotationService = AnnotationService;\r\n        this.ConfigService = ConfigService;\r\n        this.ProjectService = ProjectService;\r\n        this.studentStatuses = null;\r\n    }\r\n\r\n    retrieveStudentStatuses(config) {\r\n        var studentStatusURL = this.ConfigService.getStudentStatusURL();\r\n        var runId = this.ConfigService.getRunId();\r\n\r\n        var requestConfig = {\r\n            params: {\r\n                runId: runId\r\n            }\r\n        };\r\n\r\n        return this.$http.get(studentStatusURL, requestConfig).then((result) => {\r\n            var studentStatuses = result.data;\r\n\r\n            this.studentStatuses = studentStatuses;\r\n\r\n            return studentStatuses;\r\n        });\r\n    };\r\n\r\n    getStudentStatuses() {\r\n        return this.studentStatuses;\r\n    };\r\n\r\n    /**\r\n     * Get the current node position and title for a workgroup\r\n     * e.g. 2.2: Newton Scooter Concepts\r\n     * @param workgroupId the workgroup id\r\n     * @returns the node position and title\r\n     */\r\n    getCurrentNodePositionAndNodeTitleForWorkgroupId(workgroupId) {\r\n        var nodePositionAndTitle = null;\r\n\r\n        var studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\r\n\r\n        if(studentStatus != null) {\r\n            var currentNodeId = studentStatus.currentNodeId;\r\n            nodePositionAndTitle = this.ProjectService.getNodePositionAndTitleByNodeId(currentNodeId);\r\n        }\r\n\r\n        return nodePositionAndTitle;\r\n    };\r\n\r\n    getStudentStatusForWorkgroupId(workgroupId) {\r\n\r\n        var studentStatus = null;\r\n        var studentStatuses = this.getStudentStatuses();\r\n\r\n        for (var x = 0; x < studentStatuses.length; x++) {\r\n            var tempStudentStatus = studentStatuses[x];\r\n\r\n            if (tempStudentStatus != null) {\r\n                var tempWorkgroupId = tempStudentStatus.workgroupId;\r\n\r\n                if (workgroupId == tempWorkgroupId) {\r\n                    studentStatus = tempStudentStatus;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return studentStatus;\r\n    };\r\n\r\n    setStudentStatusForWorkgroupId(workgroupId, studentStatus) {\r\n\r\n        var studentStatuses = this.getStudentStatuses();\r\n\r\n        for (var x = 0; x < studentStatuses.length; x++) {\r\n            var tempStudentStatus = studentStatuses[x];\r\n\r\n            if (tempStudentStatus != null) {\r\n                var tempWorkgroupId = tempStudentStatus.workgroupId;\r\n\r\n                if (workgroupId === tempWorkgroupId) {\r\n                    studentStatuses.splice(x, 1, studentStatus);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get the student project completion data by workgroup id\r\n     * @param workgroupId the workgroup id\r\n     * @param excludeNonWorkNodes boolean whether to exclude nodes without\r\n     * @returns object with completed, total, and percent completed (integer\r\n     * between 0 and 100)\r\n     */\r\n    getStudentProjectCompletion(workgroupId, excludeNonWorkNodes) {\r\n        let completion = {\r\n            totalItems: 0,\r\n            completedItems: 0,\r\n            completionPct: 0\r\n        };\r\n\r\n        // get the student status for the workgroup\r\n        let studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\r\n\r\n        if (studentStatus) {\r\n          // get the project completion object\r\n          let projectCompletion = studentStatus.projectCompletion;\r\n\r\n          if (projectCompletion) {\r\n              if (excludeNonWorkNodes) {\r\n                  // we're only looking for completion of nodes with work\r\n                  let completionPctWithWork = projectCompletion.completionPctWithWork;\r\n\r\n                  if (completionPctWithWork) {\r\n                      completion.totalItems = projectCompletion.totalItemsWithWork;\r\n                      completion.completedItems = projectCompletion.completedItemsWithWork;\r\n                      completion.completionPct = projectCompletion.completionPctWithWork;\r\n                  } else {\r\n                    /*\r\n                     * we have a legacy projectCompletion object that only includes information for all nodes\r\n                     * so we need to calculate manually\r\n                     */\r\n                    completion = this.getNodeCompletion('group0', -1, workgroupId, true);\r\n                  }\r\n              } else {\r\n                  completion = projectCompletion;\r\n              }\r\n          }\r\n        }\r\n\r\n        return completion;\r\n    }\r\n\r\n    /**\r\n     * Get the workgroups on a node in the given period\r\n     * @param nodeId the node id\r\n     * @param periodId the period id. pass in -1 to select all periods.\r\n     * @returns an array of workgroup ids on a node in a period\r\n     */\r\n    getWorkgroupIdsOnNode(nodeId, periodId) {\r\n        let workgroupIds = [];\r\n        let studentStatuses = this.studentStatuses;\r\n\r\n        // loop through all the student statuses\r\n        for (var ss = 0; ss < studentStatuses.length; ss++) {\r\n            var studentStatus = studentStatuses[ss];\r\n\r\n            if (studentStatus != null) {\r\n\r\n                if (periodId == -1 || periodId == studentStatus.periodId) {\r\n                    // the period matches the one we are looking for\r\n                    let currentNodeId = studentStatus.currentNodeId;\r\n                    if (nodeId === currentNodeId) {\r\n                        // the node id matches the one we are looking for\r\n                        workgroupIds.push(studentStatus.workgroupId);\r\n                    } else if (this.ProjectService.isGroupNode(nodeId)) {\r\n                        let currentNode = this.ProjectService.getNodeById(currentNodeId);\r\n                        let group = this.ProjectService.getNodeById(nodeId);\r\n\r\n                        if (this.ProjectService.isNodeDescendentOfGroup(currentNode, group)) {\r\n                            // the node id is a descendent of the group we're looking for\r\n                            workgroupIds.push(studentStatus.workgroupId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return workgroupIds;\r\n    }\r\n\r\n    /**\r\n     * Get node completion info for the given parameters\r\n     * @param nodeId the node id\r\n     * @param periodId the period id (pass in -1 to select all periods)\r\n     * @param workgroupId the workgroup id to limit results to (optional)\r\n     * @param excludeNonWorkNodes boolean whether to exclude nodes without\r\n     * student work or not (optional)\r\n     * @returns object with completed, total, and percent completed (integer\r\n     * between 0 and 100).\r\n     */\r\n    getNodeCompletion(nodeId, periodId, workgroupId, excludeNonWorkNodes) {\r\n        let numCompleted = 0;\r\n        let numTotal = 0;\r\n        let isGroupNode = this.ProjectService.isGroupNode(nodeId);\r\n\r\n        let studentStatuses = this.studentStatuses;\r\n\r\n        // loop through all the student statuses\r\n        for (let ss = 0; ss < studentStatuses.length; ss++) {\r\n            let studentStatus = studentStatuses[ss];\r\n\r\n            if (studentStatus) {\r\n\r\n                if (periodId == -1 || periodId == studentStatus.periodId) {\r\n                    // the period matches the one we are looking for\r\n\r\n                    if (!workgroupId || workgroupId === studentStatus.workgroupId) {\r\n                        // either no workgroupId was specified or the workgroupId matches the one we're looking for\r\n\r\n                        let nodeStatuses = studentStatus.nodeStatuses;\r\n\r\n                        if (nodeStatuses) {\r\n                            // get the node status for the node\r\n                            let nodeStatus = nodeStatuses[nodeId];\r\n\r\n                            if (nodeStatus != null) {\r\n                                if (isGroupNode) {\r\n                                    // given node is a group\r\n                                    // get progress object from the nodeStatus\r\n                                    let progress = nodeStatus.progress;\r\n\r\n                                    if (excludeNonWorkNodes) {\r\n                                        // we're looking for only nodes with student work\r\n                                        if (progress && progress.totalItemsWithWork) {\r\n                                            numTotal += progress.totalItemsWithWork;\r\n                                            numCompleted += progress.completedItemsWithWork;\r\n                                        } else {\r\n                                            /*\r\n                                             * we have a legacy nodeStatus.progress that only includes completion information for all nodes\r\n                                             * so we need to calculate manually\r\n                                             */\r\n                                            let group = this.ProjectService.getNodeById(nodeId);\r\n\r\n                                            // get all the descendants of the group\r\n                                            let descendants = this.ProjectService.getDescendentsOfGroup(group);\r\n                                            let l = descendants.length;\r\n\r\n                                            // loop through all the descendants to check for completion\r\n                                            for (let i = 0; i < l; i++) {\r\n                                                let descendantId = descendants[i];\r\n\r\n                                                if (!this.ProjectService.isGroupNode(descendantId)) {\r\n                                                    // node is not a group, so add to totals if visible and has student work\r\n                                                    let descendantStatus = nodeStatuses[descendantId];\r\n\r\n                                                    if (descendantStatus && descendantStatus.isVisible && this.ProjectService.nodeHasWork(descendantId)) {\r\n                                                        numTotal++;\r\n\r\n                                                        if (descendantStatus.isCompleted) {\r\n                                                            numCompleted++;\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    } else {\r\n                                        // we're looking for completion percentage of all nodes\r\n                                        if (progress) {\r\n                                            numTotal += progress.totalItems;\r\n                                            numCompleted += progress.completedItems;\r\n                                        }\r\n                                    }\r\n                                } else {\r\n                                    // given node is not a group\r\n                                    if (nodeStatus.isVisible) {\r\n                                        /*\r\n                                         * the student can see the step. we need this check\r\n                                         * for cases when a project has branching. this way\r\n                                         * we only calculate the step completion percentage\r\n                                         * based on the students that can actually go to\r\n                                         * the step.\r\n                                         */\r\n\r\n                                        /*\r\n                                         * check whether we should include the node in the calculation\r\n                                         * i.e. either includeNonWorkNodes is true or the node has student work\r\n                                         */\r\n                                        let includeNode = !excludeNonWorkNodes || this.ProjectService.nodeHasWork(nodeId);\r\n\r\n                                        if (includeNode) {\r\n                                            numTotal++;\r\n\r\n                                            if (nodeStatus.isCompleted) {\r\n                                                // the student has completed the node\r\n                                                numCompleted++;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // generate the percentage number rounded down to the nearest integer\r\n        let completionPercentage = (numTotal > 0 ? Math.floor(100 * numCompleted / numTotal) : 0);\r\n\r\n        return {\r\n            completedItems: numCompleted,\r\n            totalItems: numTotal,\r\n            completionPct: completionPercentage\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the total number of steps that are descendants of a given node\r\n     * @param nodeId the node id\r\n     * @returns the total number of step (application node) descendants; returns\r\n     * @param periodId the period id. pass in -1 to select all periods.\r\n     * an average for all students in the selected period if the group is a\r\n     * planning activity\r\n     */\r\n    /*getTotalApplicationNodeDescendents(nodeId, periodId) {\r\n        let numTotal = 0;\r\n        let numWorkgroups = 0;\r\n\r\n        let isGroupNode = this.ProjectService.isGroupNode(nodeId);\r\n\r\n        if (isGroupNode) {\r\n            let isPlanning = this.ProjectService.isPlanning(nodeId);\r\n            let studentStatuses = this.studentStatuses;\r\n\r\n            // loop through all the student statuses\r\n            for (let ss = 0; ss < studentStatuses.length; ss++) {\r\n                let studentStatus = studentStatuses[ss];\r\n\r\n                if (studentStatus) {\r\n\r\n                    if (periodId == -1 || periodId == studentStatus.periodId) {\r\n                        // the period matches the one we are looking for\r\n\r\n                        let nodeStatuses = studentStatus.nodeStatuses;\r\n\r\n                        if (nodeStatuses) {\r\n                            // get the node status for the node\r\n                            let nodeStatus = nodeStatuses[nodeId];\r\n\r\n                            if (nodeStatus) {\r\n                                let progress = nodeStatus.progress;\r\n                                if (progress) {\r\n                                    let totalItems = progress.totalItems;\r\n                                    if (totalItems) {\r\n                                        numWorkgroups++;\r\n\r\n                                        if (isPlanning) {\r\n                                            numTotal += progress.totalItems;\r\n                                        } else {\r\n                                            // this is not a planning activity, so we can assume the total number of items is the same for all students\r\n                                            numTotal = progress.totalItems;\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return (numWorkgroups > 0 ? numTotal/numWorkgroups : 0);\r\n    };*/\r\n\r\n    /**\r\n     * Check if there is a workgroup that is online and on the node\r\n     * @param workgroupsOnline the workgroup ids that are online\r\n     * @param nodeId the node id\r\n     * @param periodId the period id. pass in -1 to select all periods.\r\n     * @returns whether there is a workgroup that is online and on the node\r\n     */\r\n    isWorkgroupOnlineOnNode(workgroupsOnline, nodeId, periodId) {\r\n        let result = false;\r\n\r\n        // find workgroups online in the given period\r\n        let workgroupsOnlineInPeriod = [];\r\n        let n = workgroupsOnline.length;\r\n        for (let i = 0; i < n; i++) {\r\n            let workgroup = workgroupsOnline[i];\r\n            let studentStatus = this.getStudentStatusForWorkgroupId(workgroup);\r\n            if (studentStatus) {\r\n                let pId = studentStatus.periodId;\r\n                if (periodId == -1 || pId == periodId) {\r\n                    workgroupsOnlineInPeriod.push(workgroup);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (workgroupsOnlineInPeriod.length) {\r\n            // get workgroups on the given node\r\n            let workgroupsOnNode = this.getWorkgroupIdsOnNode(nodeId, periodId);\r\n\r\n            // check if any online workgroups in the current period are on this node\r\n            result = workgroupsOnNode.some(w => {\r\n                return workgroupsOnlineInPeriod.indexOf(w) > -1;\r\n            });\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get the average score for a node for a period\r\n     * @param nodeId the node id\r\n     * @param periodId the period id. pass in -1 to select all periods.\r\n     * @returns the average score for the node for the period\r\n     */\r\n    getNodeAverageScore(nodeId, periodId) {\r\n        var studentScoreSum = 0;\r\n        var numStudentsWithScore = 0;\r\n\r\n        var studentStatuses = this.studentStatuses;\r\n\r\n        // loop through all the student statuses\r\n        for (var ss = 0; ss < studentStatuses.length; ss++) {\r\n            var studentStatus = studentStatuses[ss];\r\n\r\n            if (studentStatus != null) {\r\n\r\n                if (periodId == -1 || periodId == studentStatus.periodId) {\r\n                    // the period matches the one we are looking for\r\n\r\n                    var workgroupId = studentStatus.workgroupId;\r\n\r\n                    // get the workgroups score on the node\r\n                    var score = this.AnnotationService.getScore(workgroupId, nodeId);\r\n\r\n                    if (score != null) {\r\n                        // increment the counter of students with a score for this node\r\n                        numStudentsWithScore++;\r\n\r\n                        // accumulate the sum of the scores for this node\r\n                        studentScoreSum += score;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var averageScore = null;\r\n\r\n        if (numStudentsWithScore != 0) {\r\n            // calculate the average score for this node rounded down to the nearest hundredth\r\n            averageScore = Math.floor(100 * studentScoreSum / numStudentsWithScore) / 100;\r\n        }\r\n\r\n        return averageScore;\r\n    }\r\n\r\n    /**\r\n     * Get the max score for the project for the given workgroup id\r\n     * @param workgroupId\r\n     * @returns the sum of the max scores for all the nodes in the project visible\r\n     * to the given workgroupId or null if none of the visible components has max scores.\r\n     */\r\n    getMaxScoreForWorkgroupId(workgroupId) {\r\n        let maxScore = null;\r\n\r\n        let studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\r\n\r\n        if (studentStatus) {\r\n            let nodeStatuses = studentStatus.nodeStatuses;\r\n\r\n            if (nodeStatuses) {\r\n                // loop through all the node statuses\r\n                for (var p in nodeStatuses) {\r\n                    if (nodeStatuses.hasOwnProperty(p)) {\r\n                        let nodeStatus = nodeStatuses[p];\r\n                        let nodeId = nodeStatus.nodeId;\r\n\r\n                        if (nodeStatus.isVisible && !this.ProjectService.isGroupNode(nodeId)) {\r\n                            // node is visible and is not a group\r\n                            // get node max score\r\n                            let nodeMaxScore = this.ProjectService.getMaxScoreForNode(nodeId);\r\n\r\n                            if (nodeMaxScore) {\r\n                                // there is a max score for the node, so add to total\r\n                                maxScore += nodeMaxScore;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return maxScore;\r\n    }\r\n}\r\n\r\nStudentStatusService.$inject = [\r\n    '$http',\r\n    'AnnotationService',\r\n    'ConfigService',\r\n    'ProjectService'\r\n];\r\n\r\nexport default StudentStatusService;\r\n"]}