{"version":3,"sources":["studentStatusService.es6"],"names":["StudentStatusService","$http","AnnotationService","ConfigService","ProjectService","studentStatuses","config","studentStatusURL","getStudentStatusURL","runId","getRunId","requestConfig","params","get","then","result","data","workgroupId","nodePositionAndTitle","studentStatus","getStudentStatusForWorkgroupId","currentNodeId","getNodePositionAndTitleByNodeId","getStudentStatuses","x","length","tempStudentStatus","tempWorkgroupId","splice","excludeNonWorkNodes","completion","totalItems","completedItems","completionPct","projectCompletion","completionPctWithWork","totalItemsWithWork","completedItemsWithWork","getNodeCompletion","nodeId","periodId","workgroupIds","ss","push","isGroupNode","currentNode","getNodeById","group","isNodeDescendentOfGroup","numCompleted","numTotal","nodeStatuses","nodeStatus","progress","descendants","getDescendentsOfGroup","l","i","descendantId","descendantStatus","isVisible","nodeHasWork","isCompleted","includeNode","completionPercentage","Math","floor","workgroupsOnline","workgroupsOnlineInPeriod","n","workgroup","pId","workgroupsOnNode","getWorkgroupIdsOnNode","some","indexOf","w","studentScoreSum","numStudentsWithScore","score","getScore","averageScore","maxScore","p","hasOwnProperty","nodeMaxScore","getMaxScoreForNode","$inject"],"mappings":"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","file":"studentStatusService.js","sourcesContent":["class StudentStatusService {\n  constructor($http,\n              AnnotationService,\n              ConfigService,\n              ProjectService) {\n    this.$http = $http;\n    this.AnnotationService = AnnotationService;\n    this.ConfigService = ConfigService;\n    this.ProjectService = ProjectService;\n    this.studentStatuses = null;\n  }\n\n  retrieveStudentStatuses(config) {\n    var studentStatusURL = this.ConfigService.getStudentStatusURL();\n    var runId = this.ConfigService.getRunId();\n\n    var requestConfig = {\n      params: {\n        runId: runId\n      }\n    };\n\n    return this.$http.get(studentStatusURL, requestConfig).then((result) => {\n      var studentStatuses = result.data;\n\n      this.studentStatuses = studentStatuses;\n\n      return studentStatuses;\n    });\n  };\n\n  getStudentStatuses() {\n    return this.studentStatuses;\n  };\n\n  /**\n   * Get the current node position and title for a workgroup\n   * e.g. 2.2: Newton Scooter Concepts\n   * @param workgroupId the workgroup id\n   * @returns the node position and title\n   */\n  getCurrentNodePositionAndNodeTitleForWorkgroupId(workgroupId) {\n    var nodePositionAndTitle = null;\n\n    var studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\n\n    if(studentStatus != null) {\n      var currentNodeId = studentStatus.currentNodeId;\n      nodePositionAndTitle = this.ProjectService.getNodePositionAndTitleByNodeId(currentNodeId);\n    }\n\n    return nodePositionAndTitle;\n  };\n\n  getStudentStatusForWorkgroupId(workgroupId) {\n\n    var studentStatus = null;\n    var studentStatuses = this.getStudentStatuses();\n\n    for (var x = 0; x < studentStatuses.length; x++) {\n      var tempStudentStatus = studentStatuses[x];\n\n      if (tempStudentStatus != null) {\n        var tempWorkgroupId = tempStudentStatus.workgroupId;\n\n        if (workgroupId == tempWorkgroupId) {\n          studentStatus = tempStudentStatus;\n          break;\n        }\n      }\n    }\n\n    return studentStatus;\n  };\n\n  setStudentStatusForWorkgroupId(workgroupId, studentStatus) {\n\n    var studentStatuses = this.getStudentStatuses();\n\n    for (var x = 0; x < studentStatuses.length; x++) {\n      var tempStudentStatus = studentStatuses[x];\n\n      if (tempStudentStatus != null) {\n        var tempWorkgroupId = tempStudentStatus.workgroupId;\n\n        if (workgroupId === tempWorkgroupId) {\n          studentStatuses.splice(x, 1, studentStatus);\n          break;\n        }\n      }\n    }\n  };\n\n  /**\n   * Get the student project completion data by workgroup id\n   * @param workgroupId the workgroup id\n   * @param excludeNonWorkNodes boolean whether to exclude nodes without\n   * @returns object with completed, total, and percent completed (integer\n   * between 0 and 100)\n   */\n  getStudentProjectCompletion(workgroupId, excludeNonWorkNodes) {\n    let completion = {\n      totalItems: 0,\n      completedItems: 0,\n      completionPct: 0\n    };\n\n    // get the student status for the workgroup\n    let studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\n\n    if (studentStatus) {\n      // get the project completion object\n      let projectCompletion = studentStatus.projectCompletion;\n\n      if (projectCompletion) {\n        if (excludeNonWorkNodes) {\n          // we're only looking for completion of nodes with work\n          let completionPctWithWork = projectCompletion.completionPctWithWork;\n\n          if (completionPctWithWork) {\n            completion.totalItems = projectCompletion.totalItemsWithWork;\n            completion.completedItems = projectCompletion.completedItemsWithWork;\n            completion.completionPct = projectCompletion.completionPctWithWork;\n          } else {\n            /*\n             * we have a legacy projectCompletion object that only includes information for all nodes\n             * so we need to calculate manually\n             */\n            completion = this.getNodeCompletion('group0', -1, workgroupId, true);\n          }\n        } else {\n          completion = projectCompletion;\n        }\n      }\n    }\n\n    return completion;\n  }\n\n  /**\n   * Get the workgroups on a node in the given period\n   * @param nodeId the node id\n   * @param periodId the period id. pass in -1 to select all periods.\n   * @returns an array of workgroup ids on a node in a period\n   */\n  getWorkgroupIdsOnNode(nodeId, periodId) {\n    let workgroupIds = [];\n    let studentStatuses = this.studentStatuses;\n\n    // loop through all the student statuses\n    for (var ss = 0; ss < studentStatuses.length; ss++) {\n      var studentStatus = studentStatuses[ss];\n\n      if (studentStatus != null) {\n\n        if (periodId == -1 || periodId == studentStatus.periodId) {\n          // the period matches the one we are looking for\n          let currentNodeId = studentStatus.currentNodeId;\n          if (nodeId === currentNodeId) {\n            // the node id matches the one we are looking for\n            workgroupIds.push(studentStatus.workgroupId);\n          } else if (this.ProjectService.isGroupNode(nodeId)) {\n            let currentNode = this.ProjectService.getNodeById(currentNodeId);\n            let group = this.ProjectService.getNodeById(nodeId);\n\n            if (this.ProjectService.isNodeDescendentOfGroup(currentNode, group)) {\n              // the node id is a descendent of the group we're looking for\n              workgroupIds.push(studentStatus.workgroupId);\n            }\n          }\n        }\n      }\n    }\n\n    return workgroupIds;\n  }\n\n  /**\n   * Get node completion info for the given parameters\n   * @param nodeId the node id\n   * @param periodId the period id (pass in -1 to select all periods)\n   * @param workgroupId the workgroup id to limit results to (optional)\n   * @param excludeNonWorkNodes boolean whether to exclude nodes without\n   * student work or not (optional)\n   * @returns object with completed, total, and percent completed (integer\n   * between 0 and 100).\n   */\n  getNodeCompletion(nodeId, periodId, workgroupId, excludeNonWorkNodes) {\n    let numCompleted = 0;\n    let numTotal = 0;\n    let isGroupNode = this.ProjectService.isGroupNode(nodeId);\n\n    let studentStatuses = this.studentStatuses;\n\n    // loop through all the student statuses\n    for (let ss = 0; ss < studentStatuses.length; ss++) {\n      let studentStatus = studentStatuses[ss];\n\n      if (studentStatus) {\n\n        if (periodId == -1 || periodId == studentStatus.periodId) {\n          // the period matches the one we are looking for\n\n          if (!workgroupId || workgroupId === studentStatus.workgroupId) {\n            // either no workgroupId was specified or the workgroupId matches the one we're looking for\n\n            let nodeStatuses = studentStatus.nodeStatuses;\n\n            if (nodeStatuses) {\n              // get the node status for the node\n              let nodeStatus = nodeStatuses[nodeId];\n\n              if (nodeStatus != null) {\n                if (isGroupNode) {\n                  // given node is a group\n                  // get progress object from the nodeStatus\n                  let progress = nodeStatus.progress;\n\n                  if (excludeNonWorkNodes) {\n                    // we're looking for only nodes with student work\n                    if (progress && progress.totalItemsWithWork) {\n                      numTotal += progress.totalItemsWithWork;\n                      numCompleted += progress.completedItemsWithWork;\n                    } else {\n                      /*\n                       * we have a legacy nodeStatus.progress that only includes completion information for all nodes\n                       * so we need to calculate manually\n                       */\n                      let group = this.ProjectService.getNodeById(nodeId);\n\n                      // get all the descendants of the group\n                      let descendants = this.ProjectService.getDescendentsOfGroup(group);\n                      let l = descendants.length;\n\n                      // loop through all the descendants to check for completion\n                      for (let i = 0; i < l; i++) {\n                        let descendantId = descendants[i];\n\n                        if (!this.ProjectService.isGroupNode(descendantId)) {\n                          // node is not a group, so add to totals if visible and has student work\n                          let descendantStatus = nodeStatuses[descendantId];\n\n                          if (descendantStatus && descendantStatus.isVisible && this.ProjectService.nodeHasWork(descendantId)) {\n                            numTotal++;\n\n                            if (descendantStatus.isCompleted) {\n                              numCompleted++;\n                            }\n                          }\n                        }\n                      }\n                    }\n                  } else {\n                    // we're looking for completion percentage of all nodes\n                    if (progress) {\n                      numTotal += progress.totalItems;\n                      numCompleted += progress.completedItems;\n                    }\n                  }\n                } else {\n                  // given node is not a group\n                  if (nodeStatus.isVisible) {\n                    /*\n                     * the student can see the step. we need this check\n                     * for cases when a project has branching. this way\n                     * we only calculate the step completion percentage\n                     * based on the students that can actually go to\n                     * the step.\n                     */\n\n                    /*\n                     * check whether we should include the node in the calculation\n                     * i.e. either includeNonWorkNodes is true or the node has student work\n                     */\n                    let includeNode = !excludeNonWorkNodes || this.ProjectService.nodeHasWork(nodeId);\n\n                    if (includeNode) {\n                      numTotal++;\n\n                      if (nodeStatus.isCompleted) {\n                        // the student has completed the node\n                        numCompleted++;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // generate the percentage number rounded down to the nearest integer\n    let completionPercentage = (numTotal > 0 ? Math.floor(100 * numCompleted / numTotal) : 0);\n\n    return {\n      completedItems: numCompleted,\n      totalItems: numTotal,\n      completionPct: completionPercentage\n    };\n  }\n\n  /**\n   * Get the total number of steps that are descendants of a given node\n   * @param nodeId the node id\n   * @returns the total number of step (application node) descendants; returns\n   * @param periodId the period id. pass in -1 to select all periods.\n   * an average for all students in the selected period if the group is a\n   * planning activity\n   */\n  /*getTotalApplicationNodeDescendents(nodeId, periodId) {\n      let numTotal = 0;\n      let numWorkgroups = 0;\n\n      let isGroupNode = this.ProjectService.isGroupNode(nodeId);\n\n      if (isGroupNode) {\n          let isPlanning = this.ProjectService.isPlanning(nodeId);\n          let studentStatuses = this.studentStatuses;\n\n          // loop through all the student statuses\n          for (let ss = 0; ss < studentStatuses.length; ss++) {\n              let studentStatus = studentStatuses[ss];\n\n              if (studentStatus) {\n\n                  if (periodId == -1 || periodId == studentStatus.periodId) {\n                      // the period matches the one we are looking for\n\n                      let nodeStatuses = studentStatus.nodeStatuses;\n\n                      if (nodeStatuses) {\n                          // get the node status for the node\n                          let nodeStatus = nodeStatuses[nodeId];\n\n                          if (nodeStatus) {\n                              let progress = nodeStatus.progress;\n                              if (progress) {\n                                  let totalItems = progress.totalItems;\n                                  if (totalItems) {\n                                      numWorkgroups++;\n\n                                      if (isPlanning) {\n                                          numTotal += progress.totalItems;\n                                      } else {\n                                          // this is not a planning activity, so we can assume the total number of items is the same for all students\n                                          numTotal = progress.totalItems;\n                                          break;\n                                      }\n                                  }\n                              }\n                          }\n                      }\n                  }\n              }\n          }\n      }\n\n      return (numWorkgroups > 0 ? numTotal/numWorkgroups : 0);\n  };*/\n\n  /**\n   * Check if there is a workgroup that is online and on the node\n   * @param workgroupsOnline the workgroup ids that are online\n   * @param nodeId the node id\n   * @param periodId the period id. pass in -1 to select all periods.\n   * @returns whether there is a workgroup that is online and on the node\n   */\n  isWorkgroupOnlineOnNode(workgroupsOnline, nodeId, periodId) {\n    let result = false;\n\n    // find workgroups online in the given period\n    let workgroupsOnlineInPeriod = [];\n    let n = workgroupsOnline.length;\n    for (let i = 0; i < n; i++) {\n      let workgroup = workgroupsOnline[i];\n      let studentStatus = this.getStudentStatusForWorkgroupId(workgroup);\n      if (studentStatus) {\n        let pId = studentStatus.periodId;\n        if (periodId == -1 || pId == periodId) {\n          workgroupsOnlineInPeriod.push(workgroup);\n        }\n      }\n    }\n\n    if (workgroupsOnlineInPeriod.length) {\n      // get workgroups on the given node\n      let workgroupsOnNode = this.getWorkgroupIdsOnNode(nodeId, periodId);\n\n      // check if any online workgroups in the current period are on this node\n      result = workgroupsOnNode.some(w => {\n        return workgroupsOnlineInPeriod.indexOf(w) > -1;\n      });\n    }\n\n    return result;\n  }\n\n  /**\n   * Get the average score for a node for a period\n   * @param nodeId the node id\n   * @param periodId the period id. pass in -1 to select all periods.\n   * @returns the average score for the node for the period\n   */\n  getNodeAverageScore(nodeId, periodId) {\n    var studentScoreSum = 0;\n    var numStudentsWithScore = 0;\n\n    var studentStatuses = this.studentStatuses;\n\n    // loop through all the student statuses\n    for (var ss = 0; ss < studentStatuses.length; ss++) {\n      var studentStatus = studentStatuses[ss];\n\n      if (studentStatus != null) {\n\n        if (periodId == -1 || periodId == studentStatus.periodId) {\n          // the period matches the one we are looking for\n\n          var workgroupId = studentStatus.workgroupId;\n\n          // get the workgroups score on the node\n          var score = this.AnnotationService.getScore(workgroupId, nodeId);\n\n          if (score != null) {\n            // increment the counter of students with a score for this node\n            numStudentsWithScore++;\n\n            // accumulate the sum of the scores for this node\n            studentScoreSum += score;\n          }\n        }\n      }\n    }\n\n    var averageScore = null;\n\n    if (numStudentsWithScore != 0) {\n      // calculate the average score for this node rounded down to the nearest hundredth\n      averageScore = Math.floor(100 * studentScoreSum / numStudentsWithScore) / 100;\n    }\n\n    return averageScore;\n  }\n\n  /**\n   * Get the max score for the project for the given workgroup id\n   * @param workgroupId\n   * @returns the sum of the max scores for all the nodes in the project visible\n   * to the given workgroupId or null if none of the visible components has max scores.\n   */\n  getMaxScoreForWorkgroupId(workgroupId) {\n    let maxScore = null;\n\n    let studentStatus = this.getStudentStatusForWorkgroupId(workgroupId);\n\n    if (studentStatus) {\n      let nodeStatuses = studentStatus.nodeStatuses;\n\n      if (nodeStatuses) {\n        // loop through all the node statuses\n        for (var p in nodeStatuses) {\n          if (nodeStatuses.hasOwnProperty(p)) {\n            let nodeStatus = nodeStatuses[p];\n            let nodeId = nodeStatus.nodeId;\n\n            if (nodeStatus.isVisible && !this.ProjectService.isGroupNode(nodeId)) {\n              // node is visible and is not a group\n              // get node max score\n              let nodeMaxScore = this.ProjectService.getMaxScoreForNode(nodeId);\n\n              if (nodeMaxScore) {\n                // there is a max score for the node, so add to total\n                maxScore += nodeMaxScore;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return maxScore;\n  }\n}\n\nStudentStatusService.$inject = [\n  '$http',\n  'AnnotationService',\n  'ConfigService',\n  'ProjectService'\n];\n\nexport default StudentStatusService;\n"]}