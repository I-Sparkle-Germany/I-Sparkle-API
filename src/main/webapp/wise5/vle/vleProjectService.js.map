{"version":3,"sources":["vleProjectService.es6"],"names":["VLEProjectService","$filter","$http","$injector","$q","$rootScope","ConfigService","UtilService","nodeId","componentId","connectedComponentId","component","getComponentByNodeIdAndComponentId","connectedComponents","connectedComponent","id","componentContent","connectedComponentParams","annotation","componentService","get","type","displayAnnotation","previousScore","currentScore","annotationGroup","globalAnnotationSettings","globalAnnotationGroups","globalAnnotationGroup","enableCriteria","scoreSequence","previousScoreMatch","currentScoreMatch","toString","match","notificationResult","notificationSettings","notifications","notification","scriptFilename","assetDirectoryPath","getProjectAssetsDirectoryPath","scriptPath","then","result","data","additionalProcessingFunction","key","additionalProcessingFunctionsMap","push","getAdditionalProcessingFunctions","$inject"],"mappings":"AAAA;;;;;;;;AACA;;;;;;;;;;;;IAEMA,iB;;;AACJ,6BAAYC,OAAZ,EAAqBC,KAArB,EAA4BC,SAA5B,EAAuCC,EAAvC,EAA2CC,UAA3C,EAAuDC,aAAvD,EAAsEC,WAAtE,EAAmF;AAAA;;AAAA,iIAC3EN,OAD2E,EAClEC,KADkE,EAC3DC,SAD2D,EAChDC,EADgD,EAC5CC,UAD4C,EAChCC,aADgC,EACjBC,WADiB;AAElF;;AAED;;;;;;;;;;;yCAOqBC,M,EAAQC,W,EAAaC,oB,EAAsB;AAC9D,UAAMC,YAAY,KAAKC,kCAAL,CAAwCJ,MAAxC,EAAgDC,WAAhD,CAAlB;AACA,UAAIE,aAAa,IAAjB,EAAuB;AACrB,YAAME,sBAAsBF,UAAUE,mBAAtC;AACA,YAAIA,uBAAuB,IAA3B,EAAiC;AAAA;AAAA;AAAA;;AAAA;AAC/B,iCAA+BA,mBAA/B,8HAAoD;AAAA,kBAA3CC,kBAA2C;;AAClD,kBAAIA,sBAAsB,IAA1B,EAAgC;AAC9B;;;;;;;;AAQA,oBAAIJ,yBAAyBI,mBAAmBC,EAA5C,IACFL,yBAAyBI,mBAAmBL,WAD9C,EAC2D;AACzD,yBAAO,IAAP;AACD;AACF;AACF;AAhB8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBhC;AACF;AACD,aAAO,KAAP;AACD;;AAED;;;;;;;;gDAK4BO,gB,EAAkBP,W,EAAa;AACzD,UAAIQ,2BAA2B,IAA/B;AACA,UAAID,oBAAoB,IAApB,IAA4BP,eAAe,IAA/C,EAAqD;AACnD,YAAMI,sBAAsBG,iBAAiBH,mBAA7C;AACA,YAAIA,uBAAuB,IAA3B,EAAiC;AAAA;AAAA;AAAA;;AAAA;AAC/B,kCAA+BA,mBAA/B,mIAAoD;AAAA,kBAA3CC,kBAA2C;;AAClD,kBAAIA,sBAAsB,IAA1B,EAAgC;AAC9B;;;;;;;;AAQA,oBAAIL,gBAAgBK,mBAAmBC,EAAnC,IACFN,gBAAgBK,mBAAmBL,WADrC,EACkD;AAChDQ,6CAA2BH,kBAA3B;AACD;AACF;AACF;AAhB8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBhC;AACF;AACD,aAAOG,wBAAP;AACD;;AAED;;;;;;;;sCAKkBC,U,EAAY;AAC5B,UAAMP,YAAY,KAAKC,kCAAL,CAAwCM,WAAWV,MAAnD,EAA2DU,WAAWT,WAAtE,CAAlB;AACA,UAAIE,aAAa,IAAjB,EAAuB;AACrB,YAAMQ,mBAAmB,KAAKhB,SAAL,CAAeiB,GAAf,CAAmBT,UAAUU,IAAV,GAAiB,SAApC,CAAzB;AACA,eAAOF,iBAAiBG,iBAAjB,CAAmCX,SAAnC,EAA8CO,UAA9C,CAAP;AACD;AACD,aAAO,IAAP;AACD;;AAED;;;;;;;;;;;oDAQgCP,S,EAAWY,a,EAAeC,Y,EAAc;AACtE,UAAIC,kBAAkB,IAAtB;AACA,UAAId,UAAUe,wBAAV,IAAsC,IAAtC,IACFf,UAAUe,wBAAV,CAAmCC,sBAAnC,IAA6D,IAD/D,EACqE;AACnE,YAAIA,yBAAyBhB,UAAUe,wBAAV,CAAmCC,sBAAhE;AADmE;AAAA;AAAA;;AAAA;AAEnE,gCAAkCA,sBAAlC,mIAA0D;AAAA,gBAAjDC,qBAAiD;;AACxD,gBAAIA,sBAAsBC,cAAtB,IAAwC,IAAxC,IACFD,sBAAsBC,cAAtB,CAAqCC,aAArC,IAAsD,IADxD,EAC8D;AAC5D,kBAAIA,gBAAgBF,sBAAsBC,cAAtB,CAAqCC,aAAzD;AACA,kBAAIA,iBAAiB,IAArB,EAA2B;AACzB;;;;AAIA,oBAAIC,qBAAqBD,cAAc,CAAd,CAAzB;AACA,oBAAIE,oBAAoBF,cAAc,CAAd,CAAxB;;AAEA,oBAAIP,iBAAiB,IAArB,EAA2B;AACzB;AACA,sBAAIQ,sBAAsB,EAAtB,IACFP,aAAaS,QAAb,GAAwBC,KAAxB,CAA8B,MAAMF,iBAAN,GAA0B,GAAxD,CADF,EACgE;AAC9D;AACAP,sCAAkBG,qBAAlB;AACA;AACD;AACF,iBARD,MAQO;AACL,sBAAIL,cAAcU,QAAd,GAAyBC,KAAzB,CAA+B,MAAMH,kBAAN,GAA2B,GAA1D,KACFP,aAAaS,QAAb,GAAwBC,KAAxB,CAA8B,MAAMF,iBAAN,GAA0B,GAAxD,CADF,EACgE;AAC9D;;;;AAIAP,sCAAkBG,qBAAlB;AACA;AACD;AACF;AACF;AACF;AACF;AAnCkE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoCpE;AACD,aAAOH,eAAP;AACD;;AAED;;;;;;;;;;;2CAQuBd,S,EAAWY,a,EAAeC,Y,EAAc;AAC7D,UAAIW,qBAAqB,IAAzB;AACA,UAAIxB,UAAUyB,oBAAV,IAAkC,IAAlC,IACFzB,UAAUyB,oBAAV,CAA+BC,aAA/B,IAAgD,IADlD,EACwD;AACtD,YAAIA,gBAAgB1B,UAAUyB,oBAAV,CAA+BC,aAAnD;AADsD;AAAA;AAAA;;AAAA;AAEtD,gCAAyBA,aAAzB,mIAAwC;AAAA,gBAA/BC,YAA+B;;AACtC,gBAAIA,aAAaT,cAAb,IAA+B,IAA/B,IACFS,aAAaT,cAAb,CAA4BC,aAA5B,IAA6C,IAD/C,EACqD;AACnD,kBAAIA,gBAAgBQ,aAAaT,cAAb,CAA4BC,aAAhD;AACA,kBAAIA,iBAAiB,IAArB,EAA2B;AACzB;;;;AAIA,oBAAIC,qBAAqBD,cAAc,CAAd,CAAzB;AACA,oBAAIE,oBAAoBF,cAAc,CAAd,CAAxB;;AAEA,oBAAIP,iBAAiB,IAArB,EAA2B;AACzB;AACA,sBAAIQ,sBAAsB,EAAtB,IACFP,aAAaS,QAAb,GAAwBC,KAAxB,CAA8B,MAAMF,iBAAN,GAA0B,GAAxD,CADF,EACgE;AAC9DG,yCAAqBG,YAArB;AACA;AACD;AACF,iBAPD,MAOO;AACL,sBAAIf,cAAcU,QAAd,GAAyBC,KAAzB,CAA+B,MAAMH,kBAAN,GAA2B,GAA1D,KACFP,aAAaS,QAAb,GAAwBC,KAAxB,CAA8B,MAAMF,iBAAN,GAA0B,GAAxD,CADF,EACgE;AAC9D;;;;AAIAG,yCAAqBG,YAArB;AACA;AACD;AACF;AACF;AACF;AACF;AAlCqD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmCvD;AACD,aAAOH,kBAAP;AACD;;AAED;;;;;;;mCAIeI,c,EAAgB;AAC7B,UAAIC,qBAAqB,KAAKlC,aAAL,CAAmBmC,6BAAnB,EAAzB;AACA,UAAIC,aAAaF,qBAAqB,GAArB,GAA2BD,cAA5C;AACA,aAAO,KAAKrC,KAAL,CAAWkB,GAAX,CAAesB,UAAf,EAA2BC,IAA3B,CAAgC,UAACC,MAAD,EAAY;AACjD,eAAOA,OAAOC,IAAd;AACD,OAFM,CAAP;AAGD;;;;;AAED;;;;;;oDAMgCrC,M,EAAQC,W,EAAaqC,4B,EAA8B;AACjF,UAAIC,MAAMvC,SAAS,GAAT,GAAeC,WAAzB;AACA,UAAI,KAAKuC,gCAAL,CAAsCD,GAAtC,KAA8C,IAAlD,EAAwD;AACtD,aAAKC,gCAAL,CAAsCD,GAAtC,IAA6C,EAA7C;AACD;AACD,WAAKC,gCAAL,CAAsCD,GAAtC,EAA2CE,IAA3C,CAAgDH,4BAAhD;AACD;;AAED;;;;;;;;;qDAMiCtC,M,EAAQC,W,EAAa;AACpD,aAAO,KAAKyC,gCAAL,CAAsC1C,MAAtC,EAA8CC,WAA9C,KAA8D,IAArE;AACD;;AAED;;;;;;;;;qDAMiCD,M,EAAQC,W,EAAa;AACpD,UAAIsC,MAAMvC,SAAS,GAAT,GAAeC,WAAzB;AACA,aAAO,KAAKuC,gCAAL,CAAsCD,GAAtC,CAAP;AACD;;;;;;AAGH/C,kBAAkBmD,OAAlB,GAA4B,CAC1B,SAD0B,EAE1B,OAF0B,EAG1B,WAH0B,EAI1B,IAJ0B,EAK1B,YAL0B,EAM1B,eAN0B,EAO1B,aAP0B,CAA5B;;kBAUenD,iB","file":"vleProjectService.js","sourcesContent":["'use strict';\nimport ProjectService from '../services/projectService';\n\nclass VLEProjectService extends ProjectService {\n  constructor($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService) {\n    super($filter, $http, $injector, $q, $rootScope, ConfigService, UtilService);\n  }\n\n  /**\n   * Check if a component is a connected component\n   * @param nodeId the node id of the component\n   * @param componentId the component that is listening for connected changes\n   * @param connectedComponentId the component that is broadcasting connected changes\n   * @returns whether the componentId is connected to the connectedComponentId\n   */\n  isConnectedComponent(nodeId, componentId, connectedComponentId) {\n    const component = this.getComponentByNodeIdAndComponentId(nodeId, componentId);\n    if (component != null) {\n      const connectedComponents = component.connectedComponents;\n      if (connectedComponents != null) {\n        for (let connectedComponent of connectedComponents) {\n          if (connectedComponent != null) {\n            /*\n             * check if the connected component id matches the one\n             * we are looking for. connectedComponent.id is the old\n             * field we used to store the component id in so we will\n             * look for that field for the sake of backwards\n             * compatibility. connectedComponent.componentId is the\n             * new field we store the component id in.\n             */\n            if (connectedComponentId === connectedComponent.id ||\n              connectedComponentId === connectedComponent.componentId) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Get a connected component params\n   * @param componentId the connected component id\n   * @returns the params for the connected component\n   */\n  getConnectedComponentParams(componentContent, componentId) {\n    let connectedComponentParams = null;\n    if (componentContent != null && componentId != null) {\n      const connectedComponents = componentContent.connectedComponents;\n      if (connectedComponents != null) {\n        for (let connectedComponent of connectedComponents) {\n          if (connectedComponent != null) {\n            /*\n             * check if the connected component id matches the one\n             * we are looking for. connectedComponent.id is the old\n             * field we used to store the component id in so we will\n             * look for that field for the sake of backwards\n             * compatibility. connectedComponent.componentId is the\n             * new field we store the component id in.\n             */\n            if (componentId === connectedComponent.id ||\n              componentId === connectedComponent.componentId) {\n              connectedComponentParams = connectedComponent;\n            }\n          }\n        }\n      }\n    }\n    return connectedComponentParams;\n  }\n\n  /**\n   * Check if we need to display the annotation to the student\n   * @param annotation the annotation\n   * @returns {boolean} whether we need to display the annotation to the student\n   */\n  displayAnnotation(annotation) {\n    const component = this.getComponentByNodeIdAndComponentId(annotation.nodeId, annotation.componentId);\n    if (component != null) {\n      const componentService = this.$injector.get(component.type + 'Service');\n      return componentService.displayAnnotation(component, annotation);\n    }\n    return true;\n  }\n\n  /**\n   * Get the global annotation properties for the specified component and score, if exists.\n   * @param component the component content\n   * @param previousScore the previousScore we want the annotation properties for, can be null, which means we just want to look at\n   * the currentScore\n   * @param currentScore the currentScore we want the annotation properties for\n   * @returns the annotation properties for the given score\n   */\n  getGlobalAnnotationGroupByScore(component, previousScore, currentScore) {\n    let annotationGroup = null;\n    if (component.globalAnnotationSettings != null &&\n      component.globalAnnotationSettings.globalAnnotationGroups != null) {\n      let globalAnnotationGroups = component.globalAnnotationSettings.globalAnnotationGroups;\n      for (let globalAnnotationGroup of globalAnnotationGroups) {\n        if (globalAnnotationGroup.enableCriteria != null &&\n          globalAnnotationGroup.enableCriteria.scoreSequence != null) {\n          let scoreSequence = globalAnnotationGroup.enableCriteria.scoreSequence;\n          if (scoreSequence != null) {\n            /*\n             * get the expected previous score and current score\n             * that will satisfy the rule\n             */\n            let previousScoreMatch = scoreSequence[0];\n            let currentScoreMatch = scoreSequence[1];\n\n            if (previousScore == null) {\n              // just matching on the current score\n              if (previousScoreMatch == \"\" &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                // found a match\n                annotationGroup = globalAnnotationGroup;\n                break;\n              }\n            } else {\n              if (previousScore.toString().match(\"[\" + previousScoreMatch + \"]\") &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                /*\n                 * the previous score and current score match the\n                 * expected scores so we have found the rule we want\n                 */\n                annotationGroup = globalAnnotationGroup;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    return annotationGroup;\n  }\n\n  /**\n   * Get the notification for the given score, if exists.\n   * @param component the component content\n   * @param previousScore the previousScore we want notification for, can be null, which means we just want to look at\n   * the currentScore\n   * @param currentScore the currentScore we want notification for\n   * @returns the notification for the given score\n   */\n  getNotificationByScore(component, previousScore, currentScore) {\n    let notificationResult = null;\n    if (component.notificationSettings != null &&\n      component.notificationSettings.notifications != null) {\n      let notifications = component.notificationSettings.notifications;\n      for (let notification of notifications) {\n        if (notification.enableCriteria != null &&\n          notification.enableCriteria.scoreSequence != null) {\n          let scoreSequence = notification.enableCriteria.scoreSequence;\n          if (scoreSequence != null) {\n            /*\n             * get the expected previous score and current score\n             * that will satisfy the rule\n             */\n            let previousScoreMatch = scoreSequence[0];\n            let currentScoreMatch = scoreSequence[1];\n\n            if (previousScore == null) {\n              // just matching on the current score\n              if (previousScoreMatch == \"\" &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                notificationResult = notification;\n                break;\n              }\n            } else {\n              if (previousScore.toString().match(\"[\" + previousScoreMatch + \"]\") &&\n                currentScore.toString().match(\"[\" + currentScoreMatch + \"]\")) {\n                /*\n                 * the previous score and current score match the\n                 * expected scores so we have found the rule we want\n                 */\n                notificationResult = notification;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n    return notificationResult;\n  }\n\n  /**\n   * Retrieve the script with the provided script filename\n   * @param scriptFilename\n   */\n  retrieveScript(scriptFilename) {\n    let assetDirectoryPath = this.ConfigService.getProjectAssetsDirectoryPath();\n    let scriptPath = assetDirectoryPath + \"/\" + scriptFilename;\n    return this.$http.get(scriptPath).then((result) => {\n      return result.data;\n    });\n  };\n\n  /**\n   * Registers an additionalProcessingFunction for the specified node and component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @param additionalProcessingFunction the function to register for the node and component.\n   */\n  addAdditionalProcessingFunction(nodeId, componentId, additionalProcessingFunction) {\n    let key = nodeId + \"_\" + componentId;\n    if (this.additionalProcessingFunctionsMap[key] == null) {\n      this.additionalProcessingFunctionsMap[key] = [];\n    }\n    this.additionalProcessingFunctionsMap[key].push(additionalProcessingFunction);\n  }\n\n  /**\n   * Returns true iff the specified node and component has any registered additionalProcessingFunctions\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns true/false\n   */\n  hasAdditionalProcessingFunctions(nodeId, componentId) {\n    return this.getAdditionalProcessingFunctions(nodeId, componentId) != null;\n  }\n\n  /**\n   * Returns an array of registered additionalProcessingFunctions for the specified node and component\n   * @param nodeId the node id\n   * @param componentId the component id\n   * @returns an array of additionalProcessingFunctions\n   */\n  getAdditionalProcessingFunctions(nodeId, componentId) {\n    let key = nodeId + \"_\" + componentId;\n    return this.additionalProcessingFunctionsMap[key];\n  }\n}\n\nVLEProjectService.$inject = [\n  '$filter',\n  '$http',\n  '$injector',\n  '$q',\n  '$rootScope',\n  'ConfigService',\n  'UtilService'\n];\n\nexport default VLEProjectService;\n"]}